{
  "version": 3,
  "sources": ["../@vaadin/flow-frontend/comboBoxConnector.js"],
  "sourcesContent": ["import { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\nimport { timeOut } from '@polymer/polymer/lib/utils/async.js';\nimport { ComboBoxPlaceholder } from '@vaadin/combo-box/src/vaadin-combo-box-placeholder.js';\n\n(function () {\n    const tryCatchWrapper = function (callback) {\n        return window.Vaadin.Flow.tryCatchWrapper(callback, 'Vaadin Combo Box');\n    };\n\n    window.Vaadin.Flow.comboBoxConnector = {\n        initLazy: comboBox => tryCatchWrapper(function (comboBox) {\n\n            // Check whether the connector was already initialized for the ComboBox\n            if (comboBox.$connector) {\n                return;\n            }\n\n            comboBox.$connector = {};\n\n            // holds pageIndex -> callback pairs of subsequent indexes (current active range)\n            const pageCallbacks = {};\n            let cache = {};\n            let lastFilter = '';\n            const placeHolder = new window.Vaadin.ComboBoxPlaceholder();\n            const MAX_RANGE_COUNT = Math.max(comboBox.pageSize * 2, 500); // Max item count in active range\n\n            const serverFacade = (() => {\n                // Private variables\n                let lastFilterSentToServer = '';\n                let dataCommunicatorResetNeeded = false;\n\n                // Public methods\n                const needsDataCommunicatorReset = () => dataCommunicatorResetNeeded = true;\n                const getLastFilterSentToServer = () => lastFilterSentToServer;\n                const requestData = (startIndex, endIndex, params) => {\n                    const count = endIndex - startIndex;\n                    const filter = params.filter;\n\n                    comboBox.$server.setRequestedRange(startIndex, count, filter);\n                    lastFilterSentToServer = filter;\n                    if(dataCommunicatorResetNeeded) {\n                        comboBox.$server.resetDataCommunicator();\n                        dataCommunicatorResetNeeded = false;\n                    }\n                };\n\n                return {needsDataCommunicatorReset, getLastFilterSentToServer, requestData};\n\n            })();\n\n            const clearPageCallbacks = (pages = Object.keys(pageCallbacks)) => {\n                // Flush and empty the existing requests\n                pages.forEach(page => {\n                    pageCallbacks[page]([], comboBox.size);\n                    delete pageCallbacks[page];\n\n                    // Empty the comboBox's internal cache without invoking observers by filling\n                    // the filteredItems array with placeholders (comboBox will request for data when it\n                    // encounters a placeholder)\n                    const pageStart = parseInt(page) * comboBox.pageSize;\n                    const pageEnd = pageStart + comboBox.pageSize;\n                    const end = Math.min(pageEnd, comboBox.filteredItems.length);\n                    for (let i = pageStart; i < end; i++) {\n                        comboBox.filteredItems[i] = placeHolder;\n                    }\n                });\n            }\n\n            comboBox.dataProvider = function (params, callback) {\n                if (params.pageSize != comboBox.pageSize) {\n                    throw 'Invalid pageSize';\n                }\n\n                if (comboBox._clientSideFilter) {\n                    // For clientside filter we first make sure we have all data which we also\n                    // filter based on comboBox.filter. While later we only filter clientside data.\n\n                    if (cache[0]) {\n                        performClientSideFilter(cache[0], callback)\n                        return;\n\n                    } else {\n                        // If client side filter is enabled then we need to first ask all data\n                        // and filter it on client side, otherwise next time when user will\n                        // input another filter, eg. continue to type, the local cache will be only\n                        // what was received for the first filter, which may not be the whole\n                        // data from server (keep in mind that client side filter is enabled only\n                        // when the items count does not exceed one page).\n                        params.filter = \"\";\n                    }\n                }\n\n                const filterChanged = params.filter !== lastFilter;\n                if (filterChanged) {\n                    cache = {};\n                    lastFilter = params.filter;\n                    this._debouncer = Debouncer.debounce(\n                        this._debouncer,\n                        timeOut.after(500),\n                        () => {\n                            if (serverFacade.getLastFilterSentToServer() === params.filter) {\n                                // Fixes the case when the filter changes\n                                // to something else and back to the original value\n                                // within debounce timeout, and the\n                                // DataCommunicator thinks it doesn't need to send data\n                                serverFacade.needsDataCommunicatorReset();\n                            }\n                            if(params.filter !== lastFilter) {\n                                throw new Error(\"Expected params.filter to be '\"\n                                    + lastFilter + \"' but was '\" + params.filter + \"'\");\n                            }\n                            // Call the method again after debounce.\n                            clearPageCallbacks();\n                            comboBox.dataProvider(params, callback)\n                        });\n                    return;\n                }\n\n                if (cache[params.page]) {\n                    // This may happen after skipping pages by scrolling fast\n                    commitPage(params.page, callback);\n                } else {\n                    pageCallbacks[params.page] = callback\n                    const activePages = Object.keys(pageCallbacks).map(page => parseInt(page));\n                    const rangeMin = Math.min(...activePages);\n                    const rangeMax = Math.max(...activePages);\n\n                    if (activePages.length * params.pageSize > MAX_RANGE_COUNT) {\n                        if (params.page === rangeMin) {\n                            clearPageCallbacks([String(rangeMax)]);\n                        } else {\n                            clearPageCallbacks([String(rangeMin)]);\n                        }\n                        comboBox.dataProvider(params, callback);\n                    } else if (rangeMax - rangeMin + 1 !== activePages.length) {\n                        // Wasn't a sequential page index, clear the cache so combo-box will request for new pages\n                        clearPageCallbacks();\n                    } else {\n                        // The requested page was sequential, extend the requested range\n                        const startIndex = params.pageSize * rangeMin;\n                        const endIndex = params.pageSize * (rangeMax + 1);\n\n                        if (!this._debouncer || !this._debouncer.isActive()) {\n                            serverFacade.requestData(startIndex, endIndex, params);\n                        } else {\n                            this._debouncer = Debouncer.debounce(\n                                this._debouncer,\n                                timeOut.after(200),\n                                () => serverFacade.requestData(startIndex, endIndex, params));\n                        }\n                    }\n                }\n            }\n\n            comboBox.$connector.clear = tryCatchWrapper((start, length) => {\n                const firstPageToClear = Math.floor(start / comboBox.pageSize);\n                const numberOfPagesToClear = Math.ceil(length / comboBox.pageSize);\n\n                for (let i = firstPageToClear; i < firstPageToClear + numberOfPagesToClear; i++) {\n                    delete cache[i];\n                }\n            });\n\n            comboBox.$connector.filter = tryCatchWrapper(function (item, filter) {\n                filter = filter ? filter.toString().toLowerCase() : '';\n                return comboBox._getItemLabel(item).toString().toLowerCase().indexOf(filter) > -1;\n            });\n\n            comboBox.$connector.set = tryCatchWrapper(function (index, items, filter) {\n                if (filter != serverFacade.getLastFilterSentToServer()) {\n                    return;\n                }\n\n                if (index % comboBox.pageSize != 0) {\n                    throw 'Got new data to index ' + index + ' which is not aligned with the page size of ' + comboBox.pageSize;\n                }\n\n                if (index === 0 && items.length === 0 && pageCallbacks[0]) {\n                    // Makes sure that the dataProvider callback is called even when server\n                    // returns empty data set (no items match the filter).\n                    cache[0] = [];\n                    return;\n                }\n\n                const firstPageToSet = index / comboBox.pageSize;\n                const updatedPageCount = Math.ceil(items.length / comboBox.pageSize);\n\n                for (let i = 0; i < updatedPageCount; i++) {\n                    let page = firstPageToSet + i;\n                    let slice = items.slice(i * comboBox.pageSize, (i + 1) * comboBox.pageSize);\n\n                    cache[page] = slice;\n                }\n            });\n\n            comboBox.$connector.updateData = tryCatchWrapper(function (items) {\n                // IE11 doesn't work with the transpiled version of the forEach.\n                for (let i = 0; i < items.length; i++) {\n                    let item = items[i];\n\n                    for (let j = 0; j < comboBox.filteredItems.length; j++) {\n                        if (comboBox.filteredItems[j].key === item.key) {\n                            comboBox.set('filteredItems.' + j, item);\n                            break;\n                        }\n                    }\n                }\n            });\n\n            comboBox.$connector.updateSize = tryCatchWrapper(function (newSize) {\n                if (!comboBox._clientSideFilter) {\n                    // FIXME: It may be that this size set is unnecessary, since when\n                    // providing data to combobox via callback we may use data's size.\n                    // However, if this size reflect the whole data size, including\n                    // data not fetched yet into client side, and combobox expect it\n                    // to be set as such, the at least, we don't need it in case the\n                    // filter is clientSide only, since it'll increase the height of\n                    // the popup at only at first user filter to this size, while the\n                    // filtered items count are less.\n                    comboBox.size = newSize;\n                }\n            });\n\n            comboBox.$connector.reset = tryCatchWrapper(function () {\n                clearPageCallbacks();\n                cache = {};\n                comboBox.clearCache();\n            });\n\n            comboBox.$connector.confirm = tryCatchWrapper(function (id, filter) {\n\n                if (filter != serverFacade.getLastFilterSentToServer()) {\n                    return;\n                }\n\n                // We're done applying changes from this batch, resolve pending\n                // callbacks\n                let activePages = Object.getOwnPropertyNames(pageCallbacks);\n                for (let i = 0; i < activePages.length; i++) {\n                    let page = activePages[i];\n\n                    if (cache[page]) {\n                        commitPage(page, pageCallbacks[page]);\n                    }\n                }\n\n                // Let server know we're done\n                comboBox.$server.confirmUpdate(id);\n            });\n\n            comboBox.addEventListener('opened-changed', tryCatchWrapper(() => {\n                // Patch once the instance is ready and vaadin-combo-box has\n                // been finalized (i.e. opened-changed is emitted)\n\n                const isItemSelected = comboBox.$.dropdown._scroller.__isItemSelected;\n                // Override comboBox's _isItemSelected logic to handle remapped items\n                comboBox.$.dropdown._scroller.__isItemSelected = (item, selectedItem, itemIdPath) => {\n                    let selected = isItemSelected.call(comboBox, item, selectedItem, itemIdPath);\n\n                    if (comboBox._selectedKey) {\n                        if (comboBox.filteredItems.indexOf(selectedItem) > -1) {\n                            delete comboBox._selectedKey;\n                        } else {\n                            selected = selected || item.key === comboBox._selectedKey;\n                        }\n                    }\n\n                    return selected;\n                }\n            }), { once: true });\n\n            comboBox.$connector.enableClientValidation = tryCatchWrapper(function( enable ){\n                if ( comboBox.$ ){\n                    if ( enable){\n                        enableClientValidation(comboBox);\n                    }\n                    else {\n                        disableClientValidation(comboBox);\n                    }\n\n                    comboBox.validate();\n                }\n                else {\n                    setTimeout( function(){\n                        comboBox.$connector.enableClientValidation(enable);\n                    }, 10);\n                }\n            });\n\n            const disableClientValidation =  tryCatchWrapper(function (combo){\n                if ( typeof combo.$checkValidity == 'undefined'){\n                    combo.$checkValidity = combo.checkValidity;\n                    combo.checkValidity = function() { return !comboBox.invalid; };\n                }\n                if ( typeof combo.$validate == 'undefined'){\n                    combo.$validate = combo.validate;\n                    combo.validate = function() {\n                        return !(comboBox.focusElement.invalid = comboBox.invalid);\n                    };\n                }\n            });\n\n            const enableClientValidation = tryCatchWrapper(function (combo){\n                if ( combo.$checkValidity ){\n                    combo.checkValidity = combo.$checkValidity;\n                    delete combo.$checkValidity;\n                }\n                if ( combo.$validate ){\n                    combo.validate = combo.$validate;\n                    delete combo.$validate;\n                }\n            });\n\n            const commitPage = tryCatchWrapper(function (page, callback) {\n                let data = cache[page];\n\n                if (comboBox._clientSideFilter) {\n                    performClientSideFilter(data, callback)\n\n                } else {\n                    // Remove the data if server-side filtering, but keep it for client-side\n                    // filtering\n                    delete cache[page];\n\n                    // FIXME: It may be that we ought to provide data.length instead of\n                    // comboBox.size and remove updateSize function.\n                    callback(data, comboBox.size);\n                }\n            });\n\n            // Perform filter on client side (here) using the items from specified page\n            // and submitting the filtered items to specified callback.\n            // The filter used is the one from combobox, not the lastFilter stored since\n            // that may not reflect user's input.\n            const performClientSideFilter = tryCatchWrapper(function (page, callback) {\n\n                let filteredItems = page;\n\n                if (comboBox.filter) {\n                    filteredItems = page.filter(item =>\n                        comboBox.$connector.filter(item, comboBox.filter));\n                }\n\n                callback(filteredItems, filteredItems.length);\n            });\n\n            // Prevent setting the custom value as the 'value'-prop automatically\n            comboBox.addEventListener('custom-value-set', tryCatchWrapper(e => e.preventDefault()));\n        })(comboBox)\n    }\n})();\n\nwindow.Vaadin.ComboBoxPlaceholder = ComboBoxPlaceholder;\n"],
  "mappings": "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",
  "names": []
}
