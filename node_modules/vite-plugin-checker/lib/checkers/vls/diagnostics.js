"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.diagnostics = exports.logLevels = void 0;
const chalk_1 = __importDefault(require("chalk"));
const fast_glob_1 = __importDefault(require("fast-glob"));
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const stream_1 = require("stream");
const vls_1 = require("vls");
const Checker_1 = require("../../Checker");
const node_1 = require("vscode-languageserver/node");
const vscode_uri_1 = require("vscode-uri");
const logger_1 = require("../../logger");
const initParams_1 = require("./initParams");
var DOC_VERSION;
(function (DOC_VERSION) {
    DOC_VERSION[DOC_VERSION["init"] = -1] = "init";
})(DOC_VERSION || (DOC_VERSION = {}));
exports.logLevels = ['ERROR', 'WARN', 'INFO', 'HINT'];
let disposeSuppressConsole;
const logLevel2Severity = {
    ERROR: node_1.DiagnosticSeverity.Error,
    WARN: node_1.DiagnosticSeverity.Warning,
    INFO: node_1.DiagnosticSeverity.Information,
    HINT: node_1.DiagnosticSeverity.Hint,
};
function diagnostics(workspace, logLevel, options = { watch: false, verbose: false }) {
    return __awaiter(this, void 0, void 0, function* () {
        const { watch, errorCallback } = options;
        if (options.verbose) {
            console.log('====================================');
            console.log('Getting Vetur diagnostics');
        }
        let workspaceUri;
        if (workspace) {
            const absPath = path_1.default.resolve(process.cwd(), workspace);
            console.log(`Loading Vetur in workspace path: ${chalk_1.default.green(absPath)}`);
            workspaceUri = vscode_uri_1.URI.file(absPath);
        }
        else {
            console.log(`Loading Vetur in current directory: ${chalk_1.default.green(process.cwd())}`);
            workspaceUri = vscode_uri_1.URI.file(process.cwd());
        }
        const errCount = yield getDiagnostics(workspaceUri, logLevel2Severity[logLevel], options);
        if (options.verbose) {
            console.log('====================================');
        }
        // initial report
        if (!errCount) {
            console.log(chalk_1.default.green(`[VLS checker] No error found`));
            if (!watch) {
                process.exit(0);
            }
        }
        else {
            console.log(chalk_1.default.red(`[VLS checker] Found ${errCount} ${errCount === 1 ? 'error' : 'errors'}`));
            if (!watch) {
                process.exit(1);
            }
        }
    });
}
exports.diagnostics = diagnostics;
class NullLogger {
    error(_message) { }
    warn(_message) { }
    info(_message) { }
    log(_message) { }
}
class TestStream extends stream_1.Duplex {
    _write(chunk, _encoding, done) {
        this.emit('data', chunk);
        done();
    }
    _read(_size) { }
}
function suppressConsole() {
    let disposed = false;
    const rawConsoleLog = globalThis.console.log;
    globalThis.console.log = () => { };
    return () => {
        if (disposed)
            return;
        disposed = true;
        globalThis.console.log = rawConsoleLog;
    };
}
function prepareClientConnection(workspaceUri, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const up = new TestStream();
        const down = new TestStream();
        const logger = new NullLogger();
        const clientConnection = node_1.createProtocolConnection(new node_1.StreamMessageReader(down), new node_1.StreamMessageWriter(up), logger);
        const serverConnection = node_1.createConnection(new node_1.StreamMessageReader(up), new node_1.StreamMessageWriter(down));
        // hijack sendDiagnostics
        serverConnection.sendDiagnostics = (publishDiagnostics) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            disposeSuppressConsole === null || disposeSuppressConsole === void 0 ? void 0 : disposeSuppressConsole();
            if (publishDiagnostics.version === DOC_VERSION.init) {
                return;
            }
            if (!publishDiagnostics.diagnostics.length) {
                return;
            }
            if (!publishDiagnostics.diagnostics.length)
                return;
            const res = yield logger_1.normalizePublishDiagnosticParams(publishDiagnostics);
            const normalized = logger_1.diagnosticToViteError(res);
            console.log(os_1.default.EOL);
            console.log(res.map((d) => logger_1.diagnosticToTerminalLog(d, 'VLS')).join(os_1.default.EOL));
            (_a = options.errorCallback) === null || _a === void 0 ? void 0 : _a.call(options, publishDiagnostics, normalized);
        });
        const vls = new vls_1.VLS(serverConnection);
        vls.validateTextDocument = (textDocument, cancellationToken) => __awaiter(this, void 0, void 0, function* () {
            const diagnostics = yield vls.doValidate(textDocument, cancellationToken);
            if (diagnostics) {
                // @ts-ignore
                vls.lspConnection.sendDiagnostics({
                    uri: textDocument.uri,
                    version: textDocument.version,
                    diagnostics,
                });
            }
        });
        serverConnection.onInitialize((params) => __awaiter(this, void 0, void 0, function* () {
            yield vls.init(params);
            if (options.verbose) {
                console.log('Vetur initialized');
                console.log('====================================');
            }
            return {
                capabilities: vls.capabilities,
            };
        }));
        vls.listen();
        clientConnection.listen();
        const init = initParams_1.getInitParams(workspaceUri);
        yield clientConnection.sendRequest(node_1.InitializeRequest.type, init);
        return clientConnection;
    });
}
function getDiagnostics(workspaceUri, severity, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const clientConnection = yield prepareClientConnection(workspaceUri, options);
        const files = fast_glob_1.default.sync('**/*.vue', { cwd: workspaceUri.fsPath, ignore: ['node_modules/**'] });
        if (files.length === 0) {
            console.log('No input files');
            return 0;
        }
        if (options.verbose) {
            console.log('');
            console.log('Getting diagnostics from: ', files, '\n');
        }
        const absFilePaths = files.map((f) => path_1.default.resolve(workspaceUri.fsPath, f));
        // initial diagnostics report
        // watch mode will run this full diagnostic at starting
        let initialErrCount = 0;
        let logChunk = '';
        if (options.watch) {
            disposeSuppressConsole = suppressConsole();
        }
        yield Promise.all(absFilePaths.map((absFilePath) => __awaiter(this, void 0, void 0, function* () {
            const fileText = yield fs_1.default.promises.readFile(absFilePath, 'utf-8');
            clientConnection.sendNotification(node_1.DidOpenTextDocumentNotification.type, {
                textDocument: {
                    languageId: 'vue',
                    uri: vscode_uri_1.URI.file(absFilePath).toString(),
                    version: DOC_VERSION.init,
                    text: fileText,
                },
            });
            // logout in build mode
            if (!options.watch) {
                try {
                    let diagnostics = (yield clientConnection.sendRequest('$/getDiagnostics', {
                        uri: vscode_uri_1.URI.file(absFilePath).toString(),
                        version: DOC_VERSION.init,
                    }));
                    /**
                     * Ignore eslint errors for now
                     */
                    diagnostics = diagnostics
                        .filter((r) => r.source !== 'eslint-plugin-vue')
                        .filter((r) => r.severity && r.severity <= severity);
                    if (diagnostics.length > 0) {
                        logChunk +=
                            os_1.default.EOL +
                                diagnostics
                                    .map((d) => logger_1.diagnosticToTerminalLog(logger_1.normalizeLspDiagnostic({
                                    diagnostic: d,
                                    absFilePath,
                                    fileText,
                                }), 'VLS'))
                                    .join(os_1.default.EOL);
                        diagnostics.forEach((d) => {
                            if (d.severity === node_1.DiagnosticSeverity.Error) {
                                initialErrCount++;
                            }
                        });
                    }
                }
                catch (err) {
                    console.error(err.stack);
                }
            }
        })));
        // watched diagnostics report
        if (options.watch) {
            Checker_1.Checker.watcher.add(workspaceUri.fsPath);
            Checker_1.Checker.watcher.on('all', (event, path) => __awaiter(this, void 0, void 0, function* () {
                if (!path.endsWith('.vue'))
                    return;
                const fileContent = yield fs_1.default.promises.readFile(path, 'utf-8');
                // TODO: watch js change
                clientConnection.sendNotification(node_1.DidChangeTextDocumentNotification.type, {
                    textDocument: {
                        uri: vscode_uri_1.URI.file(path).toString(),
                        version: Date.now(),
                    },
                    contentChanges: [{ text: fileContent }],
                });
            }));
        }
        console.log(logChunk);
        return initialErrCount;
    });
}
