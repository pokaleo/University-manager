import {
  ComboBoxPlaceholder
} from "./chunk-YIXZHRC6.js";
import {
  Debouncer
} from "./chunk-N4COYWWO.js";
import {
  timeOut
} from "./chunk-NZ6RMXB7.js";
import "./chunk-RQI6IG5T.js";
import "./chunk-KTZKXPFA.js";

// node_modules/@vaadin/flow-frontend/comboBoxConnector.js
(function() {
  const tryCatchWrapper = function(callback) {
    return window.Vaadin.Flow.tryCatchWrapper(callback, "Vaadin Combo Box");
  };
  window.Vaadin.Flow.comboBoxConnector = {
    initLazy: (comboBox) => tryCatchWrapper(function(comboBox2) {
      if (comboBox2.$connector) {
        return;
      }
      comboBox2.$connector = {};
      const pageCallbacks = {};
      let cache = {};
      let lastFilter = "";
      const placeHolder = new window.Vaadin.ComboBoxPlaceholder();
      const MAX_RANGE_COUNT = Math.max(comboBox2.pageSize * 2, 500);
      const serverFacade = (() => {
        let lastFilterSentToServer = "";
        let dataCommunicatorResetNeeded = false;
        const needsDataCommunicatorReset = () => dataCommunicatorResetNeeded = true;
        const getLastFilterSentToServer = () => lastFilterSentToServer;
        const requestData = (startIndex, endIndex, params) => {
          const count = endIndex - startIndex;
          const filter = params.filter;
          comboBox2.$server.setRequestedRange(startIndex, count, filter);
          lastFilterSentToServer = filter;
          if (dataCommunicatorResetNeeded) {
            comboBox2.$server.resetDataCommunicator();
            dataCommunicatorResetNeeded = false;
          }
        };
        return { needsDataCommunicatorReset, getLastFilterSentToServer, requestData };
      })();
      const clearPageCallbacks = (pages = Object.keys(pageCallbacks)) => {
        pages.forEach((page) => {
          pageCallbacks[page]([], comboBox2.size);
          delete pageCallbacks[page];
          const pageStart = parseInt(page) * comboBox2.pageSize;
          const pageEnd = pageStart + comboBox2.pageSize;
          const end = Math.min(pageEnd, comboBox2.filteredItems.length);
          for (let i = pageStart; i < end; i++) {
            comboBox2.filteredItems[i] = placeHolder;
          }
        });
      };
      comboBox2.dataProvider = function(params, callback) {
        if (params.pageSize != comboBox2.pageSize) {
          throw "Invalid pageSize";
        }
        if (comboBox2._clientSideFilter) {
          if (cache[0]) {
            performClientSideFilter(cache[0], callback);
            return;
          } else {
            params.filter = "";
          }
        }
        const filterChanged = params.filter !== lastFilter;
        if (filterChanged) {
          cache = {};
          lastFilter = params.filter;
          this._debouncer = Debouncer.debounce(this._debouncer, timeOut.after(500), () => {
            if (serverFacade.getLastFilterSentToServer() === params.filter) {
              serverFacade.needsDataCommunicatorReset();
            }
            if (params.filter !== lastFilter) {
              throw new Error("Expected params.filter to be '" + lastFilter + "' but was '" + params.filter + "'");
            }
            clearPageCallbacks();
            comboBox2.dataProvider(params, callback);
          });
          return;
        }
        if (cache[params.page]) {
          commitPage(params.page, callback);
        } else {
          pageCallbacks[params.page] = callback;
          const activePages = Object.keys(pageCallbacks).map((page) => parseInt(page));
          const rangeMin = Math.min(...activePages);
          const rangeMax = Math.max(...activePages);
          if (activePages.length * params.pageSize > MAX_RANGE_COUNT) {
            if (params.page === rangeMin) {
              clearPageCallbacks([String(rangeMax)]);
            } else {
              clearPageCallbacks([String(rangeMin)]);
            }
            comboBox2.dataProvider(params, callback);
          } else if (rangeMax - rangeMin + 1 !== activePages.length) {
            clearPageCallbacks();
          } else {
            const startIndex = params.pageSize * rangeMin;
            const endIndex = params.pageSize * (rangeMax + 1);
            if (!this._debouncer || !this._debouncer.isActive()) {
              serverFacade.requestData(startIndex, endIndex, params);
            } else {
              this._debouncer = Debouncer.debounce(this._debouncer, timeOut.after(200), () => serverFacade.requestData(startIndex, endIndex, params));
            }
          }
        }
      };
      comboBox2.$connector.clear = tryCatchWrapper((start, length) => {
        const firstPageToClear = Math.floor(start / comboBox2.pageSize);
        const numberOfPagesToClear = Math.ceil(length / comboBox2.pageSize);
        for (let i = firstPageToClear; i < firstPageToClear + numberOfPagesToClear; i++) {
          delete cache[i];
        }
      });
      comboBox2.$connector.filter = tryCatchWrapper(function(item, filter) {
        filter = filter ? filter.toString().toLowerCase() : "";
        return comboBox2._getItemLabel(item).toString().toLowerCase().indexOf(filter) > -1;
      });
      comboBox2.$connector.set = tryCatchWrapper(function(index, items, filter) {
        if (filter != serverFacade.getLastFilterSentToServer()) {
          return;
        }
        if (index % comboBox2.pageSize != 0) {
          throw "Got new data to index " + index + " which is not aligned with the page size of " + comboBox2.pageSize;
        }
        if (index === 0 && items.length === 0 && pageCallbacks[0]) {
          cache[0] = [];
          return;
        }
        const firstPageToSet = index / comboBox2.pageSize;
        const updatedPageCount = Math.ceil(items.length / comboBox2.pageSize);
        for (let i = 0; i < updatedPageCount; i++) {
          let page = firstPageToSet + i;
          let slice = items.slice(i * comboBox2.pageSize, (i + 1) * comboBox2.pageSize);
          cache[page] = slice;
        }
      });
      comboBox2.$connector.updateData = tryCatchWrapper(function(items) {
        for (let i = 0; i < items.length; i++) {
          let item = items[i];
          for (let j = 0; j < comboBox2.filteredItems.length; j++) {
            if (comboBox2.filteredItems[j].key === item.key) {
              comboBox2.set("filteredItems." + j, item);
              break;
            }
          }
        }
      });
      comboBox2.$connector.updateSize = tryCatchWrapper(function(newSize) {
        if (!comboBox2._clientSideFilter) {
          comboBox2.size = newSize;
        }
      });
      comboBox2.$connector.reset = tryCatchWrapper(function() {
        clearPageCallbacks();
        cache = {};
        comboBox2.clearCache();
      });
      comboBox2.$connector.confirm = tryCatchWrapper(function(id, filter) {
        if (filter != serverFacade.getLastFilterSentToServer()) {
          return;
        }
        let activePages = Object.getOwnPropertyNames(pageCallbacks);
        for (let i = 0; i < activePages.length; i++) {
          let page = activePages[i];
          if (cache[page]) {
            commitPage(page, pageCallbacks[page]);
          }
        }
        comboBox2.$server.confirmUpdate(id);
      });
      comboBox2.addEventListener("opened-changed", tryCatchWrapper(() => {
        const isItemSelected = comboBox2.$.dropdown._scroller.__isItemSelected;
        comboBox2.$.dropdown._scroller.__isItemSelected = (item, selectedItem, itemIdPath) => {
          let selected = isItemSelected.call(comboBox2, item, selectedItem, itemIdPath);
          if (comboBox2._selectedKey) {
            if (comboBox2.filteredItems.indexOf(selectedItem) > -1) {
              delete comboBox2._selectedKey;
            } else {
              selected = selected || item.key === comboBox2._selectedKey;
            }
          }
          return selected;
        };
      }), { once: true });
      comboBox2.$connector.enableClientValidation = tryCatchWrapper(function(enable) {
        if (comboBox2.$) {
          if (enable) {
            enableClientValidation(comboBox2);
          } else {
            disableClientValidation(comboBox2);
          }
          comboBox2.validate();
        } else {
          setTimeout(function() {
            comboBox2.$connector.enableClientValidation(enable);
          }, 10);
        }
      });
      const disableClientValidation = tryCatchWrapper(function(combo) {
        if (typeof combo.$checkValidity == "undefined") {
          combo.$checkValidity = combo.checkValidity;
          combo.checkValidity = function() {
            return !comboBox2.invalid;
          };
        }
        if (typeof combo.$validate == "undefined") {
          combo.$validate = combo.validate;
          combo.validate = function() {
            return !(comboBox2.focusElement.invalid = comboBox2.invalid);
          };
        }
      });
      const enableClientValidation = tryCatchWrapper(function(combo) {
        if (combo.$checkValidity) {
          combo.checkValidity = combo.$checkValidity;
          delete combo.$checkValidity;
        }
        if (combo.$validate) {
          combo.validate = combo.$validate;
          delete combo.$validate;
        }
      });
      const commitPage = tryCatchWrapper(function(page, callback) {
        let data = cache[page];
        if (comboBox2._clientSideFilter) {
          performClientSideFilter(data, callback);
        } else {
          delete cache[page];
          callback(data, comboBox2.size);
        }
      });
      const performClientSideFilter = tryCatchWrapper(function(page, callback) {
        let filteredItems = page;
        if (comboBox2.filter) {
          filteredItems = page.filter((item) => comboBox2.$connector.filter(item, comboBox2.filter));
        }
        callback(filteredItems, filteredItems.length);
      });
      comboBox2.addEventListener("custom-value-set", tryCatchWrapper((e) => e.preventDefault()));
    })(comboBox)
  };
})();
window.Vaadin.ComboBoxPlaceholder = ComboBoxPlaceholder;
//# sourceMappingURL=@vaadin_flow-frontend_comboBoxConnector_js.js.map
