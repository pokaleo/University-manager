import {
  ComboBoxMixin
} from "./chunk-23PSU7UO.js";
import {
  ComboBoxPlaceholder
} from "./chunk-YIXZHRC6.js";
import {
  PatternMixin
} from "./chunk-SBNLMW33.js";
import {
  InputControlMixin,
  inputFieldShared
} from "./chunk-LAUGTD7S.js";
import {
  InputController
} from "./chunk-NENT67AA.js";
import {
  LabelledInputController
} from "./chunk-YESAUM4I.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-PALO6AVQ.js";
import {
  ElementMixin
} from "./chunk-ZAXSWEEW.js";
import {
  PolymerElement,
  html
} from "./chunk-EMDRMWGL.js";

// node_modules/@vaadin/combo-box/src/vaadin-combo-box-data-provider-mixin.js
var ComboBoxDataProviderMixin = (superClass) => class DataProviderMixin extends superClass {
  static get properties() {
    return {
      pageSize: {
        type: Number,
        value: 50,
        observer: "_pageSizeChanged"
      },
      size: {
        type: Number,
        observer: "_sizeChanged"
      },
      dataProvider: {
        type: Object,
        observer: "_dataProviderChanged"
      },
      _pendingRequests: {
        value: () => {
          return {};
        }
      },
      __placeHolder: {
        value: new ComboBoxPlaceholder()
      }
    };
  }
  static get observers() {
    return [
      "_dataProviderFilterChanged(filter, dataProvider)",
      "_dataProviderClearFilter(dataProvider, opened, value)",
      "_warnDataProviderValue(dataProvider, value)",
      "_ensureFirstPage(opened)"
    ];
  }
  _dataProviderClearFilter(dataProvider, opened, value) {
    if (dataProvider && !this.loading && this.filter && !(opened && this.autoOpenDisabled && value === this.filter)) {
      this.size = void 0;
      this._pendingRequests = {};
      this.filter = "";
      this.clearCache();
    }
  }
  ready() {
    super.ready();
    this.clearCache();
    this.$.dropdown.addEventListener("index-requested", (e) => {
      const index = e.detail.index;
      const currentScrollerPos = e.detail.currentScrollerPos;
      const allowedIndexRange = Math.floor(this.pageSize * 1.5);
      if (this._shouldSkipIndex(index, allowedIndexRange, currentScrollerPos)) {
        return;
      }
      if (index !== void 0) {
        const page = this._getPageForIndex(index);
        if (this._shouldLoadPage(page)) {
          this._loadPage(page);
        }
      }
    });
  }
  _dataProviderFilterChanged() {
    if (!this._shouldFetchData()) {
      return;
    }
    this.size = void 0;
    this._pendingRequests = {};
    this.clearCache();
  }
  _shouldFetchData() {
    if (!this.dataProvider) {
      return false;
    }
    return this.opened || this.filter && this.filter.length;
  }
  _ensureFirstPage(opened) {
    if (opened && this._shouldLoadPage(0)) {
      this._loadPage(0);
    }
  }
  _shouldSkipIndex(index, allowedIndexRange, currentScrollerPos) {
    return currentScrollerPos !== 0 && index >= currentScrollerPos - allowedIndexRange && index <= currentScrollerPos + allowedIndexRange;
  }
  _shouldLoadPage(page) {
    if (!this.filteredItems || this._forceNextRequest) {
      this._forceNextRequest = false;
      return true;
    }
    const loadedItem = this.filteredItems[page * this.pageSize];
    if (loadedItem !== void 0) {
      return loadedItem instanceof ComboBoxPlaceholder;
    }
    return this.size === void 0;
  }
  _loadPage(page) {
    if (!this._pendingRequests[page] && this.dataProvider) {
      this.loading = true;
      const params = {
        page,
        pageSize: this.pageSize,
        filter: this.filter
      };
      const callback = (items, size) => {
        if (this._pendingRequests[page] === callback) {
          if (!this.filteredItems) {
            const filteredItems = [];
            filteredItems.splice(params.page * params.pageSize, items.length, ...items);
            this.filteredItems = filteredItems;
          } else {
            this.splice("filteredItems", params.page * params.pageSize, items.length, ...items);
          }
          if (this._isValidValue(this.value) && this._getItemValue(this.selectedItem) !== this.value) {
            this._selectItemForValue(this.value);
          }
          if (!this.opened && !this.hasAttribute("focused")) {
            this._commitValue();
          }
          this.size = size;
          delete this._pendingRequests[page];
          if (Object.keys(this._pendingRequests).length === 0) {
            this.loading = false;
          }
        }
      };
      if (!this._pendingRequests[page]) {
        this._pendingRequests[page] = callback;
        this.dataProvider(params, callback);
      }
    }
  }
  _getPageForIndex(index) {
    return Math.floor(index / this.pageSize);
  }
  clearCache() {
    if (!this.dataProvider) {
      return;
    }
    this._pendingRequests = {};
    const filteredItems = [];
    for (let i = 0; i < (this.size || 0); i++) {
      filteredItems.push(this.__placeHolder);
    }
    this.filteredItems = filteredItems;
    if (this._shouldFetchData()) {
      this._loadPage(0);
    } else {
      this._forceNextRequest = true;
    }
  }
  _sizeChanged(size = 0) {
    const filteredItems = (this.filteredItems || []).slice(0, size);
    for (let i = 0; i < size; i++) {
      filteredItems[i] = filteredItems[i] !== void 0 ? filteredItems[i] : this.__placeHolder;
    }
    this.filteredItems = filteredItems;
    this._flushPendingRequests(size);
  }
  _pageSizeChanged(pageSize, oldPageSize) {
    if (Math.floor(pageSize) !== pageSize || pageSize < 1) {
      this.pageSize = oldPageSize;
      throw new Error("`pageSize` value must be an integer > 0");
    }
    this.clearCache();
  }
  _dataProviderChanged(dataProvider, oldDataProvider) {
    this._ensureItemsOrDataProvider(() => {
      this.dataProvider = oldDataProvider;
    });
  }
  _ensureItemsOrDataProvider(restoreOldValueCallback) {
    if (this.items !== void 0 && this.dataProvider !== void 0) {
      restoreOldValueCallback();
      throw new Error("Using `items` and `dataProvider` together is not supported");
    } else if (this.dataProvider && !this.filteredItems) {
      this.filteredItems = [];
    }
  }
  _warnDataProviderValue(dataProvider, value) {
    if (dataProvider && value !== "" && (this.selectedItem === void 0 || this.selectedItem === null)) {
      const valueIndex = this._indexOfValue(value, this.filteredItems);
      if (valueIndex < 0 || !this._getItemLabel(this.filteredItems[valueIndex])) {
        console.warn("Warning: unable to determine the label for the provided `value`. Nothing to display in the text field. This usually happens when setting an initial `value` before any items are returned from the `dataProvider` callback. Consider setting `selectedItem` instead of `value`");
      }
    }
  }
  _flushPendingRequests(size) {
    if (this._pendingRequests) {
      const lastPage = Math.ceil(size / this.pageSize);
      const pendingRequestsKeys = Object.keys(this._pendingRequests);
      for (let reqIdx = 0; reqIdx < pendingRequestsKeys.length; reqIdx++) {
        const page = parseInt(pendingRequestsKeys[reqIdx]);
        if (page >= lastPage) {
          this._pendingRequests[page]([], size);
        }
      }
    }
  }
};

// node_modules/@vaadin/combo-box/src/vaadin-combo-box.js
registerStyles("vaadin-combo-box", inputFieldShared, { moduleId: "vaadin-combo-box-styles" });
var ComboBox = class extends ComboBoxDataProviderMixin(ComboBoxMixin(PatternMixin(InputControlMixin(ThemableMixin(ElementMixin(PolymerElement)))))) {
  static get is() {
    return "vaadin-combo-box";
  }
  static get template() {
    return html`
      <style>
        :host([opened]) {
          pointer-events: auto;
        }
      </style>

      <div class="vaadin-combo-box-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-input-container
          part="input-field"
          readonly="[[readonly]]"
          disabled="[[disabled]]"
          invalid="[[invalid]]"
          theme$="[[theme]]"
        >
          <slot name="prefix" slot="prefix"></slot>
          <slot name="input"></slot>
          <div id="clearButton" part="clear-button" slot="suffix" aria-hidden="true"></div>
          <div id="toggleButton" part="toggle-button" slot="suffix" aria-hidden="true"></div>
        </vaadin-input-container>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <vaadin-combo-box-dropdown
        id="dropdown"
        opened="[[opened]]"
        renderer="[[renderer]]"
        position-target="[[_positionTarget]]"
        restore-focus-on-close="[[__restoreFocusOnClose]]"
        restore-focus-node="[[inputElement]]"
        _focused-index="[[_focusedIndex]]"
        _item-id-path="[[itemIdPath]]"
        _item-label-path="[[itemLabelPath]]"
        loading="[[loading]]"
        theme="[[theme]]"
      ></vaadin-combo-box-dropdown>
    `;
  }
  static get properties() {
    return {
      _positionTarget: {
        type: Object
      }
    };
  }
  get clearElement() {
    return this.$.clearButton;
  }
  ready() {
    super.ready();
    this.addController(new InputController(this, (input) => {
      this._setInputElement(input);
      this._setFocusElement(input);
      this.stateTarget = input;
      this.ariaTarget = input;
    }));
    this.addController(new LabelledInputController(this.inputElement, this._labelController));
    this._positionTarget = this.shadowRoot.querySelector('[part="input-field"]');
    this._toggleElement = this.$.toggleButton;
  }
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused) {
      this.validate();
    }
  }
  _shouldRemoveFocus(event) {
    if (event.relatedTarget === this.$.dropdown.$.overlay) {
      event.composedPath()[0].focus();
      return false;
    }
    return true;
  }
  _onClearButtonClick(event) {
    event.stopPropagation();
    this._handleClearButtonClick(event);
  }
  _onHostClick(event) {
    const path = event.composedPath();
    if (path.includes(this._labelNode) || path.includes(this._positionTarget)) {
      super._onHostClick(event);
    }
  }
};
customElements.define(ComboBox.is, ComboBox);
/**
 * @license
 * Copyright (c) 2015 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-PXVAWKCK.js.map
