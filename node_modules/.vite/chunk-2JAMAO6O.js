import {
  RadioButton
} from "./chunk-JIUCBBR3.js";
import {
  FieldMixin
} from "./chunk-CCEZKRVB.js";
import {
  KeyboardMixin
} from "./chunk-CHZ6BFNC.js";
import {
  DisabledMixin
} from "./chunk-TNYX3KNS.js";
import {
  FocusMixin
} from "./chunk-Q3ITW52D.js";
import {
  FlattenedNodesObserver
} from "./chunk-IASAGYPQ.js";
import {
  ThemableMixin
} from "./chunk-PALO6AVQ.js";
import {
  ElementMixin
} from "./chunk-ZAXSWEEW.js";
import {
  PolymerElement,
  html
} from "./chunk-EMDRMWGL.js";

// node_modules/@vaadin/radio-group/src/vaadin-radio-group.js
var RadioGroup = class extends FieldMixin(FocusMixin(DisabledMixin(KeyboardMixin(ElementMixin(ThemableMixin(PolymerElement)))))) {
  static get is() {
    return "vaadin-radio-group";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: inline-flex;
        }

        :host::before {
          content: '\\2003';
          width: 0;
          display: inline-block;
        }

        :host([hidden]) {
          display: none !important;
        }

        .vaadin-group-field-container {
          display: flex;
          flex-direction: column;
          width: 100%;
        }

        :host(:not([has-label])) [part='label'] {
          display: none;
        }
      </style>
      <div class="vaadin-group-field-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true"></span>
        </div>

        <div part="group-field">
          <slot></slot>
        </div>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>
    `;
  }
  static get properties() {
    return {
      value: {
        type: String,
        notify: true,
        observer: "__valueChanged"
      },
      readonly: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        observer: "__readonlyChanged"
      },
      _fieldName: {
        type: String
      }
    };
  }
  constructor() {
    super();
    this.__registerRadioButton = this.__registerRadioButton.bind(this);
    this.__unregisterRadioButton = this.__unregisterRadioButton.bind(this);
    this.__onRadioButtonCheckedChange = this.__onRadioButtonCheckedChange.bind(this);
  }
  ready() {
    super.ready();
    this.ariaTarget = this;
    this.setAttribute("role", "radiogroup");
    const uniqueId = RadioGroup._uniqueRadioGroupId = 1 + RadioGroup._uniqueRadioGroupId || 0;
    this._fieldName = `${this.localName}-${uniqueId}`;
    this._observer = new FlattenedNodesObserver(this, ({ addedNodes, removedNodes }) => {
      this.__filterRadioButtons(addedNodes).reverse().forEach(this.__registerRadioButton);
      this.__filterRadioButtons(removedNodes).forEach(this.__unregisterRadioButton);
    });
  }
  __filterRadioButtons(nodes) {
    return nodes.filter((child) => child instanceof RadioButton);
  }
  get __radioButtons() {
    return this.__filterRadioButtons([...this.children]);
  }
  get __selectedRadioButton() {
    return this.__radioButtons.find((radioButton) => radioButton.checked);
  }
  get isHorizontalRTL() {
    return this.getAttribute("dir") === "rtl" && this.theme !== "vertical";
  }
  _onKeyDown(event) {
    super._onKeyDown(event);
    const radioButton = event.composedPath().find((node) => node instanceof RadioButton);
    if (["ArrowLeft", "ArrowUp"].includes(event.key)) {
      event.preventDefault();
      this.__selectNextRadioButton(radioButton);
    }
    if (["ArrowRight", "ArrowDown"].includes(event.key)) {
      event.preventDefault();
      this.__selectPrevRadioButton(radioButton);
    }
  }
  __selectNextRadioButton(radioButton) {
    const index = this.__radioButtons.indexOf(radioButton);
    this.__selectIncRadioButton(index, this.isHorizontalRTL ? 1 : -1);
  }
  __selectPrevRadioButton(radioButton) {
    const index = this.__radioButtons.indexOf(radioButton);
    this.__selectIncRadioButton(index, this.isHorizontalRTL ? -1 : 1);
  }
  __selectIncRadioButton(index, step) {
    const newIndex = (this.__radioButtons.length + index + step) % this.__radioButtons.length;
    const newRadioButton = this.__radioButtons[newIndex];
    if (newRadioButton.disabled) {
      this.__selectIncRadioButton(newIndex, step);
    } else {
      newRadioButton.focusElement.focus();
      newRadioButton.focusElement.click();
    }
  }
  __registerRadioButton(radioButton) {
    radioButton.name = this._fieldName;
    radioButton.addEventListener("checked-changed", this.__onRadioButtonCheckedChange);
    if (this.disabled || this.readonly) {
      radioButton.disabled = true;
    }
    if (radioButton.checked) {
      this.__selectRadioButton(radioButton);
    }
  }
  __unregisterRadioButton(radioButton) {
    radioButton.removeEventListener("checked-changed", this.__onRadioButtonCheckedChange);
    if (radioButton.value === this.value) {
      this.__selectRadioButton(null);
    }
  }
  __onRadioButtonCheckedChange(event) {
    if (event.target.checked) {
      this.__selectRadioButton(event.target);
    }
  }
  __valueChanged(newValue, oldValue) {
    if (!oldValue && !newValue) {
      return;
    }
    if (oldValue && !newValue) {
      this.__selectRadioButton(null);
      this.removeAttribute("has-value");
      return;
    }
    const newSelectedRadioButton = this.__radioButtons.find((radioButton) => {
      return radioButton.value === newValue;
    });
    if (newSelectedRadioButton) {
      this.__selectRadioButton(newSelectedRadioButton);
      this.toggleAttribute("has-value", true);
    } else {
      console.warn(`The radio button with the value "${newValue}" was not found.`);
    }
  }
  __readonlyChanged(newValue, oldValue) {
    if (!newValue && oldValue === void 0) {
      return;
    }
    if (oldValue !== newValue) {
      this.__updateRadioButtonsDisabledProperty();
    }
  }
  _disabledChanged(newValue, oldValue) {
    super._disabledChanged(newValue, oldValue);
    if (!newValue && oldValue === void 0) {
      return;
    }
    if (oldValue !== newValue) {
      this.__updateRadioButtonsDisabledProperty();
    }
  }
  _shouldRemoveFocus(event) {
    return !this.contains(event.relatedTarget);
  }
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused) {
      this.validate();
    }
  }
  __selectRadioButton(radioButton) {
    if (radioButton) {
      this.value = radioButton.value;
    } else {
      this.value = "";
    }
    this.__radioButtons.forEach((button) => {
      button.checked = button === radioButton;
    });
    this.validate();
    if (this.readonly) {
      this.__updateRadioButtonsDisabledProperty();
    }
  }
  __updateRadioButtonsDisabledProperty() {
    this.__radioButtons.forEach((button) => {
      if (this.readonly) {
        button.disabled = button !== this.__selectedRadioButton;
      } else {
        button.disabled = this.disabled;
      }
    });
  }
};
customElements.define(RadioGroup.is, RadioGroup);
/**
 * @license
 * Copyright (c) 2017 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-2JAMAO6O.js.map
