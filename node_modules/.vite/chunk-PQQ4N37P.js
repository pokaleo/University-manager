import {
  Grid
} from "./chunk-5P64C7QD.js";
import {
  Debouncer
} from "./chunk-KCWZ32HQ.js";
import {
  animationFrame
} from "./chunk-QNRFZUBX.js";

// node_modules/@vaadin/grid-pro/src/vaadin-grid-pro-inline-editing-mixin.js
var InlineEditingMixin = (superClass) => class InlineEditingMixin extends superClass {
  static get properties() {
    return {
      enterNextRow: {
        type: Boolean,
        notify: true
      },
      singleCellEdit: {
        type: Boolean,
        notify: true
      },
      editOnClick: {
        type: Boolean
      },
      _editingDisabled: {
        type: Boolean
      }
    };
  }
  constructor() {
    super();
    this.__boundItemPropertyChanged = this._onItemPropertyChanged.bind(this);
    this.__boundEditorFocusOut = this._onEditorFocusOut.bind(this);
    this.__boundEditorFocusIn = this._onEditorFocusIn.bind(this);
    this.__boundCancelCellSwitch = this._setCancelCellSwitch.bind(this);
    this.__boundGlobalFocusIn = this._onGlobalFocusIn.bind(this);
    this._addEditColumnListener("mousedown", (e) => {
      e.stopImmediatePropagation();
      this.toggleAttribute("navigating", true);
    });
    this._addEditColumnListener("focusout", (e) => {
      e.stopImmediatePropagation();
    });
  }
  ready() {
    this.addEventListener("keydown", (e) => {
      switch (e.keyCode) {
        case 27:
          this.__edited && this._stopEdit(true);
          break;
        case 9:
          this.__edited && this._switchEditCell(e);
          break;
        case 13:
          this.__edited ? this._switchEditCell(e) : this._enterEditFromEvent(e);
          break;
        case 32:
          !this.__edited && this._enterEditFromEvent(e);
          break;
        default:
          e.key && e.key.length === 1 && this._enterEditFromEvent(e, "text");
          break;
      }
    });
    super.ready();
    this.$.table.addEventListener("click", (e) => {
      const column = this.getEventContext(e).column;
      if (column && this._isEditColumn(column)) {
        if (e.target.matches(":not([type=checkbox])")) {
          e.preventDefault();
        }
        if (this.editOnClick) {
          this._enterEditFromEvent(e);
        }
      }
    });
    if (this._ios) {
      let firstClickTime;
      let waitingSecondClick = false;
      this.addEventListener("click", (e) => {
        if (!waitingSecondClick) {
          firstClickTime = new Date().getTime();
          waitingSecondClick = true;
          setTimeout(() => {
            waitingSecondClick = false;
          }, 300);
        } else {
          waitingSecondClick = false;
          const time = new Date().getTime();
          if (time - firstClickTime < 300) {
            this._enterEditFromEvent(e);
          }
        }
      });
    } else {
      this.addEventListener("dblclick", (e) => {
        if (!this.editOnClick) {
          this._enterEditFromEvent(e);
        }
      });
    }
  }
  _disabledChanged(disabled, oldDisabled) {
    super._disabledChanged(disabled, oldDisabled);
    if (disabled && this.__edited) {
      this._stopEdit(true);
    }
  }
  _checkImports() {
    super._checkImports();
    ["vaadin-grid-pro-edit-column"].forEach((elementName) => {
      const element = this.querySelector(elementName);
      if (element && !customElements.get(elementName)) {
        console.warn(`Make sure you have imported the required module for <${elementName}> element.`);
      }
    });
  }
  _applyEdit({ path, value, index, item }) {
    this.set(path, value, item);
    this.notifyPath("items." + index + "." + path, value);
  }
  _addEditColumnListener(type, callback) {
    this.addEventListener(type, (e) => {
      const context = this.getEventContext(e);
      const column = context.column;
      const edited = this.__edited;
      if (context.item && this._isEditColumn(column)) {
        const path = e.composedPath();
        const cell = path[path.indexOf(this.$.table) - 3];
        if (!cell || cell.getAttribute("part").indexOf("details-cell") > -1) {
          return;
        }
        if (edited && edited.cell === cell) {
          return;
        }
        callback(e);
      }
    });
  }
  _onItemPropertyChanged(e) {
    if (!e.defaultPrevented) {
      this._applyEdit(e.detail);
    }
  }
  _getRowByIndex(index) {
    return Array.from(this.$.items.children).filter((el) => el.index === index)[0];
  }
  _isEditColumn(column) {
    return column && column.localName.toLowerCase() === "vaadin-grid-pro-edit-column";
  }
  _getEditColumns() {
    const columnTreeLevel = this._columnTree.length - 1;
    return this._columnTree[columnTreeLevel].filter((column) => this._isEditColumn(column) && !column.hidden).sort((a, b) => a._order - b._order);
  }
  _cancelStopEdit() {
    if (this._debouncerStopEdit) {
      this._debouncerStopEdit.cancel();
      delete this._debouncerStopEdit;
    }
  }
  _flushStopEdit() {
    if (this._debouncerStopEdit) {
      this._debouncerStopEdit.flush();
      delete this._debouncerStopEdit;
    }
  }
  _enterEditFromEvent(e, type) {
    const context = this.getEventContext(e);
    const column = context.column;
    const edited = this.__edited;
    if (context.item && this._isEditColumn(column)) {
      const path = e.composedPath();
      const cell = path[path.indexOf(this.$.table) - 3];
      if (!cell || cell.getAttribute("part").indexOf("details-cell") > -1) {
        return;
      }
      if (type && column.editorType !== type) {
        return;
      }
      if (edited && edited.cell === cell && column._getEditorComponent(cell).contains(e.target)) {
        return;
      }
      this._flushStopEdit();
      this._startEdit(cell, column);
    } else if (edited) {
      this._stopEdit();
    }
  }
  _onEditorFocusOut() {
    this._debouncerStopEdit = Debouncer.debounce(this._debouncerStopEdit, animationFrame, this._stopEdit.bind(this));
  }
  _onEditorFocusIn() {
    this._cancelStopEdit();
  }
  _onGlobalFocusIn(e) {
    const edited = this.__edited;
    if (edited) {
      const overlay = Array.from(e.composedPath()).filter((node) => node.nodeType === Node.ELEMENT_NODE && /^vaadin-(?!dialog).*-overlay$/i.test(node.localName))[0];
      if (overlay) {
        overlay.addEventListener("vaadin-overlay-outside-click", this.__boundEditorFocusOut);
        this._cancelStopEdit();
      }
    }
  }
  _startEdit(cell, column) {
    if (this.disabled || this._editingDisabled) {
      return;
    }
    this._cancelStopEdit();
    this._scrollHorizontallyToCell(cell);
    const model = this.__getRowModel(cell.parentElement);
    this.__edited = { cell, column, model };
    column._startCellEdit(cell, model);
    this.dispatchEvent(new CustomEvent("cell-edit-started", {
      detail: {
        index: model.index,
        item: model.item,
        path: column.path
      },
      composed: true
    }));
    this.addEventListener("item-property-changed", this.__boundItemPropertyChanged);
  }
  _stopEdit(shouldCancel, shouldRestoreFocus) {
    if (!this.__edited) {
      return;
    }
    const { cell, column, model } = this.__edited;
    if (!shouldCancel) {
      const editor = column._getEditorComponent(cell);
      if (editor) {
        const value = column._getEditorValue(editor);
        if (value !== this.get(column.path, model.item)) {
          editor.blur();
          this.dispatchEvent(new CustomEvent("item-property-changed", {
            detail: {
              index: model.index,
              item: model.item,
              path: column.path,
              value
            },
            bubbles: true,
            cancelable: true,
            composed: true
          }));
        }
      }
    }
    column._stopCellEdit(cell, model);
    this.__edited = null;
    this.removeEventListener("item-property-changed", this.__boundItemPropertyChanged);
    if (shouldRestoreFocus) {
      cell.focus();
    }
  }
  _setCancelCellSwitch() {
    this.__cancelCellSwitch = true;
    window.requestAnimationFrame(() => this.__cancelCellSwitch = false);
  }
  _switchEditCell(e) {
    if (this.__cancelCellSwitch || e.defaultPrevented && e.keyCode === 9) {
      return;
    }
    this._cancelStopEdit();
    const cols = this._getEditColumns();
    const { cell, column, model } = this.__edited;
    const colIndex = cols.indexOf(column);
    const { index } = model;
    let nextCol = null;
    let nextIdx = index;
    if (e.keyCode === 13) {
      nextCol = column;
      if (this.enterNextRow) {
        nextIdx = e.shiftKey ? index - 1 : index + 1;
      }
    }
    if (e.keyCode === 9) {
      if (e.shiftKey) {
        if (cols[colIndex - 1]) {
          nextCol = cols[colIndex - 1];
        } else if (index > 0) {
          nextIdx = index - 1;
          nextCol = cols[cols.length - 1];
        }
      } else if (cols[colIndex + 1]) {
        nextCol = cols[colIndex + 1];
      } else {
        nextIdx = index + 1;
        nextCol = cols[0];
      }
    }
    const nextRow = nextIdx === index ? cell.parentNode : this._getRowByIndex(nextIdx) || null;
    this._stopEdit();
    if (nextRow && nextCol) {
      const nextCell = Array.from(nextRow.children).filter((cell2) => cell2._column === nextCol)[0];
      e.preventDefault();
      e.stopImmediatePropagation();
      if (!this.singleCellEdit && nextCell !== cell) {
        this._startEdit(nextCell, nextCol);
      } else {
        this._ensureScrolledToIndex(nextIdx);
        nextCell.focus();
      }
    }
  }
  _updateItem(row, item) {
    if (this.__edited) {
      const { cell, model } = this.__edited;
      if (cell.parentNode === row && model.item !== item) {
        this._stopEdit();
      }
    }
    super._updateItem(row, item);
  }
};

// node_modules/@vaadin/grid-pro/src/vaadin-grid-pro.js
var GridPro = class extends InlineEditingMixin(Grid) {
  static get is() {
    return "vaadin-grid-pro";
  }
  static _finalizeClass() {
    super._finalizeClass();
    const devModeCallback = window.Vaadin.developmentModeCallback;
    const licenseChecker = devModeCallback && devModeCallback["vaadin-license-checker"];
    if (typeof licenseChecker === "function") {
      licenseChecker(GridPro);
    }
  }
};
customElements.define(GridPro.is, GridPro);
/**
 * @license
 * Copyright (c) 2018 - 2022 Vaadin Ltd.
 * This program is available under Commercial Vaadin Developer License 4.0 (CVDLv4).
 * See <a href="https://vaadin.com/license/cvdl-4.0">the website</a> for the complete license.
 */
//# sourceMappingURL=chunk-PQQ4N37P.js.map
