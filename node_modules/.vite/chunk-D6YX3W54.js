import {
  ListMixin
} from "./chunk-XQQ5YBCL.js";
import {
  ResizeMixin
} from "./chunk-WCV6MGXN.js";
import {
  afterNextRender
} from "./chunk-ZGILPT2L.js";
import {
  ThemableMixin
} from "./chunk-PALO6AVQ.js";
import {
  ElementMixin
} from "./chunk-ZAXSWEEW.js";
import {
  PolymerElement,
  html
} from "./chunk-EMDRMWGL.js";

// node_modules/@vaadin/tabs/src/vaadin-tabs.js
var Tabs = class extends ResizeMixin(ElementMixin(ListMixin(ThemableMixin(PolymerElement)))) {
  static get template() {
    return html`
      <style>
        :host {
          display: flex;
          align-items: center;
        }

        :host([hidden]) {
          display: none !important;
        }

        :host([orientation='vertical']) {
          display: block;
        }

        :host([orientation='horizontal']) [part='tabs'] {
          flex-grow: 1;
          display: flex;
          align-self: stretch;
          overflow-x: auto;
          -webkit-overflow-scrolling: touch;
        }

        /* This seems more future-proof than \`overflow: -moz-scrollbars-none\` which is marked obsolete
         and is no longer guaranteed to work:
         https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#Mozilla_Extensions */
        @-moz-document url-prefix() {
          :host([orientation='horizontal']) [part='tabs'] {
            overflow: hidden;
          }
        }

        :host([orientation='horizontal']) [part='tabs']::-webkit-scrollbar {
          display: none;
        }

        :host([orientation='vertical']) [part='tabs'] {
          height: 100%;
          overflow-y: auto;
          -webkit-overflow-scrolling: touch;
        }

        [part='back-button'],
        [part='forward-button'] {
          pointer-events: none;
          opacity: 0;
          cursor: default;
        }

        :host([overflow~='start']) [part='back-button'],
        :host([overflow~='end']) [part='forward-button'] {
          pointer-events: auto;
          opacity: 1;
        }

        [part='back-button']::after {
          content: '◀';
        }

        [part='forward-button']::after {
          content: '▶';
        }

        :host([orientation='vertical']) [part='back-button'],
        :host([orientation='vertical']) [part='forward-button'] {
          display: none;
        }

        /* RTL specific styles */

        :host([dir='rtl']) [part='back-button']::after {
          content: '▶';
        }

        :host([dir='rtl']) [part='forward-button']::after {
          content: '◀';
        }
      </style>
      <div on-click="_scrollBack" part="back-button" aria-hidden="true"></div>

      <div id="scroll" part="tabs">
        <slot></slot>
      </div>

      <div on-click="_scrollForward" part="forward-button" aria-hidden="true"></div>
    `;
  }
  static get is() {
    return "vaadin-tabs";
  }
  static get properties() {
    return {
      orientation: {
        value: "horizontal",
        type: String
      },
      selected: {
        value: 0,
        type: Number
      }
    };
  }
  static get observers() {
    return ["__tabsItemsChanged(items, items.*)"];
  }
  constructor() {
    super();
    this.__itemsResizeObserver = new ResizeObserver(() => {
      setTimeout(() => this._updateOverflow());
    });
  }
  ready() {
    super.ready();
    this._scrollerElement.addEventListener("scroll", () => this._updateOverflow());
    this.setAttribute("role", "tablist");
    afterNextRender(this, () => {
      this._updateOverflow();
    });
  }
  _onResize() {
    this._updateOverflow();
  }
  __tabsItemsChanged(items) {
    this.__itemsResizeObserver.disconnect();
    (items || []).forEach((item) => {
      this.__itemsResizeObserver.observe(item);
    });
    this._updateOverflow();
  }
  _scrollForward() {
    this._scroll(-this.__direction * this._scrollOffset);
  }
  _scrollBack() {
    this._scroll(this.__direction * this._scrollOffset);
  }
  get _scrollOffset() {
    return this._vertical ? this._scrollerElement.offsetHeight : this._scrollerElement.offsetWidth;
  }
  get _scrollerElement() {
    return this.$.scroll;
  }
  get __direction() {
    return !this._vertical && this.getAttribute("dir") === "rtl" ? 1 : -1;
  }
  _updateOverflow() {
    const scrollPosition = this._vertical ? this._scrollerElement.scrollTop : this.__getNormalizedScrollLeft(this._scrollerElement);
    const scrollSize = this._vertical ? this._scrollerElement.scrollHeight : this._scrollerElement.scrollWidth;
    let overflow = scrollPosition > 0 ? "start" : "";
    overflow += scrollPosition + this._scrollOffset < scrollSize ? " end" : "";
    if (this.__direction == 1) {
      overflow = overflow.replace(/start|end/gi, (matched) => {
        return matched === "start" ? "end" : "start";
      });
    }
    overflow ? this.setAttribute("overflow", overflow.trim()) : this.removeAttribute("overflow");
  }
};
customElements.define(Tabs.is, Tabs);
/**
 * @license
 * Copyright (c) 2017 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-D6YX3W54.js.map
