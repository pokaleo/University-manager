{
  "version": 3,
  "sources": ["../@vaadin/component-base/src/focus-utils.js", "../@vaadin/component-base/src/focus-trap-controller.js"],
  "sourcesContent": ["/**\n * @license\n * Copyright (c) 2021 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n/**\n * Returns true if the element is hidden directly with `display: none` or `visibility: hidden`,\n * false otherwise.\n *\n * The method doesn't traverse the element's ancestors, it only checks for the CSS properties\n * set directly to or inherited by the element.\n *\n * @param {HTMLElement} element\n * @return {boolean}\n */\nfunction isElementHiddenDirectly(element) {\n  // Check inline style first to save a re-flow.\n  const style = element.style;\n  if (style.visibility === 'hidden' || style.display === 'none') {\n    return true;\n  }\n\n  const computedStyle = window.getComputedStyle(element);\n  if (computedStyle.visibility === 'hidden' || computedStyle.display === 'none') {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Returns the normalized element tabindex. If not focusable, returns -1.\n * It checks for the attribute \"tabindex\" instead of the element property\n * `tabIndex` since browsers assign different values to it.\n * e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`\n *\n * @param {HTMLElement} element\n * @return {number}\n */\nfunction normalizeTabIndex(element) {\n  if (!isElementFocusable(element)) {\n    return -1;\n  }\n\n  const tabIndex = element.getAttribute('tabindex') || 0;\n  return Number(tabIndex);\n}\n\n/**\n * Returns if element `a` has lower tab order compared to element `b`\n * (both elements are assumed to be focusable and tabbable).\n * Elements with tabindex = 0 have lower tab order compared to elements\n * with tabindex > 0.\n * If both have same tabindex, it returns false.\n *\n * @param {HTMLElement} a\n * @param {HTMLElement} b\n * @return {boolean}\n */\nfunction hasLowerTabOrder(a, b) {\n  // Normalize tabIndexes\n  // e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`\n  const ati = Math.max(a.tabIndex, 0);\n  const bti = Math.max(b.tabIndex, 0);\n  return ati === 0 || bti === 0 ? bti > ati : ati > bti;\n}\n\n/**\n * Merge sort iterator, merges the two arrays into one, sorted by tabindex.\n *\n * @param {HTMLElement[]} left\n * @param {HTMLElement[]} right\n * @return {HTMLElement[]}\n */\nfunction mergeSortByTabIndex(left, right) {\n  const result = [];\n  while (left.length > 0 && right.length > 0) {\n    if (hasLowerTabOrder(left[0], right[0])) {\n      result.push(right.shift());\n    } else {\n      result.push(left.shift());\n    }\n  }\n\n  return result.concat(left, right);\n}\n\n/**\n * Sorts an array of elements by tabindex. Returns a new array.\n *\n * @param {HTMLElement[]} elements\n * @return {HTMLElement[]}\n */\nfunction sortElementsByTabIndex(elements) {\n  // Implement a merge sort as Array.prototype.sort does a non-stable sort\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n  const len = elements.length;\n  if (len < 2) {\n    return elements;\n  }\n  const pivot = Math.ceil(len / 2);\n  const left = sortElementsByTabIndex(elements.slice(0, pivot));\n  const right = sortElementsByTabIndex(elements.slice(pivot));\n\n  return mergeSortByTabIndex(left, right);\n}\n\n/**\n * Searches for nodes that are tabbable and adds them to the `result` array.\n * Returns if the `result` array needs to be sorted by tabindex.\n *\n * @param {Node} node The starting point for the search; added to `result` if tabbable.\n * @param {HTMLElement[]} result\n * @return {boolean}\n * @private\n */\nfunction collectFocusableNodes(node, result) {\n  if (node.nodeType !== Node.ELEMENT_NODE || isElementHiddenDirectly(node)) {\n    // Don't traverse children if the node is not an HTML element or not visible.\n    return false;\n  }\n\n  const element = /** @type {HTMLElement} */ (node);\n  const tabIndex = normalizeTabIndex(element);\n  let needsSort = tabIndex > 0;\n  if (tabIndex >= 0) {\n    result.push(element);\n  }\n\n  let children = [];\n  if (element.localName === 'slot') {\n    children = element.assignedNodes({ flatten: true });\n  } else {\n    // Use shadow root if possible, will check for distributed nodes.\n    children = (element.shadowRoot || element).children;\n  }\n  [...children].forEach((child) => {\n    // Ensure method is always invoked to collect focusable children.\n    needsSort = collectFocusableNodes(child, result) || needsSort;\n  });\n  return needsSort;\n}\n\n/**\n * Returns true if the element is hidden, false otherwise.\n *\n * An element is treated as hidden when any of the following conditions are met:\n * - the element itself or one of its ancestors has `display: none`.\n * - the element has or inherits `visibility: hidden`.\n *\n * @param {HTMLElement} element\n * @return {boolean}\n */\nexport function isElementHidden(element) {\n  // `offsetParent` is `null` when the element itself\n  // or one of its ancestors is hidden with `display: none`.\n  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent\n  if (element.offsetParent === null) {\n    return true;\n  }\n\n  return isElementHiddenDirectly(element);\n}\n\n/**\n * Returns true if the element is focusable, otherwise false.\n *\n * The list of focusable elements is taken from http://stackoverflow.com/a/1600194/4228703.\n * However, there isn't a definite list, it's up to the browser.\n * The only standard we have is DOM Level 2 HTML https://www.w3.org/TR/DOM-Level-2-HTML/html.html,\n * according to which the only elements that have a `focus()` method are:\n * - HTMLInputElement\n * - HTMLSelectElement\n * - HTMLTextAreaElement\n * - HTMLAnchorElement\n *\n * This notably omits HTMLButtonElement and HTMLAreaElement.\n * Referring to these tests with tabbables in different browsers\n * http://allyjs.io/data-tables/focusable.html\n *\n * @param {HTMLElement} element\n * @return {boolean}\n */\nexport function isElementFocusable(element) {\n  // The element cannot be focused if its `tabindex` attribute is set to `-1`.\n  if (element.matches('[tabindex=\"-1\"]')) {\n    return false;\n  }\n\n  // Elements that cannot be focused if they have a `disabled` attribute.\n  if (element.matches('input, select, textarea, button, object')) {\n    return element.matches(':not([disabled])');\n  }\n\n  // Elements that can be focused even if they have a `disabled` attribute.\n  return element.matches('a[href], area[href], iframe, [tabindex], [contentEditable]');\n}\n\n/**\n * Returns true if the element is focused, false otherwise.\n *\n * @param {HTMLElement} element\n * @return {boolean}\n */\nexport function isElementFocused(element) {\n  return element.getRootNode().activeElement === element;\n}\n\n/**\n * Returns a tab-ordered array of focusable elements for a root element.\n * The resulting array will include the root element if it is focusable.\n *\n * The method traverses nodes in shadow DOM trees too if any.\n *\n * @param {HTMLElement} element\n * @return {HTMLElement[]}\n */\nexport function getFocusableElements(element) {\n  const focusableElements = [];\n  const needsSortByTabIndex = collectFocusableNodes(element, focusableElements);\n  // If there is at least one element with tabindex > 0, we need to sort\n  // the final array by tabindex.\u2248\n  if (needsSortByTabIndex) {\n    return sortElementsByTabIndex(focusableElements);\n  }\n  return focusableElements;\n}\n", "/**\n * @license\n * Copyright (c) 2021 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { getFocusableElements, isElementFocused } from './focus-utils.js';\n\nconst instances = [];\n\n/**\n * A controller for trapping focus within a DOM node.\n */\nexport class FocusTrapController {\n  /**\n   * @param {HTMLElement} host\n   */\n  constructor(host) {\n    /**\n     * The controller host element.\n     *\n     * @type {HTMLElement}\n     */\n    this.host = host;\n\n    /**\n     * A node for trapping focus in.\n     *\n     * @type {HTMLElement | null}\n     * @private\n     */\n    this.__trapNode = null;\n\n    this.__onKeyDown = this.__onKeyDown.bind(this);\n  }\n\n  hostConnected() {\n    document.addEventListener('keydown', this.__onKeyDown);\n  }\n\n  hostDisconnected() {\n    document.removeEventListener('keydown', this.__onKeyDown);\n  }\n\n  /**\n   * Activates a focus trap for a DOM node that will prevent focus from escaping the node.\n   * The trap can be deactivated with the `.releaseFocus()` method.\n   *\n   * If focus is initially outside the trap, the method will move focus inside,\n   * on the first focusable element of the trap in the tab order.\n   * The first focusable element can be the trap node itself if it is focusable\n   * and comes first in the tab order.\n   *\n   * If there are no focusable elements, the method will throw an exception\n   * and the trap will not be set.\n   *\n   * @param {HTMLElement} trapNode\n   */\n  trapFocus(trapNode) {\n    this.__trapNode = trapNode;\n\n    if (this.__focusableElements.length === 0) {\n      this.__trapNode = null;\n      throw new Error('The trap node should have at least one focusable descendant or be focusable itself.');\n    }\n\n    instances.push(this);\n\n    if (this.__focusedElementIndex === -1) {\n      this.__focusableElements[0].focus();\n    }\n  }\n\n  /**\n   * Deactivates the focus trap set with the `.trapFocus()` method\n   * so that it becomes possible to tab outside the trap node.\n   */\n  releaseFocus() {\n    this.__trapNode = null;\n\n    instances.pop();\n  }\n\n  /**\n   * A `keydown` event handler that manages tabbing navigation when the trap is enabled.\n   *\n   * - Moves focus to the next focusable element of the trap on `Tab` press.\n   * When no next element to focus, the method moves focus to the first focusable element.\n   * - Moves focus to the prev focusable element of the trap on `Shift+Tab` press.\n   * When no prev element to focus, the method moves focus to the last focusable element.\n   *\n   * @param {KeyboardEvent} event\n   * @private\n   */\n  __onKeyDown(event) {\n    if (!this.__trapNode) {\n      return;\n    }\n\n    // Only handle events for the last instance\n    if (this !== Array.from(instances).pop()) {\n      return;\n    }\n\n    if (event.key === 'Tab') {\n      event.preventDefault();\n\n      const backward = event.shiftKey;\n      this.__focusNextElement(backward);\n    }\n  }\n\n  /**\n   * - Moves focus to the next focusable element if `backward === false`.\n   * When no next element to focus, the method moves focus to the first focusable element.\n   * - Moves focus to the prev focusable element if `backward === true`.\n   * When no prev element to focus the method moves focus to the last focusable element.\n   *\n   * If no focusable elements, the method returns immediately.\n   *\n   * @param {boolean} backward\n   * @private\n   */\n  __focusNextElement(backward = false) {\n    const focusableElements = this.__focusableElements;\n    const step = backward ? -1 : 1;\n    const currentIndex = this.__focusedElementIndex;\n    const nextIndex = (focusableElements.length + currentIndex + step) % focusableElements.length;\n    focusableElements[nextIndex].focus();\n  }\n\n  /**\n   * An array of tab-ordered focusable elements inside the trap node.\n   *\n   * @return {HTMLElement[]}\n   * @private\n   */\n  get __focusableElements() {\n    return getFocusableElements(this.__trapNode);\n  }\n\n  /**\n   * The index of the element inside the trap node that currently has focus.\n   *\n   * @return {HTMLElement | undefined}\n   * @private\n   */\n  get __focusedElementIndex() {\n    const focusableElements = this.__focusableElements;\n    return focusableElements.indexOf(focusableElements.filter(isElementFocused).pop());\n  }\n}\n"],
  "mappings": ";AAAA,AAgBA,iCAAiC,SAAS;AAExC,QAAM,QAAQ,QAAQ;AACtB,MAAI,MAAM,eAAe,YAAY,MAAM,YAAY,QAAQ;AAC7D,WAAO;AAAA,EACT;AAEA,QAAM,gBAAgB,OAAO,iBAAiB,OAAO;AACrD,MAAI,cAAc,eAAe,YAAY,cAAc,YAAY,QAAQ;AAC7E,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAWA,2BAA2B,SAAS;AAClC,MAAI,CAAC,mBAAmB,OAAO,GAAG;AAChC,WAAO;AAAA,EACT;AAEA,QAAM,WAAW,QAAQ,aAAa,UAAU,KAAK;AACrD,SAAO,OAAO,QAAQ;AACxB;AAaA,0BAA0B,GAAG,GAAG;AAG9B,QAAM,MAAM,KAAK,IAAI,EAAE,UAAU,CAAC;AAClC,QAAM,MAAM,KAAK,IAAI,EAAE,UAAU,CAAC;AAClC,SAAO,QAAQ,KAAK,QAAQ,IAAI,MAAM,MAAM,MAAM;AACpD;AASA,6BAA6B,MAAM,OAAO;AACxC,QAAM,SAAS,CAAC;AAChB,SAAO,KAAK,SAAS,KAAK,MAAM,SAAS,GAAG;AAC1C,QAAI,iBAAiB,KAAK,IAAI,MAAM,EAAE,GAAG;AACvC,aAAO,KAAK,MAAM,MAAM,CAAC;AAAA,IAC3B,OAAO;AACL,aAAO,KAAK,KAAK,MAAM,CAAC;AAAA,IAC1B;AAAA,EACF;AAEA,SAAO,OAAO,OAAO,MAAM,KAAK;AAClC;AAQA,gCAAgC,UAAU;AAGxC,QAAM,MAAM,SAAS;AACrB,MAAI,MAAM,GAAG;AACX,WAAO;AAAA,EACT;AACA,QAAM,QAAQ,KAAK,KAAK,MAAM,CAAC;AAC/B,QAAM,OAAO,uBAAuB,SAAS,MAAM,GAAG,KAAK,CAAC;AAC5D,QAAM,QAAQ,uBAAuB,SAAS,MAAM,KAAK,CAAC;AAE1D,SAAO,oBAAoB,MAAM,KAAK;AACxC;AAWA,+BAA+B,MAAM,QAAQ;AAC3C,MAAI,KAAK,aAAa,KAAK,gBAAgB,wBAAwB,IAAI,GAAG;AAExE,WAAO;AAAA,EACT;AAEA,QAAM,UAAsC;AAC5C,QAAM,WAAW,kBAAkB,OAAO;AAC1C,MAAI,YAAY,WAAW;AAC3B,MAAI,YAAY,GAAG;AACjB,WAAO,KAAK,OAAO;AAAA,EACrB;AAEA,MAAI,WAAW,CAAC;AAChB,MAAI,QAAQ,cAAc,QAAQ;AAChC,eAAW,QAAQ,cAAc,EAAE,SAAS,KAAK,CAAC;AAAA,EACpD,OAAO;AAEL,eAAY,SAAQ,cAAc,SAAS;AAAA,EAC7C;AACA,GAAC,GAAG,QAAQ,EAAE,QAAQ,CAAC,UAAU;AAE/B,gBAAY,sBAAsB,OAAO,MAAM,KAAK;AAAA,EACtD,CAAC;AACD,SAAO;AACT;AA0CO,4BAA4B,SAAS;AAE1C,MAAI,QAAQ,QAAQ,iBAAiB,GAAG;AACtC,WAAO;AAAA,EACT;AAGA,MAAI,QAAQ,QAAQ,yCAAyC,GAAG;AAC9D,WAAO,QAAQ,QAAQ,kBAAkB;AAAA,EAC3C;AAGA,SAAO,QAAQ,QAAQ,4DAA4D;AACrF;AAQO,0BAA0B,SAAS;AACxC,SAAO,QAAQ,YAAY,EAAE,kBAAkB;AACjD;AAWO,8BAA8B,SAAS;AAC5C,QAAM,oBAAoB,CAAC;AAC3B,QAAM,sBAAsB,sBAAsB,SAAS,iBAAiB;AAG5E,MAAI,qBAAqB;AACvB,WAAO,uBAAuB,iBAAiB;AAAA,EACjD;AACA,SAAO;AACT;;;ACnOA,AAOA,IAAM,YAAY,CAAC;AAKZ,gCAA0B;AAAA,EAI/B,YAAY,MAAM;AAMhB,SAAK,OAAO;AAQZ,SAAK,aAAa;AAElB,SAAK,cAAc,KAAK,YAAY,KAAK,IAAI;AAAA,EAC/C;AAAA,EAEA,gBAAgB;AACd,aAAS,iBAAiB,WAAW,KAAK,WAAW;AAAA,EACvD;AAAA,EAEA,mBAAmB;AACjB,aAAS,oBAAoB,WAAW,KAAK,WAAW;AAAA,EAC1D;AAAA,EAgBA,UAAU,UAAU;AAClB,SAAK,aAAa;AAElB,QAAI,KAAK,oBAAoB,WAAW,GAAG;AACzC,WAAK,aAAa;AAClB,YAAM,IAAI,MAAM,qFAAqF;AAAA,IACvG;AAEA,cAAU,KAAK,IAAI;AAEnB,QAAI,KAAK,0BAA0B,IAAI;AACrC,WAAK,oBAAoB,GAAG,MAAM;AAAA,IACpC;AAAA,EACF;AAAA,EAMA,eAAe;AACb,SAAK,aAAa;AAElB,cAAU,IAAI;AAAA,EAChB;AAAA,EAaA,YAAY,OAAO;AACjB,QAAI,CAAC,KAAK,YAAY;AACpB;AAAA,IACF;AAGA,QAAI,SAAS,MAAM,KAAK,SAAS,EAAE,IAAI,GAAG;AACxC;AAAA,IACF;AAEA,QAAI,MAAM,QAAQ,OAAO;AACvB,YAAM,eAAe;AAErB,YAAM,WAAW,MAAM;AACvB,WAAK,mBAAmB,QAAQ;AAAA,IAClC;AAAA,EACF;AAAA,EAaA,mBAAmB,WAAW,OAAO;AACnC,UAAM,oBAAoB,KAAK;AAC/B,UAAM,OAAO,WAAW,KAAK;AAC7B,UAAM,eAAe,KAAK;AAC1B,UAAM,YAAa,mBAAkB,SAAS,eAAe,QAAQ,kBAAkB;AACvF,sBAAkB,WAAW,MAAM;AAAA,EACrC;AAAA,MAQI,sBAAsB;AACxB,WAAO,qBAAqB,KAAK,UAAU;AAAA,EAC7C;AAAA,MAQI,wBAAwB;AAC1B,UAAM,oBAAoB,KAAK;AAC/B,WAAO,kBAAkB,QAAQ,kBAAkB,OAAO,gBAAgB,EAAE,IAAI,CAAC;AAAA,EACnF;AACF;",
  "names": []
}
