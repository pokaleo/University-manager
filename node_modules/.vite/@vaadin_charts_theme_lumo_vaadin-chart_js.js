import "./chunk-WVVSKGSY.js";
import {
  ResizeMixin
} from "./chunk-WCV6MGXN.js";
import "./chunk-SJ45UT3W.js";
import {
  beforeNextRender
} from "./chunk-ZGILPT2L.js";
import "./chunk-TSMFV5J4.js";
import "./chunk-WUR5UZ22.js";
import "./chunk-YZXPUGLM.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-PALO6AVQ.js";
import {
  ElementMixin
} from "./chunk-OKCEHAIA.js";
import "./chunk-KCWZ32HQ.js";
import "./chunk-ZFVP5VBM.js";
import "./chunk-QNRFZUBX.js";
import {
  css
} from "./chunk-PYLEJJK2.js";
import {
  FlattenedNodesObserver
} from "./chunk-IASAGYPQ.js";
import {
  PolymerElement,
  html
} from "./chunk-EMDRMWGL.js";
import "./chunk-H3KD7FYF.js";
import "./chunk-NZ6RMXB7.js";
import "./chunk-RQI6IG5T.js";
import {
  __spreadProps,
  __spreadValues
} from "./chunk-KTZKXPFA.js";

// node_modules/@vaadin/charts/theme/vaadin-chart-base-theme.js
var chartBaseTheme = css`
  :host {
    font-family: -apple-system, BlinkMacSystemFont, 'Roboto', 'Segoe UI', Helvetica, Arial, sans-serif,
      'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';
    font-size: 12px;
    line-height: normal;
  }

  .highcharts-container {
    position: relative;
    overflow: hidden;
    width: 100%;
    height: 100%;
    text-align: left;
    z-index: 0;
    /* #1072 */
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
  }

  :where([styled-mode]) .highcharts-root {
    display: block;
  }

  :where([styled-mode]) .highcharts-root text {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-strong {
    font-weight: 600;
  }

  :where([styled-mode]) .highcharts-emphasized {
    font-style: italic;
  }

  :where([styled-mode]) .highcharts-anchor {
    cursor: pointer;
  }

  :where([styled-mode]) .highcharts-background {
    fill: var(--vaadin-charts-background, #fff);
  }

  :where([styled-mode]) .highcharts-plot-border,
  :where([styled-mode]) .highcharts-plot-background {
    fill: none;
  }

  :where([styled-mode]) .highcharts-label-box {
    fill: none;
  }

  :where([styled-mode]) .highcharts-button-box {
    fill: inherit;
  }

  :where([styled-mode]) .highcharts-tracker-line {
    stroke-linejoin: round;
    stroke: rgba(192, 192, 192, 0.0001);
    stroke-width: 22;
    fill: none;
  }

  :where([styled-mode]) .highcharts-tracker-area {
    fill: rgba(192, 192, 192, 0.0001);
    stroke-width: 0;
  }

  /* Titles */
  :where([styled-mode]) .highcharts-title {
    fill: var(--vaadin-charts-title-label, hsl(214, 35%, 15%));
    font-size: 1.5em;
    font-weight: 600;
  }

  :where([styled-mode]) .highcharts-subtitle {
    fill: var(--vaadin-charts-secondary-label, hsla(214, 42%, 18%, 0.72));
  }

  /* Axes */
  :where([styled-mode]) .highcharts-axis-line {
    fill: none;
    stroke: var(--vaadin-charts-axis-line, hsla(214, 61%, 25%, 0.05));
  }

  :where([styled-mode]) .highcharts-yaxis .highcharts-axis-line {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-axis-title {
    fill: var(--vaadin-charts-axis-title, hsla(214, 42%, 18%, 0.72));
  }

  :where([styled-mode]) .highcharts-axis-labels {
    fill: var(--vaadin-charts-axis-label, hsla(214, 42%, 18%, 0.72));
    cursor: default;
    font-size: 0.9em;
  }

  :where([styled-mode]) .highcharts-grid-line {
    fill: none;
    stroke: var(--vaadin-charts-grid-line, hsla(214, 53%, 23%, 0.16));
  }

  :where([styled-mode]) .highcharts-xaxis-grid .highcharts-grid-line {
    stroke-width: var(--vaadin-charts-xaxis-line-width, 0px);
  }

  :where([styled-mode]) .highcharts-tick {
    stroke: var(--vaadin-charts-grid-line, hsla(214, 53%, 23%, 0.16));
  }

  :where([styled-mode]) .highcharts-yaxis .highcharts-tick {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-minor-grid-line {
    stroke: var(--vaadin-charts-contrast-5pct, hsla(214, 61%, 25%, 0.05));
  }

  :where([styled-mode]) .highcharts-crosshair-thin {
    stroke-width: 1px;
    stroke: var(--vaadin-charts-grid-line, hsla(214, 53%, 23%, 0.16));
  }

  :where([styled-mode]) .highcharts-crosshair-category {
    stroke: var(--vaadin-charts-color-0, #5ac2f7);
    stroke-opacity: 0.25;
  }

  /* Credits */
  :where([styled-mode]) .highcharts-credits {
    cursor: pointer;
    fill: var(--vaadin-charts-disabled-label, hsla(214, 50%, 22%, 0.26));
    font-size: 0.7em;
    transition: fill 250ms, font-size 250ms;
  }

  :where([styled-mode]) .highcharts-credits:hover {
    fill: black;
    font-size: 1em;
  }

  /* Tooltip */
  :where([styled-mode]) .highcharts-tooltip {
    cursor: default;
    pointer-events: none;
    white-space: nowrap;
    transition: stroke 150ms;
  }

  :where([styled-mode]) .highcharts-tooltip {
    filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.05)) !important;
  }

  :where([styled-mode]) .highcharts-tooltip text {
    fill: var(--vaadin-charts-data-label, hsla(214, 40%, 16%, 0.94));
  }

  :where([styled-mode]) .highcharts-tooltip .highcharts-header {
    font-size: 0.85em;
    color: var(--vaadin-charts-secondary-label, hsla(214, 42%, 18%, 0.72));
  }

  :where([styled-mode]) .highcharts-tooltip-box {
    stroke-width: 1px;
    stroke: var(--vaadin-charts-tooltip-border, inherit);
    fill: var(--vaadin-charts-tooltip-background, #fff);
    fill-opacity: var(--vaadin-charts-tooltip-background-opacity, 1);
  }

  :where([styled-mode]) .highcharts-tooltip-box .highcharts-label-box {
    fill: var(--vaadin-charts-tooltip-background, #fff);
    fill-opacity: var(--vaadin-charts-tooltip-background-opacity, 1);
  }

  :where([styled-mode]) .highcharts-tooltip-header {
    stroke-width: 1px;
    stroke: var(--vaadin-charts-contrast-20pct, hsla(214, 53%, 23%, 0.16));
  }

  :where([styled-mode]) div.highcharts-tooltip {
    filter: none;
  }

  :where([styled-mode]) .highcharts-selection-marker {
    fill: var(--vaadin-charts-color-0, #5ac2f7);
    fill-opacity: 0.25;
  }

  :where([styled-mode]) .highcharts-graph {
    fill: none;
    stroke-width: 2px;
    stroke-linecap: round;
    stroke-linejoin: round;
  }

  :where([styled-mode]) .highcharts-state-hover .highcharts-graph {
    stroke-width: 3;
  }

  :where([styled-mode]) .highcharts-point-inactive {
    opacity: 0.2;
    transition: opacity 50ms;
    /* quick in */
  }

  :where([styled-mode]) .highcharts-series-inactive {
    opacity: 0.2;
    transition: opacity 50ms;
    /* quick in */
  }

  :where([styled-mode]) .highcharts-state-hover path {
    transition: stroke-width 50ms;
    /* quick in */
  }

  :where([styled-mode]) .highcharts-state-normal path {
    transition: stroke-width 250ms;
    /* slow out */
  }

  /* Legend hover affects points and series */
  :where([styled-mode]) g.highcharts-series,
  :where([styled-mode]) .highcharts-point,
  :where([styled-mode]) .highcharts-markers,
  :where([styled-mode]) .highcharts-data-labels {
    transition: opacity 250ms;
  }

  :where([styled-mode]) .highcharts-legend-series-active g.highcharts-series:not(.highcharts-series-hover),
  :where([styled-mode]) .highcharts-legend-point-active .highcharts-point:not(.highcharts-point-hover),
  :where([styled-mode]) .highcharts-legend-series-active .highcharts-markers:not(.highcharts-series-hover),
  :where([styled-mode]) .highcharts-legend-series-active .highcharts-data-labels:not(.highcharts-series-hover) {
    opacity: 0.2;
  }

  /* Series options */
  /* Default colors */
  /* vaadin-charts custom properties */
  /* Use of :where() function to avoid setting classes with high specificity */
  :where([styled-mode]) .highcharts-color-0 {
    fill: var(--vaadin-charts-color-0, #5ac2f7);
    stroke: var(--vaadin-charts-color-0, #5ac2f7);
  }

  :where([styled-mode]) .highcharts-color-1 {
    fill: var(--vaadin-charts-color-1, #1676f3);
    stroke: var(--vaadin-charts-color-1, #1676f3);
  }

  :where([styled-mode]) .highcharts-color-2 {
    fill: var(--vaadin-charts-color-2, #ff7d94);
    stroke: var(--vaadin-charts-color-2, #ff7d94);
  }

  :where([styled-mode]) .highcharts-color-3 {
    fill: var(--vaadin-charts-color-3, #c5164e);
    stroke: var(--vaadin-charts-color-3, #c5164e);
  }

  :where([styled-mode]) .highcharts-color-4 {
    fill: var(--vaadin-charts-color-4, #15c15d);
    stroke: var(--vaadin-charts-color-4, #15c15d);
  }

  :where([styled-mode]) .highcharts-color-5 {
    fill: var(--vaadin-charts-color-5, #0e8151);
    stroke: var(--vaadin-charts-color-5, #0e8151);
  }

  :where([styled-mode]) .highcharts-color-6 {
    fill: var(--vaadin-charts-color-6, #c18ed2);
    stroke: var(--vaadin-charts-color-6, #c18ed2);
  }

  :where([styled-mode]) .highcharts-color-7 {
    fill: var(--vaadin-charts-color-7, #9233b3);
    stroke: var(--vaadin-charts-color-7, #9233b3);
  }

  :where([styled-mode]) .highcharts-color-8 {
    fill: var(--vaadin-charts-color-8, #fda253);
    stroke: var(--vaadin-charts-color-8, #fda253);
  }

  :where([styled-mode]) .highcharts-color-9 {
    fill: var(--vaadin-charts-color-9, #e24932);
    stroke: var(--vaadin-charts-color-9, #e24932);
  }

  /* end of vaadin-charts custom properties */

  :where([styled-mode]) .highcharts-area {
    fill-opacity: 0.5;
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-markers {
    stroke-width: 1px;
    stroke: var(--vaadin-charts-background, #fff);
  }

  :where([styled-mode])
    .highcharts-a11y-markers-hidden
    .highcharts-point:not(.highcharts-point-hover):not(.highcharts-a11y-marker-visible),
  :where([styled-mode]) .highcharts-a11y-marker-hidden {
    opacity: 0;
  }

  :where([styled-mode]) .highcharts-point {
    stroke-width: 1px;
  }

  :where([styled-mode]) .highcharts-dense-data .highcharts-point {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-data-label {
    font-size: 0.9em;
    font-weight: normal;
  }

  :where([styled-mode]) .highcharts-data-label-box {
    fill: none;
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-data-label text,
  :where([styled-mode]) text.highcharts-data-label {
    fill: var(--vaadin-charts-data-label, hsla(214, 40%, 16%, 0.94));
  }

  :where([styled-mode]) .highcharts-data-label-connector {
    fill: none;
  }

  :where([styled-mode]) .highcharts-data-label-hidden {
    pointer-events: none;
  }

  :where([styled-mode]) .highcharts-halo {
    fill-opacity: 0.25;
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-series:not(.highcharts-pie-series) .highcharts-point-select,
  :where([styled-mode]) .highcharts-markers .highcharts-point-select {
    fill: var(--vaadin-charts-grid-line, hsla(214, 53%, 23%, 0.16));
    stroke: var(--vaadin-charts-contrast, hsl(214, 35%, 15%));
  }

  :where([styled-mode]) .highcharts-column-series rect.highcharts-point {
    stroke: var(--vaadin-charts-background, #fff);
  }

  :where([styled-mode]) .highcharts-column-series .highcharts-point {
    transition: fill-opacity 250ms;
  }

  :where([styled-mode]) .highcharts-column-series .highcharts-point-hover {
    fill-opacity: 0.75;
    transition: fill-opacity 50ms;
  }

  :where([styled-mode]) .highcharts-pie-series .highcharts-point {
    stroke-linejoin: round;
    stroke: var(--vaadin-charts-background, #fff);
  }

  :where([styled-mode]) .highcharts-pie-series .highcharts-point-hover {
    fill-opacity: 0.75;
    transition: fill-opacity 50ms;
  }

  :where([styled-mode]) .highcharts-funnel-series .highcharts-point {
    stroke-linejoin: round;
    stroke: var(--vaadin-charts-background, #fff);
    stroke-width: 2px;
  }

  :where([styled-mode]) .highcharts-funnel-series .highcharts-point-hover {
    fill-opacity: 0.75;
    transition: fill-opacity 50ms;
  }

  :where([styled-mode]) .highcharts-funnel-series .highcharts-point-select {
    fill: inherit;
    stroke: inherit;
  }

  :where([styled-mode]) .highcharts-pyramid-series .highcharts-point {
    stroke-linejoin: round;
    stroke: var(--vaadin-charts-background, #fff);
    stroke-width: 2px;
  }

  :where([styled-mode]) .highcharts-pyramid-series .highcharts-point-hover {
    fill-opacity: 0.75;
    transition: fill-opacity 50ms;
  }

  :where([styled-mode]) .highcharts-pyramid-series .highcharts-point-select {
    fill: inherit;
    stroke: inherit;
  }

  :where([styled-mode]) .highcharts-solidgauge-series .highcharts-point {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-treemap-series .highcharts-point {
    stroke-width: 2px;
    stroke: var(--vaadin-charts-background, #fff);
    transition: stroke 250ms, fill 250ms, fill-opacity 250ms;
  }

  :where([styled-mode]) .highcharts-treemap-series .highcharts-point-hover {
    stroke-width: 0px;
    stroke: var(--vaadin-charts-background, #fff);
    fill-opacity: 0.75;
    transition: stroke 25ms, fill 25ms, fill-opacity 25ms;
  }

  :where([styled-mode]) .highcharts-treemap-series .highcharts-above-level {
    display: none;
  }

  :where([styled-mode]) .highcharts-treemap-series .highcharts-internal-node {
    fill: none;
  }

  :where([styled-mode]) .highcharts-treemap-series .highcharts-internal-node-interactive {
    fill-opacity: 0.15;
    cursor: pointer;
  }

  :where([styled-mode]) .highcharts-treemap-series .highcharts-internal-node-interactive:hover {
    fill-opacity: 0.75;
  }

  :where([styled-mode]) .highcharts-vector-series .highcharts-point {
    fill: none;
    stroke-width: 2px;
  }

  :where([styled-mode]) .highcharts-windbarb-series .highcharts-point {
    fill: none;
    stroke-width: 2px;
  }

  :where([styled-mode]) .highcharts-lollipop-stem {
    stroke: var(--vaadin-charts-contrast, hsl(214, 35%, 15%));
  }

  :where([styled-mode]) .highcharts-focus-border {
    fill: none;
    stroke-width: 2px;
  }

  :where([styled-mode]) .highcharts-legend-item-hidden .highcharts-focus-border {
    fill: none !important;
  }

  /* Legend */
  :where([styled-mode]) .highcharts-legend-box {
    fill: none;
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-legend-item > text {
    fill: var(--vaadin-charts-data-label, hsla(214, 40%, 16%, 0.94));
    font-weight: normal;
    font-size: 1em;
    cursor: pointer;
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-legend-item > .highcharts-point {
    stroke-width: 0px;
  }

  :where([styled-mode]) .highcharts-legend-item:hover text {
    fill: var(--vaadin-charts-title-label, hsl(214, 35%, 15%));
  }

  :where([styled-mode]) .highcharts-legend-item-hidden * {
    fill: var(--vaadin-charts-disabled-label, hsla(214, 50%, 22%, 0.26)) !important;
    stroke: var(--vaadin-charts-disabled-label, hsla(214, 50%, 22%, 0.26)) !important;
    transition: fill 250ms;
  }

  :where([styled-mode]) .highcharts-legend-nav-active {
    fill: var(--vaadin-charts-button-label, hsl(214, 90%, 52%));
    cursor: pointer;
  }

  :where([styled-mode]) .highcharts-legend-nav-inactive {
    fill: var(--vaadin-charts-disabled-label, hsla(214, 50%, 22%, 0.26));
  }

  :where([styled-mode]) circle.highcharts-legend-nav-active,
  :where([styled-mode]) circle.highcharts-legend-nav-inactive {
    /* tracker */
    fill: rgba(192, 192, 192, 0.0001);
  }

  :where([styled-mode]) .highcharts-legend-title-box {
    fill: none;
    stroke-width: 0;
  }

  /* Bubble legend */
  :where([styled-mode]) .highcharts-bubble-legend-symbol {
    stroke-width: 2;
    fill-opacity: 0.5;
  }

  :where([styled-mode]) .highcharts-bubble-legend-connectors {
    stroke-width: 1;
  }

  :where([styled-mode]) .highcharts-bubble-legend-labels {
    fill: var(--vaadin-charts-data-label, hsla(214, 40%, 16%, 0.94));
  }

  /* Loading */
  :where([styled-mode]) .highcharts-loading {
    position: absolute;
    background-color: var(--vaadin-charts-background, #fff);
    opacity: 0.5;
    text-align: center;
    z-index: 10;
    transition: opacity 250ms;
  }

  :where([styled-mode]) .highcharts-loading-hidden {
    height: 0 !important;
    opacity: 0;
    overflow: hidden;
    transition: opacity 250ms, height 250ms step-end;
  }

  :where([styled-mode]) .highcharts-loading-inner {
    font-weight: normal;
    position: relative;
    top: 45%;
  }

  /* Plot bands and polar pane backgrounds */
  :where([styled-mode]) .highcharts-plot-band,
  :where([styled-mode]) .highcharts-pane {
    fill: var(--vaadin-charts-contrast, hsl(214, 35%, 15%));
    fill-opacity: 0.05;
  }

  :where([styled-mode]) .highcharts-plot-line {
    fill: none;
    stroke: var(--vaadin-charts-contrast-60pct, hsla(214, 43%, 19%, 0.61));
    stroke-width: 1px;
  }

  :where([styled-mode]) .highcharts-plot-line-label {
    fill: var(--vaadin-charts-data-label, hsla(214, 40%, 16%, 0.94));
  }

  /* Highcharts More and modules */
  :where([styled-mode]) .highcharts-boxplot-box {
    fill: var(--vaadin-charts-background, #fff);
  }

  :where([styled-mode]) .highcharts-boxplot-median {
    stroke-width: 2px;
  }

  :where([styled-mode]) .highcharts-bubble-series .highcharts-point {
    fill-opacity: 0.5;
  }

  :where([styled-mode]) .highcharts-errorbar-series .highcharts-point {
    stroke: var(--vaadin-charts-contrast, hsl(214, 35%, 15%));
  }

  :where([styled-mode]) .highcharts-gauge-series .highcharts-data-label-box {
    stroke: var(--vaadin-charts-grid-line, hsla(214, 53%, 23%, 0.16));
    stroke-width: 1px;
  }

  :where([styled-mode]) .highcharts-gauge-series .highcharts-dial {
    fill: var(--vaadin-charts-contrast, hsl(214, 35%, 15%));
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-polygon-series .highcharts-graph {
    fill: inherit;
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-waterfall-series .highcharts-graph {
    stroke: var(--vaadin-charts-contrast-60pct, hsla(214, 43%, 19%, 0.61));
    stroke-dasharray: 1, 3;
  }

  :where([styled-mode]) .highcharts-sankey-series .highcharts-point {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-sankey-series .highcharts-link {
    transition: fill 250ms, fill-opacity 250ms;
    fill-opacity: 0.5;
  }

  :where([styled-mode]) .highcharts-sankey-series .highcharts-point-hover.highcharts-link {
    transition: fill 50ms, fill-opacity 50ms;
    fill-opacity: 1;
  }

  :where([styled-mode]) .highcharts-venn-series .highcharts-point {
    fill-opacity: 0.75;
    stroke: var(--vaadin-charts-background, #fff);
    transition: stroke 250ms, fill-opacity 250ms;
  }

  :where([styled-mode]) .highcharts-venn-series .highcharts-point-hover {
    fill-opacity: 1;
    stroke: var(--vaadin-charts-background, #fff);
  }

  /* Highstock */
  :where([styled-mode]) .highcharts-navigator-mask-outside {
    fill-opacity: 0;
  }

  :where([styled-mode]) .highcharts-navigator-mask-inside {
    fill: var(--vaadin-charts-color-0, #5ac2f7);
    /* navigator.maskFill option */
    fill-opacity: 0.2;
    cursor: ew-resize;
  }

  :where([styled-mode]) .highcharts-navigator-outline {
    stroke: var(--vaadin-charts-grid-line, hsla(214, 53%, 23%, 0.16));
    fill: none;
  }

  :where([styled-mode]) .highcharts-navigator-handle {
    stroke: var(--vaadin-charts-contrast-20pct, hsla(214, 53%, 23%, 0.16));
    fill: var(--vaadin-charts-background, #fff);
    cursor: ew-resize;
  }

  :where([styled-mode]) .highcharts-navigator-series {
    fill: var(--vaadin-charts-color-1, #1676f3);
    stroke: var(--vaadin-charts-color-1, #1676f3);
  }

  :where([styled-mode]) .highcharts-navigator-series .highcharts-graph {
    stroke-width: 1px;
  }

  :where([styled-mode]) .highcharts-navigator-series .highcharts-area {
    fill-opacity: 0.05;
  }

  :where([styled-mode]) .highcharts-navigator-xaxis .highcharts-axis-line {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-navigator-xaxis .highcharts-grid-line {
    stroke-width: 1px;
    stroke: var(--vaadin-charts-grid-line, hsla(214, 53%, 23%, 0.16));
  }

  :where([styled-mode]) .highcharts-navigator-xaxis.highcharts-axis-labels {
    fill: var(--vaadin-charts-secondary-label, hsla(214, 42%, 18%, 0.72));
  }

  :where([styled-mode]) .highcharts-navigator-yaxis .highcharts-grid-line {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-scrollbar-thumb {
    fill: var(--vaadin-charts-contrast-20pct, hsla(214, 53%, 23%, 0.16));
  }

  :where([styled-mode]) .highcharts-scrollbar-button {
    fill: var(--vaadin-charts-background, #fff);
  }

  :where([styled-mode]) .highcharts-scrollbar-arrow {
    fill: var(--vaadin-charts-data-label, hsla(214, 40%, 16%, 0.94));
  }

  :where([styled-mode]) .highcharts-scrollbar-rifles {
    stroke: var(--vaadin-charts-data-label, hsla(214, 40%, 16%, 0.94));
    stroke-width: 1px;
  }

  :where([styled-mode]) .highcharts-scrollbar-track {
    fill: var(--vaadin-charts-contrast-5pct, hsla(214, 61%, 25%, 0.05));
  }

  :where([styled-mode]) .highcharts-button {
    fill: var(--vaadin-charts-button-background, hsla(214, 61%, 25%, 0.05));
    cursor: default;
    transition: fill 250ms;
  }

  :where([styled-mode]) .highcharts-button text {
    fill: var(--vaadin-charts-button-label, hsl(214, 90%, 52%));
    font-weight: 600;
  }

  :where([styled-mode]) .highcharts-button-hover {
    transition: fill 0ms;
    fill: var(--vaadin-charts-button-hover-background, hsla(214, 90%, 52%, 0.1));
    stroke-width: 0px;
  }

  :where([styled-mode]) .highcharts-button-hover text {
    fill: var(--vaadin-charts-button-label, hsl(214, 90%, 52%));
  }

  :where([styled-mode]) .highcharts-button-pressed {
    fill: var(--vaadin-charts-button-active-background, hsl(214, 90%, 52%));
  }

  :where([styled-mode]) .highcharts-button-pressed text {
    fill: var(--vaadin-charts-button-active-label, #fff);
  }

  :where([styled-mode]) .highcharts-button-disabled text {
    fill: var(--vaadin-charts-button-label, hsl(214, 90%, 52%));
  }

  :where([styled-mode]) .highcharts-range-selector-buttons > text {
    fill: var(--vaadin-charts-secondary-label, hsla(214, 42%, 18%, 0.72));
  }

  :where([styled-mode]) .highcharts-range-selector-buttons .highcharts-button {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-range-label rect {
    fill: none;
  }

  :where([styled-mode]) .highcharts-range-label text {
    fill: var(--vaadin-charts-secondary-label, hsla(214, 42%, 18%, 0.72));
  }

  :where([styled-mode]) .highcharts-range-input rect {
    fill: var(--vaadin-charts-contrast-10pct, hsla(214, 57%, 24%, 0.1));
    rx: 2;
    ry: 2;
  }

  :where([styled-mode]) .highcharts-range-input:hover rect {
    fill: var(--vaadin-charts-contrast-20pct, hsla(214, 53%, 23%, 0.16));
    transition: fill 250ms;
  }

  :where([styled-mode]) .highcharts-range-input text {
    fill: var(--vaadin-charts-data-label, hsla(214, 40%, 16%, 0.94));
  }

  :where([styled-mode]) input.highcharts-range-selector {
    position: absolute;
    border: 0;
    width: 1px;
    /* Chrome needs a pixel to see it */
    height: 1px;
    padding: 0;
    text-align: center;
    left: -9em;
    /* #4798 */
  }

  :where([styled-mode]) .highcharts-crosshair-label text {
    fill: var(--vaadin-charts-background, #fff);
    font-size: 1.1em;
  }

  :where([styled-mode]) .highcharts-crosshair-label .highcharts-label-box {
    fill: inherit;
  }

  :where([styled-mode]) .highcharts-candlestick-series .highcharts-point {
    stroke: var(--vaadin-charts-contrast-60pct, hsla(214, 43%, 19%, 0.61));
    stroke-width: 1px;
  }

  :where([styled-mode]) .highcharts-candlestick-series .highcharts-point-up {
    fill: var(--vaadin-charts-color-positive, #15c15d);
  }

  :where([styled-mode]) .highcharts-candlestick-series .highcharts-point-down {
    fill: var(--vaadin-charts-color-negative, #e24932);
  }

  :where([styled-mode]) .highcharts-ohlc-series .highcharts-point-hover {
    stroke-width: 3px;
  }

  :where([styled-mode]) .highcharts-flags-series .highcharts-point .highcharts-label-box {
    stroke: var(--vaadin-charts-grid-line, hsla(214, 53%, 23%, 0.16));
    fill: var(--vaadin-charts-background, #fff);
    transition: fill 250ms;
  }

  :where([styled-mode]) .highcharts-flags-series .highcharts-point-hover .highcharts-label-box {
    stroke: var(--vaadin-charts-contrast-60pct, hsla(214, 43%, 19%, 0.61));
    fill: var(--vaadin-charts-background, #fff);
  }

  :where([styled-mode]) .highcharts-flags-series .highcharts-point text {
    fill: var(--vaadin-charts-data-label, hsla(214, 40%, 16%, 0.94));
    font-size: 0.9em;
    font-weight: normal;
  }

  :where([styled-mode]) .highcharts-flags-series .highcharts-point-hover text {
    fill: var(--vaadin-charts-title-label, hsl(214, 35%, 15%));
  }

  /* Highmaps */
  :where([styled-mode]) .highcharts-map-series .highcharts-point {
    transition: fill 500ms, fill-opacity 500ms, stroke-width 250ms;
    stroke: var(--vaadin-charts-contrast-20pct, hsla(214, 53%, 23%, 0.16));
  }

  :where([styled-mode]) .highcharts-map-series .highcharts-point-hover {
    transition: fill 0ms, fill-opacity 0ms;
    fill-opacity: 0.5;
    stroke-width: 2px;
  }

  :where([styled-mode]) .highcharts-mapline-series .highcharts-point {
    fill: none;
  }

  :where([styled-mode]) .highcharts-heatmap-series .highcharts-point {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-map-navigation {
    font-size: 1.3em;
    font-weight: normal;
    text-align: center;
  }

  :where([styled-mode]) .highcharts-coloraxis {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-coloraxis-grid .highcharts-grid-line {
    stroke: var(--vaadin-charts-background, #fff);
  }

  :where([styled-mode]) .highcharts-coloraxis-marker {
    fill: var(--vaadin-charts-axis-label, hsla(214, 42%, 18%, 0.72));
    stroke-width: 0px;
  }

  :where([styled-mode]) .highcharts-null-point {
    fill: var(--vaadin-charts-contrast-5pct, hsla(214, 61%, 25%, 0.05));
    stroke: var(--vaadin-charts-contrast-60pct, hsla(214, 43%, 19%, 0.61));
  }

  /* 3d charts */
  :where([styled-mode]) .highcharts-3d-frame {
    fill: transparent;
  }

  /* Exporting module */
  :where([styled-mode]) .highcharts-contextbutton {
    fill: #fff;
    /* needed to capture hover */
    stroke: none;
    stroke-linecap: round;
  }

  :where([styled-mode]) .highcharts-contextbutton:hover {
    fill: #e6e6e6;
    stroke: #e6e6e6;
  }

  :where([styled-mode]) .highcharts-button-symbol {
    stroke: var(--vaadin-charts-secondary-label, hsla(214, 42%, 18%, 0.72));
    stroke-width: 3px;
  }

  :where([styled-mode]) .highcharts-menu {
    border: 1px solid #999;
    background: #fff;
    padding: 5px 0;
    box-shadow: 3px 3px 10px #888;
  }

  :where([styled-mode]) .highcharts-menu-item {
    padding: 0.5em 1em;
    background: none;
    color: var(--vaadin-charts-button-label, hsl(214, 90%, 52%));
    cursor: pointer;
    transition: background 250ms, color 250ms;
  }

  :where([styled-mode]) .highcharts-menu-item:hover {
    background: #335cad;
    color: #fff;
  }

  /* Drilldown module */
  :where([styled-mode]) .highcharts-drilldown-point {
    cursor: pointer;
  }

  :where([styled-mode]) .highcharts-drilldown-data-label text,
  :where([styled-mode]) text.highcharts-drilldown-data-label,
  :where([styled-mode]) .highcharts-drilldown-axis-label {
    cursor: pointer;
    fill: var(--vaadin-charts-button-label, hsl(214, 90%, 52%));
    font-weight: normal;
    text-decoration: underline;
  }

  /* No-data module */
  :where([styled-mode]) .highcharts-no-data text {
    font-weight: normal;
    font-size: 1rem;
    fill: var(--vaadin-charts-secondary-label, hsla(214, 42%, 18%, 0.72));
  }

  /* Drag-panes module */
  :where([styled-mode]) .highcharts-axis-resizer {
    cursor: ns-resize;
    stroke: black;
    stroke-width: 2px;
  }

  /* Bullet type series */
  :where([styled-mode]) .highcharts-bullet-target {
    stroke-width: 0;
  }

  /* Lineargauge type series */
  :where([styled-mode]) .highcharts-lineargauge-target {
    stroke-width: 1px;
    stroke: var(--vaadin-charts-contrast-60pct, hsla(214, 43%, 19%, 0.61));
  }

  :where([styled-mode]) .highcharts-lineargauge-target-line {
    stroke-width: 1px;
    stroke: var(--vaadin-charts-contrast-60pct, hsla(214, 43%, 19%, 0.61));
  }

  /* Annotations module */
  :where([styled-mode]) .highcharts-annotation-label-box {
    stroke-width: 1px;
    stroke: var(--vaadin-charts-contrast, hsl(214, 35%, 15%));
    fill: var(--vaadin-charts-contrast, hsl(214, 35%, 15%));
    fill-opacity: 0.75;
  }

  :where([styled-mode]) .highcharts-annotation-label text {
    fill: var(--vaadin-charts-disabled-label, hsla(214, 50%, 22%, 0.26));
  }

  /* Gantt */
  :where([styled-mode]) .highcharts-treegrid-node-collapsed,
  :where([styled-mode]) .highcharts-treegrid-node-expanded {
    cursor: pointer;
  }

  :where([styled-mode]) .highcharts-point-connecting-path {
    fill: none;
  }

  :where([styled-mode]) .highcharts-grid-axis .highcharts-tick {
    stroke-width: 1px;
  }

  :where([styled-mode]) .highcharts-grid-axis .highcharts-axis-line {
    stroke-width: 1px;
  }

  /* RTL styles */
  :host([dir='rtl']) :where([styled-mode]) .highcharts-container {
    text-align: right;
  }

  :host([dir='rtl']) :where([styled-mode]) input.highcharts-range-selector {
    left: auto;
    right: -9em;
  }

  :host([dir='rtl']) :where([styled-mode]) .highcharts-menu {
    box-shadow: -3px 3px 10px #888;
  }

  /* https://github.com/highcharts/highcharts/issues/16282 */
  /* without this the resize callback always calls __reflow */
  ul[aria-hidden='false'] {
    margin: 0px;
  }
`;
registerStyles("vaadin-chart", chartBaseTheme, { moduleId: "vaadin-chart-base-theme" });

// node_modules/@vaadin/charts/theme/lumo/vaadin-chart-styles.js
var chartColors = css`
  :host {
    --vaadin-charts-color-0: #5ac2f7;
    --vaadin-charts-color-1: #1676f3;
    --vaadin-charts-color-2: #ff7d94;
    --vaadin-charts-color-3: #c5164e;
    --vaadin-charts-color-4: #15c15d;
    --vaadin-charts-color-5: #0e8151;
    --vaadin-charts-color-6: #c18ed2;
    --vaadin-charts-color-7: #9233b3;
    --vaadin-charts-color-8: #fda253;
    --vaadin-charts-color-9: #e24932;
    --vaadin-charts-color-positive: var(--vaadin-charts-color-4, #15c15d);
    --vaadin-charts-color-negative: var(--vaadin-charts-color-9, #e24932);
  }

  :host([theme~='gradient']) {
    --vaadin-charts-color-0: #1676f3;
    --vaadin-charts-color-1: #13bbf0;
    --vaadin-charts-color-2: #1ee;
    --vaadin-charts-color-3: #0cd9bf;
    --vaadin-charts-color-4: #06be81;
    --vaadin-charts-color-5: #00a344;
    --vaadin-charts-color-6: #41c639;
    --vaadin-charts-color-7: #8aed2c;
    --vaadin-charts-color-8: #c0e632;
    --vaadin-charts-color-9: #f6db3a;
    --vaadin-charts-color-positive: var(--vaadin-charts-color-6);
    --vaadin-charts-color-negative: var(--vaadin-charts-color-1);
  }

  :host([theme~='monotone']) {
    --vaadin-charts-color-0: #1676f3;
    --vaadin-charts-color-1: #4795f5;
    --vaadin-charts-color-2: #71b0f7;
    --vaadin-charts-color-3: #a0cef9;
    --vaadin-charts-color-4: #bce0fa;
    --vaadin-charts-color-5: #a8d8ed;
    --vaadin-charts-color-6: #7fc3dd;
    --vaadin-charts-color-7: #54adcc;
    --vaadin-charts-color-8: #2b99bc;
    --vaadin-charts-color-9: #0284ac;
    --vaadin-charts-color-positive: var(--vaadin-charts-color-3);
    --vaadin-charts-color-negative: var(--vaadin-charts-color-9);
  }

  :host([theme~='classic']) {
    --vaadin-charts-color-0: #7cb5ec;
    --vaadin-charts-color-1: #434348;
    --vaadin-charts-color-2: #90ed7d;
    --vaadin-charts-color-3: #f7a35c;
    --vaadin-charts-color-4: #8085e9;
    --vaadin-charts-color-5: #f15c80;
    --vaadin-charts-color-6: #e4d354;
    --vaadin-charts-color-7: #2b908f;
    --vaadin-charts-color-8: #f45b5b;
    --vaadin-charts-color-9: #91e8e1;
  }
`;
var chartTheme = css`
  :host {
    --vaadin-charts-background: var(--lumo-base-color);
    --vaadin-charts-title-label: var(--lumo-header-text-color);
    --vaadin-charts-axis-title: var(--lumo-secondary-text-color);
    --vaadin-charts-axis-label: var(--lumo-secondary-text-color);
    --vaadin-charts-data-label: var(--lumo-body-text-color);
    --vaadin-charts-secondary-label: var(--lumo-secondary-text-color);
    --vaadin-charts-axis-line: var(--lumo-contrast-5pct);
    --vaadin-charts-grid-line: var(--lumo-contrast-20pct);
    --vaadin-charts-disabled-label: var(--lumo-disabled-text-color);
    --vaadin-charts-contrast: var(--lumo-contrast);
    --vaadin-charts-contrast-5pct: var(--lumo-contrast-5pct);
    --vaadin-charts-contrast-10pct: var(--lumo-contrast-10pct);
    --vaadin-charts-contrast-20pct: var(--lumo-contrast-20pct);
    --vaadin-charts-contrast-60pct: var(--lumo-contrast-60pct);
    --vaadin-charts-tooltip-background: var(--lumo-base-color);
    --vaadin-charts-tooltip-border-color: inherit;
    --vaadin-charts-button-label: var(--lumo-primary-text-color);
    --vaadin-charts-button-background: var(--lumo-contrast-5pct);
    --vaadin-charts-button-hover-background: var(--lumo-primary-color-10pct);
    --vaadin-charts-button-active-label: var(--lumo-primary-contrast-color);
    --vaadin-charts-button-active-background: var(--lumo-primary-color);
    --vaadin-charts-xaxis-line-width: 0;
    --vaadin-charts-tooltip-background-opacity: 1;
    font-family: var(--lumo-font-family);
  }
`;
registerStyles("vaadin-chart", [chartColors, chartTheme], { moduleId: "lumo-chart" });

// node_modules/highcharts/es-modules/Core/Globals.js
var w = typeof win !== "undefined" ? win : typeof window !== "undefined" ? window : {};
var Globals;
(function(Globals2) {
  Globals2.SVG_NS = "http://www.w3.org/2000/svg", Globals2.product = "Highcharts", Globals2.version = "9.2.2", Globals2.win = w, Globals2.doc = Globals2.win.document, Globals2.svg = Globals2.doc && Globals2.doc.createElementNS && !!Globals2.doc.createElementNS(Globals2.SVG_NS, "svg").createSVGRect, Globals2.userAgent = Globals2.win.navigator && Globals2.win.navigator.userAgent || "", Globals2.isChrome = Globals2.userAgent.indexOf("Chrome") !== -1, Globals2.isFirefox = Globals2.userAgent.indexOf("Firefox") !== -1, Globals2.isMS = /(edge|msie|trident)/i.test(Globals2.userAgent) && !Globals2.win.opera, Globals2.isSafari = !Globals2.isChrome && Globals2.userAgent.indexOf("Safari") !== -1, Globals2.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(Globals2.userAgent), Globals2.isWebKit = Globals2.userAgent.indexOf("AppleWebKit") !== -1, Globals2.deg2rad = Math.PI * 2 / 360, Globals2.hasBidiBug = Globals2.isFirefox && parseInt(Globals2.userAgent.split("Firefox/")[1], 10) < 4, Globals2.hasTouch = !!Globals2.win.TouchEvent, Globals2.marginNames = [
    "plotTop",
    "marginRight",
    "marginBottom",
    "plotLeft"
  ], Globals2.noop = function() {
  }, Globals2.supportsPassiveEvents = function() {
    var supportsPassive = false;
    if (!Globals2.isMS) {
      var opts = Object.defineProperty({}, "passive", {
        get: function() {
          supportsPassive = true;
        }
      });
      if (Globals2.win.addEventListener && Globals2.win.removeEventListener) {
        Globals2.win.addEventListener("testPassive", Globals2.noop, opts);
        Globals2.win.removeEventListener("testPassive", Globals2.noop, opts);
      }
    }
    return supportsPassive;
  }();
  Globals2.charts = [];
  Globals2.dateFormats = {};
  Globals2.seriesTypes = {};
  Globals2.symbolSizes = {};
  Globals2.chartCount = 0;
})(Globals || (Globals = {}));
var Globals_default = Globals;

// node_modules/highcharts/es-modules/Core/Utilities.js
var charts = Globals_default.charts;
var doc = Globals_default.doc;
var win2 = Globals_default.win;
function error(code, stop4, chart, params) {
  var severity = stop4 ? "Highcharts error" : "Highcharts warning";
  if (code === 32) {
    code = severity + ": Deprecated member";
  }
  var isCode = isNumber(code);
  var message = isCode ? severity + " #" + code + ": www.highcharts.com/errors/" + code + "/" : code.toString();
  var defaultHandler = function() {
    if (stop4) {
      throw new Error(message);
    }
    if (win2.console && error.messages.indexOf(message) === -1) {
      console.warn(message);
    }
  };
  if (typeof params !== "undefined") {
    var additionalMessages_1 = "";
    if (isCode) {
      message += "?";
    }
    objectEach(params, function(value, key) {
      additionalMessages_1 += "\n - " + key + ": " + value;
      if (isCode) {
        message += encodeURI(key) + "=" + encodeURI(value);
      }
    });
    message += additionalMessages_1;
  }
  fireEvent(Globals_default, "displayError", { chart, code, message, params }, defaultHandler);
  error.messages.push(message);
}
(function(error12) {
  error12.messages = [];
})(error || (error = {}));
function merge() {
  var i, args = arguments, ret = {};
  var doCopy = function(copy, original) {
    if (typeof copy !== "object") {
      copy = {};
    }
    objectEach(original, function(value, key) {
      if (key === "__proto__" || key === "constructor") {
        return;
      }
      if (isObject(value, true) && !isClass(value) && !isDOMElement(value)) {
        copy[key] = doCopy(copy[key] || {}, value);
      } else {
        copy[key] = original[key];
      }
    });
    return copy;
  };
  if (args[0] === true) {
    ret = args[1];
    args = Array.prototype.slice.call(args, 2);
  }
  var len = args.length;
  for (i = 0; i < len; i++) {
    ret = doCopy(ret, args[i]);
  }
  return ret;
}
function clamp(value, min, max) {
  return value > min ? value < max ? value : max : min;
}
function cleanRecursively(newer, older) {
  var result2 = {};
  objectEach(newer, function(_val, key) {
    var ob;
    if (isObject(newer[key], true) && !newer.nodeType && older[key]) {
      ob = cleanRecursively(newer[key], older[key]);
      if (Object.keys(ob).length) {
        result2[key] = ob;
      }
    } else if (isObject(newer[key]) || newer[key] !== older[key]) {
      result2[key] = newer[key];
    }
  });
  return result2;
}
function pInt(s, mag) {
  return parseInt(s, mag || 10);
}
function isString(s) {
  return typeof s === "string";
}
function isArray(obj) {
  var str = Object.prototype.toString.call(obj);
  return str === "[object Array]" || str === "[object Array Iterator]";
}
function isObject(obj, strict) {
  return !!obj && typeof obj === "object" && (!strict || !isArray(obj));
}
function isDOMElement(obj) {
  return isObject(obj) && typeof obj.nodeType === "number";
}
function isClass(obj) {
  var c = obj && obj.constructor;
  return !!(isObject(obj, true) && !isDOMElement(obj) && (c && c.name && c.name !== "Object"));
}
function isNumber(n) {
  return typeof n === "number" && !isNaN(n) && n < Infinity && n > -Infinity;
}
function erase(arr, item) {
  var i = arr.length;
  while (i--) {
    if (arr[i] === item) {
      arr.splice(i, 1);
      break;
    }
  }
}
function defined(obj) {
  return typeof obj !== "undefined" && obj !== null;
}
function attr2(elem, prop, value) {
  var ret;
  if (isString(prop)) {
    if (defined(value)) {
      elem.setAttribute(prop, value);
    } else if (elem && elem.getAttribute) {
      ret = elem.getAttribute(prop);
      if (!ret && prop === "class") {
        ret = elem.getAttribute(prop + "Name");
      }
    }
  } else {
    objectEach(prop, function(val, key) {
      elem.setAttribute(key, val);
    });
  }
  return ret;
}
function splat(obj) {
  return isArray(obj) ? obj : [obj];
}
function syncTimeout(fn, delay, context) {
  if (delay > 0) {
    return setTimeout(fn, delay, context);
  }
  fn.call(0, context);
  return -1;
}
function internalClearTimeout(id) {
  if (defined(id)) {
    clearTimeout(id);
  }
}
function extend(a, b) {
  var n;
  if (!a) {
    a = {};
  }
  for (n in b) {
    a[n] = b[n];
  }
  return a;
}
function pick() {
  var args = arguments;
  var length = args.length;
  for (var i = 0; i < length; i++) {
    var arg = args[i];
    if (typeof arg !== "undefined" && arg !== null) {
      return arg;
    }
  }
}
function css2(el, styles) {
  if (Globals_default.isMS && !Globals_default.svg) {
    if (styles && typeof styles.opacity !== "undefined") {
      styles.filter = "alpha(opacity=" + styles.opacity * 100 + ")";
    }
  }
  extend(el.style, styles);
}
function createElement(tag, attribs, styles, parent, nopad) {
  var el = doc.createElement(tag);
  if (attribs) {
    extend(el, attribs);
  }
  if (nopad) {
    css2(el, { padding: "0", border: "none", margin: "0" });
  }
  if (styles) {
    css2(el, styles);
  }
  if (parent) {
    parent.appendChild(el);
  }
  return el;
}
function extendClass(parent, members) {
  var obj = function() {
  };
  obj.prototype = new parent();
  extend(obj.prototype, members);
  return obj;
}
function pad(number, length, padder) {
  return new Array((length || 2) + 1 - String(number).replace("-", "").length).join(padder || "0") + number;
}
function relativeLength(value, base, offset3) {
  return /%$/.test(value) ? base * parseFloat(value) / 100 + (offset3 || 0) : parseFloat(value);
}
function wrap(obj, method, func) {
  var proceed = obj[method];
  obj[method] = function() {
    var args = Array.prototype.slice.call(arguments), outerArgs = arguments, ctx = this;
    ctx.proceed = function() {
      proceed.apply(ctx, arguments.length ? arguments : outerArgs);
    };
    args.unshift(proceed);
    var ret = func.apply(this, args);
    ctx.proceed = null;
    return ret;
  };
}
function getMagnitude(num) {
  return Math.pow(10, Math.floor(Math.log(num) / Math.LN10));
}
function normalizeTickInterval(interval, multiples, magnitude, allowDecimals, hasTickAmount) {
  var i, retInterval = interval;
  magnitude = pick(magnitude, 1);
  var normalized = interval / magnitude;
  if (!multiples) {
    multiples = hasTickAmount ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10];
    if (allowDecimals === false) {
      if (magnitude === 1) {
        multiples = multiples.filter(function(num) {
          return num % 1 === 0;
        });
      } else if (magnitude <= 0.1) {
        multiples = [1 / magnitude];
      }
    }
  }
  for (i = 0; i < multiples.length; i++) {
    retInterval = multiples[i];
    if (hasTickAmount && retInterval * magnitude >= interval || !hasTickAmount && normalized <= (multiples[i] + (multiples[i + 1] || multiples[i])) / 2) {
      break;
    }
  }
  retInterval = correctFloat(retInterval * magnitude, -Math.round(Math.log(1e-3) / Math.LN10));
  return retInterval;
}
function stableSort(arr, sortFunction) {
  var length = arr.length;
  var sortValue, i;
  for (i = 0; i < length; i++) {
    arr[i].safeI = i;
  }
  arr.sort(function(a, b) {
    sortValue = sortFunction(a, b);
    return sortValue === 0 ? a.safeI - b.safeI : sortValue;
  });
  for (i = 0; i < length; i++) {
    delete arr[i].safeI;
  }
}
function arrayMin(data) {
  var i = data.length, min = data[0];
  while (i--) {
    if (data[i] < min) {
      min = data[i];
    }
  }
  return min;
}
function arrayMax(data) {
  var i = data.length, max = data[0];
  while (i--) {
    if (data[i] > max) {
      max = data[i];
    }
  }
  return max;
}
function destroyObjectProperties(obj, except) {
  objectEach(obj, function(val, n) {
    if (val && val !== except && val.destroy) {
      val.destroy();
    }
    delete obj[n];
  });
}
function discardElement(element) {
  if (!garbageBin) {
    garbageBin = createElement("div");
  }
  if (element) {
    garbageBin.appendChild(element);
  }
  garbageBin.innerHTML = "";
}
var garbageBin;
function correctFloat(num, prec) {
  return parseFloat(num.toPrecision(prec || 14));
}
var timeUnits = {
  millisecond: 1,
  second: 1e3,
  minute: 6e4,
  hour: 36e5,
  day: 24 * 36e5,
  week: 7 * 24 * 36e5,
  month: 28 * 24 * 36e5,
  year: 364 * 24 * 36e5
};
Math.easeInOutSine = function(pos) {
  return -0.5 * (Math.cos(Math.PI * pos) - 1);
};
function getNestedProperty(path, parent) {
  var pathElements = path.split(".");
  while (pathElements.length && defined(parent)) {
    var pathElement = pathElements.shift();
    if (typeof pathElement === "undefined" || pathElement === "__proto__") {
      return;
    }
    var child = parent[pathElement];
    if (!defined(child) || typeof child === "function" || typeof child.nodeType === "number" || child === win2) {
      return;
    }
    parent = child;
  }
  return parent;
}
function getStyle(el, prop, toInt) {
  var customGetStyle = Globals_default.getStyle || getStyle;
  var style;
  if (prop === "width") {
    var offsetWidth = Math.min(el.offsetWidth, el.scrollWidth);
    var boundingClientRectWidth = el.getBoundingClientRect && el.getBoundingClientRect().width;
    if (boundingClientRectWidth < offsetWidth && boundingClientRectWidth >= offsetWidth - 1) {
      offsetWidth = Math.floor(boundingClientRectWidth);
    }
    return Math.max(0, offsetWidth - (customGetStyle(el, "padding-left", true) || 0) - (customGetStyle(el, "padding-right", true) || 0));
  }
  if (prop === "height") {
    return Math.max(0, Math.min(el.offsetHeight, el.scrollHeight) - (customGetStyle(el, "padding-top", true) || 0) - (customGetStyle(el, "padding-bottom", true) || 0));
  }
  if (!win2.getComputedStyle) {
    error(27, true);
  }
  var css16 = win2.getComputedStyle(el, void 0);
  if (css16) {
    style = css16.getPropertyValue(prop);
    if (pick(toInt, prop !== "opacity")) {
      style = pInt(style);
    }
  }
  return style;
}
function inArray(item, arr, fromIndex) {
  error(32, false, void 0, { "Highcharts.inArray": "use Array.indexOf" });
  return arr.indexOf(item, fromIndex);
}
var find = Array.prototype.find ? function(arr, callback) {
  return arr.find(callback);
} : function(arr, callback) {
  var i;
  var length = arr.length;
  for (i = 0; i < length; i++) {
    if (callback(arr[i], i)) {
      return arr[i];
    }
  }
};
function keys(obj) {
  error(32, false, void 0, { "Highcharts.keys": "use Object.keys" });
  return Object.keys(obj);
}
function offset(el) {
  var docElem = doc.documentElement, box = el.parentElement || el.parentNode ? el.getBoundingClientRect() : { top: 0, left: 0, width: 0, height: 0 };
  return {
    top: box.top + (win2.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
    left: box.left + (win2.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0),
    width: box.width,
    height: box.height
  };
}
function objectEach(obj, fn, ctx) {
  for (var key in obj) {
    if (Object.hasOwnProperty.call(obj, key)) {
      fn.call(ctx || obj[key], obj[key], key, obj);
    }
  }
}
objectEach({
  map: "map",
  each: "forEach",
  grep: "filter",
  reduce: "reduce",
  some: "some"
}, function(val, key) {
  Globals_default[key] = function(arr) {
    var _a15;
    error(32, false, void 0, (_a15 = {}, _a15["Highcharts." + key] = "use Array." + val, _a15));
    return Array.prototype[val].apply(arr, [].slice.call(arguments, 1));
  };
});
function addEvent(el, type, fn, options) {
  if (options === void 0) {
    options = {};
  }
  var owner = typeof el === "function" && el.prototype || el;
  if (!Object.hasOwnProperty.call(owner, "hcEvents")) {
    owner.hcEvents = {};
  }
  var events = owner.hcEvents;
  if (Globals_default.Point && el instanceof Globals_default.Point && el.series && el.series.chart) {
    el.series.chart.runTrackerClick = true;
  }
  var addEventListener = el.addEventListener || Globals_default.addEventListenerPolyfill;
  if (addEventListener) {
    addEventListener.call(el, type, fn, Globals_default.supportsPassiveEvents ? {
      passive: options.passive === void 0 ? type.indexOf("touch") !== -1 : options.passive,
      capture: false
    } : false);
  }
  if (!events[type]) {
    events[type] = [];
  }
  var eventObject = {
    fn,
    order: typeof options.order === "number" ? options.order : Infinity
  };
  events[type].push(eventObject);
  events[type].sort(function(a, b) {
    return a.order - b.order;
  });
  return function() {
    removeEvent(el, type, fn);
  };
}
function removeEvent(el, type, fn) {
  function removeOneEvent(type2, fn2) {
    var removeEventListener = el.removeEventListener || Globals_default.removeEventListenerPolyfill;
    if (removeEventListener) {
      removeEventListener.call(el, type2, fn2, false);
    }
  }
  function removeAllEvents(eventCollection) {
    var types, len;
    if (!el.nodeName) {
      return;
    }
    if (type) {
      types = {};
      types[type] = true;
    } else {
      types = eventCollection;
    }
    objectEach(types, function(_val, n) {
      if (eventCollection[n]) {
        len = eventCollection[n].length;
        while (len--) {
          removeOneEvent(n, eventCollection[n][len].fn);
        }
      }
    });
  }
  var owner = typeof el === "function" && el.prototype || el;
  if (Object.hasOwnProperty.call(owner, "hcEvents")) {
    var events = owner.hcEvents;
    if (type) {
      var typeEvents = events[type] || [];
      if (fn) {
        events[type] = typeEvents.filter(function(obj) {
          return fn !== obj.fn;
        });
        removeOneEvent(type, fn);
      } else {
        removeAllEvents(events);
        events[type] = [];
      }
    } else {
      removeAllEvents(events);
      delete owner.hcEvents;
    }
  }
}
function fireEvent(el, type, eventArguments, defaultFunction) {
  var e2, i;
  eventArguments = eventArguments || {};
  if (doc.createEvent && (el.dispatchEvent || el.fireEvent && el !== Globals_default)) {
    e2 = doc.createEvent("Events");
    e2.initEvent(type, true, true);
    eventArguments = extend(e2, eventArguments);
    if (el.dispatchEvent) {
      el.dispatchEvent(eventArguments);
    } else {
      el.fireEvent(type, eventArguments);
    }
  } else if (el.hcEvents) {
    if (!eventArguments.target) {
      extend(eventArguments, {
        preventDefault: function() {
          eventArguments.defaultPrevented = true;
        },
        target: el,
        type
      });
    }
    var events = [];
    var object = el;
    var multilevel = false;
    while (object.hcEvents) {
      if (Object.hasOwnProperty.call(object, "hcEvents") && object.hcEvents[type]) {
        if (events.length) {
          multilevel = true;
        }
        events.unshift.apply(events, object.hcEvents[type]);
      }
      object = Object.getPrototypeOf(object);
    }
    if (multilevel) {
      events.sort(function(a, b) {
        return a.order - b.order;
      });
    }
    events.forEach(function(obj) {
      if (obj.fn.call(el, eventArguments) === false) {
        eventArguments.preventDefault();
      }
    });
  }
  if (defaultFunction && !eventArguments.defaultPrevented) {
    defaultFunction.call(el, eventArguments);
  }
}
var serialMode;
var uniqueKey = function() {
  var hash = Math.random().toString(36).substring(2, 9) + "-";
  var id = 0;
  return function() {
    return "highcharts-" + (serialMode ? "" : hash) + id++;
  };
}();
function useSerialIds(mode) {
  return serialMode = pick(mode, serialMode);
}
function isFunction(obj) {
  return typeof obj === "function";
}
if (win2.jQuery) {
  win2.jQuery.fn.highcharts = function() {
    var args = [].slice.call(arguments);
    if (this[0]) {
      if (args[0]) {
        new Globals_default[isString(args[0]) ? args.shift() : "Chart"](this[0], args[0], args[1]);
        return this;
      }
      return charts[attr2(this[0], "data-highcharts-chart")];
    }
  };
}
var Utilities = {
  addEvent,
  arrayMax,
  arrayMin,
  attr: attr2,
  clamp,
  cleanRecursively,
  clearTimeout: internalClearTimeout,
  correctFloat,
  createElement,
  css: css2,
  defined,
  destroyObjectProperties,
  discardElement,
  erase,
  error,
  extend,
  extendClass,
  find,
  fireEvent,
  getMagnitude,
  getNestedProperty,
  getStyle,
  inArray,
  isArray,
  isClass,
  isDOMElement,
  isFunction,
  isNumber,
  isObject,
  isString,
  keys,
  merge,
  normalizeTickInterval,
  objectEach,
  offset,
  pad,
  pick,
  pInt,
  relativeLength,
  removeEvent,
  splat,
  stableSort,
  syncTimeout,
  timeUnits,
  uniqueKey,
  useSerialIds,
  wrap
};
var Utilities_default = Utilities;

// node_modules/highcharts/es-modules/Core/Color/Palette.js
var palette = {
  colors: [
    "#7cb5ec",
    "#434348",
    "#90ed7d",
    "#f7a35c",
    "#8085e9",
    "#f15c80",
    "#e4d354",
    "#2b908f",
    "#f45b5b",
    "#91e8e1"
  ],
  backgroundColor: "#ffffff",
  neutralColor100: "#000000",
  neutralColor80: "#333333",
  neutralColor60: "#666666",
  neutralColor40: "#999999",
  neutralColor20: "#cccccc",
  neutralColor10: "#e6e6e6",
  neutralColor5: "#f2f2f2",
  neutralColor3: "#f7f7f7",
  highlightColor100: "#003399",
  highlightColor80: "#335cad",
  highlightColor60: "#6685c2",
  highlightColor20: "#ccd6eb",
  highlightColor10: "#e6ebf5",
  positiveColor: "#06b535",
  negativeColor: "#f21313"
};
var Palette_default = palette;

// node_modules/highcharts/es-modules/Core/Chart/ChartDefaults.js
var ChartDefaults = {
  panning: {
    enabled: false,
    type: "x"
  },
  styledMode: false,
  borderRadius: 0,
  colorCount: 10,
  defaultSeriesType: "line",
  ignoreHiddenSeries: true,
  spacing: [10, 10, 15, 10],
  resetZoomButton: {
    theme: {
      zIndex: 6
    },
    position: {
      align: "right",
      x: -10,
      y: 10
    }
  },
  zoomBySingleTouch: false,
  width: null,
  height: null,
  borderColor: Palette_default.highlightColor80,
  backgroundColor: Palette_default.backgroundColor,
  plotBorderColor: Palette_default.neutralColor20
};
var ChartDefaults_default = ChartDefaults;

// node_modules/highcharts/es-modules/Core/Color/Color.js
var isNumber2 = Utilities_default.isNumber;
var merge2 = Utilities_default.merge;
var pInt2 = Utilities_default.pInt;
var Color = function() {
  function Color2(input) {
    this.rgba = [NaN, NaN, NaN, NaN];
    this.input = input;
    var GlobalColor = Globals_default.Color;
    if (GlobalColor && GlobalColor !== Color2) {
      return new GlobalColor(input);
    }
    if (!(this instanceof Color2)) {
      return new Color2(input);
    }
    this.init(input);
  }
  Color2.parse = function(input) {
    return input ? new Color2(input) : Color2.None;
  };
  Color2.prototype.init = function(input) {
    var result2, rgba, i, parser;
    if (typeof input === "object" && typeof input.stops !== "undefined") {
      this.stops = input.stops.map(function(stop4) {
        return new Color2(stop4[1]);
      });
    } else if (typeof input === "string") {
      this.input = input = Color2.names[input.toLowerCase()] || input;
      if (input.charAt(0) === "#") {
        var len = input.length, col = parseInt(input.substr(1), 16);
        if (len === 7) {
          rgba = [
            (col & 16711680) >> 16,
            (col & 65280) >> 8,
            col & 255,
            1
          ];
        } else if (len === 4) {
          rgba = [
            (col & 3840) >> 4 | (col & 3840) >> 8,
            (col & 240) >> 4 | col & 240,
            (col & 15) << 4 | col & 15,
            1
          ];
        }
      }
      if (!rgba) {
        i = Color2.parsers.length;
        while (i-- && !rgba) {
          parser = Color2.parsers[i];
          result2 = parser.regex.exec(input);
          if (result2) {
            rgba = parser.parse(result2);
          }
        }
      }
    }
    if (rgba) {
      this.rgba = rgba;
    }
  };
  Color2.prototype.get = function(format13) {
    var input = this.input, rgba = this.rgba;
    if (typeof input === "object" && typeof this.stops !== "undefined") {
      var ret_1 = merge2(input);
      ret_1.stops = [].slice.call(ret_1.stops);
      this.stops.forEach(function(stop4, i) {
        ret_1.stops[i] = [
          ret_1.stops[i][0],
          stop4.get(format13)
        ];
      });
      return ret_1;
    }
    if (rgba && isNumber2(rgba[0])) {
      if (format13 === "rgb" || !format13 && rgba[3] === 1) {
        return "rgb(" + rgba[0] + "," + rgba[1] + "," + rgba[2] + ")";
      }
      if (format13 === "a") {
        return "" + rgba[3];
      }
      return "rgba(" + rgba.join(",") + ")";
    }
    return input;
  };
  Color2.prototype.brighten = function(alpha) {
    var rgba = this.rgba;
    if (this.stops) {
      this.stops.forEach(function(stop4) {
        stop4.brighten(alpha);
      });
    } else if (isNumber2(alpha) && alpha !== 0) {
      for (var i = 0; i < 3; i++) {
        rgba[i] += pInt2(alpha * 255);
        if (rgba[i] < 0) {
          rgba[i] = 0;
        }
        if (rgba[i] > 255) {
          rgba[i] = 255;
        }
      }
    }
    return this;
  };
  Color2.prototype.setOpacity = function(alpha) {
    this.rgba[3] = alpha;
    return this;
  };
  Color2.prototype.tweenTo = function(to, pos) {
    var fromRgba = this.rgba, toRgba = to.rgba;
    if (!isNumber2(fromRgba[0]) || !isNumber2(toRgba[0])) {
      return to.input || "none";
    }
    var hasAlpha = toRgba[3] !== 1 || fromRgba[3] !== 1;
    return (hasAlpha ? "rgba(" : "rgb(") + Math.round(toRgba[0] + (fromRgba[0] - toRgba[0]) * (1 - pos)) + "," + Math.round(toRgba[1] + (fromRgba[1] - toRgba[1]) * (1 - pos)) + "," + Math.round(toRgba[2] + (fromRgba[2] - toRgba[2]) * (1 - pos)) + (hasAlpha ? "," + (toRgba[3] + (fromRgba[3] - toRgba[3]) * (1 - pos)) : "") + ")";
  };
  Color2.names = {
    white: "#ffffff",
    black: "#000000"
  };
  Color2.parsers = [{
    regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
    parse: function(result2) {
      return [
        pInt2(result2[1]),
        pInt2(result2[2]),
        pInt2(result2[3]),
        parseFloat(result2[4], 10)
      ];
    }
  }, {
    regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
    parse: function(result2) {
      return [pInt2(result2[1]), pInt2(result2[2]), pInt2(result2[3]), 1];
    }
  }];
  Color2.None = new Color2("");
  return Color2;
}();
var Color_default = Color;

// node_modules/highcharts/es-modules/Core/Time.js
var win3 = Globals_default.win;
var defined2 = Utilities_default.defined;
var error2 = Utilities_default.error;
var extend2 = Utilities_default.extend;
var isObject2 = Utilities_default.isObject;
var merge3 = Utilities_default.merge;
var objectEach2 = Utilities_default.objectEach;
var pad2 = Utilities_default.pad;
var pick2 = Utilities_default.pick;
var splat2 = Utilities_default.splat;
var timeUnits2 = Utilities_default.timeUnits;
var hasNewSafariBug = Globals_default.isSafari && win3.Intl && win3.Intl.DateTimeFormat.prototype.formatRange;
var hasOldSafariBug = Globals_default.isSafari && win3.Intl && !win3.Intl.DateTimeFormat.prototype.formatRange;
var Time = function() {
  function Time2(options) {
    this.options = {};
    this.useUTC = false;
    this.variableTimezone = false;
    this.Date = win3.Date;
    this.getTimezoneOffset = this.timezoneOffsetFunction();
    this.update(options);
  }
  Time2.prototype.get = function(unit, date) {
    if (this.variableTimezone || this.timezoneOffset) {
      var realMs = date.getTime();
      var ms = realMs - this.getTimezoneOffset(date);
      date.setTime(ms);
      var ret = date["getUTC" + unit]();
      date.setTime(realMs);
      return ret;
    }
    if (this.useUTC) {
      return date["getUTC" + unit]();
    }
    return date["get" + unit]();
  };
  Time2.prototype.set = function(unit, date, value) {
    if (this.variableTimezone || this.timezoneOffset) {
      if (unit === "Milliseconds" || unit === "Seconds" || unit === "Minutes" && this.getTimezoneOffset(date) % 36e5 === 0) {
        return date["setUTC" + unit](value);
      }
      var offset3 = this.getTimezoneOffset(date);
      var ms = date.getTime() - offset3;
      date.setTime(ms);
      date["setUTC" + unit](value);
      var newOffset = this.getTimezoneOffset(date);
      ms = date.getTime() + newOffset;
      return date.setTime(ms);
    }
    if (this.useUTC || hasNewSafariBug && unit === "FullYear") {
      return date["setUTC" + unit](value);
    }
    return date["set" + unit](value);
  };
  Time2.prototype.update = function(options) {
    var useUTC = pick2(options && options.useUTC, true), time = this;
    this.options = options = merge3(true, this.options || {}, options);
    this.Date = options.Date || win3.Date || Date;
    this.useUTC = useUTC;
    this.timezoneOffset = useUTC && options.timezoneOffset;
    this.getTimezoneOffset = this.timezoneOffsetFunction();
    this.variableTimezone = useUTC && !!(options.getTimezoneOffset || options.timezone);
  };
  Time2.prototype.makeTime = function(year, month, date, hours, minutes, seconds) {
    var d, offset3, newOffset;
    if (this.useUTC) {
      d = this.Date.UTC.apply(0, arguments);
      offset3 = this.getTimezoneOffset(d);
      d += offset3;
      newOffset = this.getTimezoneOffset(d);
      if (offset3 !== newOffset) {
        d += newOffset - offset3;
      } else if (offset3 - 36e5 === this.getTimezoneOffset(d - 36e5) && !hasOldSafariBug) {
        d -= 36e5;
      }
    } else {
      d = new this.Date(year, month, pick2(date, 1), pick2(hours, 0), pick2(minutes, 0), pick2(seconds, 0)).getTime();
    }
    return d;
  };
  Time2.prototype.timezoneOffsetFunction = function() {
    var time = this, options = this.options, moment = options.moment || win3.moment;
    if (!this.useUTC) {
      return function(timestamp) {
        return new Date(timestamp.toString()).getTimezoneOffset() * 6e4;
      };
    }
    if (options.timezone) {
      if (!moment) {
        error2(25);
      } else {
        return function(timestamp) {
          return -moment.tz(timestamp, options.timezone).utcOffset() * 6e4;
        };
      }
    }
    if (this.useUTC && options.getTimezoneOffset) {
      return function(timestamp) {
        return options.getTimezoneOffset(timestamp.valueOf()) * 6e4;
      };
    }
    return function() {
      return (time.timezoneOffset || 0) * 6e4;
    };
  };
  Time2.prototype.dateFormat = function(format13, timestamp, capitalize) {
    if (!defined2(timestamp) || isNaN(timestamp)) {
      return Globals_default.defaultOptions.lang && Globals_default.defaultOptions.lang.invalidDate || "";
    }
    format13 = pick2(format13, "%Y-%m-%d %H:%M:%S");
    var time = this, date = new this.Date(timestamp), hours = this.get("Hours", date), day = this.get("Day", date), dayOfMonth = this.get("Date", date), month = this.get("Month", date), fullYear = this.get("FullYear", date), lang2 = Globals_default.defaultOptions.lang, langWeekdays = lang2 && lang2.weekdays, shortWeekdays = lang2 && lang2.shortWeekdays, replacements = extend2({
      a: shortWeekdays ? shortWeekdays[day] : langWeekdays[day].substr(0, 3),
      A: langWeekdays[day],
      d: pad2(dayOfMonth),
      e: pad2(dayOfMonth, 2, " "),
      w: day,
      b: lang2.shortMonths[month],
      B: lang2.months[month],
      m: pad2(month + 1),
      o: month + 1,
      y: fullYear.toString().substr(2, 2),
      Y: fullYear,
      H: pad2(hours),
      k: hours,
      I: pad2(hours % 12 || 12),
      l: hours % 12 || 12,
      M: pad2(this.get("Minutes", date)),
      p: hours < 12 ? "AM" : "PM",
      P: hours < 12 ? "am" : "pm",
      S: pad2(date.getSeconds()),
      L: pad2(Math.floor(timestamp % 1e3), 3)
    }, Globals_default.dateFormats);
    objectEach2(replacements, function(val, key) {
      while (format13.indexOf("%" + key) !== -1) {
        format13 = format13.replace("%" + key, typeof val === "function" ? val.call(time, timestamp) : val);
      }
    });
    return capitalize ? format13.substr(0, 1).toUpperCase() + format13.substr(1) : format13;
  };
  Time2.prototype.resolveDTLFormat = function(f) {
    if (!isObject2(f, true)) {
      f = splat2(f);
      return {
        main: f[0],
        from: f[1],
        to: f[2]
      };
    }
    return f;
  };
  Time2.prototype.getTimeTicks = function(normalizedInterval, min, max, startOfWeek) {
    var time = this, Date2 = time.Date, tickPositions = [], higherRanks = {}, minDate = new Date2(min), interval = normalizedInterval.unitRange, count = normalizedInterval.count || 1;
    var i, minYear, variableDayLength, minDay;
    startOfWeek = pick2(startOfWeek, 1);
    if (defined2(min)) {
      time.set("Milliseconds", minDate, interval >= timeUnits2.second ? 0 : count * Math.floor(time.get("Milliseconds", minDate) / count));
      if (interval >= timeUnits2.second) {
        time.set("Seconds", minDate, interval >= timeUnits2.minute ? 0 : count * Math.floor(time.get("Seconds", minDate) / count));
      }
      if (interval >= timeUnits2.minute) {
        time.set("Minutes", minDate, interval >= timeUnits2.hour ? 0 : count * Math.floor(time.get("Minutes", minDate) / count));
      }
      if (interval >= timeUnits2.hour) {
        time.set("Hours", minDate, interval >= timeUnits2.day ? 0 : count * Math.floor(time.get("Hours", minDate) / count));
      }
      if (interval >= timeUnits2.day) {
        time.set("Date", minDate, interval >= timeUnits2.month ? 1 : Math.max(1, count * Math.floor(time.get("Date", minDate) / count)));
      }
      if (interval >= timeUnits2.month) {
        time.set("Month", minDate, interval >= timeUnits2.year ? 0 : count * Math.floor(time.get("Month", minDate) / count));
        minYear = time.get("FullYear", minDate);
      }
      if (interval >= timeUnits2.year) {
        minYear -= minYear % count;
        time.set("FullYear", minDate, minYear);
      }
      if (interval === timeUnits2.week) {
        minDay = time.get("Day", minDate);
        time.set("Date", minDate, time.get("Date", minDate) - minDay + startOfWeek + (minDay < startOfWeek ? -7 : 0));
      }
      minYear = time.get("FullYear", minDate);
      var minMonth = time.get("Month", minDate), minDateDate = time.get("Date", minDate), minHours = time.get("Hours", minDate);
      min = minDate.getTime();
      if ((time.variableTimezone || !time.useUTC) && defined2(max)) {
        variableDayLength = max - min > 4 * timeUnits2.month || time.getTimezoneOffset(min) !== time.getTimezoneOffset(max);
      }
      var t = minDate.getTime();
      i = 1;
      while (t < max) {
        tickPositions.push(t);
        if (interval === timeUnits2.year) {
          t = time.makeTime(minYear + i * count, 0);
        } else if (interval === timeUnits2.month) {
          t = time.makeTime(minYear, minMonth + i * count);
        } else if (variableDayLength && (interval === timeUnits2.day || interval === timeUnits2.week)) {
          t = time.makeTime(minYear, minMonth, minDateDate + i * count * (interval === timeUnits2.day ? 1 : 7));
        } else if (variableDayLength && interval === timeUnits2.hour && count > 1) {
          t = time.makeTime(minYear, minMonth, minDateDate, minHours + i * count);
        } else {
          t += interval * count;
        }
        i++;
      }
      tickPositions.push(t);
      if (interval <= timeUnits2.hour && tickPositions.length < 1e4) {
        tickPositions.forEach(function(t2) {
          if (t2 % 18e5 === 0 && time.dateFormat("%H%M%S%L", t2) === "000000000") {
            higherRanks[t2] = "day";
          }
        });
      }
    }
    tickPositions.info = extend2(normalizedInterval, {
      higherRanks,
      totalRange: interval * count
    });
    return tickPositions;
  };
  Time2.prototype.getDateFormat = function(range, timestamp, startOfWeek, dateTimeLabelFormats) {
    var dateStr = this.dateFormat("%m-%d %H:%M:%S.%L", timestamp), blank = "01-01 00:00:00.000", strpos = {
      millisecond: 15,
      second: 12,
      minute: 9,
      hour: 6,
      day: 3
    };
    var format13, n, lastN = "millisecond";
    for (n in timeUnits2) {
      if (range === timeUnits2.week && +this.dateFormat("%w", timestamp) === startOfWeek && dateStr.substr(6) === blank.substr(6)) {
        n = "week";
        break;
      }
      if (timeUnits2[n] > range) {
        n = lastN;
        break;
      }
      if (strpos[n] && dateStr.substr(strpos[n]) !== blank.substr(strpos[n])) {
        break;
      }
      if (n !== "week") {
        lastN = n;
      }
    }
    if (n) {
      format13 = this.resolveDTLFormat(dateTimeLabelFormats[n]).main;
    }
    return format13;
  };
  return Time2;
}();
var Time_default = Time;

// node_modules/highcharts/es-modules/Core/DefaultOptions.js
var color = Color_default.parse;
var isTouchDevice = Globals_default.isTouchDevice;
var svg = Globals_default.svg;
var merge4 = Utilities_default.merge;
var defaultOptions = {
  colors: Palette_default.colors,
  symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
  lang: {
    loading: "Loading...",
    months: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ],
    shortMonths: [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ],
    weekdays: [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ],
    decimalPoint: ".",
    numericSymbols: ["k", "M", "G", "T", "P", "E"],
    resetZoom: "Reset zoom",
    resetZoomTitle: "Reset zoom level 1:1",
    thousandsSep: " "
  },
  global: {},
  time: {
    Date: void 0,
    getTimezoneOffset: void 0,
    timezone: void 0,
    timezoneOffset: 0,
    useUTC: true
  },
  chart: ChartDefaults_default,
  title: {
    text: "Chart title",
    align: "center",
    margin: 15,
    widthAdjust: -44
  },
  subtitle: {
    text: "",
    align: "center",
    widthAdjust: -44
  },
  caption: {
    margin: 15,
    text: "",
    align: "left",
    verticalAlign: "bottom"
  },
  plotOptions: {},
  labels: {
    style: {
      position: "absolute",
      color: Palette_default.neutralColor80
    }
  },
  legend: {
    enabled: true,
    align: "center",
    alignColumns: true,
    className: "highcharts-no-tooltip",
    layout: "horizontal",
    labelFormatter: function() {
      return this.name;
    },
    borderColor: Palette_default.neutralColor40,
    borderRadius: 0,
    navigation: {
      activeColor: Palette_default.highlightColor100,
      inactiveColor: Palette_default.neutralColor20
    },
    itemStyle: {
      color: Palette_default.neutralColor80,
      cursor: "pointer",
      fontSize: "12px",
      fontWeight: "bold",
      textOverflow: "ellipsis"
    },
    itemHoverStyle: {
      color: Palette_default.neutralColor100
    },
    itemHiddenStyle: {
      color: Palette_default.neutralColor20
    },
    shadow: false,
    itemCheckboxStyle: {
      position: "absolute",
      width: "13px",
      height: "13px"
    },
    squareSymbol: true,
    symbolPadding: 5,
    verticalAlign: "bottom",
    x: 0,
    y: 0,
    title: {
      style: {
        fontWeight: "bold"
      }
    }
  },
  loading: {
    labelStyle: {
      fontWeight: "bold",
      position: "relative",
      top: "45%"
    },
    style: {
      position: "absolute",
      backgroundColor: Palette_default.backgroundColor,
      opacity: 0.5,
      textAlign: "center"
    }
  },
  tooltip: {
    enabled: true,
    animation: svg,
    borderRadius: 3,
    dateTimeLabelFormats: {
      millisecond: "%A, %b %e, %H:%M:%S.%L",
      second: "%A, %b %e, %H:%M:%S",
      minute: "%A, %b %e, %H:%M",
      hour: "%A, %b %e, %H:%M",
      day: "%A, %b %e, %Y",
      week: "Week from %A, %b %e, %Y",
      month: "%B %Y",
      year: "%Y"
    },
    footerFormat: "",
    headerShape: "callout",
    hideDelay: 500,
    padding: 8,
    shape: "callout",
    shared: false,
    snap: isTouchDevice ? 25 : 10,
    headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
    pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b><br/>',
    backgroundColor: color(Palette_default.neutralColor3).setOpacity(0.85).get(),
    borderWidth: 1,
    shadow: true,
    stickOnContact: false,
    style: {
      color: Palette_default.neutralColor80,
      cursor: "default",
      fontSize: "12px",
      whiteSpace: "nowrap"
    },
    useHTML: false
  },
  credits: {
    enabled: true,
    href: "https://www.highcharts.com?credits",
    position: {
      align: "right",
      x: -10,
      verticalAlign: "bottom",
      y: -5
    },
    style: {
      cursor: "pointer",
      color: Palette_default.neutralColor40,
      fontSize: "9px"
    },
    text: "Highcharts.com"
  }
};
defaultOptions.chart.styledMode = false;
var defaultTime = new Time_default(merge4(defaultOptions.global, defaultOptions.time));
function getOptions() {
  return defaultOptions;
}
function setOptions(options) {
  merge4(true, defaultOptions, options);
  if (options.time || options.global) {
    if (Globals_default.time) {
      Globals_default.time.update(merge4(defaultOptions.global, defaultOptions.time, options.global, options.time));
    } else {
      Globals_default.time = defaultTime;
    }
  }
  return defaultOptions;
}
var DefaultOptions = {
  defaultOptions,
  defaultTime,
  getOptions,
  setOptions
};
var DefaultOptions_default = DefaultOptions;

// node_modules/highcharts/es-modules/Core/Animation/Fx.js
var color2 = Color_default.parse;
var win4 = Globals_default.win;
var isNumber3 = Utilities_default.isNumber;
var objectEach3 = Utilities_default.objectEach;
var Fx = function() {
  function Fx2(elem, options, prop) {
    this.pos = NaN;
    this.options = options;
    this.elem = elem;
    this.prop = prop;
  }
  Fx2.prototype.dSetter = function() {
    var paths = this.paths, start = paths && paths[0], end = paths && paths[1], now = this.now || 0;
    var path = [];
    if (now === 1 || !start || !end) {
      path = this.toD || [];
    } else if (start.length === end.length && now < 1) {
      for (var i = 0; i < end.length; i++) {
        var startSeg = start[i];
        var endSeg = end[i];
        var tweenSeg = [];
        for (var j = 0; j < endSeg.length; j++) {
          var startItem = startSeg[j];
          var endItem = endSeg[j];
          if (isNumber3(startItem) && isNumber3(endItem) && !(endSeg[0] === "A" && (j === 4 || j === 5))) {
            tweenSeg[j] = startItem + now * (endItem - startItem);
          } else {
            tweenSeg[j] = endItem;
          }
        }
        path.push(tweenSeg);
      }
    } else {
      path = end;
    }
    this.elem.attr("d", path, void 0, true);
  };
  Fx2.prototype.update = function() {
    var elem = this.elem, prop = this.prop, now = this.now, step = this.options.step;
    if (this[prop + "Setter"]) {
      this[prop + "Setter"]();
    } else if (elem.attr) {
      if (elem.element) {
        elem.attr(prop, now, null, true);
      }
    } else {
      elem.style[prop] = now + this.unit;
    }
    if (step) {
      step.call(elem, now, this);
    }
  };
  Fx2.prototype.run = function(from, to, unit) {
    var self = this, options = self.options, timer = function(gotoEnd) {
      return timer.stopped ? false : self.step(gotoEnd);
    }, requestAnimationFrame = win4.requestAnimationFrame || function(step2) {
      setTimeout(step2, 13);
    }, step = function() {
      for (var i = 0; i < Fx2.timers.length; i++) {
        if (!Fx2.timers[i]()) {
          Fx2.timers.splice(i--, 1);
        }
      }
      if (Fx2.timers.length) {
        requestAnimationFrame(step);
      }
    };
    if (from === to && !this.elem["forceAnimate:" + this.prop]) {
      delete options.curAnim[this.prop];
      if (options.complete && Object.keys(options.curAnim).length === 0) {
        options.complete.call(this.elem);
      }
    } else {
      this.startTime = +new Date();
      this.start = from;
      this.end = to;
      this.unit = unit;
      this.now = this.start;
      this.pos = 0;
      timer.elem = this.elem;
      timer.prop = this.prop;
      if (timer() && Fx2.timers.push(timer) === 1) {
        requestAnimationFrame(step);
      }
    }
  };
  Fx2.prototype.step = function(gotoEnd) {
    var t = +new Date(), options = this.options, elem = this.elem, complete = options.complete, duration = options.duration, curAnim = options.curAnim;
    var ret, done;
    if (elem.attr && !elem.element) {
      ret = false;
    } else if (gotoEnd || t >= duration + this.startTime) {
      this.now = this.end;
      this.pos = 1;
      this.update();
      curAnim[this.prop] = true;
      done = true;
      objectEach3(curAnim, function(val) {
        if (val !== true) {
          done = false;
        }
      });
      if (done && complete) {
        complete.call(elem);
      }
      ret = false;
    } else {
      this.pos = options.easing((t - this.startTime) / duration);
      this.now = this.start + (this.end - this.start) * this.pos;
      this.update();
      ret = true;
    }
    return ret;
  };
  Fx2.prototype.initPath = function(elem, fromD, toD) {
    var startX = elem.startX, endX = elem.endX, end = toD.slice(), isArea = elem.isArea, positionFactor = isArea ? 2 : 1;
    var shift, fullLength, i, reverse, start = fromD && fromD.slice();
    if (!start) {
      return [end, end];
    }
    function prepend(arr, other) {
      while (arr.length < fullLength) {
        var moveSegment = arr[0], otherSegment = other[fullLength - arr.length];
        if (otherSegment && moveSegment[0] === "M") {
          if (otherSegment[0] === "C") {
            arr[0] = [
              "C",
              moveSegment[1],
              moveSegment[2],
              moveSegment[1],
              moveSegment[2],
              moveSegment[1],
              moveSegment[2]
            ];
          } else {
            arr[0] = ["L", moveSegment[1], moveSegment[2]];
          }
        }
        arr.unshift(moveSegment);
        if (isArea) {
          var z = arr.pop();
          arr.push(arr[arr.length - 1], z);
        }
      }
    }
    function append(arr, other) {
      while (arr.length < fullLength) {
        var segmentToAdd = arr[Math.floor(arr.length / positionFactor) - 1].slice();
        if (segmentToAdd[0] === "C") {
          segmentToAdd[1] = segmentToAdd[5];
          segmentToAdd[2] = segmentToAdd[6];
        }
        if (!isArea) {
          arr.push(segmentToAdd);
        } else {
          var lowerSegmentToAdd = arr[Math.floor(arr.length / positionFactor)].slice();
          arr.splice(arr.length / 2, 0, segmentToAdd, lowerSegmentToAdd);
        }
      }
    }
    if (startX && endX && endX.length) {
      for (i = 0; i < startX.length; i++) {
        if (startX[i] === endX[0]) {
          shift = i;
          break;
        } else if (startX[0] === endX[endX.length - startX.length + i]) {
          shift = i;
          reverse = true;
          break;
        } else if (startX[startX.length - 1] === endX[endX.length - startX.length + i]) {
          shift = startX.length - i;
          break;
        }
      }
      if (typeof shift === "undefined") {
        start = [];
      }
    }
    if (start.length && isNumber3(shift)) {
      fullLength = end.length + shift * positionFactor;
      if (!reverse) {
        prepend(end, start);
        append(start, end);
      } else {
        prepend(start, end);
        append(end, start);
      }
    }
    return [start, end];
  };
  Fx2.prototype.fillSetter = function() {
    Fx2.prototype.strokeSetter.apply(this, arguments);
  };
  Fx2.prototype.strokeSetter = function() {
    this.elem.attr(this.prop, color2(this.start).tweenTo(color2(this.end), this.pos), null, true);
  };
  Fx2.timers = [];
  return Fx2;
}();
var Fx_default = Fx;

// node_modules/highcharts/es-modules/Core/Animation/AnimationUtilities.js
var defined3 = Utilities_default.defined;
var getStyle2 = Utilities_default.getStyle;
var isArray2 = Utilities_default.isArray;
var isNumber4 = Utilities_default.isNumber;
var isObject3 = Utilities_default.isObject;
var merge5 = Utilities_default.merge;
var objectEach4 = Utilities_default.objectEach;
var pick3 = Utilities_default.pick;
function setAnimation(animation, chart) {
  chart.renderer.globalAnimation = pick3(animation, chart.options.chart.animation, true);
}
function animObject(animation) {
  return isObject3(animation) ? merge5({ duration: 500, defer: 0 }, animation) : { duration: animation ? 500 : 0, defer: 0 };
}
function getDeferredAnimation(chart, animation, series) {
  var labelAnimation = animObject(animation), s = series ? [series] : chart.series;
  var defer = 0, duration = 0;
  s.forEach(function(series2) {
    var seriesAnim = animObject(series2.options.animation);
    defer = animation && defined3(animation.defer) ? labelAnimation.defer : Math.max(defer, seriesAnim.duration + seriesAnim.defer);
    duration = Math.min(labelAnimation.duration, seriesAnim.duration);
  });
  if (chart.renderer.forExport) {
    defer = 0;
  }
  var anim = {
    defer: Math.max(0, defer - duration),
    duration: Math.min(defer, duration)
  };
  return anim;
}
function animate(el, params, opt) {
  var start, unit = "", end, fx, args;
  if (!isObject3(opt)) {
    args = arguments;
    opt = {
      duration: args[2],
      easing: args[3],
      complete: args[4]
    };
  }
  if (!isNumber4(opt.duration)) {
    opt.duration = 400;
  }
  opt.easing = typeof opt.easing === "function" ? opt.easing : Math[opt.easing] || Math.easeInOutSine;
  opt.curAnim = merge5(params);
  objectEach4(params, function(val, prop) {
    stop(el, prop);
    fx = new Fx_default(el, opt, prop);
    end = void 0;
    if (prop === "d" && isArray2(params.d)) {
      fx.paths = fx.initPath(el, el.pathArray, params.d);
      fx.toD = params.d;
      start = 0;
      end = 1;
    } else if (el.attr) {
      start = el.attr(prop);
    } else {
      start = parseFloat(getStyle2(el, prop)) || 0;
      if (prop !== "opacity") {
        unit = "px";
      }
    }
    if (!end) {
      end = val;
    }
    if (typeof end === "string" && end.match("px")) {
      end = end.replace(/px/g, "");
    }
    fx.run(start, end, unit);
  });
}
function stop(el, prop) {
  var i = Fx_default.timers.length;
  while (i--) {
    if (Fx_default.timers[i].elem === el && (!prop || prop === Fx_default.timers[i].prop)) {
      Fx_default.timers[i].stopped = true;
    }
  }
}
var animationExports = {
  animate,
  animObject,
  getDeferredAnimation,
  setAnimation,
  stop
};
var AnimationUtilities_default = animationExports;

// node_modules/highcharts/es-modules/Core/Renderer/HTML/AST.js
var SVG_NS = Globals_default.SVG_NS;
var attr3 = Utilities_default.attr;
var createElement2 = Utilities_default.createElement;
var discardElement2 = Utilities_default.discardElement;
var error3 = Utilities_default.error;
var isString2 = Utilities_default.isString;
var objectEach5 = Utilities_default.objectEach;
var splat3 = Utilities_default.splat;
var hasValidDOMParser = function() {
  try {
    return Boolean(new DOMParser().parseFromString("", "text/html"));
  } catch (e2) {
    return false;
  }
}();
var AST = function() {
  function AST2(source) {
    this.nodes = typeof source === "string" ? this.parseMarkup(source) : source;
  }
  AST2.filterUserAttributes = function(attributes) {
    objectEach5(attributes, function(val, key) {
      var valid = true;
      if (AST2.allowedAttributes.indexOf(key) === -1) {
        valid = false;
      }
      if (["background", "dynsrc", "href", "lowsrc", "src"].indexOf(key) !== -1) {
        valid = isString2(val) && AST2.allowedReferences.some(function(ref) {
          return val.indexOf(ref) === 0;
        });
      }
      if (!valid) {
        error3("Highcharts warning: Invalid attribute '" + key + "' in config");
        delete attributes[key];
      }
    });
    return attributes;
  };
  AST2.setElementHTML = function(el, html2) {
    el.innerHTML = "";
    if (html2) {
      var ast = new AST2(html2);
      ast.addToDOM(el);
    }
  };
  AST2.prototype.addToDOM = function(parent) {
    function recurse(subtree, subParent) {
      var ret;
      splat3(subtree).forEach(function(item) {
        var tagName = item.tagName;
        var textNode = item.textContent ? Globals_default.doc.createTextNode(item.textContent) : void 0;
        var node;
        if (tagName) {
          if (tagName === "#text") {
            node = textNode;
          } else if (AST2.allowedTags.indexOf(tagName) !== -1) {
            var NS = tagName === "svg" ? SVG_NS : subParent.namespaceURI || SVG_NS;
            var element = Globals_default.doc.createElementNS(NS, tagName);
            var attributes_1 = item.attributes || {};
            objectEach5(item, function(val, key) {
              if (key !== "tagName" && key !== "attributes" && key !== "children" && key !== "textContent") {
                attributes_1[key] = val;
              }
            });
            attr3(element, AST2.filterUserAttributes(attributes_1));
            if (textNode) {
              element.appendChild(textNode);
            }
            recurse(item.children || [], element);
            node = element;
          } else {
            error3("Highcharts warning: Invalid tagName '" + tagName + "' in config");
          }
        }
        if (node) {
          subParent.appendChild(node);
        }
        ret = node;
      });
      return ret;
    }
    return recurse(this.nodes, parent);
  };
  AST2.prototype.parseMarkup = function(markup) {
    var nodes = [];
    markup = markup.trim();
    var doc23;
    var body;
    if (hasValidDOMParser) {
      doc23 = new DOMParser().parseFromString(markup, "text/html");
    } else {
      body = createElement2("div");
      body.innerHTML = markup;
      doc23 = { body };
    }
    var appendChildNodes = function(node, addTo) {
      var tagName = node.nodeName.toLowerCase();
      var astNode = {
        tagName
      };
      if (tagName === "#text") {
        astNode.textContent = node.textContent || "";
      }
      var parsedAttributes = node.attributes;
      if (parsedAttributes) {
        var attributes_2 = {};
        [].forEach.call(parsedAttributes, function(attrib) {
          attributes_2[attrib.name] = attrib.value;
        });
        astNode.attributes = attributes_2;
      }
      if (node.childNodes.length) {
        var children_1 = [];
        [].forEach.call(node.childNodes, function(childNode) {
          appendChildNodes(childNode, children_1);
        });
        if (children_1.length) {
          astNode.children = children_1;
        }
      }
      addTo.push(astNode);
    };
    [].forEach.call(doc23.body.childNodes, function(childNode) {
      return appendChildNodes(childNode, nodes);
    });
    if (body) {
      discardElement2(body);
    }
    return nodes;
  };
  AST2.allowedAttributes = [
    "aria-controls",
    "aria-describedby",
    "aria-expanded",
    "aria-haspopup",
    "aria-hidden",
    "aria-label",
    "aria-labelledby",
    "aria-live",
    "aria-pressed",
    "aria-readonly",
    "aria-roledescription",
    "aria-selected",
    "class",
    "clip-path",
    "color",
    "colspan",
    "cx",
    "cy",
    "d",
    "dx",
    "dy",
    "disabled",
    "fill",
    "height",
    "href",
    "id",
    "in",
    "markerHeight",
    "markerWidth",
    "offset",
    "opacity",
    "orient",
    "padding",
    "paddingLeft",
    "paddingRight",
    "patternUnits",
    "r",
    "refX",
    "refY",
    "role",
    "scope",
    "slope",
    "src",
    "startOffset",
    "stdDeviation",
    "stroke",
    "stroke-linecap",
    "stroke-width",
    "style",
    "tableValues",
    "result",
    "rowspan",
    "summary",
    "target",
    "tabindex",
    "text-align",
    "textAnchor",
    "textLength",
    "type",
    "valign",
    "width",
    "x",
    "x1",
    "x2",
    "y",
    "y1",
    "y2",
    "zIndex"
  ];
  AST2.allowedReferences = [
    "https://",
    "http://",
    "mailto:",
    "/",
    "../",
    "./",
    "#"
  ];
  AST2.allowedTags = [
    "a",
    "b",
    "br",
    "button",
    "caption",
    "circle",
    "clipPath",
    "code",
    "dd",
    "defs",
    "div",
    "dl",
    "dt",
    "em",
    "feComponentTransfer",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feOffset",
    "feMerge",
    "feMergeNode",
    "filter",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "hr",
    "i",
    "img",
    "li",
    "linearGradient",
    "marker",
    "ol",
    "p",
    "path",
    "pattern",
    "pre",
    "rect",
    "small",
    "span",
    "stop",
    "strong",
    "style",
    "sub",
    "sup",
    "svg",
    "table",
    "text",
    "thead",
    "tbody",
    "tspan",
    "td",
    "th",
    "tr",
    "u",
    "ul",
    "#text"
  ];
  return AST2;
}();
var AST_default = AST;

// node_modules/highcharts/es-modules/Core/FormatUtilities.js
var defaultOptions2 = DefaultOptions_default.defaultOptions;
var defaultTime2 = DefaultOptions_default.defaultTime;
var getNestedProperty2 = Utilities_default.getNestedProperty;
var isNumber5 = Utilities_default.isNumber;
var pick4 = Utilities_default.pick;
var pInt3 = Utilities_default.pInt;
function dateFormat(format13, timestamp, capitalize) {
  return defaultTime2.dateFormat(format13, timestamp, capitalize);
}
function format(str, ctx, chart) {
  var splitter = "{", isInside = false, segment, valueAndFormat, val, index;
  var floatRegex = /f$/;
  var decRegex = /\.([0-9])/;
  var lang2 = defaultOptions2.lang;
  var time = chart && chart.time || defaultTime2;
  var numberFormatter = chart && chart.numberFormatter || numberFormat;
  var ret = [];
  while (str) {
    index = str.indexOf(splitter);
    if (index === -1) {
      break;
    }
    segment = str.slice(0, index);
    if (isInside) {
      valueAndFormat = segment.split(":");
      val = getNestedProperty2(valueAndFormat.shift() || "", ctx);
      if (valueAndFormat.length && typeof val === "number") {
        segment = valueAndFormat.join(":");
        if (floatRegex.test(segment)) {
          var decimals = parseInt((segment.match(decRegex) || ["", "-1"])[1], 10);
          if (val !== null) {
            val = numberFormatter(val, decimals, lang2.decimalPoint, segment.indexOf(",") > -1 ? lang2.thousandsSep : "");
          }
        } else {
          val = time.dateFormat(segment, val);
        }
      }
      ret.push(val);
    } else {
      ret.push(segment);
    }
    str = str.slice(index + 1);
    isInside = !isInside;
    splitter = isInside ? "}" : "{";
  }
  ret.push(str);
  return ret.join("");
}
function numberFormat(number, decimals, decimalPoint, thousandsSep) {
  number = +number || 0;
  decimals = +decimals;
  var ret, fractionDigits;
  var lang2 = defaultOptions2.lang, origDec = (number.toString().split(".")[1] || "").split("e")[0].length, exponent = number.toString().split("e"), firstDecimals = decimals;
  if (decimals === -1) {
    decimals = Math.min(origDec, 20);
  } else if (!isNumber5(decimals)) {
    decimals = 2;
  } else if (decimals && exponent[1] && exponent[1] < 0) {
    fractionDigits = decimals + +exponent[1];
    if (fractionDigits >= 0) {
      exponent[0] = (+exponent[0]).toExponential(fractionDigits).split("e")[0];
      decimals = fractionDigits;
    } else {
      exponent[0] = exponent[0].split(".")[0] || 0;
      if (decimals < 20) {
        number = (exponent[0] * Math.pow(10, exponent[1])).toFixed(decimals);
      } else {
        number = 0;
      }
      exponent[1] = 0;
    }
  }
  var roundedNumber = (Math.abs(exponent[1] ? exponent[0] : number) + Math.pow(10, -Math.max(decimals, origDec) - 1)).toFixed(decimals);
  var strinteger = String(pInt3(roundedNumber));
  var thousands = strinteger.length > 3 ? strinteger.length % 3 : 0;
  decimalPoint = pick4(decimalPoint, lang2.decimalPoint);
  thousandsSep = pick4(thousandsSep, lang2.thousandsSep);
  ret = number < 0 ? "-" : "";
  ret += thousands ? strinteger.substr(0, thousands) + thousandsSep : "";
  if (+exponent[1] < 0 && !firstDecimals) {
    ret = "0";
  } else {
    ret += strinteger.substr(thousands).replace(/(\d{3})(?=\d)/g, "$1" + thousandsSep);
  }
  if (decimals) {
    ret += decimalPoint + roundedNumber.slice(-decimals);
  }
  if (exponent[1] && +ret !== 0) {
    ret += "e" + exponent[1];
  }
  return ret;
}
var FormatUtilities = {
  dateFormat,
  format,
  numberFormat
};
var FormatUtilities_default = FormatUtilities;

// node_modules/highcharts/es-modules/Core/Renderer/RendererUtilities.js
var clamp2 = Utilities_default.clamp;
var pick5 = Utilities_default.pick;
var stableSort2 = Utilities_default.stableSort;
var RendererUtilities;
(function(RendererUtilities2) {
  function distribute5(boxes, len, maxDistance) {
    var origBoxes = boxes, reducedLen = origBoxes.reducedLen || len, sortByRank = function(a, b) {
      return (b.rank || 0) - (a.rank || 0);
    }, sortByTarget = function(a, b) {
      return a.target - b.target;
    };
    var i, overlapping = true, restBoxes = [], box, target, total = 0;
    i = boxes.length;
    while (i--) {
      total += boxes[i].size;
    }
    if (total > reducedLen) {
      stableSort2(boxes, sortByRank);
      i = 0;
      total = 0;
      while (total <= reducedLen) {
        total += boxes[i].size;
        i++;
      }
      restBoxes = boxes.splice(i - 1, boxes.length);
    }
    stableSort2(boxes, sortByTarget);
    boxes = boxes.map(function(box2) {
      return {
        size: box2.size,
        targets: [box2.target],
        align: pick5(box2.align, 0.5)
      };
    });
    while (overlapping) {
      i = boxes.length;
      while (i--) {
        box = boxes[i];
        target = (Math.min.apply(0, box.targets) + Math.max.apply(0, box.targets)) / 2;
        box.pos = clamp2(target - box.size * box.align, 0, len - box.size);
      }
      i = boxes.length;
      overlapping = false;
      while (i--) {
        if (i > 0 && boxes[i - 1].pos + boxes[i - 1].size > boxes[i].pos) {
          boxes[i - 1].size += boxes[i].size;
          boxes[i - 1].targets = boxes[i - 1].targets.concat(boxes[i].targets);
          boxes[i - 1].align = 0.5;
          if (boxes[i - 1].pos + boxes[i - 1].size > len) {
            boxes[i - 1].pos = len - boxes[i - 1].size;
          }
          boxes.splice(i, 1);
          overlapping = true;
        }
      }
    }
    origBoxes.push.apply(origBoxes, restBoxes);
    i = 0;
    boxes.some(function(box2) {
      var posInCompositeBox = 0;
      return (box2.targets || []).some(function() {
        origBoxes[i].pos = box2.pos + posInCompositeBox;
        if (typeof maxDistance !== "undefined" && Math.abs(origBoxes[i].pos - origBoxes[i].target) > maxDistance) {
          origBoxes.slice(0, i + 1).forEach(function(box3) {
            return delete box3.pos;
          });
          origBoxes.reducedLen = (origBoxes.reducedLen || len) - len * 0.1;
          if (origBoxes.reducedLen > len * 0.1) {
            distribute5(origBoxes, len, maxDistance);
          }
          return true;
        }
        posInCompositeBox += origBoxes[i].size;
        i++;
        return false;
      });
    });
    stableSort2(origBoxes, sortByTarget);
    return origBoxes;
  }
  RendererUtilities2.distribute = distribute5;
})(RendererUtilities || (RendererUtilities = {}));
var RendererUtilities_default = RendererUtilities;

// node_modules/highcharts/es-modules/Core/Renderer/SVG/SVGElement.js
var animate2 = AnimationUtilities_default.animate;
var animObject2 = AnimationUtilities_default.animObject;
var stop2 = AnimationUtilities_default.stop;
var deg2rad = Globals_default.deg2rad;
var doc2 = Globals_default.doc;
var noop = Globals_default.noop;
var svg2 = Globals_default.svg;
var SVG_NS2 = Globals_default.SVG_NS;
var win5 = Globals_default.win;
var addEvent2 = Utilities_default.addEvent;
var attr4 = Utilities_default.attr;
var createElement3 = Utilities_default.createElement;
var css3 = Utilities_default.css;
var defined4 = Utilities_default.defined;
var erase2 = Utilities_default.erase;
var extend3 = Utilities_default.extend;
var fireEvent2 = Utilities_default.fireEvent;
var isArray3 = Utilities_default.isArray;
var isFunction2 = Utilities_default.isFunction;
var isNumber6 = Utilities_default.isNumber;
var isString3 = Utilities_default.isString;
var merge6 = Utilities_default.merge;
var objectEach6 = Utilities_default.objectEach;
var pick6 = Utilities_default.pick;
var pInt4 = Utilities_default.pInt;
var syncTimeout2 = Utilities_default.syncTimeout;
var uniqueKey2 = Utilities_default.uniqueKey;
var SVGElement = function() {
  function SVGElement2() {
    this.element = void 0;
    this.onEvents = {};
    this.opacity = 1;
    this.renderer = void 0;
    this.SVG_NS = SVG_NS2;
    this.symbolCustomAttribs = [
      "x",
      "y",
      "width",
      "height",
      "r",
      "start",
      "end",
      "innerR",
      "anchorX",
      "anchorY",
      "rounded"
    ];
  }
  SVGElement2.prototype._defaultGetter = function(key) {
    var ret = pick6(this[key + "Value"], this[key], this.element ? this.element.getAttribute(key) : null, 0);
    if (/^[\-0-9\.]+$/.test(ret)) {
      ret = parseFloat(ret);
    }
    return ret;
  };
  SVGElement2.prototype._defaultSetter = function(value, key, element) {
    element.setAttribute(key, value);
  };
  SVGElement2.prototype.add = function(parent) {
    var renderer = this.renderer, element = this.element;
    var inserted;
    if (parent) {
      this.parentGroup = parent;
    }
    this.parentInverted = parent && parent.inverted;
    if (typeof this.textStr !== "undefined" && this.element.nodeName === "text") {
      renderer.buildText(this);
    }
    this.added = true;
    if (!parent || parent.handleZ || this.zIndex) {
      inserted = this.zIndexSetter();
    }
    if (!inserted) {
      (parent ? parent.element : renderer.box).appendChild(element);
    }
    if (this.onAdd) {
      this.onAdd();
    }
    return this;
  };
  SVGElement2.prototype.addClass = function(className, replace) {
    var currentClassName = replace ? "" : this.attr("class") || "";
    className = (className || "").split(/ /g).reduce(function(newClassName, name) {
      if (currentClassName.indexOf(name) === -1) {
        newClassName.push(name);
      }
      return newClassName;
    }, currentClassName ? [currentClassName] : []).join(" ");
    if (className !== currentClassName) {
      this.attr("class", className);
    }
    return this;
  };
  SVGElement2.prototype.afterSetters = function() {
    if (this.doTransform) {
      this.updateTransform();
      this.doTransform = false;
    }
  };
  SVGElement2.prototype.align = function(alignOptions, alignByTranslate, box) {
    var attribs = {}, renderer = this.renderer, alignedObjects = renderer.alignedObjects;
    var x, y, alignTo, alignFactor, vAlignFactor;
    if (alignOptions) {
      this.alignOptions = alignOptions;
      this.alignByTranslate = alignByTranslate;
      if (!box || isString3(box)) {
        this.alignTo = alignTo = box || "renderer";
        erase2(alignedObjects, this);
        alignedObjects.push(this);
        box = void 0;
      }
    } else {
      alignOptions = this.alignOptions;
      alignByTranslate = this.alignByTranslate;
      alignTo = this.alignTo;
    }
    box = pick6(box, renderer[alignTo], alignTo === "scrollablePlotBox" ? renderer.plotBox : void 0, renderer);
    var align = alignOptions.align, vAlign = alignOptions.verticalAlign;
    x = (box.x || 0) + (alignOptions.x || 0);
    y = (box.y || 0) + (alignOptions.y || 0);
    if (align === "right") {
      alignFactor = 1;
    } else if (align === "center") {
      alignFactor = 2;
    }
    if (alignFactor) {
      x += (box.width - (alignOptions.width || 0)) / alignFactor;
    }
    attribs[alignByTranslate ? "translateX" : "x"] = Math.round(x);
    if (vAlign === "bottom") {
      vAlignFactor = 1;
    } else if (vAlign === "middle") {
      vAlignFactor = 2;
    }
    if (vAlignFactor) {
      y += (box.height - (alignOptions.height || 0)) / vAlignFactor;
    }
    attribs[alignByTranslate ? "translateY" : "y"] = Math.round(y);
    this[this.placed ? "animate" : "attr"](attribs);
    this.placed = true;
    this.alignAttr = attribs;
    return this;
  };
  SVGElement2.prototype.alignSetter = function(value) {
    var convert = {
      left: "start",
      center: "middle",
      right: "end"
    };
    if (convert[value]) {
      this.alignValue = value;
      this.element.setAttribute("text-anchor", convert[value]);
    }
  };
  SVGElement2.prototype.animate = function(params, options, complete) {
    var _this = this;
    var animOptions = animObject2(pick6(options, this.renderer.globalAnimation, true)), deferTime = animOptions.defer;
    if (pick6(doc2.hidden, doc2.msHidden, doc2.webkitHidden, false)) {
      animOptions.duration = 0;
    }
    if (animOptions.duration !== 0) {
      if (complete) {
        animOptions.complete = complete;
      }
      syncTimeout2(function() {
        if (_this.element) {
          animate2(_this, params, animOptions);
        }
      }, deferTime);
    } else {
      this.attr(params, void 0, complete);
      objectEach6(params, function(val, prop) {
        if (animOptions.step) {
          animOptions.step.call(this, val, { prop, pos: 1, elem: this });
        }
      }, this);
    }
    return this;
  };
  SVGElement2.prototype.applyTextOutline = function(textOutline) {
    var elem = this.element, hasContrast = textOutline.indexOf("contrast") !== -1, styles = {};
    if (hasContrast) {
      styles.textOutline = textOutline = textOutline.replace(/contrast/g, this.renderer.getContrast(elem.style.fill));
    }
    var parts = textOutline.split(" ");
    var color18 = parts[parts.length - 1];
    var strokeWidth = parts[0];
    if (strokeWidth && strokeWidth !== "none" && Globals_default.svg) {
      this.fakeTS = true;
      this.ySetter = this.xSetter;
      strokeWidth = strokeWidth.replace(/(^[\d\.]+)(.*?)$/g, function(match, digit, unit) {
        return 2 * Number(digit) + unit;
      });
      this.removeTextOutline();
      var outline_1 = doc2.createElementNS(SVG_NS2, "tspan");
      attr4(outline_1, {
        "class": "highcharts-text-outline",
        fill: color18,
        stroke: color18,
        "stroke-width": strokeWidth,
        "stroke-linejoin": "round"
      });
      [].forEach.call(elem.childNodes, function(childNode) {
        var clone = childNode.cloneNode(true);
        if (clone.removeAttribute) {
          ["fill", "stroke", "stroke-width", "stroke"].forEach(function(prop) {
            return clone.removeAttribute(prop);
          });
        }
        outline_1.appendChild(clone);
      });
      var br_1 = doc2.createElementNS(SVG_NS2, "tspan");
      br_1.textContent = "\u200B";
      ["x", "y"].forEach(function(key) {
        var value = elem.getAttribute(key);
        if (value) {
          br_1.setAttribute(key, value);
        }
      });
      outline_1.appendChild(br_1);
      elem.insertBefore(outline_1, elem.firstChild);
    }
  };
  SVGElement2.prototype.attr = function(hash, val, complete, continueAnimation) {
    var element = this.element, symbolCustomAttribs = this.symbolCustomAttribs;
    var key, hasSetSymbolSize, ret = this, skipAttr, setter;
    if (typeof hash === "string" && typeof val !== "undefined") {
      key = hash;
      hash = {};
      hash[key] = val;
    }
    if (typeof hash === "string") {
      ret = (this[hash + "Getter"] || this._defaultGetter).call(this, hash, element);
    } else {
      objectEach6(hash, function eachAttribute(val2, key2) {
        skipAttr = false;
        if (!continueAnimation) {
          stop2(this, key2);
        }
        if (this.symbolName && symbolCustomAttribs.indexOf(key2) !== -1) {
          if (!hasSetSymbolSize) {
            this.symbolAttr(hash);
            hasSetSymbolSize = true;
          }
          skipAttr = true;
        }
        if (this.rotation && (key2 === "x" || key2 === "y")) {
          this.doTransform = true;
        }
        if (!skipAttr) {
          setter = this[key2 + "Setter"] || this._defaultSetter;
          setter.call(this, val2, key2, element);
          if (!this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(key2)) {
            this.updateShadows(key2, val2, setter);
          }
        }
      }, this);
      this.afterSetters();
    }
    if (complete) {
      complete.call(this);
    }
    return ret;
  };
  SVGElement2.prototype.clip = function(clipRect) {
    return this.attr("clip-path", clipRect ? "url(" + this.renderer.url + "#" + clipRect.id + ")" : "none");
  };
  SVGElement2.prototype.crisp = function(rect2, strokeWidth) {
    var wrapper = this;
    strokeWidth = strokeWidth || rect2.strokeWidth || 0;
    var normalizer = Math.round(strokeWidth) % 2 / 2;
    rect2.x = Math.floor(rect2.x || wrapper.x || 0) + normalizer;
    rect2.y = Math.floor(rect2.y || wrapper.y || 0) + normalizer;
    rect2.width = Math.floor((rect2.width || wrapper.width || 0) - 2 * normalizer);
    rect2.height = Math.floor((rect2.height || wrapper.height || 0) - 2 * normalizer);
    if (defined4(rect2.strokeWidth)) {
      rect2.strokeWidth = strokeWidth;
    }
    return rect2;
  };
  SVGElement2.prototype.complexColor = function(colorOptions, prop, elem) {
    var renderer = this.renderer;
    var colorObject, gradName, gradAttr, radAttr, gradients, stops, stopColor, stopOpacity, radialReference, id, key = [], value;
    fireEvent2(this.renderer, "complexColor", {
      args: arguments
    }, function() {
      if (colorOptions.radialGradient) {
        gradName = "radialGradient";
      } else if (colorOptions.linearGradient) {
        gradName = "linearGradient";
      }
      if (gradName) {
        gradAttr = colorOptions[gradName];
        gradients = renderer.gradients;
        stops = colorOptions.stops;
        radialReference = elem.radialReference;
        if (isArray3(gradAttr)) {
          colorOptions[gradName] = gradAttr = {
            x1: gradAttr[0],
            y1: gradAttr[1],
            x2: gradAttr[2],
            y2: gradAttr[3],
            gradientUnits: "userSpaceOnUse"
          };
        }
        if (gradName === "radialGradient" && radialReference && !defined4(gradAttr.gradientUnits)) {
          radAttr = gradAttr;
          gradAttr = merge6(gradAttr, renderer.getRadialAttr(radialReference, radAttr), { gradientUnits: "userSpaceOnUse" });
        }
        objectEach6(gradAttr, function(value2, n) {
          if (n !== "id") {
            key.push(n, value2);
          }
        });
        objectEach6(stops, function(val) {
          key.push(val);
        });
        key = key.join(",");
        if (gradients[key]) {
          id = gradients[key].attr("id");
        } else {
          gradAttr.id = id = uniqueKey2();
          var gradientObject_1 = gradients[key] = renderer.createElement(gradName).attr(gradAttr).add(renderer.defs);
          gradientObject_1.radAttr = radAttr;
          gradientObject_1.stops = [];
          stops.forEach(function(stop4) {
            if (stop4[1].indexOf("rgba") === 0) {
              colorObject = Color_default.parse(stop4[1]);
              stopColor = colorObject.get("rgb");
              stopOpacity = colorObject.get("a");
            } else {
              stopColor = stop4[1];
              stopOpacity = 1;
            }
            var stopObject = renderer.createElement("stop").attr({
              offset: stop4[0],
              "stop-color": stopColor,
              "stop-opacity": stopOpacity
            }).add(gradientObject_1);
            gradientObject_1.stops.push(stopObject);
          });
        }
        value = "url(" + renderer.url + "#" + id + ")";
        elem.setAttribute(prop, value);
        elem.gradient = key;
        colorOptions.toString = function() {
          return value;
        };
      }
    });
  };
  SVGElement2.prototype.css = function(styles) {
    var oldStyles = this.styles, newStyles = {}, elem = this.element, svgPseudoProps = ["textOutline", "textOverflow", "width"];
    var textWidth, serializedCss = "", hyphenate, hasNew = !oldStyles;
    if (styles && styles.color) {
      styles.fill = styles.color;
    }
    if (oldStyles) {
      objectEach6(styles, function(style, n) {
        if (oldStyles && oldStyles[n] !== style) {
          newStyles[n] = style;
          hasNew = true;
        }
      });
    }
    if (hasNew) {
      if (oldStyles) {
        styles = extend3(oldStyles, newStyles);
      }
      if (styles) {
        if (styles.width === null || styles.width === "auto") {
          delete this.textWidth;
        } else if (elem.nodeName.toLowerCase() === "text" && styles.width) {
          textWidth = this.textWidth = pInt4(styles.width);
        }
      }
      this.styles = styles;
      if (textWidth && (!svg2 && this.renderer.forExport)) {
        delete styles.width;
      }
      if (elem.namespaceURI === this.SVG_NS) {
        hyphenate = function(a, b) {
          return "-" + b.toLowerCase();
        };
        objectEach6(styles, function(style, n) {
          if (svgPseudoProps.indexOf(n) === -1) {
            serializedCss += n.replace(/([A-Z])/g, hyphenate) + ":" + style + ";";
          }
        });
        if (serializedCss) {
          attr4(elem, "style", serializedCss);
        }
      } else {
        css3(elem, styles);
      }
      if (this.added) {
        if (this.element.nodeName === "text") {
          this.renderer.buildText(this);
        }
        if (styles && styles.textOutline) {
          this.applyTextOutline(styles.textOutline);
        }
      }
    }
    return this;
  };
  SVGElement2.prototype.dashstyleSetter = function(value) {
    var i, strokeWidth = this["stroke-width"];
    if (strokeWidth === "inherit") {
      strokeWidth = 1;
    }
    value = value && value.toLowerCase();
    if (value) {
      var v = value.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
      i = v.length;
      while (i--) {
        v[i] = "" + pInt4(v[i]) * pick6(strokeWidth, NaN);
      }
      value = v.join(",").replace(/NaN/g, "none");
      this.element.setAttribute("stroke-dasharray", value);
    }
  };
  SVGElement2.prototype.destroy = function() {
    var wrapper = this, element = wrapper.element || {}, renderer = wrapper.renderer, ownerSVGElement = element.ownerSVGElement;
    var parentToClean = renderer.isSVG && element.nodeName === "SPAN" && wrapper.parentGroup || void 0, grandParent, i;
    element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = null;
    stop2(wrapper);
    if (wrapper.clipPath && ownerSVGElement) {
      var clipPath_1 = wrapper.clipPath;
      [].forEach.call(ownerSVGElement.querySelectorAll("[clip-path],[CLIP-PATH]"), function(el) {
        if (el.getAttribute("clip-path").indexOf(clipPath_1.element.id) > -1) {
          el.removeAttribute("clip-path");
        }
      });
      wrapper.clipPath = clipPath_1.destroy();
    }
    if (wrapper.stops) {
      for (i = 0; i < wrapper.stops.length; i++) {
        wrapper.stops[i].destroy();
      }
      wrapper.stops.length = 0;
      wrapper.stops = void 0;
    }
    wrapper.safeRemoveChild(element);
    if (!renderer.styledMode) {
      wrapper.destroyShadows();
    }
    while (parentToClean && parentToClean.div && parentToClean.div.childNodes.length === 0) {
      grandParent = parentToClean.parentGroup;
      wrapper.safeRemoveChild(parentToClean.div);
      delete parentToClean.div;
      parentToClean = grandParent;
    }
    if (wrapper.alignTo) {
      erase2(renderer.alignedObjects, wrapper);
    }
    objectEach6(wrapper, function(val, key) {
      if (wrapper[key] && wrapper[key].parentGroup === wrapper && wrapper[key].destroy) {
        wrapper[key].destroy();
      }
      delete wrapper[key];
    });
    return;
  };
  SVGElement2.prototype.destroyShadows = function() {
    (this.shadows || []).forEach(function(shadow) {
      this.safeRemoveChild(shadow);
    }, this);
    this.shadows = void 0;
  };
  SVGElement2.prototype.destroyTextPath = function(elem, path) {
    var textElement = elem.getElementsByTagName("text")[0];
    var childNodes;
    if (textElement) {
      textElement.removeAttribute("dx");
      textElement.removeAttribute("dy");
      path.element.setAttribute("id", "");
      if (this.textPathWrapper && textElement.getElementsByTagName("textPath").length) {
        childNodes = this.textPathWrapper.element.childNodes;
        while (childNodes.length) {
          textElement.appendChild(childNodes[0]);
        }
        textElement.removeChild(this.textPathWrapper.element);
      }
    } else if (elem.getAttribute("dx") || elem.getAttribute("dy")) {
      elem.removeAttribute("dx");
      elem.removeAttribute("dy");
    }
    if (this.textPathWrapper) {
      this.textPathWrapper = this.textPathWrapper.destroy();
    }
  };
  SVGElement2.prototype.dSetter = function(value, key, element) {
    if (isArray3(value)) {
      if (typeof value[0] === "string") {
        value = this.renderer.pathToSegments(value);
      }
      this.pathArray = value;
      value = value.reduce(function(acc, seg, i) {
        if (!seg || !seg.join) {
          return (seg || "").toString();
        }
        return (i ? acc + " " : "") + seg.join(" ");
      }, "");
    }
    if (/(NaN| {2}|^$)/.test(value)) {
      value = "M 0 0";
    }
    if (this[key] !== value) {
      element.setAttribute(key, value);
      this[key] = value;
    }
  };
  SVGElement2.prototype.fadeOut = function(duration) {
    var elemWrapper = this;
    elemWrapper.animate({
      opacity: 0
    }, {
      duration: pick6(duration, 150),
      complete: function() {
        elemWrapper.attr({ y: -9999 }).hide();
      }
    });
  };
  SVGElement2.prototype.fillSetter = function(value, key, element) {
    if (typeof value === "string") {
      element.setAttribute(key, value);
    } else if (value) {
      this.complexColor(value, key, element);
    }
  };
  SVGElement2.prototype.getBBox = function(reload, rot) {
    var wrapper = this, renderer = wrapper.renderer, element = wrapper.element, styles = wrapper.styles, textStr = wrapper.textStr, cache = renderer.cache, cacheKeys = renderer.cacheKeys, isSVG = element.namespaceURI === wrapper.SVG_NS, rotation = pick6(rot, wrapper.rotation, 0), fontSize = renderer.styledMode ? element && SVGElement2.prototype.getStyle.call(element, "font-size") : styles && styles.fontSize;
    var bBox, width, height, toggleTextShadowShim, cacheKey;
    if (defined4(textStr)) {
      cacheKey = textStr.toString();
      if (cacheKey.indexOf("<") === -1) {
        cacheKey = cacheKey.replace(/[0-9]/g, "0");
      }
      cacheKey += [
        "",
        rotation,
        fontSize,
        wrapper.textWidth,
        styles && styles.textOverflow,
        styles && styles.fontWeight
      ].join(",");
    }
    if (cacheKey && !reload) {
      bBox = cache[cacheKey];
    }
    if (!bBox) {
      if (isSVG || renderer.forExport) {
        try {
          toggleTextShadowShim = this.fakeTS && function(display) {
            var outline = element.querySelector(".highcharts-text-outline");
            if (outline) {
              css3(outline, { display });
            }
          };
          if (isFunction2(toggleTextShadowShim)) {
            toggleTextShadowShim("none");
          }
          bBox = element.getBBox ? extend3({}, element.getBBox()) : {
            width: element.offsetWidth,
            height: element.offsetHeight
          };
          if (isFunction2(toggleTextShadowShim)) {
            toggleTextShadowShim("");
          }
        } catch (e2) {
          "";
        }
        if (!bBox || bBox.width < 0) {
          bBox = { width: 0, height: 0 };
        }
      } else {
        bBox = wrapper.htmlGetBBox();
      }
      if (renderer.isSVG) {
        width = bBox.width;
        height = bBox.height;
        if (isSVG) {
          bBox.height = height = {
            "11px,17": 14,
            "13px,20": 16
          }[styles && styles.fontSize + "," + Math.round(height)] || height;
        }
        if (rotation) {
          var rad = rotation * deg2rad;
          bBox.width = Math.abs(height * Math.sin(rad)) + Math.abs(width * Math.cos(rad));
          bBox.height = Math.abs(height * Math.cos(rad)) + Math.abs(width * Math.sin(rad));
        }
      }
      if (cacheKey && (textStr === "" || bBox.height > 0)) {
        while (cacheKeys.length > 250) {
          delete cache[cacheKeys.shift()];
        }
        if (!cache[cacheKey]) {
          cacheKeys.push(cacheKey);
        }
        cache[cacheKey] = bBox;
      }
    }
    return bBox;
  };
  SVGElement2.prototype.getStyle = function(prop) {
    return win5.getComputedStyle(this.element || this, "").getPropertyValue(prop);
  };
  SVGElement2.prototype.hasClass = function(className) {
    return ("" + this.attr("class")).split(" ").indexOf(className) !== -1;
  };
  SVGElement2.prototype.hide = function(hideByTranslation) {
    if (hideByTranslation) {
      this.attr({ y: -9999 });
    } else {
      this.attr({ visibility: "hidden" });
    }
    return this;
  };
  SVGElement2.prototype.htmlGetBBox = function() {
    return { height: 0, width: 0, x: 0, y: 0 };
  };
  SVGElement2.prototype.init = function(renderer, nodeName) {
    this.element = nodeName === "span" ? createElement3(nodeName) : doc2.createElementNS(this.SVG_NS, nodeName);
    this.renderer = renderer;
    fireEvent2(this, "afterInit");
  };
  SVGElement2.prototype.invert = function(inverted) {
    this.inverted = inverted;
    this.updateTransform();
    return this;
  };
  SVGElement2.prototype.on = function(eventType, handler) {
    var onEvents = this.onEvents;
    if (onEvents[eventType]) {
      onEvents[eventType]();
    }
    onEvents[eventType] = addEvent2(this.element, eventType, handler);
    return this;
  };
  SVGElement2.prototype.opacitySetter = function(value, key, element) {
    var opacity = Number(Number(value).toFixed(3));
    this.opacity = opacity;
    element.setAttribute(key, opacity);
  };
  SVGElement2.prototype.removeClass = function(className) {
    return this.attr("class", ("" + this.attr("class")).replace(isString3(className) ? new RegExp("(^| )" + className + "( |$)") : className, " ").replace(/ +/g, " ").trim());
  };
  SVGElement2.prototype.removeTextOutline = function() {
    var outline = this.element.querySelector("tspan.highcharts-text-outline");
    if (outline) {
      this.safeRemoveChild(outline);
    }
  };
  SVGElement2.prototype.safeRemoveChild = function(element) {
    var parentNode = element.parentNode;
    if (parentNode) {
      parentNode.removeChild(element);
    }
  };
  SVGElement2.prototype.setRadialReference = function(coordinates) {
    var existingGradient = this.element.gradient && this.renderer.gradients[this.element.gradient];
    this.element.radialReference = coordinates;
    if (existingGradient && existingGradient.radAttr) {
      existingGradient.animate(this.renderer.getRadialAttr(coordinates, existingGradient.radAttr));
    }
    return this;
  };
  SVGElement2.prototype.setTextPath = function(path, textPathOptions) {
    var elem = this.element, textNode = this.text ? this.text.element : elem, attribsMap = {
      textAnchor: "text-anchor"
    };
    var adder = false, textPathElement, textPathId, textPathWrapper = this.textPathWrapper, firstTime = !textPathWrapper;
    textPathOptions = merge6(true, {
      enabled: true,
      attributes: {
        dy: -5,
        startOffset: "50%",
        textAnchor: "middle"
      }
    }, textPathOptions);
    var attrs = AST_default.filterUserAttributes(textPathOptions.attributes);
    if (path && textPathOptions && textPathOptions.enabled) {
      if (textPathWrapper && textPathWrapper.element.parentNode === null) {
        firstTime = true;
        textPathWrapper = textPathWrapper.destroy();
      } else if (textPathWrapper) {
        this.removeTextOutline.call(textPathWrapper.parentGroup);
      }
      if (this.options && this.options.padding) {
        attrs.dx = -this.options.padding;
      }
      if (!textPathWrapper) {
        this.textPathWrapper = textPathWrapper = this.renderer.createElement("textPath");
        adder = true;
      }
      textPathElement = textPathWrapper.element;
      textPathId = path.element.getAttribute("id");
      if (!textPathId) {
        path.element.setAttribute("id", textPathId = uniqueKey2());
      }
      if (firstTime) {
        textNode.setAttribute("y", 0);
        if (isNumber6(attrs.dx)) {
          textNode.setAttribute("x", -attrs.dx);
        }
        var childNodes = [].slice.call(textNode.childNodes);
        for (var i = 0; i < childNodes.length; i++) {
          var childNode = childNodes[i];
          if (childNode.nodeType === Node.TEXT_NODE || childNode.nodeName === "tspan") {
            textPathElement.appendChild(childNode);
          }
        }
      }
      if (adder && textPathWrapper) {
        textPathWrapper.add({ element: textNode });
      }
      textPathElement.setAttributeNS("http://www.w3.org/1999/xlink", "href", this.renderer.url + "#" + textPathId);
      if (defined4(attrs.dy)) {
        textPathElement.parentNode.setAttribute("dy", attrs.dy);
        delete attrs.dy;
      }
      if (defined4(attrs.dx)) {
        textPathElement.parentNode.setAttribute("dx", attrs.dx);
        delete attrs.dx;
      }
      objectEach6(attrs, function(val, key) {
        textPathElement.setAttribute(attribsMap[key] || key, val);
      });
      elem.removeAttribute("transform");
      this.removeTextOutline.call(textPathWrapper);
      if (this.text && !this.renderer.styledMode) {
        this.attr({
          fill: "none",
          "stroke-width": 0
        });
      }
      this.updateTransform = noop;
      this.applyTextOutline = noop;
    } else if (textPathWrapper) {
      delete this.updateTransform;
      delete this.applyTextOutline;
      this.destroyTextPath(elem, path);
      this.updateTransform();
      if (this.options && this.options.rotation) {
        this.applyTextOutline(this.options.style.textOutline);
      }
    }
    return this;
  };
  SVGElement2.prototype.shadow = function(shadowOptions, group, cutOff) {
    var shadows = [], element = this.element, oldShadowOptions = this.oldShadowOptions, defaultShadowOptions = {
      color: Palette_default.neutralColor100,
      offsetX: this.parentInverted ? -1 : 1,
      offsetY: this.parentInverted ? -1 : 1,
      opacity: 0.15,
      width: 3
    };
    var i, shadow, strokeWidth, shadowElementOpacity, update = false, transform, options;
    if (shadowOptions === true) {
      options = defaultShadowOptions;
    } else if (typeof shadowOptions === "object") {
      options = extend3(defaultShadowOptions, shadowOptions);
    }
    if (options) {
      if (options && oldShadowOptions) {
        objectEach6(options, function(value, key) {
          if (value !== oldShadowOptions[key]) {
            update = true;
          }
        });
      }
      if (update) {
        this.destroyShadows();
      }
      this.oldShadowOptions = options;
    }
    if (!options) {
      this.destroyShadows();
    } else if (!this.shadows) {
      shadowElementOpacity = options.opacity / options.width;
      transform = this.parentInverted ? "translate(" + options.offsetY + ", " + options.offsetX + ")" : "translate(" + options.offsetX + ", " + options.offsetY + ")";
      for (i = 1; i <= options.width; i++) {
        shadow = element.cloneNode(false);
        strokeWidth = options.width * 2 + 1 - 2 * i;
        attr4(shadow, {
          stroke: shadowOptions.color || Palette_default.neutralColor100,
          "stroke-opacity": shadowElementOpacity * i,
          "stroke-width": strokeWidth,
          transform,
          fill: "none"
        });
        shadow.setAttribute("class", (shadow.getAttribute("class") || "") + " highcharts-shadow");
        if (cutOff) {
          attr4(shadow, "height", Math.max(attr4(shadow, "height") - strokeWidth, 0));
          shadow.cutHeight = strokeWidth;
        }
        if (group) {
          group.element.appendChild(shadow);
        } else if (element.parentNode) {
          element.parentNode.insertBefore(shadow, element);
        }
        shadows.push(shadow);
      }
      this.shadows = shadows;
    }
    return this;
  };
  SVGElement2.prototype.show = function(inherit) {
    return this.attr({ visibility: inherit ? "inherit" : "visible" });
  };
  SVGElement2.prototype.strokeSetter = function(value, key, element) {
    this[key] = value;
    if (this.stroke && this["stroke-width"]) {
      SVGElement2.prototype.fillSetter.call(this, this.stroke, "stroke", element);
      element.setAttribute("stroke-width", this["stroke-width"]);
      this.hasStroke = true;
    } else if (key === "stroke-width" && value === 0 && this.hasStroke) {
      element.removeAttribute("stroke");
      this.hasStroke = false;
    } else if (this.renderer.styledMode && this["stroke-width"]) {
      element.setAttribute("stroke-width", this["stroke-width"]);
      this.hasStroke = true;
    }
  };
  SVGElement2.prototype.strokeWidth = function() {
    if (!this.renderer.styledMode) {
      return this["stroke-width"] || 0;
    }
    var val = this.getStyle("stroke-width");
    var ret = 0, dummy;
    if (val.indexOf("px") === val.length - 2) {
      ret = pInt4(val);
    } else if (val !== "") {
      dummy = doc2.createElementNS(SVG_NS2, "rect");
      attr4(dummy, {
        width: val,
        "stroke-width": 0
      });
      this.element.parentNode.appendChild(dummy);
      ret = dummy.getBBox().width;
      dummy.parentNode.removeChild(dummy);
    }
    return ret;
  };
  SVGElement2.prototype.symbolAttr = function(hash) {
    var wrapper = this;
    [
      "x",
      "y",
      "r",
      "start",
      "end",
      "width",
      "height",
      "innerR",
      "anchorX",
      "anchorY",
      "clockwise"
    ].forEach(function(key) {
      wrapper[key] = pick6(hash[key], wrapper[key]);
    });
    wrapper.attr({
      d: wrapper.renderer.symbols[wrapper.symbolName](wrapper.x, wrapper.y, wrapper.width, wrapper.height, wrapper)
    });
  };
  SVGElement2.prototype.textSetter = function(value) {
    if (value !== this.textStr) {
      delete this.textPxLength;
      this.textStr = value;
      if (this.added) {
        this.renderer.buildText(this);
      }
    }
  };
  SVGElement2.prototype.titleSetter = function(value) {
    var el = this.element;
    var titleNode = el.getElementsByTagName("title")[0] || doc2.createElementNS(this.SVG_NS, "title");
    if (el.insertBefore) {
      el.insertBefore(titleNode, el.firstChild);
    } else {
      el.appendChild(titleNode);
    }
    titleNode.textContent = String(pick6(value, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
  };
  SVGElement2.prototype.toFront = function() {
    var element = this.element;
    element.parentNode.appendChild(element);
    return this;
  };
  SVGElement2.prototype.translate = function(x, y) {
    return this.attr({
      translateX: x,
      translateY: y
    });
  };
  SVGElement2.prototype.updateShadows = function(key, value, setter) {
    var shadows = this.shadows;
    if (shadows) {
      var i = shadows.length;
      while (i--) {
        setter.call(shadows[i], key === "height" ? Math.max(value - (shadows[i].cutHeight || 0), 0) : key === "d" ? this.d : value, key, shadows[i]);
      }
    }
  };
  SVGElement2.prototype.updateTransform = function() {
    var wrapper = this, scaleX = wrapper.scaleX, scaleY = wrapper.scaleY, inverted = wrapper.inverted, rotation = wrapper.rotation, matrix = wrapper.matrix, element = wrapper.element;
    var translateX = wrapper.translateX || 0, translateY = wrapper.translateY || 0;
    if (inverted) {
      translateX += wrapper.width;
      translateY += wrapper.height;
    }
    var transform = ["translate(" + translateX + "," + translateY + ")"];
    if (defined4(matrix)) {
      transform.push("matrix(" + matrix.join(",") + ")");
    }
    if (inverted) {
      transform.push("rotate(90) scale(-1,1)");
    } else if (rotation) {
      transform.push("rotate(" + rotation + " " + pick6(this.rotationOriginX, element.getAttribute("x"), 0) + " " + pick6(this.rotationOriginY, element.getAttribute("y") || 0) + ")");
    }
    if (defined4(scaleX) || defined4(scaleY)) {
      transform.push("scale(" + pick6(scaleX, 1) + " " + pick6(scaleY, 1) + ")");
    }
    if (transform.length) {
      element.setAttribute("transform", transform.join(" "));
    }
  };
  SVGElement2.prototype.visibilitySetter = function(value, key, element) {
    if (value === "inherit") {
      element.removeAttribute(key);
    } else if (this[key] !== value) {
      element.setAttribute(key, value);
    }
    this[key] = value;
  };
  SVGElement2.prototype.xGetter = function(key) {
    if (this.element.nodeName === "circle") {
      if (key === "x") {
        key = "cx";
      } else if (key === "y") {
        key = "cy";
      }
    }
    return this._defaultGetter(key);
  };
  SVGElement2.prototype.zIndexSetter = function(value, key) {
    var renderer = this.renderer, parentGroup = this.parentGroup, parentWrapper = parentGroup || renderer, parentNode = parentWrapper.element || renderer.box, element = this.element, svgParent = parentNode === renderer.box;
    var childNodes, otherElement, otherZIndex, inserted = false, undefinedOtherZIndex, run = this.added, i;
    if (defined4(value)) {
      element.setAttribute("data-z-index", value);
      value = +value;
      if (this[key] === value) {
        run = false;
      }
    } else if (defined4(this[key])) {
      element.removeAttribute("data-z-index");
    }
    this[key] = value;
    if (run) {
      value = this.zIndex;
      if (value && parentGroup) {
        parentGroup.handleZ = true;
      }
      childNodes = parentNode.childNodes;
      for (i = childNodes.length - 1; i >= 0 && !inserted; i--) {
        otherElement = childNodes[i];
        otherZIndex = otherElement.getAttribute("data-z-index");
        undefinedOtherZIndex = !defined4(otherZIndex);
        if (otherElement !== element) {
          if (value < 0 && undefinedOtherZIndex && !svgParent && !i) {
            parentNode.insertBefore(element, childNodes[i]);
            inserted = true;
          } else if (pInt4(otherZIndex) <= value || undefinedOtherZIndex && (!defined4(value) || value >= 0)) {
            parentNode.insertBefore(element, childNodes[i + 1] || null);
            inserted = true;
          }
        }
      }
      if (!inserted) {
        parentNode.insertBefore(element, childNodes[svgParent ? 3 : 0] || null);
        inserted = true;
      }
    }
    return inserted;
  };
  return SVGElement2;
}();
SVGElement.prototype["stroke-widthSetter"] = SVGElement.prototype.strokeSetter;
SVGElement.prototype.yGetter = SVGElement.prototype.xGetter;
SVGElement.prototype.matrixSetter = SVGElement.prototype.rotationOriginXSetter = SVGElement.prototype.rotationOriginYSetter = SVGElement.prototype.rotationSetter = SVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = SVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter = SVGElement.prototype.verticalAlignSetter = function(value, key) {
  this[key] = value;
  this.doTransform = true;
};
var SVGElement_default = SVGElement;

// node_modules/highcharts/es-modules/Core/Renderer/RendererRegistry.js
var RendererRegistry;
(function(RendererRegistry2) {
  RendererRegistry2.rendererTypes = {};
  var defaultRenderer;
  function getRendererType(rendererType) {
    if (rendererType === void 0) {
      rendererType = defaultRenderer;
    }
    return RendererRegistry2.rendererTypes[rendererType] || RendererRegistry2.rendererTypes[defaultRenderer];
  }
  RendererRegistry2.getRendererType = getRendererType;
  function registerRendererType(rendererType, rendererClass, setAsDefault) {
    RendererRegistry2.rendererTypes[rendererType] = rendererClass;
    if (!defaultRenderer || setAsDefault) {
      defaultRenderer = rendererType;
      Globals_default.Renderer = rendererClass;
    }
  }
  RendererRegistry2.registerRendererType = registerRendererType;
})(RendererRegistry || (RendererRegistry = {}));
var RendererRegistry_default = RendererRegistry;

// node_modules/highcharts/es-modules/Core/Renderer/SVG/SVGLabel.js
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var defined5 = Utilities_default.defined;
var extend4 = Utilities_default.extend;
var isNumber7 = Utilities_default.isNumber;
var merge7 = Utilities_default.merge;
var pick7 = Utilities_default.pick;
var removeEvent2 = Utilities_default.removeEvent;
var SVGLabel = function(_super) {
  __extends(SVGLabel2, _super);
  function SVGLabel2(renderer, str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {
    var _this = _super.call(this) || this;
    _this.paddingLeftSetter = _this.paddingSetter;
    _this.paddingRightSetter = _this.paddingSetter;
    _this.init(renderer, "g");
    _this.textStr = str;
    _this.x = x;
    _this.y = y;
    _this.anchorX = anchorX;
    _this.anchorY = anchorY;
    _this.baseline = baseline;
    _this.className = className;
    _this.addClass(className === "button" ? "highcharts-no-tooltip" : "highcharts-label");
    if (className) {
      _this.addClass("highcharts-" + className);
    }
    _this.text = renderer.text(void 0, 0, 0, useHTML).attr({ zIndex: 1 });
    var hasBGImage;
    if (typeof shape === "string") {
      hasBGImage = /^url\((.*?)\)$/.test(shape);
      if (hasBGImage || _this.renderer.symbols[shape]) {
        _this.symbolKey = shape;
      }
    }
    _this.bBox = SVGLabel2.emptyBBox;
    _this.padding = 3;
    _this.baselineOffset = 0;
    _this.needsBox = renderer.styledMode || hasBGImage;
    _this.deferredAttr = {};
    _this.alignFactor = 0;
    return _this;
  }
  SVGLabel2.prototype.alignSetter = function(value) {
    var alignFactor = {
      left: 0,
      center: 0.5,
      right: 1
    }[value];
    if (alignFactor !== this.alignFactor) {
      this.alignFactor = alignFactor;
      if (this.bBox && isNumber7(this.xSetting)) {
        this.attr({ x: this.xSetting });
      }
    }
  };
  SVGLabel2.prototype.anchorXSetter = function(value, key) {
    this.anchorX = value;
    this.boxAttr(key, Math.round(value) - this.getCrispAdjust() - this.xSetting);
  };
  SVGLabel2.prototype.anchorYSetter = function(value, key) {
    this.anchorY = value;
    this.boxAttr(key, value - this.ySetting);
  };
  SVGLabel2.prototype.boxAttr = function(key, value) {
    if (this.box) {
      this.box.attr(key, value);
    } else {
      this.deferredAttr[key] = value;
    }
  };
  SVGLabel2.prototype.css = function(styles) {
    if (styles) {
      var textStyles_1 = {};
      styles = merge7(styles);
      SVGLabel2.textProps.forEach(function(prop) {
        if (typeof styles[prop] !== "undefined") {
          textStyles_1[prop] = styles[prop];
          delete styles[prop];
        }
      });
      this.text.css(textStyles_1);
      var isWidth = "width" in textStyles_1, isFontStyle = "fontSize" in textStyles_1 || "fontWeight" in textStyles_1;
      if (isFontStyle) {
        this.updateTextPadding();
      } else if (isWidth) {
        this.updateBoxSize();
      }
    }
    return SVGElement_default.prototype.css.call(this, styles);
  };
  SVGLabel2.prototype.destroy = function() {
    removeEvent2(this.element, "mouseenter");
    removeEvent2(this.element, "mouseleave");
    if (this.text) {
      this.text.destroy();
    }
    if (this.box) {
      this.box = this.box.destroy();
    }
    SVGElement_default.prototype.destroy.call(this);
    return void 0;
  };
  SVGLabel2.prototype.fillSetter = function(value, key) {
    if (value) {
      this.needsBox = true;
    }
    this.fill = value;
    this.boxAttr(key, value);
  };
  SVGLabel2.prototype.getBBox = function() {
    if (this.textStr && this.bBox.width === 0 && this.bBox.height === 0) {
      this.updateBoxSize();
    }
    var padding = this.padding;
    var paddingLeft = pick7(this.paddingLeft, padding);
    return {
      width: this.width,
      height: this.height,
      x: this.bBox.x - paddingLeft,
      y: this.bBox.y - padding
    };
  };
  SVGLabel2.prototype.getCrispAdjust = function() {
    return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
  };
  SVGLabel2.prototype.heightSetter = function(value) {
    this.heightSetting = value;
  };
  SVGLabel2.prototype.onAdd = function() {
    var str = this.textStr;
    this.text.add(this);
    this.attr({
      text: defined5(str) ? str : "",
      x: this.x,
      y: this.y
    });
    if (this.box && defined5(this.anchorX)) {
      this.attr({
        anchorX: this.anchorX,
        anchorY: this.anchorY
      });
    }
  };
  SVGLabel2.prototype.paddingSetter = function(value, key) {
    if (!isNumber7(value)) {
      this[key] = void 0;
    } else if (value !== this[key]) {
      this[key] = value;
      this.updateTextPadding();
    }
  };
  SVGLabel2.prototype.rSetter = function(value, key) {
    this.boxAttr(key, value);
  };
  SVGLabel2.prototype.shadow = function(b) {
    if (b && !this.renderer.styledMode) {
      this.updateBoxSize();
      if (this.box) {
        this.box.shadow(b);
      }
    }
    return this;
  };
  SVGLabel2.prototype.strokeSetter = function(value, key) {
    this.stroke = value;
    this.boxAttr(key, value);
  };
  SVGLabel2.prototype["stroke-widthSetter"] = function(value, key) {
    if (value) {
      this.needsBox = true;
    }
    this["stroke-width"] = value;
    this.boxAttr(key, value);
  };
  SVGLabel2.prototype["text-alignSetter"] = function(value) {
    this.textAlign = value;
  };
  SVGLabel2.prototype.textSetter = function(text) {
    if (typeof text !== "undefined") {
      this.text.attr({ text });
    }
    this.updateTextPadding();
  };
  SVGLabel2.prototype.updateBoxSize = function() {
    var style = this.text.element.style, attribs = {}, padding = this.padding, bBox = this.bBox = (!isNumber7(this.widthSetting) || !isNumber7(this.heightSetting) || this.textAlign) && defined5(this.text.textStr) ? this.text.getBBox() : SVGLabel2.emptyBBox;
    var crispAdjust;
    this.width = this.getPaddedWidth();
    this.height = (this.heightSetting || bBox.height || 0) + 2 * padding;
    var metrics = this.renderer.fontMetrics(style && style.fontSize, this.text);
    this.baselineOffset = padding + Math.min((this.text.firstLineMetrics || metrics).b, bBox.height || Infinity);
    if (this.heightSetting) {
      this.baselineOffset += (this.heightSetting - metrics.h) / 2;
    }
    if (this.needsBox) {
      if (!this.box) {
        var box = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect();
        box.addClass((this.className === "button" ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : ""));
        box.add(this);
      }
      crispAdjust = this.getCrispAdjust();
      attribs.x = crispAdjust;
      attribs.y = (this.baseline ? -this.baselineOffset : 0) + crispAdjust;
      attribs.width = Math.round(this.width);
      attribs.height = Math.round(this.height);
      this.box.attr(extend4(attribs, this.deferredAttr));
      this.deferredAttr = {};
    }
  };
  SVGLabel2.prototype.updateTextPadding = function() {
    var text = this.text;
    this.updateBoxSize();
    var textY = this.baseline ? 0 : this.baselineOffset;
    var textX = pick7(this.paddingLeft, this.padding);
    if (defined5(this.widthSetting) && this.bBox && (this.textAlign === "center" || this.textAlign === "right")) {
      textX += { center: 0.5, right: 1 }[this.textAlign] * (this.widthSetting - this.bBox.width);
    }
    if (textX !== text.x || textY !== text.y) {
      text.attr("x", textX);
      if (text.hasBoxWidthChanged) {
        this.bBox = text.getBBox(true);
      }
      if (typeof textY !== "undefined") {
        text.attr("y", textY);
      }
    }
    text.x = textX;
    text.y = textY;
  };
  SVGLabel2.prototype.widthSetter = function(value) {
    this.widthSetting = isNumber7(value) ? value : void 0;
  };
  SVGLabel2.prototype.getPaddedWidth = function() {
    var padding = this.padding;
    var paddingLeft = pick7(this.paddingLeft, padding);
    var paddingRight = pick7(this.paddingRight, padding);
    return (this.widthSetting || this.bBox.width || 0) + paddingLeft + paddingRight;
  };
  SVGLabel2.prototype.xSetter = function(value) {
    this.x = value;
    if (this.alignFactor) {
      value -= this.alignFactor * this.getPaddedWidth();
      this["forceAnimate:x"] = true;
    }
    this.xSetting = Math.round(value);
    this.attr("translateX", this.xSetting);
  };
  SVGLabel2.prototype.ySetter = function(value) {
    this.ySetting = this.y = Math.round(value);
    this.attr("translateY", this.ySetting);
  };
  SVGLabel2.emptyBBox = { width: 0, height: 0, x: 0, y: 0 };
  SVGLabel2.textProps = [
    "color",
    "direction",
    "fontFamily",
    "fontSize",
    "fontStyle",
    "fontWeight",
    "lineHeight",
    "textAlign",
    "textDecoration",
    "textOutline",
    "textOverflow",
    "width"
  ];
  return SVGLabel2;
}(SVGElement_default);
var SVGLabel_default = SVGLabel;

// node_modules/highcharts/es-modules/Core/Renderer/SVG/Symbols.js
var defined6 = Utilities_default.defined;
var isNumber8 = Utilities_default.isNumber;
var pick8 = Utilities_default.pick;
function arc(x, y, w2, h, options) {
  var arc3 = [];
  if (options) {
    var start = options.start || 0, rx = pick8(options.r, w2), ry = pick8(options.r, h || w2), proximity = 1e-3, fullCircle = Math.abs((options.end || 0) - start - 2 * Math.PI) < proximity, end = (options.end || 0) - proximity, innerRadius = options.innerR, open_1 = pick8(options.open, fullCircle), cosStart = Math.cos(start), sinStart = Math.sin(start), cosEnd = Math.cos(end), sinEnd = Math.sin(end), longArc = pick8(options.longArc, end - start - Math.PI < proximity ? 0 : 1);
    arc3.push([
      "M",
      x + rx * cosStart,
      y + ry * sinStart
    ], [
      "A",
      rx,
      ry,
      0,
      longArc,
      pick8(options.clockwise, 1),
      x + rx * cosEnd,
      y + ry * sinEnd
    ]);
    if (defined6(innerRadius)) {
      arc3.push(open_1 ? [
        "M",
        x + innerRadius * cosEnd,
        y + innerRadius * sinEnd
      ] : [
        "L",
        x + innerRadius * cosEnd,
        y + innerRadius * sinEnd
      ], [
        "A",
        innerRadius,
        innerRadius,
        0,
        longArc,
        defined6(options.clockwise) ? 1 - options.clockwise : 0,
        x + innerRadius * cosStart,
        y + innerRadius * sinStart
      ]);
    }
    if (!open_1) {
      arc3.push(["Z"]);
    }
  }
  return arc3;
}
function callout(x, y, w2, h, options) {
  var arrowLength = 6, halfDistance = 6, r = Math.min(options && options.r || 0, w2, h), safeDistance = r + halfDistance, anchorX = options && options.anchorX, anchorY = options && options.anchorY || 0;
  var path = roundedRect(x, y, w2, h, { r });
  if (!isNumber8(anchorX)) {
    return path;
  }
  if (x + anchorX >= w2) {
    if (anchorY > y + safeDistance && anchorY < y + h - safeDistance) {
      path.splice(3, 1, ["L", x + w2, anchorY - halfDistance], ["L", x + w2 + arrowLength, anchorY], ["L", x + w2, anchorY + halfDistance], ["L", x + w2, y + h - r]);
    } else {
      path.splice(3, 1, ["L", x + w2, h / 2], ["L", anchorX, anchorY], ["L", x + w2, h / 2], ["L", x + w2, y + h - r]);
    }
  } else if (x + anchorX <= 0) {
    if (anchorY > y + safeDistance && anchorY < y + h - safeDistance) {
      path.splice(7, 1, ["L", x, anchorY + halfDistance], ["L", x - arrowLength, anchorY], ["L", x, anchorY - halfDistance], ["L", x, y + r]);
    } else {
      path.splice(7, 1, ["L", x, h / 2], ["L", anchorX, anchorY], ["L", x, h / 2], ["L", x, y + r]);
    }
  } else if (anchorY && anchorY > h && anchorX > x + safeDistance && anchorX < x + w2 - safeDistance) {
    path.splice(5, 1, ["L", anchorX + halfDistance, y + h], ["L", anchorX, y + h + arrowLength], ["L", anchorX - halfDistance, y + h], ["L", x + r, y + h]);
  } else if (anchorY && anchorY < 0 && anchorX > x + safeDistance && anchorX < x + w2 - safeDistance) {
    path.splice(1, 1, ["L", anchorX - halfDistance, y], ["L", anchorX, y - arrowLength], ["L", anchorX + halfDistance, y], ["L", w2 - r, y]);
  }
  return path;
}
function circle(x, y, w2, h) {
  return arc(x + w2 / 2, y + h / 2, w2 / 2, h / 2, {
    start: Math.PI * 0.5,
    end: Math.PI * 2.5,
    open: false
  });
}
function diamond(x, y, w2, h) {
  return [
    ["M", x + w2 / 2, y],
    ["L", x + w2, y + h / 2],
    ["L", x + w2 / 2, y + h],
    ["L", x, y + h / 2],
    ["Z"]
  ];
}
function rect(x, y, w2, h, options) {
  if (options && options.r) {
    return roundedRect(x, y, w2, h, options);
  }
  return [
    ["M", x, y],
    ["L", x + w2, y],
    ["L", x + w2, y + h],
    ["L", x, y + h],
    ["Z"]
  ];
}
function roundedRect(x, y, w2, h, options) {
  var r = options && options.r || 0;
  return [
    ["M", x + r, y],
    ["L", x + w2 - r, y],
    ["C", x + w2, y, x + w2, y, x + w2, y + r],
    ["L", x + w2, y + h - r],
    ["C", x + w2, y + h, x + w2, y + h, x + w2 - r, y + h],
    ["L", x + r, y + h],
    ["C", x, y + h, x, y + h, x, y + h - r],
    ["L", x, y + r],
    ["C", x, y, x, y, x + r, y]
  ];
}
function triangle(x, y, w2, h) {
  return [
    ["M", x + w2 / 2, y],
    ["L", x + w2, y + h],
    ["L", x, y + h],
    ["Z"]
  ];
}
function triangleDown(x, y, w2, h) {
  return [
    ["M", x, y],
    ["L", x + w2, y],
    ["L", x + w2 / 2, y + h],
    ["Z"]
  ];
}
var Symbols = {
  arc,
  callout,
  circle,
  diamond,
  rect,
  roundedRect,
  square: rect,
  triangle,
  "triangle-down": triangleDown
};
var Symbols_default = Symbols;

// node_modules/highcharts/es-modules/Core/Renderer/SVG/TextBuilder.js
var doc3 = Globals_default.doc;
var SVG_NS3 = Globals_default.SVG_NS;
var attr5 = Utilities_default.attr;
var isString4 = Utilities_default.isString;
var objectEach7 = Utilities_default.objectEach;
var pick9 = Utilities_default.pick;
var TextBuilder = function() {
  function TextBuilder2(svgElement) {
    var textStyles = svgElement.styles;
    this.renderer = svgElement.renderer;
    this.svgElement = svgElement;
    this.width = svgElement.textWidth;
    this.textLineHeight = textStyles && textStyles.lineHeight;
    this.textOutline = textStyles && textStyles.textOutline;
    this.ellipsis = Boolean(textStyles && textStyles.textOverflow === "ellipsis");
    this.noWrap = Boolean(textStyles && textStyles.whiteSpace === "nowrap");
    this.fontSize = textStyles && textStyles.fontSize;
  }
  TextBuilder2.prototype.buildSVG = function() {
    var wrapper = this.svgElement, textNode = wrapper.element, renderer = wrapper.renderer, textStr = pick9(wrapper.textStr, "").toString(), hasMarkup = textStr.indexOf("<") !== -1, childNodes = textNode.childNodes, tempParent = this.width && !wrapper.added && renderer.box, regexMatchBreaks = /<br.*?>/g, textCache = [
      textStr,
      this.ellipsis,
      this.noWrap,
      this.textLineHeight,
      this.textOutline,
      this.fontSize,
      this.width
    ].join(",");
    if (textCache === wrapper.textCache) {
      return;
    }
    wrapper.textCache = textCache;
    delete wrapper.actualWidth;
    for (var i = childNodes.length; i--; ) {
      textNode.removeChild(childNodes[i]);
    }
    if (!hasMarkup && !this.ellipsis && !this.width && (textStr.indexOf(" ") === -1 || this.noWrap && !regexMatchBreaks.test(textStr))) {
      textNode.appendChild(doc3.createTextNode(this.unescapeEntities(textStr)));
    } else if (textStr !== "") {
      if (tempParent) {
        tempParent.appendChild(textNode);
      }
      var ast = new AST_default(textStr);
      this.modifyTree(ast.nodes);
      ast.addToDOM(wrapper.element);
      this.modifyDOM();
      if (this.ellipsis && (textNode.textContent || "").indexOf("\u2026") !== -1) {
        wrapper.attr("title", this.unescapeEntities(wrapper.textStr || "", ["&lt;", "&gt;"]));
      }
      if (tempParent) {
        tempParent.removeChild(textNode);
      }
    }
    if (isString4(this.textOutline) && wrapper.applyTextOutline) {
      wrapper.applyTextOutline(this.textOutline);
    }
  };
  TextBuilder2.prototype.modifyDOM = function() {
    var _this = this;
    var wrapper = this.svgElement;
    var x = attr5(wrapper.element, "x");
    wrapper.firstLineMetrics = void 0;
    var firstChild;
    while (firstChild = wrapper.element.firstChild) {
      if (/^[\s\u200B]*$/.test(firstChild.textContent || " ")) {
        wrapper.element.removeChild(firstChild);
      } else {
        break;
      }
    }
    [].forEach.call(wrapper.element.querySelectorAll("tspan.highcharts-br"), function(br, i) {
      if (br.nextSibling && br.previousSibling) {
        if (i === 0 && br.previousSibling.nodeType === 1) {
          wrapper.firstLineMetrics = wrapper.renderer.fontMetrics(void 0, br.previousSibling);
        }
        attr5(br, {
          dy: _this.getLineHeight(br.nextSibling),
          x
        });
      }
    });
    var width = this.width || 0;
    if (!width) {
      return;
    }
    var modifyTextNode = function(textNode, parentElement) {
      var text = textNode.textContent || "";
      var words = text.replace(/([^\^])-/g, "$1- ").split(" ");
      var hasWhiteSpace = !_this.noWrap && (words.length > 1 || wrapper.element.childNodes.length > 1);
      var dy = _this.getLineHeight(parentElement);
      var lineNo = 0;
      var startAt = wrapper.actualWidth;
      if (_this.ellipsis) {
        if (text) {
          _this.truncate(textNode, text, void 0, 0, Math.max(0, width - parseInt(_this.fontSize || 12, 10)), function(text2, currentIndex) {
            return text2.substring(0, currentIndex) + "\u2026";
          });
        }
      } else if (hasWhiteSpace) {
        var lines = [];
        var precedingSiblings = [];
        while (parentElement.firstChild && parentElement.firstChild !== textNode) {
          precedingSiblings.push(parentElement.firstChild);
          parentElement.removeChild(parentElement.firstChild);
        }
        while (words.length) {
          if (words.length && !_this.noWrap && lineNo > 0) {
            lines.push(textNode.textContent || "");
            textNode.textContent = words.join(" ").replace(/- /g, "-");
          }
          _this.truncate(textNode, void 0, words, lineNo === 0 ? startAt || 0 : 0, width, function(t, currentIndex) {
            return words.slice(0, currentIndex).join(" ").replace(/- /g, "-");
          });
          startAt = wrapper.actualWidth;
          lineNo++;
        }
        precedingSiblings.forEach(function(childNode) {
          parentElement.insertBefore(childNode, textNode);
        });
        lines.forEach(function(line) {
          parentElement.insertBefore(doc3.createTextNode(line), textNode);
          var br = doc3.createElementNS(SVG_NS3, "tspan");
          br.textContent = "\u200B";
          attr5(br, { dy, x });
          parentElement.insertBefore(br, textNode);
        });
      }
    };
    var modifyChildren = function(node) {
      var childNodes = [].slice.call(node.childNodes);
      childNodes.forEach(function(childNode) {
        if (childNode.nodeType === Node.TEXT_NODE) {
          modifyTextNode(childNode, node);
        } else {
          if (childNode.className.baseVal.indexOf("highcharts-br") !== -1) {
            wrapper.actualWidth = 0;
          }
          modifyChildren(childNode);
        }
      });
    };
    modifyChildren(wrapper.element);
  };
  TextBuilder2.prototype.getLineHeight = function(node) {
    var fontSizeStyle;
    var element = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
    if (!this.renderer.styledMode) {
      fontSizeStyle = element && /(px|em)$/.test(element.style.fontSize) ? element.style.fontSize : this.fontSize || this.renderer.style.fontSize || 12;
    }
    return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(fontSizeStyle, element || this.svgElement.element).h;
  };
  TextBuilder2.prototype.modifyTree = function(nodes) {
    var _this = this;
    var modifyChild = function(node, i) {
      var tagName = node.tagName;
      var styledMode = _this.renderer.styledMode;
      var attributes = node.attributes || {};
      if (tagName === "b" || tagName === "strong") {
        if (styledMode) {
          attributes["class"] = "highcharts-strong";
        } else {
          attributes.style = "font-weight:bold;" + (attributes.style || "");
        }
      } else if (tagName === "i" || tagName === "em") {
        if (styledMode) {
          attributes["class"] = "highcharts-emphasized";
        } else {
          attributes.style = "font-style:italic;" + (attributes.style || "");
        }
      }
      if (isString4(attributes.style)) {
        attributes.style = attributes.style.replace(/(;| |^)color([ :])/, "$1fill$2");
      }
      if (tagName === "br") {
        attributes["class"] = "highcharts-br";
        node.textContent = "\u200B";
        var nextNode = nodes[i + 1];
        if (nextNode && nextNode.textContent) {
          nextNode.textContent = nextNode.textContent.replace(/^ +/gm, "");
        }
      }
      if (tagName !== "#text" && tagName !== "a") {
        node.tagName = "tspan";
      }
      node.attributes = attributes;
      if (node.children) {
        node.children.filter(function(c) {
          return c.tagName !== "#text";
        }).forEach(modifyChild);
      }
    };
    nodes.forEach(modifyChild);
  };
  TextBuilder2.prototype.truncate = function(textNode, text, words, startAt, width, getString) {
    var svgElement = this.svgElement;
    var renderer = svgElement.renderer, rotation = svgElement.rotation;
    var lengths = [];
    var minIndex = words ? 1 : 0;
    var maxIndex = (text || words || "").length;
    var currentIndex = maxIndex;
    var str;
    var actualWidth;
    var getSubStringLength = function(charEnd, concatenatedEnd) {
      var end = concatenatedEnd || charEnd;
      var parentNode = textNode.parentNode;
      if (parentNode && typeof lengths[end] === "undefined") {
        if (parentNode.getSubStringLength) {
          try {
            lengths[end] = startAt + parentNode.getSubStringLength(0, words ? end + 1 : end);
          } catch (e2) {
            "";
          }
        } else if (renderer.getSpanWidth) {
          textNode.textContent = getString(text || words, charEnd);
          lengths[end] = startAt + renderer.getSpanWidth(svgElement, textNode);
        }
      }
      return lengths[end];
    };
    svgElement.rotation = 0;
    actualWidth = getSubStringLength(textNode.textContent.length);
    if (startAt + actualWidth > width) {
      while (minIndex <= maxIndex) {
        currentIndex = Math.ceil((minIndex + maxIndex) / 2);
        if (words) {
          str = getString(words, currentIndex);
        }
        actualWidth = getSubStringLength(currentIndex, str && str.length - 1);
        if (minIndex === maxIndex) {
          minIndex = maxIndex + 1;
        } else if (actualWidth > width) {
          maxIndex = currentIndex - 1;
        } else {
          minIndex = currentIndex;
        }
      }
      if (maxIndex === 0) {
        textNode.textContent = "";
      } else if (!(text && maxIndex === text.length - 1)) {
        textNode.textContent = str || getString(text || words, currentIndex);
      }
    }
    if (words) {
      words.splice(0, currentIndex);
    }
    svgElement.actualWidth = actualWidth;
    svgElement.rotation = rotation;
  };
  TextBuilder2.prototype.unescapeEntities = function(inputStr, except) {
    objectEach7(this.renderer.escapes, function(value, key) {
      if (!except || except.indexOf(value) === -1) {
        inputStr = inputStr.toString().replace(new RegExp(value, "g"), key);
      }
    });
    return inputStr;
  };
  return TextBuilder2;
}();
var TextBuilder_default = TextBuilder;

// node_modules/highcharts/es-modules/Core/Renderer/SVG/SVGRenderer.js
var charts2 = Globals_default.charts;
var deg2rad2 = Globals_default.deg2rad;
var doc4 = Globals_default.doc;
var isFirefox = Globals_default.isFirefox;
var isMS = Globals_default.isMS;
var isWebKit = Globals_default.isWebKit;
var noop2 = Globals_default.noop;
var SVG_NS4 = Globals_default.SVG_NS;
var symbolSizes = Globals_default.symbolSizes;
var win6 = Globals_default.win;
var addEvent3 = Utilities_default.addEvent;
var attr6 = Utilities_default.attr;
var createElement4 = Utilities_default.createElement;
var css4 = Utilities_default.css;
var defined7 = Utilities_default.defined;
var destroyObjectProperties2 = Utilities_default.destroyObjectProperties;
var extend5 = Utilities_default.extend;
var isArray4 = Utilities_default.isArray;
var isNumber9 = Utilities_default.isNumber;
var isObject4 = Utilities_default.isObject;
var isString5 = Utilities_default.isString;
var merge8 = Utilities_default.merge;
var pick10 = Utilities_default.pick;
var pInt5 = Utilities_default.pInt;
var uniqueKey3 = Utilities_default.uniqueKey;
var hasInternalReferenceBug;
var SVGRenderer = function() {
  function SVGRenderer2(container, width, height, style, forExport, allowHTML, styledMode) {
    this.alignedObjects = void 0;
    this.box = void 0;
    this.boxWrapper = void 0;
    this.cache = void 0;
    this.cacheKeys = void 0;
    this.chartIndex = void 0;
    this.defs = void 0;
    this.globalAnimation = void 0;
    this.gradients = void 0;
    this.height = void 0;
    this.imgCount = void 0;
    this.isSVG = void 0;
    this.style = void 0;
    this.url = void 0;
    this.width = void 0;
    this.init(container, width, height, style, forExport, allowHTML, styledMode);
  }
  SVGRenderer2.prototype.init = function(container, width, height, style, forExport, allowHTML, styledMode) {
    var renderer = this, boxWrapper = renderer.createElement("svg").attr({
      version: "1.1",
      "class": "highcharts-root"
    }), element = boxWrapper.element;
    if (!styledMode) {
      boxWrapper.css(this.getStyle(style));
    }
    container.appendChild(element);
    attr6(container, "dir", "ltr");
    if (container.innerHTML.indexOf("xmlns") === -1) {
      attr6(element, "xmlns", this.SVG_NS);
    }
    renderer.isSVG = true;
    this.box = element;
    this.boxWrapper = boxWrapper;
    renderer.alignedObjects = [];
    this.url = this.getReferenceURL();
    var desc = this.createElement("desc").add();
    desc.element.appendChild(doc4.createTextNode("Created with Highcharts 9.2.2"));
    renderer.defs = this.createElement("defs").add();
    renderer.allowHTML = allowHTML;
    renderer.forExport = forExport;
    renderer.styledMode = styledMode;
    renderer.gradients = {};
    renderer.cache = {};
    renderer.cacheKeys = [];
    renderer.imgCount = 0;
    renderer.setSize(width, height, false);
    var subPixelFix, rect2;
    if (isFirefox && container.getBoundingClientRect) {
      subPixelFix = function() {
        css4(container, { left: 0, top: 0 });
        rect2 = container.getBoundingClientRect();
        css4(container, {
          left: Math.ceil(rect2.left) - rect2.left + "px",
          top: Math.ceil(rect2.top) - rect2.top + "px"
        });
      };
      subPixelFix();
      renderer.unSubPixelFix = addEvent3(win6, "resize", subPixelFix);
    }
  };
  SVGRenderer2.prototype.definition = function(def) {
    var ast = new AST_default([def]);
    return ast.addToDOM(this.defs.element);
  };
  SVGRenderer2.prototype.getReferenceURL = function() {
    if ((isFirefox || isWebKit) && doc4.getElementsByTagName("base").length) {
      if (!defined7(hasInternalReferenceBug)) {
        var id = uniqueKey3();
        var ast = new AST_default([{
          tagName: "svg",
          attributes: {
            width: 8,
            height: 8
          },
          children: [{
            tagName: "defs",
            children: [{
              tagName: "clipPath",
              attributes: {
                id
              },
              children: [{
                tagName: "rect",
                attributes: {
                  width: 4,
                  height: 4
                }
              }]
            }]
          }, {
            tagName: "rect",
            attributes: {
              id: "hitme",
              width: 8,
              height: 8,
              "clip-path": "url(#" + id + ")",
              fill: "rgba(0,0,0,0.001)"
            }
          }]
        }]);
        var svg7 = ast.addToDOM(doc4.body);
        css4(svg7, {
          position: "fixed",
          top: 0,
          left: 0,
          zIndex: 9e5
        });
        var hitElement = doc4.elementFromPoint(6, 6);
        hasInternalReferenceBug = (hitElement && hitElement.id) === "hitme";
        doc4.body.removeChild(svg7);
      }
      if (hasInternalReferenceBug) {
        return win6.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20");
      }
    }
    return "";
  };
  SVGRenderer2.prototype.getStyle = function(style) {
    this.style = extend5({
      fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',
      fontSize: "12px"
    }, style);
    return this.style;
  };
  SVGRenderer2.prototype.setStyle = function(style) {
    this.boxWrapper.css(this.getStyle(style));
  };
  SVGRenderer2.prototype.isHidden = function() {
    return !this.boxWrapper.getBBox().width;
  };
  SVGRenderer2.prototype.destroy = function() {
    var renderer = this, rendererDefs = renderer.defs;
    renderer.box = null;
    renderer.boxWrapper = renderer.boxWrapper.destroy();
    destroyObjectProperties2(renderer.gradients || {});
    renderer.gradients = null;
    if (rendererDefs) {
      renderer.defs = rendererDefs.destroy();
    }
    if (renderer.unSubPixelFix) {
      renderer.unSubPixelFix();
    }
    renderer.alignedObjects = null;
    return null;
  };
  SVGRenderer2.prototype.createElement = function(nodeName) {
    var wrapper = new this.Element();
    wrapper.init(this, nodeName);
    return wrapper;
  };
  SVGRenderer2.prototype.getRadialAttr = function(radialReference, gradAttr) {
    return {
      cx: radialReference[0] - radialReference[2] / 2 + (gradAttr.cx || 0) * radialReference[2],
      cy: radialReference[1] - radialReference[2] / 2 + (gradAttr.cy || 0) * radialReference[2],
      r: (gradAttr.r || 0) * radialReference[2]
    };
  };
  SVGRenderer2.prototype.buildText = function(wrapper) {
    new TextBuilder_default(wrapper).buildSVG();
  };
  SVGRenderer2.prototype.getContrast = function(rgba) {
    rgba = Color_default.parse(rgba).rgba;
    rgba[0] *= 1;
    rgba[1] *= 1.2;
    rgba[2] *= 0.5;
    return rgba[0] + rgba[1] + rgba[2] > 1.8 * 255 ? "#000000" : "#FFFFFF";
  };
  SVGRenderer2.prototype.button = function(text, x, y, callback, theme2, hoverState, pressedState, disabledState, shape, useHTML) {
    var label = this.label(text, x, y, shape, void 0, void 0, useHTML, void 0, "button"), styledMode = this.styledMode;
    var curState = 0, normalState = theme2 ? merge8(theme2) : {};
    var userNormalStyle = normalState && normalState.style || {};
    normalState = AST_default.filterUserAttributes(normalState);
    label.attr(merge8({ padding: 8, r: 2 }, normalState));
    var normalStyle, hoverStyle, pressedStyle, disabledStyle;
    if (!styledMode) {
      normalState = merge8({
        fill: Palette_default.neutralColor3,
        stroke: Palette_default.neutralColor20,
        "stroke-width": 1,
        style: {
          color: Palette_default.neutralColor80,
          cursor: "pointer",
          fontWeight: "normal"
        }
      }, {
        style: userNormalStyle
      }, normalState);
      normalStyle = normalState.style;
      delete normalState.style;
      hoverState = merge8(normalState, {
        fill: Palette_default.neutralColor10
      }, AST_default.filterUserAttributes(hoverState || {}));
      hoverStyle = hoverState.style;
      delete hoverState.style;
      pressedState = merge8(normalState, {
        fill: Palette_default.highlightColor10,
        style: {
          color: Palette_default.neutralColor100,
          fontWeight: "bold"
        }
      }, AST_default.filterUserAttributes(pressedState || {}));
      pressedStyle = pressedState.style;
      delete pressedState.style;
      disabledState = merge8(normalState, {
        style: {
          color: Palette_default.neutralColor20
        }
      }, AST_default.filterUserAttributes(disabledState || {}));
      disabledStyle = disabledState.style;
      delete disabledState.style;
    }
    addEvent3(label.element, isMS ? "mouseover" : "mouseenter", function() {
      if (curState !== 3) {
        label.setState(1);
      }
    });
    addEvent3(label.element, isMS ? "mouseout" : "mouseleave", function() {
      if (curState !== 3) {
        label.setState(curState);
      }
    });
    label.setState = function(state) {
      if (state !== 1) {
        label.state = curState = state;
      }
      label.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][state || 0]);
      if (!styledMode) {
        label.attr([
          normalState,
          hoverState,
          pressedState,
          disabledState
        ][state || 0]).css([
          normalStyle,
          hoverStyle,
          pressedStyle,
          disabledStyle
        ][state || 0]);
      }
    };
    if (!styledMode) {
      label.attr(normalState).css(extend5({ cursor: "default" }, normalStyle));
    }
    return label.on("touchstart", function(e2) {
      return e2.stopPropagation();
    }).on("click", function(e2) {
      if (curState !== 3) {
        callback.call(label, e2);
      }
    });
  };
  SVGRenderer2.prototype.crispLine = function(points, width, roundingFunction) {
    if (roundingFunction === void 0) {
      roundingFunction = "round";
    }
    var start = points[0];
    var end = points[1];
    if (defined7(start[1]) && start[1] === end[1]) {
      start[1] = end[1] = Math[roundingFunction](start[1]) - width % 2 / 2;
    }
    if (defined7(start[2]) && start[2] === end[2]) {
      start[2] = end[2] = Math[roundingFunction](start[2]) + width % 2 / 2;
    }
    return points;
  };
  SVGRenderer2.prototype.path = function(path) {
    var attribs = this.styledMode ? {} : {
      fill: "none"
    };
    if (isArray4(path)) {
      attribs.d = path;
    } else if (isObject4(path)) {
      extend5(attribs, path);
    }
    return this.createElement("path").attr(attribs);
  };
  SVGRenderer2.prototype.circle = function(x, y, r) {
    var attribs = isObject4(x) ? x : typeof x === "undefined" ? {} : { x, y, r }, wrapper = this.createElement("circle");
    wrapper.xSetter = wrapper.ySetter = function(value, key, element) {
      element.setAttribute("c" + key, value);
    };
    return wrapper.attr(attribs);
  };
  SVGRenderer2.prototype.arc = function(x, y, r, innerR, start, end) {
    var options;
    if (isObject4(x)) {
      options = x;
      y = options.y;
      r = options.r;
      innerR = options.innerR;
      start = options.start;
      end = options.end;
      x = options.x;
    } else {
      options = { innerR, start, end };
    }
    var arc3 = this.symbol("arc", x, y, r, r, options);
    arc3.r = r;
    return arc3;
  };
  SVGRenderer2.prototype.rect = function(x, y, width, height, r, strokeWidth) {
    r = isObject4(x) ? x.r : r;
    var wrapper = this.createElement("rect");
    var attribs = isObject4(x) ? x : typeof x === "undefined" ? {} : {
      x,
      y,
      width: Math.max(width, 0),
      height: Math.max(height, 0)
    };
    if (!this.styledMode) {
      if (typeof strokeWidth !== "undefined") {
        attribs["stroke-width"] = strokeWidth;
        attribs = wrapper.crisp(attribs);
      }
      attribs.fill = "none";
    }
    if (r) {
      attribs.r = r;
    }
    wrapper.rSetter = function(value, _key, element) {
      wrapper.r = value;
      attr6(element, {
        rx: value,
        ry: value
      });
    };
    wrapper.rGetter = function() {
      return wrapper.r || 0;
    };
    return wrapper.attr(attribs);
  };
  SVGRenderer2.prototype.setSize = function(width, height, animate4) {
    var renderer = this;
    renderer.width = width;
    renderer.height = height;
    renderer.boxWrapper.animate({
      width,
      height
    }, {
      step: function() {
        this.attr({
          viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
        });
      },
      duration: pick10(animate4, true) ? void 0 : 0
    });
    renderer.alignElements();
  };
  SVGRenderer2.prototype.g = function(name) {
    var elem = this.createElement("g");
    return name ? elem.attr({ "class": "highcharts-" + name }) : elem;
  };
  SVGRenderer2.prototype.image = function(src, x, y, width, height, onload) {
    var attribs = { preserveAspectRatio: "none" }, setSVGImageSource = function(el, src2) {
      if (el.setAttributeNS) {
        el.setAttributeNS("http://www.w3.org/1999/xlink", "href", src2);
      } else {
        el.setAttribute("hc-svg-href", src2);
      }
    };
    if (arguments.length > 1) {
      extend5(attribs, {
        x,
        y,
        width,
        height
      });
    }
    var elemWrapper = this.createElement("image").attr(attribs), onDummyLoad = function(e2) {
      setSVGImageSource(elemWrapper.element, src);
      onload.call(elemWrapper, e2);
    };
    if (onload) {
      setSVGImageSource(elemWrapper.element, "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==");
      var dummy = new win6.Image();
      addEvent3(dummy, "load", onDummyLoad);
      dummy.src = src;
      if (dummy.complete) {
        onDummyLoad({});
      }
    } else {
      setSVGImageSource(elemWrapper.element, src);
    }
    return elemWrapper;
  };
  SVGRenderer2.prototype.symbol = function(symbol, x, y, width, height, options) {
    var ren = this, imageRegex = /^url\((.*?)\)$/, isImage = imageRegex.test(symbol), sym = !isImage && (this.symbols[symbol] ? symbol : "circle"), symbolFn = sym && this.symbols[sym];
    var obj, path, imageSrc, centerImage;
    if (symbolFn) {
      if (typeof x === "number") {
        path = symbolFn.call(this.symbols, Math.round(x || 0), Math.round(y || 0), width || 0, height || 0, options);
      }
      obj = this.path(path);
      if (!ren.styledMode) {
        obj.attr("fill", "none");
      }
      extend5(obj, {
        symbolName: sym || void 0,
        x,
        y,
        width,
        height
      });
      if (options) {
        extend5(obj, options);
      }
    } else if (isImage) {
      imageSrc = symbol.match(imageRegex)[1];
      var img_1 = obj = this.image(imageSrc);
      img_1.imgwidth = pick10(symbolSizes[imageSrc] && symbolSizes[imageSrc].width, options && options.width);
      img_1.imgheight = pick10(symbolSizes[imageSrc] && symbolSizes[imageSrc].height, options && options.height);
      centerImage = function(obj2) {
        return obj2.attr({
          width: obj2.width,
          height: obj2.height
        });
      };
      ["width", "height"].forEach(function(key) {
        img_1[key + "Setter"] = function(value, key2) {
          var imgSize = this["img" + key2];
          this[key2] = value;
          if (defined7(imgSize)) {
            if (options && options.backgroundSize === "within" && this.width && this.height) {
              imgSize = Math.round(imgSize * Math.min(this.width / this.imgwidth, this.height / this.imgheight));
            }
            if (this.element) {
              this.element.setAttribute(key2, imgSize);
            }
            if (!this.alignByTranslate) {
              var translate = ((this[key2] || 0) - imgSize) / 2;
              var attribs = key2 === "width" ? { translateX: translate } : { translateY: translate };
              this.attr(attribs);
            }
          }
        };
      });
      if (defined7(x)) {
        img_1.attr({
          x,
          y
        });
      }
      img_1.isImg = true;
      if (defined7(img_1.imgwidth) && defined7(img_1.imgheight)) {
        centerImage(img_1);
      } else {
        img_1.attr({ width: 0, height: 0 });
        createElement4("img", {
          onload: function() {
            var chart = charts2[ren.chartIndex];
            if (this.width === 0) {
              css4(this, {
                position: "absolute",
                top: "-999em"
              });
              doc4.body.appendChild(this);
            }
            symbolSizes[imageSrc] = {
              width: this.width,
              height: this.height
            };
            img_1.imgwidth = this.width;
            img_1.imgheight = this.height;
            if (img_1.element) {
              centerImage(img_1);
            }
            if (this.parentNode) {
              this.parentNode.removeChild(this);
            }
            ren.imgCount--;
            if (!ren.imgCount && chart && !chart.hasLoaded) {
              chart.onload();
            }
          },
          src: imageSrc
        });
        this.imgCount++;
      }
    }
    return obj;
  };
  SVGRenderer2.prototype.clipRect = function(x, y, width, height) {
    var id = uniqueKey3() + "-", clipPath = this.createElement("clipPath").attr({
      id
    }).add(this.defs), wrapper = this.rect(x, y, width, height, 0).add(clipPath);
    wrapper.id = id;
    wrapper.clipPath = clipPath;
    wrapper.count = 0;
    return wrapper;
  };
  SVGRenderer2.prototype.text = function(str, x, y, useHTML) {
    var renderer = this, attribs = {};
    if (useHTML && (renderer.allowHTML || !renderer.forExport)) {
      return renderer.html(str, x, y);
    }
    attribs.x = Math.round(x || 0);
    if (y) {
      attribs.y = Math.round(y);
    }
    if (defined7(str)) {
      attribs.text = str;
    }
    var wrapper = renderer.createElement("text").attr(attribs);
    if (!useHTML || renderer.forExport && !renderer.allowHTML) {
      wrapper.xSetter = function(value, key, element) {
        var tspans = element.getElementsByTagName("tspan"), parentVal = element.getAttribute(key);
        for (var i = 0, tspan = void 0; i < tspans.length; i++) {
          tspan = tspans[i];
          if (tspan.getAttribute(key) === parentVal) {
            tspan.setAttribute(key, value);
          }
        }
        element.setAttribute(key, value);
      };
    }
    return wrapper;
  };
  SVGRenderer2.prototype.fontMetrics = function(fontSize, elem) {
    if ((this.styledMode || !/px/.test(fontSize)) && win6.getComputedStyle) {
      fontSize = elem && SVGElement_default.prototype.getStyle.call(elem, "font-size");
    } else {
      fontSize = fontSize || elem && elem.style && elem.style.fontSize || this.style && this.style.fontSize;
    }
    if (/px/.test(fontSize)) {
      fontSize = pInt5(fontSize);
    } else {
      fontSize = 12;
    }
    var lineHeight = fontSize < 24 ? fontSize + 3 : Math.round(fontSize * 1.2), baseline = Math.round(lineHeight * 0.8);
    return {
      h: lineHeight,
      b: baseline,
      f: fontSize
    };
  };
  SVGRenderer2.prototype.rotCorr = function(baseline, rotation, alterY) {
    var y = baseline;
    if (rotation && alterY) {
      y = Math.max(y * Math.cos(rotation * deg2rad2), 4);
    }
    return {
      x: -baseline / 3 * Math.sin(rotation * deg2rad2),
      y
    };
  };
  SVGRenderer2.prototype.pathToSegments = function(path) {
    var ret = [];
    var segment = [];
    var commandLength = {
      A: 8,
      C: 7,
      H: 2,
      L: 3,
      M: 3,
      Q: 5,
      S: 5,
      T: 3,
      V: 2
    };
    for (var i = 0; i < path.length; i++) {
      if (isString5(segment[0]) && isNumber9(path[i]) && segment.length === commandLength[segment[0].toUpperCase()]) {
        path.splice(i, 0, segment[0].replace("M", "L").replace("m", "l"));
      }
      if (typeof path[i] === "string") {
        if (segment.length) {
          ret.push(segment.slice(0));
        }
        segment.length = 0;
      }
      segment.push(path[i]);
    }
    ret.push(segment.slice(0));
    return ret;
  };
  SVGRenderer2.prototype.label = function(str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {
    return new SVGLabel_default(this, str, x, y, shape, anchorX, anchorY, useHTML, baseline, className);
  };
  SVGRenderer2.prototype.alignElements = function() {
    this.alignedObjects.forEach(function(el) {
      return el.align();
    });
  };
  return SVGRenderer2;
}();
extend5(SVGRenderer.prototype, {
  Element: SVGElement_default,
  SVG_NS: SVG_NS4,
  escapes: {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    "'": "&#39;",
    '"': "&quot;"
  },
  symbols: Symbols_default,
  draw: noop2
});
RendererRegistry_default.registerRendererType("svg", SVGRenderer, true);
var SVGRenderer_default = SVGRenderer;

// node_modules/highcharts/es-modules/Core/Renderer/HTML/HTMLElement.js
var __extends2 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var isFirefox2 = Globals_default.isFirefox;
var isMS2 = Globals_default.isMS;
var isWebKit2 = Globals_default.isWebKit;
var win7 = Globals_default.win;
var css5 = Utilities_default.css;
var defined8 = Utilities_default.defined;
var extend6 = Utilities_default.extend;
var pick11 = Utilities_default.pick;
var pInt6 = Utilities_default.pInt;
var HTMLElement = function(_super) {
  __extends2(HTMLElement2, _super);
  function HTMLElement2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  HTMLElement2.compose = function(SVGElementClass) {
    if (HTMLElement2.composedClasses.indexOf(SVGElementClass) === -1) {
      HTMLElement2.composedClasses.push(SVGElementClass);
      var htmlElementProto = HTMLElement2.prototype, svgElementProto = SVGElementClass.prototype;
      svgElementProto.getSpanCorrection = htmlElementProto.getSpanCorrection;
      svgElementProto.htmlCss = htmlElementProto.htmlCss;
      svgElementProto.htmlGetBBox = htmlElementProto.htmlGetBBox;
      svgElementProto.htmlUpdateTransform = htmlElementProto.htmlUpdateTransform;
      svgElementProto.setSpanRotation = htmlElementProto.setSpanRotation;
    }
    return SVGElementClass;
  };
  HTMLElement2.prototype.getSpanCorrection = function(width, baseline, alignCorrection) {
    this.xCorr = -width * alignCorrection;
    this.yCorr = -baseline;
  };
  HTMLElement2.prototype.htmlCss = function(styles) {
    var wrapper = this, element = wrapper.element, isSettingWidth = element.tagName === "SPAN" && styles && "width" in styles, textWidth = pick11(isSettingWidth && styles.width, void 0);
    var doTransform;
    if (isSettingWidth) {
      delete styles.width;
      wrapper.textWidth = textWidth;
      doTransform = true;
    }
    if (styles && styles.textOverflow === "ellipsis") {
      styles.whiteSpace = "nowrap";
      styles.overflow = "hidden";
    }
    wrapper.styles = extend6(wrapper.styles, styles);
    css5(wrapper.element, styles);
    if (doTransform) {
      wrapper.htmlUpdateTransform();
    }
    return wrapper;
  };
  HTMLElement2.prototype.htmlGetBBox = function() {
    var wrapper = this, element = wrapper.element;
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width: element.offsetWidth,
      height: element.offsetHeight
    };
  };
  HTMLElement2.prototype.htmlUpdateTransform = function() {
    if (!this.added) {
      this.alignOnAdd = true;
      return;
    }
    var wrapper = this, renderer = wrapper.renderer, elem = wrapper.element, translateX = wrapper.translateX || 0, translateY = wrapper.translateY || 0, x = wrapper.x || 0, y = wrapper.y || 0, align = wrapper.textAlign || "left", alignCorrection = {
      left: 0,
      center: 0.5,
      right: 1
    }[align], styles = wrapper.styles, whiteSpace = styles && styles.whiteSpace;
    function getTextPxLength() {
      css5(elem, {
        width: "",
        whiteSpace: whiteSpace || "nowrap"
      });
      return elem.offsetWidth;
    }
    css5(elem, {
      marginLeft: translateX,
      marginTop: translateY
    });
    if (!renderer.styledMode && wrapper.shadows) {
      wrapper.shadows.forEach(function(shadow) {
        css5(shadow, {
          marginLeft: translateX + 1,
          marginTop: translateY + 1
        });
      });
    }
    if (wrapper.inverted) {
      [].forEach.call(elem.childNodes, function(child) {
        renderer.invertChild(child, elem);
      });
    }
    if (elem.tagName === "SPAN") {
      var rotation = wrapper.rotation, textWidth = wrapper.textWidth && pInt6(wrapper.textWidth), currentTextTransform = [
        rotation,
        align,
        elem.innerHTML,
        wrapper.textWidth,
        wrapper.textAlign
      ].join(",");
      var baseline = void 0;
      if (textWidth !== wrapper.oldTextWidth && (textWidth > wrapper.oldTextWidth || (wrapper.textPxLength || getTextPxLength()) > textWidth) && (/[ \-]/.test(elem.textContent || elem.innerText) || elem.style.textOverflow === "ellipsis")) {
        css5(elem, {
          width: textWidth + "px",
          display: "block",
          whiteSpace: whiteSpace || "normal"
        });
        wrapper.oldTextWidth = textWidth;
        wrapper.hasBoxWidthChanged = true;
      } else {
        wrapper.hasBoxWidthChanged = false;
      }
      if (currentTextTransform !== wrapper.cTT) {
        baseline = renderer.fontMetrics(elem.style.fontSize, elem).b;
        if (defined8(rotation) && (rotation !== (wrapper.oldRotation || 0) || align !== wrapper.oldAlign)) {
          wrapper.setSpanRotation(rotation, alignCorrection, baseline);
        }
        wrapper.getSpanCorrection(!defined8(rotation) && wrapper.textPxLength || elem.offsetWidth, baseline, alignCorrection, rotation, align);
      }
      css5(elem, {
        left: x + (wrapper.xCorr || 0) + "px",
        top: y + (wrapper.yCorr || 0) + "px"
      });
      wrapper.cTT = currentTextTransform;
      wrapper.oldRotation = rotation;
      wrapper.oldAlign = align;
    }
  };
  HTMLElement2.prototype.setSpanRotation = function(rotation, alignCorrection, baseline) {
    var getTransformKey = function() {
      return isMS2 && !/Edge/.test(win7.navigator.userAgent) ? "-ms-transform" : isWebKit2 ? "-webkit-transform" : isFirefox2 ? "MozTransform" : win7.opera ? "-o-transform" : void 0;
    };
    var rotationStyle = {}, cssTransformKey = getTransformKey();
    if (cssTransformKey) {
      rotationStyle[cssTransformKey] = rotationStyle.transform = "rotate(" + rotation + "deg)";
      rotationStyle[cssTransformKey + (isFirefox2 ? "Origin" : "-origin")] = rotationStyle.transformOrigin = alignCorrection * 100 + "% " + baseline + "px";
      css5(this.element, rotationStyle);
    }
  };
  HTMLElement2.composedClasses = [];
  return HTMLElement2;
}(SVGElement_default);
var HTMLElement_default = HTMLElement;

// node_modules/highcharts/es-modules/Core/Renderer/HTML/HTMLRenderer.js
var __extends3 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var attr7 = Utilities_default.attr;
var createElement5 = Utilities_default.createElement;
var extend7 = Utilities_default.extend;
var pick12 = Utilities_default.pick;
var HTMLRenderer = function(_super) {
  __extends3(HTMLRenderer2, _super);
  function HTMLRenderer2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  HTMLRenderer2.compose = function(SVGRendererClass) {
    if (HTMLRenderer2.composedClasses.indexOf(SVGRendererClass) === -1) {
      HTMLRenderer2.composedClasses.push(SVGRendererClass);
      var htmlRendererProto = HTMLRenderer2.prototype, svgRendererProto = SVGRendererClass.prototype;
      svgRendererProto.html = htmlRendererProto.html;
    }
    return SVGRendererClass;
  };
  HTMLRenderer2.prototype.html = function(str, x, y) {
    var wrapper = this.createElement("span"), element = wrapper.element, renderer = wrapper.renderer, isSVG = renderer.isSVG, addSetters = function(gWrapper, style) {
      ["opacity", "visibility"].forEach(function(prop) {
        gWrapper[prop + "Setter"] = function(value, key, elem) {
          var styleObject = gWrapper.div ? gWrapper.div.style : style;
          SVGElement_default.prototype[prop + "Setter"].call(this, value, key, elem);
          if (styleObject) {
            styleObject[key] = value;
          }
        };
      });
      gWrapper.addedSetters = true;
    };
    wrapper.textSetter = function(value) {
      if (value !== this.textStr) {
        delete this.bBox;
        delete this.oldTextWidth;
        AST_default.setElementHTML(this.element, pick12(value, ""));
        this.textStr = value;
        wrapper.doTransform = true;
      }
    };
    if (isSVG) {
      addSetters(wrapper, wrapper.element.style);
    }
    wrapper.xSetter = wrapper.ySetter = wrapper.alignSetter = wrapper.rotationSetter = function(value, key) {
      if (key === "align") {
        wrapper.alignValue = wrapper.textAlign = value;
      } else {
        wrapper[key] = value;
      }
      wrapper.doTransform = true;
    };
    wrapper.afterSetters = function() {
      if (this.doTransform) {
        this.htmlUpdateTransform();
        this.doTransform = false;
      }
    };
    wrapper.attr({
      text: str,
      x: Math.round(x),
      y: Math.round(y)
    }).css({
      position: "absolute"
    });
    if (!renderer.styledMode) {
      wrapper.css({
        fontFamily: this.style.fontFamily,
        fontSize: this.style.fontSize
      });
    }
    element.style.whiteSpace = "nowrap";
    wrapper.css = wrapper.htmlCss;
    if (isSVG) {
      wrapper.add = function(svgGroupWrapper) {
        var container = renderer.box.parentNode, parents = [];
        var htmlGroup, parentGroup;
        this.parentGroup = svgGroupWrapper;
        if (svgGroupWrapper) {
          htmlGroup = svgGroupWrapper.div;
          if (!htmlGroup) {
            parentGroup = svgGroupWrapper;
            while (parentGroup) {
              parents.push(parentGroup);
              parentGroup = parentGroup.parentGroup;
            }
            parents.reverse().forEach(function(parentGroup2) {
              var cls = attr7(parentGroup2.element, "class");
              function translateSetter(value, key) {
                parentGroup2[key] = value;
                if (key === "translateX") {
                  htmlGroupStyle.left = value + "px";
                } else {
                  htmlGroupStyle.top = value + "px";
                }
                parentGroup2.doTransform = true;
              }
              var parentGroupStyles = parentGroup2.styles || {};
              htmlGroup = parentGroup2.div = parentGroup2.div || createElement5("div", cls ? { className: cls } : void 0, {
                position: "absolute",
                left: (parentGroup2.translateX || 0) + "px",
                top: (parentGroup2.translateY || 0) + "px",
                display: parentGroup2.display,
                opacity: parentGroup2.opacity,
                cursor: parentGroupStyles.cursor,
                pointerEvents: parentGroupStyles.pointerEvents,
                visibility: parentGroup2.visibility
              }, htmlGroup || container);
              var htmlGroupStyle = htmlGroup.style;
              extend7(parentGroup2, {
                classSetter: function(htmlGroup2) {
                  return function(value) {
                    this.element.setAttribute("class", value);
                    htmlGroup2.className = value;
                  };
                }(htmlGroup),
                on: function() {
                  if (parents[0].div) {
                    wrapper.on.apply({
                      element: parents[0].div,
                      onEvents: parentGroup2.onEvents
                    }, arguments);
                  }
                  return parentGroup2;
                },
                translateXSetter: translateSetter,
                translateYSetter: translateSetter
              });
              if (!parentGroup2.addedSetters) {
                addSetters(parentGroup2);
              }
            });
          }
        } else {
          htmlGroup = container;
        }
        htmlGroup.appendChild(element);
        wrapper.added = true;
        if (wrapper.alignOnAdd) {
          wrapper.htmlUpdateTransform();
        }
        return wrapper;
      };
    }
    return wrapper;
  };
  HTMLRenderer2.composedClasses = [];
  return HTMLRenderer2;
}(SVGRenderer_default);
var HTMLRenderer_default = HTMLRenderer;

// node_modules/highcharts/es-modules/Core/Axis/AxisDefaults.js
var AxisDefaults;
(function(AxisDefaults2) {
  AxisDefaults2.defaultXAxisOptions = {
    alignTicks: true,
    allowDecimals: void 0,
    panningEnabled: true,
    zIndex: 2,
    zoomEnabled: true,
    dateTimeLabelFormats: {
      millisecond: {
        main: "%H:%M:%S.%L",
        range: false
      },
      second: {
        main: "%H:%M:%S",
        range: false
      },
      minute: {
        main: "%H:%M",
        range: false
      },
      hour: {
        main: "%H:%M",
        range: false
      },
      day: {
        main: "%e. %b"
      },
      week: {
        main: "%e. %b"
      },
      month: {
        main: "%b '%y"
      },
      year: {
        main: "%Y"
      }
    },
    endOnTick: false,
    gridLineDashStyle: "Solid",
    gridZIndex: 1,
    labels: {
      autoRotation: void 0,
      autoRotationLimit: 80,
      distance: void 0,
      enabled: true,
      indentation: 10,
      overflow: "justify",
      padding: 5,
      reserveSpace: void 0,
      rotation: void 0,
      staggerLines: 0,
      step: 0,
      useHTML: false,
      x: 0,
      zIndex: 7,
      style: {
        color: Palette_default.neutralColor60,
        cursor: "default",
        fontSize: "11px"
      }
    },
    maxPadding: 0.01,
    minorGridLineDashStyle: "Solid",
    minorTickLength: 2,
    minorTickPosition: "outside",
    minPadding: 0.01,
    offset: void 0,
    opposite: false,
    reversed: void 0,
    reversedStacks: false,
    showEmpty: true,
    showFirstLabel: true,
    showLastLabel: true,
    startOfWeek: 1,
    startOnTick: false,
    tickLength: 10,
    tickPixelInterval: 100,
    tickmarkPlacement: "between",
    tickPosition: "outside",
    title: {
      align: "middle",
      rotation: 0,
      useHTML: false,
      x: 0,
      y: 0,
      style: {
        color: Palette_default.neutralColor60
      }
    },
    type: "linear",
    uniqueNames: true,
    visible: true,
    minorGridLineColor: Palette_default.neutralColor5,
    minorGridLineWidth: 1,
    minorTickColor: Palette_default.neutralColor40,
    lineColor: Palette_default.highlightColor20,
    lineWidth: 1,
    gridLineColor: Palette_default.neutralColor10,
    gridLineWidth: void 0,
    tickColor: Palette_default.highlightColor20
  };
  AxisDefaults2.defaultYAxisOptions = {
    reversedStacks: true,
    endOnTick: true,
    maxPadding: 0.05,
    minPadding: 0.05,
    tickPixelInterval: 72,
    showLastLabel: true,
    labels: {
      x: -8
    },
    startOnTick: true,
    title: {
      rotation: 270,
      text: "Values"
    },
    stackLabels: {
      animation: {},
      allowOverlap: false,
      enabled: false,
      crop: true,
      overflow: "justify",
      formatter: function() {
        var numberFormatter = this.axis.chart.numberFormatter;
        return numberFormatter(this.total, -1);
      },
      style: {
        color: Palette_default.neutralColor100,
        fontSize: "11px",
        fontWeight: "bold",
        textOutline: "1px contrast"
      }
    },
    gridLineWidth: 1,
    lineWidth: 0
  };
  AxisDefaults2.defaultLeftAxisOptions = {
    labels: {
      x: -15
    },
    title: {
      rotation: 270
    }
  };
  AxisDefaults2.defaultRightAxisOptions = {
    labels: {
      x: 15
    },
    title: {
      rotation: 90
    }
  };
  AxisDefaults2.defaultBottomAxisOptions = {
    labels: {
      autoRotation: [-45],
      x: 0
    },
    margin: 15,
    title: {
      rotation: 0
    }
  };
  AxisDefaults2.defaultTopAxisOptions = {
    labels: {
      autoRotation: [-45],
      x: 0
    },
    margin: 15,
    title: {
      rotation: 0
    }
  };
})(AxisDefaults || (AxisDefaults = {}));
var AxisDefaults_default = AxisDefaults;

// node_modules/highcharts/es-modules/Core/Foundation.js
var addEvent4 = Utilities_default.addEvent;
var isFunction3 = Utilities_default.isFunction;
var objectEach8 = Utilities_default.objectEach;
var removeEvent3 = Utilities_default.removeEvent;
var registerEventOptions = function(component, options) {
  component.eventOptions = component.eventOptions || {};
  objectEach8(options.events, function(event, eventType) {
    if (component.eventOptions[eventType] !== event) {
      if (component.eventOptions[eventType]) {
        removeEvent3(component, eventType, component.eventOptions[eventType]);
        delete component.eventOptions[eventType];
      }
      if (isFunction3(event)) {
        component.eventOptions[eventType] = event;
        addEvent4(component, eventType, event);
      }
    }
  });
};
var exports = {
  registerEventOptions
};
var Foundation_default = exports;

// node_modules/highcharts/es-modules/Core/Axis/Tick.js
var deg2rad3 = Globals_default.deg2rad;
var clamp3 = Utilities_default.clamp;
var correctFloat2 = Utilities_default.correctFloat;
var defined9 = Utilities_default.defined;
var destroyObjectProperties3 = Utilities_default.destroyObjectProperties;
var extend8 = Utilities_default.extend;
var fireEvent3 = Utilities_default.fireEvent;
var isNumber10 = Utilities_default.isNumber;
var merge9 = Utilities_default.merge;
var objectEach9 = Utilities_default.objectEach;
var pick13 = Utilities_default.pick;
var Tick = function() {
  function Tick2(axis, pos, type, noLabel, parameters) {
    this.isNew = true;
    this.isNewLabel = true;
    this.axis = axis;
    this.pos = pos;
    this.type = type || "";
    this.parameters = parameters || {};
    this.tickmarkOffset = this.parameters.tickmarkOffset;
    this.options = this.parameters.options;
    fireEvent3(this, "init");
    if (!type && !noLabel) {
      this.addLabel();
    }
  }
  Tick2.prototype.addLabel = function() {
    var tick = this, axis = tick.axis, options = axis.options, chart = axis.chart, categories = axis.categories, log = axis.logarithmic, names = axis.names, pos = tick.pos, labelOptions = pick13(tick.options && tick.options.labels, options.labels), tickPositions = axis.tickPositions, isFirst = pos === tickPositions[0], isLast = pos === tickPositions[tickPositions.length - 1], animateLabels = (!labelOptions.step || labelOptions.step === 1) && axis.tickInterval === 1, tickPositionInfo = tickPositions.info;
    var label = tick.label, dateTimeLabelFormat, dateTimeLabelFormats, i;
    var value = this.parameters.category || (categories ? pick13(categories[pos], names[pos], pos) : pos);
    if (log && isNumber10(value)) {
      value = correctFloat2(log.lin2log(value));
    }
    if (axis.dateTime) {
      if (tickPositionInfo) {
        dateTimeLabelFormats = chart.time.resolveDTLFormat(options.dateTimeLabelFormats[!options.grid && tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName]);
        dateTimeLabelFormat = dateTimeLabelFormats.main;
      } else if (isNumber10(value)) {
        dateTimeLabelFormat = axis.dateTime.getXDateFormat(value, options.dateTimeLabelFormats || {});
      }
    }
    tick.isFirst = isFirst;
    tick.isLast = isLast;
    var ctx = {
      axis,
      chart,
      dateTimeLabelFormat,
      isFirst,
      isLast,
      pos,
      tick,
      tickPositionInfo,
      value
    };
    fireEvent3(this, "labelFormat", ctx);
    var labelFormatter = function(ctx2) {
      if (labelOptions.formatter) {
        return labelOptions.formatter.call(ctx2, ctx2);
      }
      if (labelOptions.format) {
        ctx2.text = axis.defaultLabelFormatter.call(ctx2);
        return FormatUtilities_default.format(labelOptions.format, ctx2, chart);
      }
      return axis.defaultLabelFormatter.call(ctx2, ctx2);
    };
    var str = labelFormatter.call(ctx, ctx);
    var list = dateTimeLabelFormats && dateTimeLabelFormats.list;
    if (list) {
      tick.shortenLabel = function() {
        for (i = 0; i < list.length; i++) {
          extend8(ctx, { dateTimeLabelFormat: list[i] });
          label.attr({
            text: labelFormatter.call(ctx, ctx)
          });
          if (label.getBBox().width < axis.getSlotWidth(tick) - 2 * labelOptions.padding) {
            return;
          }
        }
        label.attr({
          text: ""
        });
      };
    } else {
      tick.shortenLabel = void 0;
    }
    if (animateLabels && axis._addedPlotLB) {
      tick.moveLabel(str, labelOptions);
    }
    if (!defined9(label) && !tick.movedLabel) {
      tick.label = label = tick.createLabel({ x: 0, y: 0 }, str, labelOptions);
      tick.rotation = 0;
    } else if (label && label.textStr !== str && !animateLabels) {
      if (label.textWidth && !labelOptions.style.width && !label.styles.width) {
        label.css({ width: null });
      }
      label.attr({ text: str });
      label.textPxLength = label.getBBox().width;
    }
  };
  Tick2.prototype.createLabel = function(xy, str, labelOptions) {
    var axis = this.axis, chart = axis.chart, label = defined9(str) && labelOptions.enabled ? chart.renderer.text(str, xy.x, xy.y, labelOptions.useHTML).add(axis.labelGroup) : null;
    if (label) {
      if (!chart.styledMode) {
        label.css(merge9(labelOptions.style));
      }
      label.textPxLength = label.getBBox().width;
    }
    return label;
  };
  Tick2.prototype.destroy = function() {
    destroyObjectProperties3(this, this.axis);
  };
  Tick2.prototype.getPosition = function(horiz, tickPos, tickmarkOffset, old) {
    var axis = this.axis, chart = axis.chart, cHeight = old && chart.oldChartHeight || chart.chartHeight, pos = {
      x: horiz ? correctFloat2(axis.translate(tickPos + tickmarkOffset, null, null, old) + axis.transB) : axis.left + axis.offset + (axis.opposite ? (old && chart.oldChartWidth || chart.chartWidth) - axis.right - axis.left : 0),
      y: horiz ? cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) : correctFloat2(cHeight - axis.translate(tickPos + tickmarkOffset, null, null, old) - axis.transB)
    };
    pos.y = clamp3(pos.y, -1e5, 1e5);
    fireEvent3(this, "afterGetPosition", { pos });
    return pos;
  };
  Tick2.prototype.getLabelPosition = function(x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {
    var axis = this.axis, transA = axis.transA, reversed = axis.isLinked && axis.linkedParent ? axis.linkedParent.reversed : axis.reversed, staggerLines = axis.staggerLines, rotCorr = axis.tickRotCorr || { x: 0, y: 0 }, labelOffsetCorrection = !horiz && !axis.reserveSpaceDefault ? -axis.labelOffset * (axis.labelAlign === "center" ? 0.5 : 1) : 0, pos = {};
    var yOffset = labelOptions.y, line;
    if (!defined9(yOffset)) {
      if (axis.side === 0) {
        yOffset = label.rotation ? -8 : -label.getBBox().height;
      } else if (axis.side === 2) {
        yOffset = rotCorr.y + 8;
      } else {
        yOffset = Math.cos(label.rotation * deg2rad3) * (rotCorr.y - label.getBBox(false, 0).height / 2);
      }
    }
    x = x + labelOptions.x + labelOffsetCorrection + rotCorr.x - (tickmarkOffset && horiz ? tickmarkOffset * transA * (reversed ? -1 : 1) : 0);
    y = y + yOffset - (tickmarkOffset && !horiz ? tickmarkOffset * transA * (reversed ? 1 : -1) : 0);
    if (staggerLines) {
      line = index / (step || 1) % staggerLines;
      if (axis.opposite) {
        line = staggerLines - line - 1;
      }
      y += line * (axis.labelOffset / staggerLines);
    }
    pos.x = x;
    pos.y = Math.round(y);
    fireEvent3(this, "afterGetLabelPosition", { pos, tickmarkOffset, index });
    return pos;
  };
  Tick2.prototype.getLabelSize = function() {
    return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
  };
  Tick2.prototype.getMarkPath = function(x, y, tickLength, tickWidth, horiz, renderer) {
    return renderer.crispLine([[
      "M",
      x,
      y
    ], [
      "L",
      x + (horiz ? 0 : -tickLength),
      y + (horiz ? tickLength : 0)
    ]], tickWidth);
  };
  Tick2.prototype.handleOverflow = function(xy) {
    var tick = this, axis = this.axis, labelOptions = axis.options.labels, pxPos = xy.x, chartWidth = axis.chart.chartWidth, spacing = axis.chart.spacing, leftBound = pick13(axis.labelLeft, Math.min(axis.pos, spacing[3])), rightBound = pick13(axis.labelRight, Math.max(!axis.isRadial ? axis.pos + axis.len : 0, chartWidth - spacing[1])), label = this.label, rotation = this.rotation, factor = {
      left: 0,
      center: 0.5,
      right: 1
    }[axis.labelAlign || label.attr("align")], labelWidth = label.getBBox().width, slotWidth = axis.getSlotWidth(tick), xCorrection = factor, css16 = {};
    var modifiedSlotWidth = slotWidth, goRight = 1, leftPos, rightPos, textWidth;
    if (!rotation && labelOptions.overflow === "justify") {
      leftPos = pxPos - factor * labelWidth;
      rightPos = pxPos + (1 - factor) * labelWidth;
      if (leftPos < leftBound) {
        modifiedSlotWidth = xy.x + modifiedSlotWidth * (1 - factor) - leftBound;
      } else if (rightPos > rightBound) {
        modifiedSlotWidth = rightBound - xy.x + modifiedSlotWidth * factor;
        goRight = -1;
      }
      modifiedSlotWidth = Math.min(slotWidth, modifiedSlotWidth);
      if (modifiedSlotWidth < slotWidth && axis.labelAlign === "center") {
        xy.x += goRight * (slotWidth - modifiedSlotWidth - xCorrection * (slotWidth - Math.min(labelWidth, modifiedSlotWidth)));
      }
      if (labelWidth > modifiedSlotWidth || axis.autoRotation && (label.styles || {}).width) {
        textWidth = modifiedSlotWidth;
      }
    } else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {
      textWidth = Math.round(pxPos / Math.cos(rotation * deg2rad3) - leftBound);
    } else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {
      textWidth = Math.round((chartWidth - pxPos) / Math.cos(rotation * deg2rad3));
    }
    if (textWidth) {
      if (tick.shortenLabel) {
        tick.shortenLabel();
      } else {
        css16.width = Math.floor(textWidth) + "px";
        if (!(labelOptions.style || {}).textOverflow) {
          css16.textOverflow = "ellipsis";
        }
        label.css(css16);
      }
    }
  };
  Tick2.prototype.moveLabel = function(str, labelOptions) {
    var tick = this, label = tick.label, axis = tick.axis, reversed = axis.reversed;
    var moved = false, labelPos, xPos, yPos;
    if (label && label.textStr === str) {
      tick.movedLabel = label;
      moved = true;
      delete tick.label;
    } else {
      objectEach9(axis.ticks, function(currentTick) {
        if (!moved && !currentTick.isNew && currentTick !== tick && currentTick.label && currentTick.label.textStr === str) {
          tick.movedLabel = currentTick.label;
          moved = true;
          currentTick.labelPos = tick.movedLabel.xy;
          delete currentTick.label;
        }
      });
    }
    if (!moved && (tick.labelPos || label)) {
      labelPos = tick.labelPos || label.xy;
      xPos = axis.horiz ? reversed ? 0 : axis.width + axis.left : labelPos.x;
      yPos = axis.horiz ? labelPos.y : reversed ? axis.width + axis.left : 0;
      tick.movedLabel = tick.createLabel({ x: xPos, y: yPos }, str, labelOptions);
      if (tick.movedLabel) {
        tick.movedLabel.attr({ opacity: 0 });
      }
    }
  };
  Tick2.prototype.render = function(index, old, opacity) {
    var tick = this, axis = tick.axis, horiz = axis.horiz, pos = tick.pos, tickmarkOffset = pick13(tick.tickmarkOffset, axis.tickmarkOffset), xy = tick.getPosition(horiz, pos, tickmarkOffset, old), x = xy.x, y = xy.y, reverseCrisp = horiz && x === axis.pos + axis.len || !horiz && y === axis.pos ? -1 : 1;
    var labelOpacity = pick13(opacity, tick.label && tick.label.newOpacity, 1);
    opacity = pick13(opacity, 1);
    this.isActive = true;
    this.renderGridLine(old, opacity, reverseCrisp);
    this.renderMark(xy, opacity, reverseCrisp);
    this.renderLabel(xy, old, labelOpacity, index);
    tick.isNew = false;
    fireEvent3(this, "afterRender");
  };
  Tick2.prototype.renderGridLine = function(old, opacity, reverseCrisp) {
    var tick = this, axis = tick.axis, options = axis.options, attribs = {}, pos = tick.pos, type = tick.type, tickmarkOffset = pick13(tick.tickmarkOffset, axis.tickmarkOffset), renderer = axis.chart.renderer;
    var gridLine = tick.gridLine, gridLinePath, gridLineWidth = options.gridLineWidth, gridLineColor = options.gridLineColor, dashStyle = options.gridLineDashStyle;
    if (tick.type === "minor") {
      gridLineWidth = options.minorGridLineWidth;
      gridLineColor = options.minorGridLineColor;
      dashStyle = options.minorGridLineDashStyle;
    }
    if (!gridLine) {
      if (!axis.chart.styledMode) {
        attribs.stroke = gridLineColor;
        attribs["stroke-width"] = gridLineWidth || 0;
        attribs.dashstyle = dashStyle;
      }
      if (!type) {
        attribs.zIndex = 1;
      }
      if (old) {
        opacity = 0;
      }
      tick.gridLine = gridLine = renderer.path().attr(attribs).addClass("highcharts-" + (type ? type + "-" : "") + "grid-line").add(axis.gridGroup);
    }
    if (gridLine) {
      gridLinePath = axis.getPlotLinePath({
        value: pos + tickmarkOffset,
        lineWidth: gridLine.strokeWidth() * reverseCrisp,
        force: "pass",
        old
      });
      if (gridLinePath) {
        gridLine[old || tick.isNew ? "attr" : "animate"]({
          d: gridLinePath,
          opacity
        });
      }
    }
  };
  Tick2.prototype.renderMark = function(xy, opacity, reverseCrisp) {
    var tick = this, axis = tick.axis, options = axis.options, renderer = axis.chart.renderer, type = tick.type, tickSize = axis.tickSize(type ? type + "Tick" : "tick"), x = xy.x, y = xy.y, tickWidth = pick13(options[type !== "minor" ? "tickWidth" : "minorTickWidth"], !type && axis.isXAxis ? 1 : 0), tickColor = options[type !== "minor" ? "tickColor" : "minorTickColor"];
    var mark = tick.mark;
    var isNewMark = !mark;
    if (tickSize) {
      if (axis.opposite) {
        tickSize[0] = -tickSize[0];
      }
      if (!mark) {
        tick.mark = mark = renderer.path().addClass("highcharts-" + (type ? type + "-" : "") + "tick").add(axis.axisGroup);
        if (!axis.chart.styledMode) {
          mark.attr({
            stroke: tickColor,
            "stroke-width": tickWidth
          });
        }
      }
      mark[isNewMark ? "attr" : "animate"]({
        d: tick.getMarkPath(x, y, tickSize[0], mark.strokeWidth() * reverseCrisp, axis.horiz, renderer),
        opacity
      });
    }
  };
  Tick2.prototype.renderLabel = function(xy, old, opacity, index) {
    var tick = this, axis = tick.axis, horiz = axis.horiz, options = axis.options, label = tick.label, labelOptions = options.labels, step = labelOptions.step, tickmarkOffset = pick13(tick.tickmarkOffset, axis.tickmarkOffset), x = xy.x, y = xy.y;
    var show = true;
    if (label && isNumber10(x)) {
      label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);
      if (tick.isFirst && !tick.isLast && !options.showFirstLabel || tick.isLast && !tick.isFirst && !options.showLastLabel) {
        show = false;
      } else if (horiz && !labelOptions.step && !labelOptions.rotation && !old && opacity !== 0) {
        tick.handleOverflow(xy);
      }
      if (step && index % step) {
        show = false;
      }
      if (show && isNumber10(xy.y)) {
        xy.opacity = opacity;
        label[tick.isNewLabel ? "attr" : "animate"](xy);
        tick.isNewLabel = false;
      } else {
        label.attr("y", -9999);
        tick.isNewLabel = true;
      }
    }
  };
  Tick2.prototype.replaceMovedLabel = function() {
    var tick = this, label = tick.label, axis = tick.axis, reversed = axis.reversed;
    var x, y;
    if (label && !tick.isNew) {
      x = axis.horiz ? reversed ? axis.left : axis.width + axis.left : label.xy.x;
      y = axis.horiz ? label.xy.y : reversed ? axis.width + axis.top : axis.top;
      label.animate({ x, y, opacity: 0 }, void 0, label.destroy);
      delete tick.label;
    }
    axis.isDirty = true;
    tick.label = tick.movedLabel;
    delete tick.movedLabel;
  };
  return Tick2;
}();
var Tick_default = Tick;

// node_modules/highcharts/es-modules/Core/Axis/Axis.js
var animObject3 = AnimationUtilities_default.animObject;
var defaultOptions3 = DefaultOptions_default.defaultOptions;
var registerEventOptions2 = Foundation_default.registerEventOptions;
var deg2rad4 = Globals_default.deg2rad;
var arrayMax2 = Utilities_default.arrayMax;
var arrayMin2 = Utilities_default.arrayMin;
var clamp4 = Utilities_default.clamp;
var correctFloat3 = Utilities_default.correctFloat;
var defined10 = Utilities_default.defined;
var destroyObjectProperties4 = Utilities_default.destroyObjectProperties;
var erase3 = Utilities_default.erase;
var error4 = Utilities_default.error;
var extend9 = Utilities_default.extend;
var fireEvent4 = Utilities_default.fireEvent;
var getMagnitude2 = Utilities_default.getMagnitude;
var isArray5 = Utilities_default.isArray;
var isNumber11 = Utilities_default.isNumber;
var isString6 = Utilities_default.isString;
var merge10 = Utilities_default.merge;
var normalizeTickInterval2 = Utilities_default.normalizeTickInterval;
var objectEach10 = Utilities_default.objectEach;
var pick14 = Utilities_default.pick;
var relativeLength2 = Utilities_default.relativeLength;
var removeEvent4 = Utilities_default.removeEvent;
var splat4 = Utilities_default.splat;
var syncTimeout3 = Utilities_default.syncTimeout;
var Axis = function() {
  function Axis2(chart, userOptions) {
    this.alternateBands = void 0;
    this.bottom = void 0;
    this.categories = void 0;
    this.chart = void 0;
    this.closestPointRange = void 0;
    this.coll = void 0;
    this.eventOptions = void 0;
    this.hasNames = void 0;
    this.hasVisibleSeries = void 0;
    this.height = void 0;
    this.isLinked = void 0;
    this.labelEdge = void 0;
    this.labelFormatter = void 0;
    this.left = void 0;
    this.len = void 0;
    this.max = void 0;
    this.maxLabelLength = void 0;
    this.min = void 0;
    this.minorTickInterval = void 0;
    this.minorTicks = void 0;
    this.minPixelPadding = void 0;
    this.names = void 0;
    this.offset = void 0;
    this.options = void 0;
    this.overlap = void 0;
    this.paddedTicks = void 0;
    this.plotLinesAndBands = void 0;
    this.plotLinesAndBandsGroups = void 0;
    this.pointRange = void 0;
    this.pointRangePadding = void 0;
    this.pos = void 0;
    this.positiveValuesOnly = void 0;
    this.right = void 0;
    this.series = void 0;
    this.side = void 0;
    this.tickAmount = void 0;
    this.tickInterval = void 0;
    this.tickmarkOffset = void 0;
    this.tickPositions = void 0;
    this.tickRotCorr = void 0;
    this.ticks = void 0;
    this.top = void 0;
    this.transA = void 0;
    this.transB = void 0;
    this.translationSlope = void 0;
    this.userOptions = void 0;
    this.visible = void 0;
    this.width = void 0;
    this.zoomEnabled = void 0;
    this.init(chart, userOptions);
  }
  Axis2.prototype.init = function(chart, userOptions) {
    var isXAxis = userOptions.isX, axis = this;
    axis.chart = chart;
    axis.horiz = chart.inverted && !axis.isZAxis ? !isXAxis : isXAxis;
    axis.isXAxis = isXAxis;
    axis.coll = axis.coll || (isXAxis ? "xAxis" : "yAxis");
    fireEvent4(this, "init", { userOptions });
    axis.opposite = pick14(userOptions.opposite, axis.opposite);
    axis.side = pick14(userOptions.side, axis.side, axis.horiz ? axis.opposite ? 0 : 2 : axis.opposite ? 1 : 3);
    axis.setOptions(userOptions);
    var options = this.options, labelsOptions = options.labels, type = options.type;
    axis.userOptions = userOptions;
    axis.minPixelPadding = 0;
    axis.reversed = pick14(options.reversed, axis.reversed);
    axis.visible = options.visible;
    axis.zoomEnabled = options.zoomEnabled;
    axis.hasNames = type === "category" || options.categories === true;
    axis.categories = options.categories || axis.hasNames;
    if (!axis.names) {
      axis.names = [];
      axis.names.keys = {};
    }
    axis.plotLinesAndBandsGroups = {};
    axis.positiveValuesOnly = !!axis.logarithmic;
    axis.isLinked = defined10(options.linkedTo);
    axis.ticks = {};
    axis.labelEdge = [];
    axis.minorTicks = {};
    axis.plotLinesAndBands = [];
    axis.alternateBands = {};
    axis.len = 0;
    axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;
    axis.range = options.range;
    axis.offset = options.offset || 0;
    axis.max = null;
    axis.min = null;
    var crosshair = pick14(options.crosshair, splat4(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1]);
    axis.crosshair = crosshair === true ? {} : crosshair;
    if (chart.axes.indexOf(axis) === -1) {
      if (isXAxis) {
        chart.axes.splice(chart.xAxis.length, 0, axis);
      } else {
        chart.axes.push(axis);
      }
      chart[axis.coll].push(axis);
    }
    axis.series = axis.series || [];
    if (chart.inverted && !axis.isZAxis && isXAxis && typeof axis.reversed === "undefined") {
      axis.reversed = true;
    }
    axis.labelRotation = isNumber11(labelsOptions.rotation) ? labelsOptions.rotation : void 0;
    registerEventOptions2(axis, options);
    fireEvent4(this, "afterInit");
  };
  Axis2.prototype.setOptions = function(userOptions) {
    this.options = merge10(AxisDefaults_default.defaultXAxisOptions, this.coll === "yAxis" && AxisDefaults_default.defaultYAxisOptions, [
      AxisDefaults_default.defaultTopAxisOptions,
      AxisDefaults_default.defaultRightAxisOptions,
      AxisDefaults_default.defaultBottomAxisOptions,
      AxisDefaults_default.defaultLeftAxisOptions
    ][this.side], merge10(defaultOptions3[this.coll], userOptions));
    fireEvent4(this, "afterSetOptions", { userOptions });
  };
  Axis2.prototype.defaultLabelFormatter = function(ctx) {
    var axis = this.axis, chart = this.chart, numberFormatter = chart.numberFormatter, value = isNumber11(this.value) ? this.value : NaN, time = axis.chart.time, categories = axis.categories, dateTimeLabelFormat = this.dateTimeLabelFormat, lang2 = defaultOptions3.lang, numericSymbols = lang2.numericSymbols, numSymMagnitude = lang2.numericSymbolMagnitude || 1e3, numericSymbolDetector = axis.logarithmic ? Math.abs(value) : axis.tickInterval;
    var i = numericSymbols && numericSymbols.length, multi, ret;
    if (categories) {
      ret = "" + this.value;
    } else if (dateTimeLabelFormat) {
      ret = time.dateFormat(dateTimeLabelFormat, value);
    } else if (i && numericSymbolDetector >= 1e3) {
      while (i-- && typeof ret === "undefined") {
        multi = Math.pow(numSymMagnitude, i + 1);
        if (numericSymbolDetector >= multi && value * 10 % multi === 0 && numericSymbols[i] !== null && value !== 0) {
          ret = numberFormatter(value / multi, -1) + numericSymbols[i];
        }
      }
    }
    if (typeof ret === "undefined") {
      if (Math.abs(value) >= 1e4) {
        ret = numberFormatter(value, -1);
      } else {
        ret = numberFormatter(value, -1, void 0, "");
      }
    }
    return ret;
  };
  Axis2.prototype.getSeriesExtremes = function() {
    var axis = this, chart = axis.chart;
    var xExtremes;
    fireEvent4(this, "getSeriesExtremes", null, function() {
      axis.hasVisibleSeries = false;
      axis.dataMin = axis.dataMax = axis.threshold = null;
      axis.softThreshold = !axis.isXAxis;
      if (axis.stacking) {
        axis.stacking.buildStacks();
      }
      axis.series.forEach(function(series) {
        if (series.visible || !chart.options.chart.ignoreHiddenSeries) {
          var seriesOptions = series.options;
          var xData = void 0, threshold = seriesOptions.threshold, seriesDataMin = void 0, seriesDataMax = void 0;
          axis.hasVisibleSeries = true;
          if (axis.positiveValuesOnly && threshold <= 0) {
            threshold = null;
          }
          if (axis.isXAxis) {
            xData = series.xData;
            if (xData.length) {
              var isPositive = function(number) {
                return number > 0;
              };
              xData = axis.logarithmic ? xData.filter(axis.validatePositiveValue) : xData;
              xExtremes = series.getXExtremes(xData);
              seriesDataMin = xExtremes.min;
              seriesDataMax = xExtremes.max;
              if (!isNumber11(seriesDataMin) && !(seriesDataMin instanceof Date)) {
                xData = xData.filter(isNumber11);
                xExtremes = series.getXExtremes(xData);
                seriesDataMin = xExtremes.min;
                seriesDataMax = xExtremes.max;
              }
              if (xData.length) {
                axis.dataMin = Math.min(pick14(axis.dataMin, seriesDataMin), seriesDataMin);
                axis.dataMax = Math.max(pick14(axis.dataMax, seriesDataMax), seriesDataMax);
              }
            }
          } else {
            var dataExtremes = series.applyExtremes();
            if (isNumber11(dataExtremes.dataMin)) {
              seriesDataMin = dataExtremes.dataMin;
              axis.dataMin = Math.min(pick14(axis.dataMin, seriesDataMin), seriesDataMin);
            }
            if (isNumber11(dataExtremes.dataMax)) {
              seriesDataMax = dataExtremes.dataMax;
              axis.dataMax = Math.max(pick14(axis.dataMax, seriesDataMax), seriesDataMax);
            }
            if (defined10(threshold)) {
              axis.threshold = threshold;
            }
            if (!seriesOptions.softThreshold || axis.positiveValuesOnly) {
              axis.softThreshold = false;
            }
          }
        }
      });
    });
    fireEvent4(this, "afterGetSeriesExtremes");
  };
  Axis2.prototype.translate = function(val, backwards, cvsCoord, old, handleLog, pointPlacement) {
    var axis = this.linkedParent || this, localMin = old && axis.old ? axis.old.min : axis.min, minPixelPadding = axis.minPixelPadding, doPostTranslate = (axis.isOrdinal || axis.brokenAxis && axis.brokenAxis.hasBreaks || axis.logarithmic && handleLog) && axis.lin2val;
    var sign = 1, cvsOffset = 0, localA = old && axis.old ? axis.old.transA : axis.transA, returnValue = 0;
    if (!localA) {
      localA = axis.transA;
    }
    if (cvsCoord) {
      sign *= -1;
      cvsOffset = axis.len;
    }
    if (axis.reversed) {
      sign *= -1;
      cvsOffset -= sign * (axis.sector || axis.len);
    }
    if (backwards) {
      val = val * sign + cvsOffset;
      val -= minPixelPadding;
      returnValue = val / localA + localMin;
      if (doPostTranslate) {
        returnValue = axis.lin2val(returnValue);
      }
    } else {
      if (doPostTranslate) {
        val = axis.val2lin(val);
      }
      returnValue = isNumber11(localMin) ? sign * (val - localMin) * localA + cvsOffset + sign * minPixelPadding + (isNumber11(pointPlacement) ? localA * pointPlacement : 0) : void 0;
    }
    return returnValue;
  };
  Axis2.prototype.toPixels = function(value, paneCoordinates) {
    return this.translate(value, false, !this.horiz, null, true) + (paneCoordinates ? 0 : this.pos);
  };
  Axis2.prototype.toValue = function(pixel, paneCoordinates) {
    return this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, null, true);
  };
  Axis2.prototype.getPlotLinePath = function(options) {
    var axis = this, chart = axis.chart, axisLeft = axis.left, axisTop = axis.top, old = options.old, value = options.value, lineWidth = options.lineWidth, cHeight = old && chart.oldChartHeight || chart.chartHeight, cWidth = old && chart.oldChartWidth || chart.chartWidth, transB = axis.transB;
    var translatedValue = options.translatedValue, force = options.force, x1, y1, x2, y2, skip;
    function between(x, a, b) {
      if (force !== "pass" && x < a || x > b) {
        if (force) {
          x = clamp4(x, a, b);
        } else {
          skip = true;
        }
      }
      return x;
    }
    var evt = {
      value,
      lineWidth,
      old,
      force,
      acrossPanes: options.acrossPanes,
      translatedValue
    };
    fireEvent4(this, "getPlotLinePath", evt, function(e2) {
      translatedValue = pick14(translatedValue, axis.translate(value, null, null, old));
      translatedValue = clamp4(translatedValue, -1e5, 1e5);
      x1 = x2 = Math.round(translatedValue + transB);
      y1 = y2 = Math.round(cHeight - translatedValue - transB);
      if (!isNumber11(translatedValue)) {
        skip = true;
        force = false;
      } else if (axis.horiz) {
        y1 = axisTop;
        y2 = cHeight - axis.bottom;
        x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);
      } else {
        x1 = axisLeft;
        x2 = cWidth - axis.right;
        y1 = y2 = between(y1, axisTop, axisTop + axis.height);
      }
      e2.path = skip && !force ? null : chart.renderer.crispLine([["M", x1, y1], ["L", x2, y2]], lineWidth || 1);
    });
    return evt.path;
  };
  Axis2.prototype.getLinearTickPositions = function(tickInterval, min, max) {
    var roundedMin = correctFloat3(Math.floor(min / tickInterval) * tickInterval), roundedMax = correctFloat3(Math.ceil(max / tickInterval) * tickInterval), tickPositions = [];
    var pos, lastPos, precision;
    if (correctFloat3(roundedMin + tickInterval) === roundedMin) {
      precision = 20;
    }
    if (this.single) {
      return [min];
    }
    pos = roundedMin;
    while (pos <= roundedMax) {
      tickPositions.push(pos);
      pos = correctFloat3(pos + tickInterval, precision);
      if (pos === lastPos) {
        break;
      }
      lastPos = pos;
    }
    return tickPositions;
  };
  Axis2.prototype.getMinorTickInterval = function() {
    var options = this.options;
    if (options.minorTicks === true) {
      return pick14(options.minorTickInterval, "auto");
    }
    if (options.minorTicks === false) {
      return null;
    }
    return options.minorTickInterval;
  };
  Axis2.prototype.getMinorTickPositions = function() {
    var axis = this, options = axis.options, tickPositions = axis.tickPositions, minorTickInterval = axis.minorTickInterval, pointRangePadding = axis.pointRangePadding || 0, min = axis.min - pointRangePadding, max = axis.max + pointRangePadding, range = max - min;
    var minorTickPositions = [], pos;
    if (range && range / minorTickInterval < axis.len / 3) {
      var logarithmic_1 = axis.logarithmic;
      if (logarithmic_1) {
        this.paddedTicks.forEach(function(_pos, i, paddedTicks) {
          if (i) {
            minorTickPositions.push.apply(minorTickPositions, logarithmic_1.getLogTickPositions(minorTickInterval, paddedTicks[i - 1], paddedTicks[i], true));
          }
        });
      } else if (axis.dateTime && this.getMinorTickInterval() === "auto") {
        minorTickPositions = minorTickPositions.concat(axis.getTimeTicks(axis.dateTime.normalizeTimeTickInterval(minorTickInterval), min, max, options.startOfWeek));
      } else {
        for (pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval) {
          if (pos === minorTickPositions[0]) {
            break;
          }
          minorTickPositions.push(pos);
        }
      }
    }
    if (minorTickPositions.length !== 0) {
      axis.trimTicks(minorTickPositions);
    }
    return minorTickPositions;
  };
  Axis2.prototype.adjustForMinRange = function() {
    var axis = this, options = axis.options, log = axis.logarithmic;
    var min = axis.min, max = axis.max, zoomOffset, spaceAvailable, closestDataRange = 0, i, distance, xData, loopLength, minArgs, maxArgs, minRange;
    if (axis.isXAxis && typeof axis.minRange === "undefined" && !log) {
      if (defined10(options.min) || defined10(options.max)) {
        axis.minRange = null;
      } else {
        axis.series.forEach(function(series) {
          xData = series.xData;
          loopLength = series.xIncrement ? 1 : xData.length - 1;
          if (xData.length > 1) {
            for (i = loopLength; i > 0; i--) {
              distance = xData[i] - xData[i - 1];
              if (!closestDataRange || distance < closestDataRange) {
                closestDataRange = distance;
              }
            }
          }
        });
        axis.minRange = Math.min(closestDataRange * 5, axis.dataMax - axis.dataMin);
      }
    }
    if (max - min < axis.minRange) {
      spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange;
      minRange = axis.minRange;
      zoomOffset = (minRange - max + min) / 2;
      minArgs = [
        min - zoomOffset,
        pick14(options.min, min - zoomOffset)
      ];
      if (spaceAvailable) {
        minArgs[2] = axis.logarithmic ? axis.logarithmic.log2lin(axis.dataMin) : axis.dataMin;
      }
      min = arrayMax2(minArgs);
      maxArgs = [
        min + minRange,
        pick14(options.max, min + minRange)
      ];
      if (spaceAvailable) {
        maxArgs[2] = log ? log.log2lin(axis.dataMax) : axis.dataMax;
      }
      max = arrayMin2(maxArgs);
      if (max - min < minRange) {
        minArgs[0] = max - minRange;
        minArgs[1] = pick14(options.min, max - minRange);
        min = arrayMax2(minArgs);
      }
    }
    axis.min = min;
    axis.max = max;
  };
  Axis2.prototype.getClosest = function() {
    var ret;
    if (this.categories) {
      ret = 1;
    } else {
      this.series.forEach(function(series) {
        var seriesClosest = series.closestPointRange, visible = series.visible || !series.chart.options.chart.ignoreHiddenSeries;
        if (!series.noSharedTooltip && defined10(seriesClosest) && visible) {
          ret = defined10(ret) ? Math.min(ret, seriesClosest) : seriesClosest;
        }
      });
    }
    return ret;
  };
  Axis2.prototype.nameToX = function(point) {
    var explicitCategories = isArray5(this.categories), names = explicitCategories ? this.categories : this.names;
    var nameX = point.options.x, x;
    point.series.requireSorting = false;
    if (!defined10(nameX)) {
      nameX = this.options.uniqueNames ? explicitCategories ? names.indexOf(point.name) : pick14(names.keys[point.name], -1) : point.series.autoIncrement();
    }
    if (nameX === -1) {
      if (!explicitCategories) {
        x = names.length;
      }
    } else {
      x = nameX;
    }
    if (typeof x !== "undefined") {
      this.names[x] = point.name;
      this.names.keys[point.name] = x;
    }
    return x;
  };
  Axis2.prototype.updateNames = function() {
    var axis = this, names = this.names, i = names.length;
    if (i > 0) {
      Object.keys(names.keys).forEach(function(key) {
        delete names.keys[key];
      });
      names.length = 0;
      this.minRange = this.userMinRange;
      (this.series || []).forEach(function(series) {
        series.xIncrement = null;
        if (!series.points || series.isDirtyData) {
          axis.max = Math.max(axis.max, series.xData.length - 1);
          series.processData();
          series.generatePoints();
        }
        series.data.forEach(function(point, i2) {
          var x;
          if (point && point.options && typeof point.name !== "undefined") {
            x = axis.nameToX(point);
            if (typeof x !== "undefined" && x !== point.x) {
              point.x = x;
              series.xData[i2] = x;
            }
          }
        });
      });
    }
  };
  Axis2.prototype.setAxisTranslation = function() {
    var axis = this, range = axis.max - axis.min, linkedParent = axis.linkedParent, hasCategories = !!axis.categories, isXAxis = axis.isXAxis;
    var pointRange = axis.axisPointRange || 0, closestPointRange, minPointOffset = 0, pointRangePadding = 0, ordinalCorrection, transA = axis.transA;
    if (isXAxis || hasCategories || pointRange) {
      closestPointRange = axis.getClosest();
      if (linkedParent) {
        minPointOffset = linkedParent.minPointOffset;
        pointRangePadding = linkedParent.pointRangePadding;
      } else {
        axis.series.forEach(function(series) {
          var seriesPointRange = hasCategories ? 1 : isXAxis ? pick14(series.options.pointRange, closestPointRange, 0) : axis.axisPointRange || 0, pointPlacement = series.options.pointPlacement;
          pointRange = Math.max(pointRange, seriesPointRange);
          if (!axis.single || hasCategories) {
            var isPointPlacementAxis = series.is("xrange") ? !isXAxis : isXAxis;
            minPointOffset = Math.max(minPointOffset, isPointPlacementAxis && isString6(pointPlacement) ? 0 : seriesPointRange / 2);
            pointRangePadding = Math.max(pointRangePadding, isPointPlacementAxis && pointPlacement === "on" ? 0 : seriesPointRange);
          }
        });
      }
      ordinalCorrection = axis.ordinal && axis.ordinal.slope && closestPointRange ? axis.ordinal.slope / closestPointRange : 1;
      axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;
      axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;
      axis.pointRange = Math.min(pointRange, axis.single && hasCategories ? 1 : range);
      if (isXAxis) {
        axis.closestPointRange = closestPointRange;
      }
    }
    axis.translationSlope = axis.transA = transA = axis.staticScale || axis.len / (range + pointRangePadding || 1);
    axis.transB = axis.horiz ? axis.left : axis.bottom;
    axis.minPixelPadding = transA * minPointOffset;
    fireEvent4(this, "afterSetAxisTranslation");
  };
  Axis2.prototype.minFromRange = function() {
    var axis = this;
    return axis.max - axis.range;
  };
  Axis2.prototype.setTickInterval = function(secondPass) {
    var axis = this, chart = axis.chart, log = axis.logarithmic, options = axis.options, isXAxis = axis.isXAxis, isLinked = axis.isLinked, tickPixelIntervalOption = options.tickPixelInterval, categories = axis.categories, softThreshold = axis.softThreshold;
    var maxPadding = options.maxPadding, minPadding = options.minPadding, length, linkedParentExtremes, tickIntervalOption = options.tickInterval, threshold = isNumber11(axis.threshold) ? axis.threshold : null, thresholdMin, thresholdMax, hardMin, hardMax;
    if (!axis.dateTime && !categories && !isLinked) {
      this.getTickAmount();
    }
    hardMin = pick14(axis.userMin, options.min);
    hardMax = pick14(axis.userMax, options.max);
    if (isLinked) {
      axis.linkedParent = chart[axis.coll][options.linkedTo];
      linkedParentExtremes = axis.linkedParent.getExtremes();
      axis.min = pick14(linkedParentExtremes.min, linkedParentExtremes.dataMin);
      axis.max = pick14(linkedParentExtremes.max, linkedParentExtremes.dataMax);
      if (options.type !== axis.linkedParent.options.type) {
        error4(11, 1, chart);
      }
    } else {
      if (softThreshold && defined10(threshold)) {
        if (axis.dataMin >= threshold) {
          thresholdMin = threshold;
          minPadding = 0;
        } else if (axis.dataMax <= threshold) {
          thresholdMax = threshold;
          maxPadding = 0;
        }
      }
      axis.min = pick14(hardMin, thresholdMin, axis.dataMin);
      axis.max = pick14(hardMax, thresholdMax, axis.dataMax);
    }
    if (log) {
      if (axis.positiveValuesOnly && !secondPass && Math.min(axis.min, pick14(axis.dataMin, axis.min)) <= 0) {
        error4(10, 1, chart);
      }
      axis.min = correctFloat3(log.log2lin(axis.min), 16);
      axis.max = correctFloat3(log.log2lin(axis.max), 16);
    }
    if (axis.range && defined10(axis.max)) {
      axis.userMin = axis.min = hardMin = Math.max(axis.dataMin, axis.minFromRange());
      axis.userMax = hardMax = axis.max;
      axis.range = null;
    }
    fireEvent4(axis, "foundExtremes");
    if (axis.beforePadding) {
      axis.beforePadding();
    }
    axis.adjustForMinRange();
    if (!categories && !axis.axisPointRange && !(axis.stacking && axis.stacking.usePercentage) && !isLinked && defined10(axis.min) && defined10(axis.max)) {
      length = axis.max - axis.min;
      if (length) {
        if (!defined10(hardMin) && minPadding) {
          axis.min -= length * minPadding;
        }
        if (!defined10(hardMax) && maxPadding) {
          axis.max += length * maxPadding;
        }
      }
    }
    if (!isNumber11(axis.userMin)) {
      if (isNumber11(options.softMin) && options.softMin < axis.min) {
        axis.min = hardMin = options.softMin;
      }
      if (isNumber11(options.floor)) {
        axis.min = Math.max(axis.min, options.floor);
      }
    }
    if (!isNumber11(axis.userMax)) {
      if (isNumber11(options.softMax) && options.softMax > axis.max) {
        axis.max = hardMax = options.softMax;
      }
      if (isNumber11(options.ceiling)) {
        axis.max = Math.min(axis.max, options.ceiling);
      }
    }
    if (softThreshold && defined10(axis.dataMin)) {
      threshold = threshold || 0;
      if (!defined10(hardMin) && axis.min < threshold && axis.dataMin >= threshold) {
        axis.min = axis.options.minRange ? Math.min(threshold, axis.max - axis.minRange) : threshold;
      } else if (!defined10(hardMax) && axis.max > threshold && axis.dataMax <= threshold) {
        axis.max = axis.options.minRange ? Math.max(threshold, axis.min + axis.minRange) : threshold;
      }
    }
    if (isNumber11(axis.min) && isNumber11(axis.max) && !this.chart.polar && axis.min > axis.max) {
      if (defined10(axis.options.min)) {
        axis.max = axis.min;
      } else if (defined10(axis.options.max)) {
        axis.min = axis.max;
      }
    }
    if (axis.min === axis.max || typeof axis.min === "undefined" || typeof axis.max === "undefined") {
      axis.tickInterval = 1;
    } else if (isLinked && axis.linkedParent && !tickIntervalOption && tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {
      axis.tickInterval = tickIntervalOption = axis.linkedParent.tickInterval;
    } else {
      axis.tickInterval = pick14(tickIntervalOption, this.tickAmount ? (axis.max - axis.min) / Math.max(this.tickAmount - 1, 1) : void 0, categories ? 1 : (axis.max - axis.min) * tickPixelIntervalOption / Math.max(axis.len, tickPixelIntervalOption));
    }
    if (isXAxis && !secondPass) {
      axis.series.forEach(function(series) {
        series.forceCrop = series.forceCropping && series.forceCropping();
        series.processData(axis.min !== (axis.old && axis.old.min) || axis.max !== (axis.old && axis.old.max));
      });
      fireEvent4(this, "postProcessData");
    }
    axis.setAxisTranslation();
    fireEvent4(this, "initialAxisTranslation");
    if (axis.pointRange && !tickIntervalOption) {
      axis.tickInterval = Math.max(axis.pointRange, axis.tickInterval);
    }
    var minTickInterval = pick14(options.minTickInterval, axis.dateTime && !axis.series.some(function(s) {
      return s.noSharedTooltip;
    }) ? axis.closestPointRange : 0);
    if (!tickIntervalOption && axis.tickInterval < minTickInterval) {
      axis.tickInterval = minTickInterval;
    }
    if (!axis.dateTime && !axis.logarithmic && !tickIntervalOption) {
      axis.tickInterval = normalizeTickInterval2(axis.tickInterval, void 0, getMagnitude2(axis.tickInterval), pick14(options.allowDecimals, axis.tickInterval < 0.5 || this.tickAmount !== void 0), !!this.tickAmount);
    }
    if (!this.tickAmount) {
      axis.tickInterval = axis.unsquish();
    }
    this.setTickPositions();
  };
  Axis2.prototype.setTickPositions = function() {
    var axis = this, options = this.options, tickPositionsOption = options.tickPositions, minorTickIntervalOption = this.getMinorTickInterval(), hasVerticalPanning = this.hasVerticalPanning(), isColorAxis = this.coll === "colorAxis", startOnTick = (isColorAxis || !hasVerticalPanning) && options.startOnTick, endOnTick = (isColorAxis || !hasVerticalPanning) && options.endOnTick;
    var tickPositions, tickPositioner = options.tickPositioner;
    this.tickmarkOffset = this.categories && options.tickmarkPlacement === "between" && this.tickInterval === 1 ? 0.5 : 0;
    this.minorTickInterval = minorTickIntervalOption === "auto" && this.tickInterval ? this.tickInterval / 5 : minorTickIntervalOption;
    this.single = this.min === this.max && defined10(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || options.allowDecimals !== false);
    this.tickPositions = tickPositions = tickPositionsOption && tickPositionsOption.slice();
    if (!tickPositions) {
      if ((!axis.ordinal || !axis.ordinal.positions) && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) {
        tickPositions = [this.min, this.max];
        error4(19, false, this.chart);
      } else if (axis.dateTime) {
        tickPositions = axis.getTimeTicks(axis.dateTime.normalizeTimeTickInterval(this.tickInterval, options.units), this.min, this.max, options.startOfWeek, axis.ordinal && axis.ordinal.positions, this.closestPointRange, true);
      } else if (axis.logarithmic) {
        tickPositions = axis.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);
      } else {
        tickPositions = this.getLinearTickPositions(this.tickInterval, this.min, this.max);
      }
      if (tickPositions.length > this.len) {
        tickPositions = [tickPositions[0], tickPositions.pop()];
        if (tickPositions[0] === tickPositions[1]) {
          tickPositions.length = 1;
        }
      }
      this.tickPositions = tickPositions;
      if (tickPositioner) {
        tickPositioner = tickPositioner.apply(axis, [this.min, this.max]);
        if (tickPositioner) {
          this.tickPositions = tickPositions = tickPositioner;
        }
      }
    }
    this.paddedTicks = tickPositions.slice(0);
    this.trimTicks(tickPositions, startOnTick, endOnTick);
    if (!this.isLinked) {
      if (this.single && tickPositions.length < 2 && !this.categories && !this.series.some(function(s) {
        return s.is("heatmap") && s.options.pointPlacement === "between";
      })) {
        this.min -= 0.5;
        this.max += 0.5;
      }
      if (!tickPositionsOption && !tickPositioner) {
        this.adjustTickAmount();
      }
    }
    fireEvent4(this, "afterSetTickPositions");
  };
  Axis2.prototype.trimTicks = function(tickPositions, startOnTick, endOnTick) {
    var roundedMin = tickPositions[0], roundedMax = tickPositions[tickPositions.length - 1], minPointOffset = !this.isOrdinal && this.minPointOffset || 0;
    fireEvent4(this, "trimTicks");
    if (!this.isLinked) {
      if (startOnTick && roundedMin !== -Infinity) {
        this.min = roundedMin;
      } else {
        while (this.min - minPointOffset > tickPositions[0]) {
          tickPositions.shift();
        }
      }
      if (endOnTick) {
        this.max = roundedMax;
      } else {
        while (this.max + minPointOffset < tickPositions[tickPositions.length - 1]) {
          tickPositions.pop();
        }
      }
      if (tickPositions.length === 0 && defined10(roundedMin) && !this.options.tickPositions) {
        tickPositions.push((roundedMax + roundedMin) / 2);
      }
    }
  };
  Axis2.prototype.alignToOthers = function() {
    var axis = this, others = {}, options = axis.options;
    var hasOther;
    if (this.chart.options.chart.alignTicks !== false && options.alignTicks && options.startOnTick !== false && options.endOnTick !== false && !axis.logarithmic) {
      this.chart[this.coll].forEach(function(axis2) {
        var otherOptions = axis2.options, horiz = axis2.horiz, key = [
          horiz ? otherOptions.left : otherOptions.top,
          otherOptions.width,
          otherOptions.height,
          otherOptions.pane
        ].join(",");
        if (axis2.series.length) {
          if (others[key]) {
            hasOther = true;
          } else {
            others[key] = 1;
          }
        }
      });
    }
    return hasOther;
  };
  Axis2.prototype.getTickAmount = function() {
    var axis = this, options = this.options, tickPixelInterval = options.tickPixelInterval;
    var tickAmount = options.tickAmount;
    if (!defined10(options.tickInterval) && !tickAmount && this.len < tickPixelInterval && !this.isRadial && !axis.logarithmic && options.startOnTick && options.endOnTick) {
      tickAmount = 2;
    }
    if (!tickAmount && this.alignToOthers()) {
      tickAmount = Math.ceil(this.len / tickPixelInterval) + 1;
    }
    if (tickAmount < 4) {
      this.finalTickAmt = tickAmount;
      tickAmount = 5;
    }
    this.tickAmount = tickAmount;
  };
  Axis2.prototype.adjustTickAmount = function() {
    var axis = this, axisOptions = axis.options, tickInterval = axis.tickInterval, tickPositions = axis.tickPositions, tickAmount = axis.tickAmount, finalTickAmt = axis.finalTickAmt, currentTickAmount = tickPositions && tickPositions.length, threshold = pick14(axis.threshold, axis.softThreshold ? 0 : null);
    var len, i;
    if (axis.hasData() && isNumber11(axis.min) && isNumber11(axis.max)) {
      if (currentTickAmount < tickAmount) {
        while (tickPositions.length < tickAmount) {
          if (tickPositions.length % 2 || axis.min === threshold) {
            tickPositions.push(correctFloat3(tickPositions[tickPositions.length - 1] + tickInterval));
          } else {
            tickPositions.unshift(correctFloat3(tickPositions[0] - tickInterval));
          }
        }
        axis.transA *= (currentTickAmount - 1) / (tickAmount - 1);
        axis.min = axisOptions.startOnTick ? tickPositions[0] : Math.min(axis.min, tickPositions[0]);
        axis.max = axisOptions.endOnTick ? tickPositions[tickPositions.length - 1] : Math.max(axis.max, tickPositions[tickPositions.length - 1]);
      } else if (currentTickAmount > tickAmount) {
        axis.tickInterval *= 2;
        axis.setTickPositions();
      }
      if (defined10(finalTickAmt)) {
        i = len = tickPositions.length;
        while (i--) {
          if (finalTickAmt === 3 && i % 2 === 1 || finalTickAmt <= 2 && i > 0 && i < len - 1) {
            tickPositions.splice(i, 1);
          }
        }
        axis.finalTickAmt = void 0;
      }
    }
  };
  Axis2.prototype.setScale = function() {
    var axis = this;
    var isDirtyData = false, isXAxisDirty = false;
    axis.series.forEach(function(series) {
      isDirtyData = isDirtyData || series.isDirtyData || series.isDirty;
      isXAxisDirty = isXAxisDirty || series.xAxis && series.xAxis.isDirty || false;
    });
    axis.setAxisSize();
    var isDirtyAxisLength = axis.len !== (axis.old && axis.old.len);
    if (isDirtyAxisLength || isDirtyData || isXAxisDirty || axis.isLinked || axis.forceRedraw || axis.userMin !== (axis.old && axis.old.userMin) || axis.userMax !== (axis.old && axis.old.userMax) || axis.alignToOthers()) {
      if (axis.stacking) {
        axis.stacking.resetStacks();
      }
      axis.forceRedraw = false;
      axis.getSeriesExtremes();
      axis.setTickInterval();
      if (!axis.isDirty) {
        axis.isDirty = isDirtyAxisLength || axis.min !== (axis.old && axis.old.min) || axis.max !== (axis.old && axis.old.max);
      }
    } else if (axis.stacking) {
      axis.stacking.cleanStacks();
    }
    if (isDirtyData && axis.panningState) {
      axis.panningState.isDirty = true;
    }
    fireEvent4(this, "afterSetScale");
  };
  Axis2.prototype.setExtremes = function(newMin, newMax, redraw, animation, eventArguments) {
    var axis = this, chart = axis.chart;
    redraw = pick14(redraw, true);
    axis.series.forEach(function(serie) {
      delete serie.kdTree;
    });
    eventArguments = extend9(eventArguments, {
      min: newMin,
      max: newMax
    });
    fireEvent4(axis, "setExtremes", eventArguments, function() {
      axis.userMin = newMin;
      axis.userMax = newMax;
      axis.eventArgs = eventArguments;
      if (redraw) {
        chart.redraw(animation);
      }
    });
  };
  Axis2.prototype.zoom = function(newMin, newMax) {
    var axis = this, dataMin = this.dataMin, dataMax = this.dataMax, options = this.options, min = Math.min(dataMin, pick14(options.min, dataMin)), max = Math.max(dataMax, pick14(options.max, dataMax)), evt = {
      newMin,
      newMax
    };
    fireEvent4(this, "zoom", evt, function(e2) {
      var newMin2 = e2.newMin, newMax2 = e2.newMax;
      if (newMin2 !== axis.min || newMax2 !== axis.max) {
        if (!axis.allowZoomOutside) {
          if (defined10(dataMin)) {
            if (newMin2 < min) {
              newMin2 = min;
            }
            if (newMin2 > max) {
              newMin2 = max;
            }
          }
          if (defined10(dataMax)) {
            if (newMax2 < min) {
              newMax2 = min;
            }
            if (newMax2 > max) {
              newMax2 = max;
            }
          }
        }
        axis.displayBtn = typeof newMin2 !== "undefined" || typeof newMax2 !== "undefined";
        axis.setExtremes(newMin2, newMax2, false, void 0, { trigger: "zoom" });
      }
      e2.zoomed = true;
    });
    return evt.zoomed;
  };
  Axis2.prototype.setAxisSize = function() {
    var chart = this.chart, options = this.options, offsets = options.offsets || [0, 0, 0, 0], horiz = this.horiz, width = this.width = Math.round(relativeLength2(pick14(options.width, chart.plotWidth - offsets[3] + offsets[1]), chart.plotWidth)), height = this.height = Math.round(relativeLength2(pick14(options.height, chart.plotHeight - offsets[0] + offsets[2]), chart.plotHeight)), top = this.top = Math.round(relativeLength2(pick14(options.top, chart.plotTop + offsets[0]), chart.plotHeight, chart.plotTop)), left = this.left = Math.round(relativeLength2(pick14(options.left, chart.plotLeft + offsets[3]), chart.plotWidth, chart.plotLeft));
    this.bottom = chart.chartHeight - height - top;
    this.right = chart.chartWidth - width - left;
    this.len = Math.max(horiz ? width : height, 0);
    this.pos = horiz ? left : top;
  };
  Axis2.prototype.getExtremes = function() {
    var axis = this, log = axis.logarithmic;
    return {
      min: log ? correctFloat3(log.lin2log(axis.min)) : axis.min,
      max: log ? correctFloat3(log.lin2log(axis.max)) : axis.max,
      dataMin: axis.dataMin,
      dataMax: axis.dataMax,
      userMin: axis.userMin,
      userMax: axis.userMax
    };
  };
  Axis2.prototype.getThreshold = function(threshold) {
    var axis = this, log = axis.logarithmic, realMin = log ? log.lin2log(axis.min) : axis.min, realMax = log ? log.lin2log(axis.max) : axis.max;
    if (threshold === null || threshold === -Infinity) {
      threshold = realMin;
    } else if (threshold === Infinity) {
      threshold = realMax;
    } else if (realMin > threshold) {
      threshold = realMin;
    } else if (realMax < threshold) {
      threshold = realMax;
    }
    return axis.translate(threshold, 0, 1, 0, 1);
  };
  Axis2.prototype.autoLabelAlign = function(rotation) {
    var angle = (pick14(rotation, 0) - this.side * 90 + 720) % 360, evt = { align: "center" };
    fireEvent4(this, "autoLabelAlign", evt, function(e2) {
      if (angle > 15 && angle < 165) {
        e2.align = "right";
      } else if (angle > 195 && angle < 345) {
        e2.align = "left";
      }
    });
    return evt.align;
  };
  Axis2.prototype.tickSize = function(prefix) {
    var options = this.options, tickWidth = pick14(options[prefix === "tick" ? "tickWidth" : "minorTickWidth"], prefix === "tick" && this.isXAxis && !this.categories ? 1 : 0);
    var tickLength = options[prefix === "tick" ? "tickLength" : "minorTickLength"], tickSize;
    if (tickWidth && tickLength) {
      if (options[prefix + "Position"] === "inside") {
        tickLength = -tickLength;
      }
      tickSize = [tickLength, tickWidth];
    }
    var e2 = { tickSize };
    fireEvent4(this, "afterTickSize", e2);
    return e2.tickSize;
  };
  Axis2.prototype.labelMetrics = function() {
    var index = this.tickPositions && this.tickPositions[0] || 0;
    return this.chart.renderer.fontMetrics(this.options.labels.style.fontSize, this.ticks[index] && this.ticks[index].label);
  };
  Axis2.prototype.unsquish = function() {
    var labelOptions = this.options.labels, horiz = this.horiz, tickInterval = this.tickInterval, slotSize = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / tickInterval), rotationOption = labelOptions.rotation, labelMetrics = this.labelMetrics(), range = Math.max(this.max - this.min, 0), getStep = function(spaceNeeded) {
      var step2 = spaceNeeded / (slotSize || 1);
      step2 = step2 > 1 ? Math.ceil(step2) : 1;
      if (step2 * tickInterval > range && spaceNeeded !== Infinity && slotSize !== Infinity && range) {
        step2 = Math.ceil(range / tickInterval);
      }
      return correctFloat3(step2 * tickInterval);
    };
    var newTickInterval = tickInterval, rotation, step, bestScore = Number.MAX_VALUE, autoRotation;
    if (horiz) {
      if (!labelOptions.staggerLines && !labelOptions.step) {
        if (isNumber11(rotationOption)) {
          autoRotation = [rotationOption];
        } else if (slotSize < labelOptions.autoRotationLimit) {
          autoRotation = labelOptions.autoRotation;
        }
      }
      if (autoRotation) {
        autoRotation.forEach(function(rot) {
          var score;
          if (rot === rotationOption || rot && rot >= -90 && rot <= 90) {
            step = getStep(Math.abs(labelMetrics.h / Math.sin(deg2rad4 * rot)));
            score = step + Math.abs(rot / 360);
            if (score < bestScore) {
              bestScore = score;
              rotation = rot;
              newTickInterval = step;
            }
          }
        });
      }
    } else if (!labelOptions.step) {
      newTickInterval = getStep(labelMetrics.h);
    }
    this.autoRotation = autoRotation;
    this.labelRotation = pick14(rotation, isNumber11(rotationOption) ? rotationOption : 0);
    return newTickInterval;
  };
  Axis2.prototype.getSlotWidth = function(tick) {
    var chart = this.chart, horiz = this.horiz, labelOptions = this.options.labels, slotCount = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1), marginLeft = chart.margin[3];
    if (tick && isNumber11(tick.slotWidth)) {
      return tick.slotWidth;
    }
    if (horiz && labelOptions.step < 2) {
      if (labelOptions.rotation) {
        return 0;
      }
      return (this.staggerLines || 1) * this.len / slotCount;
    }
    if (!horiz) {
      var cssWidth = labelOptions.style.width;
      if (cssWidth !== void 0) {
        return parseInt(String(cssWidth), 10);
      }
      if (marginLeft) {
        return marginLeft - chart.spacing[3];
      }
    }
    return chart.chartWidth * 0.33;
  };
  Axis2.prototype.renderUnsquish = function() {
    var chart = this.chart, renderer = chart.renderer, tickPositions = this.tickPositions, ticks = this.ticks, labelOptions = this.options.labels, labelStyleOptions = labelOptions.style, horiz = this.horiz, slotWidth = this.getSlotWidth(), innerWidth = Math.max(1, Math.round(slotWidth - 2 * labelOptions.padding)), attr10 = {}, labelMetrics = this.labelMetrics(), textOverflowOption = labelStyleOptions.textOverflow;
    var commonWidth, commonTextOverflow, maxLabelLength = 0, label, i, pos;
    if (!isString6(labelOptions.rotation)) {
      attr10.rotation = labelOptions.rotation || 0;
    }
    tickPositions.forEach(function(tickPosition) {
      var tick = ticks[tickPosition];
      if (tick.movedLabel) {
        tick.replaceMovedLabel();
      }
      if (tick && tick.label && tick.label.textPxLength > maxLabelLength) {
        maxLabelLength = tick.label.textPxLength;
      }
    });
    this.maxLabelLength = maxLabelLength;
    if (this.autoRotation) {
      if (maxLabelLength > innerWidth && maxLabelLength > labelMetrics.h) {
        attr10.rotation = this.labelRotation;
      } else {
        this.labelRotation = 0;
      }
    } else if (slotWidth) {
      commonWidth = innerWidth;
      if (!textOverflowOption) {
        commonTextOverflow = "clip";
        i = tickPositions.length;
        while (!horiz && i--) {
          pos = tickPositions[i];
          label = ticks[pos].label;
          if (label) {
            if (label.styles && label.styles.textOverflow === "ellipsis") {
              label.css({ textOverflow: "clip" });
            } else if (label.textPxLength > slotWidth) {
              label.css({ width: slotWidth + "px" });
            }
            if (label.getBBox().height > this.len / tickPositions.length - (labelMetrics.h - labelMetrics.f)) {
              label.specificTextOverflow = "ellipsis";
            }
          }
        }
      }
    }
    if (attr10.rotation) {
      commonWidth = maxLabelLength > chart.chartHeight * 0.5 ? chart.chartHeight * 0.33 : maxLabelLength;
      if (!textOverflowOption) {
        commonTextOverflow = "ellipsis";
      }
    }
    this.labelAlign = labelOptions.align || this.autoLabelAlign(this.labelRotation);
    if (this.labelAlign) {
      attr10.align = this.labelAlign;
    }
    tickPositions.forEach(function(pos2) {
      var tick = ticks[pos2], label2 = tick && tick.label, widthOption = labelStyleOptions.width, css16 = {};
      if (label2) {
        label2.attr(attr10);
        if (tick.shortenLabel) {
          tick.shortenLabel();
        } else if (commonWidth && !widthOption && labelStyleOptions.whiteSpace !== "nowrap" && (commonWidth < label2.textPxLength || label2.element.tagName === "SPAN")) {
          css16.width = commonWidth + "px";
          if (!textOverflowOption) {
            css16.textOverflow = label2.specificTextOverflow || commonTextOverflow;
          }
          label2.css(css16);
        } else if (label2.styles && label2.styles.width && !css16.width && !widthOption) {
          label2.css({ width: null });
        }
        delete label2.specificTextOverflow;
        tick.rotation = attr10.rotation;
      }
    }, this);
    this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side !== 0);
  };
  Axis2.prototype.hasData = function() {
    return this.series.some(function(s) {
      return s.hasData();
    }) || this.options.showEmpty && defined10(this.min) && defined10(this.max);
  };
  Axis2.prototype.addTitle = function(display) {
    var axis = this, renderer = axis.chart.renderer, horiz = axis.horiz, opposite = axis.opposite, options = axis.options, axisTitleOptions = options.title, styledMode = axis.chart.styledMode;
    var textAlign;
    if (!axis.axisTitle) {
      textAlign = axisTitleOptions.textAlign;
      if (!textAlign) {
        textAlign = (horiz ? {
          low: "left",
          middle: "center",
          high: "right"
        } : {
          low: opposite ? "right" : "left",
          middle: "center",
          high: opposite ? "left" : "right"
        })[axisTitleOptions.align];
      }
      axis.axisTitle = renderer.text(axisTitleOptions.text || "", 0, 0, axisTitleOptions.useHTML).attr({
        zIndex: 7,
        rotation: axisTitleOptions.rotation,
        align: textAlign
      }).addClass("highcharts-axis-title");
      if (!styledMode) {
        axis.axisTitle.css(merge10(axisTitleOptions.style));
      }
      axis.axisTitle.add(axis.axisGroup);
      axis.axisTitle.isNew = true;
    }
    if (!styledMode && !axisTitleOptions.style.width && !axis.isRadial) {
      axis.axisTitle.css({
        width: axis.len + "px"
      });
    }
    axis.axisTitle[display ? "show" : "hide"](display);
  };
  Axis2.prototype.generateTick = function(pos) {
    var axis = this, ticks = axis.ticks;
    if (!ticks[pos]) {
      ticks[pos] = new Tick_default(axis, pos);
    } else {
      ticks[pos].addLabel();
    }
  };
  Axis2.prototype.getOffset = function() {
    var _this = this;
    var axis = this, chart = axis.chart, renderer = chart.renderer, options = axis.options, tickPositions = axis.tickPositions, ticks = axis.ticks, horiz = axis.horiz, side = axis.side, invertedSide = chart.inverted && !axis.isZAxis ? [1, 0, 3, 2][side] : side, hasData = axis.hasData(), axisTitleOptions = options.title, labelOptions = options.labels, axisOffset = chart.axisOffset, clipOffset = chart.clipOffset, directionFactor = [-1, 1, 1, -1][side], className = options.className, axisParent = axis.axisParent;
    var showAxis, titleOffset = 0, titleOffsetOption, titleMargin = 0, labelOffset = 0, labelOffsetPadded, lineHeightCorrection;
    axis.showAxis = showAxis = hasData || options.showEmpty;
    axis.staggerLines = axis.horiz && labelOptions.staggerLines || void 0;
    if (!axis.axisGroup) {
      var createGroup = function(name, suffix, zIndex) {
        return renderer.g(name).attr({ zIndex }).addClass("highcharts-" + _this.coll.toLowerCase() + suffix + " " + (_this.isRadial ? "highcharts-radial-axis" + suffix + " " : "") + (className || "")).add(axisParent);
      };
      axis.gridGroup = createGroup("grid", "-grid", options.gridZIndex);
      axis.axisGroup = createGroup("axis", "", options.zIndex);
      axis.labelGroup = createGroup("axis-labels", "-labels", labelOptions.zIndex);
    }
    if (hasData || axis.isLinked) {
      tickPositions.forEach(function(pos) {
        axis.generateTick(pos);
      });
      axis.renderUnsquish();
      axis.reserveSpaceDefault = side === 0 || side === 2 || { 1: "left", 3: "right" }[side] === axis.labelAlign;
      if (pick14(labelOptions.reserveSpace, axis.labelAlign === "center" ? true : null, axis.reserveSpaceDefault)) {
        tickPositions.forEach(function(pos) {
          labelOffset = Math.max(ticks[pos].getLabelSize(), labelOffset);
        });
      }
      if (axis.staggerLines) {
        labelOffset *= axis.staggerLines;
      }
      axis.labelOffset = labelOffset * (axis.opposite ? -1 : 1);
    } else {
      objectEach10(ticks, function(tick, n) {
        tick.destroy();
        delete ticks[n];
      });
    }
    if (axisTitleOptions && axisTitleOptions.text && axisTitleOptions.enabled !== false) {
      axis.addTitle(showAxis);
      if (showAxis && axisTitleOptions.reserveSpace !== false) {
        axis.titleOffset = titleOffset = axis.axisTitle.getBBox()[horiz ? "height" : "width"];
        titleOffsetOption = axisTitleOptions.offset;
        titleMargin = defined10(titleOffsetOption) ? 0 : pick14(axisTitleOptions.margin, horiz ? 5 : 10);
      }
    }
    axis.renderLine();
    axis.offset = directionFactor * pick14(options.offset, axisOffset[side] ? axisOffset[side] + (options.margin || 0) : 0);
    axis.tickRotCorr = axis.tickRotCorr || { x: 0, y: 0 };
    if (side === 0) {
      lineHeightCorrection = -axis.labelMetrics().h;
    } else if (side === 2) {
      lineHeightCorrection = axis.tickRotCorr.y;
    } else {
      lineHeightCorrection = 0;
    }
    labelOffsetPadded = Math.abs(labelOffset) + titleMargin;
    if (labelOffset) {
      labelOffsetPadded -= lineHeightCorrection;
      labelOffsetPadded += directionFactor * (horiz ? pick14(labelOptions.y, axis.tickRotCorr.y + directionFactor * 8) : labelOptions.x);
    }
    axis.axisTitleMargin = pick14(titleOffsetOption, labelOffsetPadded);
    if (axis.getMaxLabelDimensions) {
      axis.maxLabelDimensions = axis.getMaxLabelDimensions(ticks, tickPositions);
    }
    var tickSize = this.tickSize("tick");
    axisOffset[side] = Math.max(axisOffset[side], (axis.axisTitleMargin || 0) + titleOffset + directionFactor * axis.offset, labelOffsetPadded, tickPositions && tickPositions.length && tickSize ? tickSize[0] + directionFactor * axis.offset : 0);
    var clip = options.offset ? 0 : Math.floor(axis.axisLine.strokeWidth() / 2) * 2;
    clipOffset[invertedSide] = Math.max(clipOffset[invertedSide], clip);
    fireEvent4(this, "afterGetOffset");
  };
  Axis2.prototype.getLinePath = function(lineWidth) {
    var chart = this.chart, opposite = this.opposite, offset3 = this.offset, horiz = this.horiz, lineLeft = this.left + (opposite ? this.width : 0) + offset3, lineTop = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + offset3;
    if (opposite) {
      lineWidth *= -1;
    }
    return chart.renderer.crispLine([
      [
        "M",
        horiz ? this.left : lineLeft,
        horiz ? lineTop : this.top
      ],
      [
        "L",
        horiz ? chart.chartWidth - this.right : lineLeft,
        horiz ? lineTop : chart.chartHeight - this.bottom
      ]
    ], lineWidth);
  };
  Axis2.prototype.renderLine = function() {
    if (!this.axisLine) {
      this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup);
      if (!this.chart.styledMode) {
        this.axisLine.attr({
          stroke: this.options.lineColor,
          "stroke-width": this.options.lineWidth,
          zIndex: 7
        });
      }
    }
  };
  Axis2.prototype.getTitlePosition = function() {
    var horiz = this.horiz, axisLeft = this.left, axisTop = this.top, axisLength = this.len, axisTitleOptions = this.options.title, margin = horiz ? axisLeft : axisTop, opposite = this.opposite, offset3 = this.offset, xOption = axisTitleOptions.x, yOption = axisTitleOptions.y, axisTitle = this.axisTitle, fontMetrics = this.chart.renderer.fontMetrics(axisTitleOptions.style.fontSize, axisTitle), textHeightOvershoot = Math.max(axisTitle.getBBox(null, 0).height - fontMetrics.h - 1, 0), alongAxis = {
      low: margin + (horiz ? 0 : axisLength),
      middle: margin + axisLength / 2,
      high: margin + (horiz ? axisLength : 0)
    }[axisTitleOptions.align], offAxis = (horiz ? axisTop + this.height : axisLeft) + (horiz ? 1 : -1) * (opposite ? -1 : 1) * this.axisTitleMargin + [
      -textHeightOvershoot,
      textHeightOvershoot,
      fontMetrics.f,
      -textHeightOvershoot
    ][this.side], titlePosition = {
      x: horiz ? alongAxis + xOption : offAxis + (opposite ? this.width : 0) + offset3 + xOption,
      y: horiz ? offAxis + yOption - (opposite ? this.height : 0) + offset3 : alongAxis + yOption
    };
    fireEvent4(this, "afterGetTitlePosition", { titlePosition });
    return titlePosition;
  };
  Axis2.prototype.renderMinorTick = function(pos, slideIn) {
    var axis = this;
    var minorTicks = axis.minorTicks;
    if (!minorTicks[pos]) {
      minorTicks[pos] = new Tick_default(axis, pos, "minor");
    }
    if (slideIn && minorTicks[pos].isNew) {
      minorTicks[pos].render(null, true);
    }
    minorTicks[pos].render(null, false, 1);
  };
  Axis2.prototype.renderTick = function(pos, i, slideIn) {
    var axis = this, isLinked = axis.isLinked, ticks = axis.ticks;
    if (!isLinked || pos >= axis.min && pos <= axis.max || axis.grid && axis.grid.isColumn) {
      if (!ticks[pos]) {
        ticks[pos] = new Tick_default(axis, pos);
      }
      if (slideIn && ticks[pos].isNew) {
        ticks[pos].render(i, true, -1);
      }
      ticks[pos].render(i);
    }
  };
  Axis2.prototype.render = function() {
    var axis = this, chart = axis.chart, log = axis.logarithmic, renderer = chart.renderer, options = axis.options, isLinked = axis.isLinked, tickPositions = axis.tickPositions, axisTitle = axis.axisTitle, ticks = axis.ticks, minorTicks = axis.minorTicks, alternateBands = axis.alternateBands, stackLabelOptions = options.stackLabels, alternateGridColor = options.alternateGridColor, tickmarkOffset = axis.tickmarkOffset, axisLine = axis.axisLine, showAxis = axis.showAxis, animation = animObject3(renderer.globalAnimation);
    var from, to;
    axis.labelEdge.length = 0;
    axis.overlap = false;
    [ticks, minorTicks, alternateBands].forEach(function(coll) {
      objectEach10(coll, function(tick) {
        tick.isActive = false;
      });
    });
    if (axis.hasData() || isLinked) {
      var slideInTicks_1 = axis.chart.hasRendered && axis.old && isNumber11(axis.old.min);
      if (axis.minorTickInterval && !axis.categories) {
        axis.getMinorTickPositions().forEach(function(pos) {
          axis.renderMinorTick(pos, slideInTicks_1);
        });
      }
      if (tickPositions.length) {
        tickPositions.forEach(function(pos, i) {
          axis.renderTick(pos, i, slideInTicks_1);
        });
        if (tickmarkOffset && (axis.min === 0 || axis.single)) {
          if (!ticks[-1]) {
            ticks[-1] = new Tick_default(axis, -1, null, true);
          }
          ticks[-1].render(-1);
        }
      }
      if (alternateGridColor) {
        tickPositions.forEach(function(pos, i) {
          to = typeof tickPositions[i + 1] !== "undefined" ? tickPositions[i + 1] + tickmarkOffset : axis.max - tickmarkOffset;
          if (i % 2 === 0 && pos < axis.max && to <= axis.max + (chart.polar ? -tickmarkOffset : tickmarkOffset)) {
            if (!alternateBands[pos]) {
              alternateBands[pos] = new Globals_default.PlotLineOrBand(axis);
            }
            from = pos + tickmarkOffset;
            alternateBands[pos].options = {
              from: log ? log.lin2log(from) : from,
              to: log ? log.lin2log(to) : to,
              color: alternateGridColor,
              className: "highcharts-alternate-grid"
            };
            alternateBands[pos].render();
            alternateBands[pos].isActive = true;
          }
        });
      }
      if (!axis._addedPlotLB) {
        axis._addedPlotLB = true;
        (options.plotLines || []).concat(options.plotBands || []).forEach(function(plotLineOptions) {
          axis.addPlotBandOrLine(plotLineOptions);
        });
      }
    }
    [ticks, minorTicks, alternateBands].forEach(function(coll) {
      var forDestruction = [], delay = animation.duration, destroyInactiveItems = function() {
        var i = forDestruction.length;
        while (i--) {
          if (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {
            coll[forDestruction[i]].destroy();
            delete coll[forDestruction[i]];
          }
        }
      };
      objectEach10(coll, function(tick, pos) {
        if (!tick.isActive) {
          tick.render(pos, false, 0);
          tick.isActive = false;
          forDestruction.push(pos);
        }
      });
      syncTimeout3(destroyInactiveItems, coll === alternateBands || !chart.hasRendered || !delay ? 0 : delay);
    });
    if (axisLine) {
      axisLine[axisLine.isPlaced ? "animate" : "attr"]({
        d: this.getLinePath(axisLine.strokeWidth())
      });
      axisLine.isPlaced = true;
      axisLine[showAxis ? "show" : "hide"](showAxis);
    }
    if (axisTitle && showAxis) {
      var titleXy = axis.getTitlePosition();
      if (isNumber11(titleXy.y)) {
        axisTitle[axisTitle.isNew ? "attr" : "animate"](titleXy);
        axisTitle.isNew = false;
      } else {
        axisTitle.attr("y", -9999);
        axisTitle.isNew = true;
      }
    }
    if (stackLabelOptions && stackLabelOptions.enabled && axis.stacking) {
      axis.stacking.renderStackTotals();
    }
    axis.old = {
      len: axis.len,
      max: axis.max,
      min: axis.min,
      transA: axis.transA,
      userMax: axis.userMax,
      userMin: axis.userMin
    };
    axis.isDirty = false;
    fireEvent4(this, "afterRender");
  };
  Axis2.prototype.redraw = function() {
    if (this.visible) {
      this.render();
      this.plotLinesAndBands.forEach(function(plotLine) {
        plotLine.render();
      });
    }
    this.series.forEach(function(series) {
      series.isDirty = true;
    });
  };
  Axis2.prototype.getKeepProps = function() {
    return this.keepProps || Axis2.keepProps;
  };
  Axis2.prototype.destroy = function(keepEvents) {
    var axis = this, plotLinesAndBands = axis.plotLinesAndBands, eventOptions = this.eventOptions;
    fireEvent4(this, "destroy", { keepEvents });
    if (!keepEvents) {
      removeEvent4(axis);
    }
    [axis.ticks, axis.minorTicks, axis.alternateBands].forEach(function(coll) {
      destroyObjectProperties4(coll);
    });
    if (plotLinesAndBands) {
      var i = plotLinesAndBands.length;
      while (i--) {
        plotLinesAndBands[i].destroy();
      }
    }
    [
      "axisLine",
      "axisTitle",
      "axisGroup",
      "gridGroup",
      "labelGroup",
      "cross",
      "scrollbar"
    ].forEach(function(prop) {
      if (axis[prop]) {
        axis[prop] = axis[prop].destroy();
      }
    });
    for (var plotGroup in axis.plotLinesAndBandsGroups) {
      axis.plotLinesAndBandsGroups[plotGroup] = axis.plotLinesAndBandsGroups[plotGroup].destroy();
    }
    objectEach10(axis, function(val, key) {
      if (axis.getKeepProps().indexOf(key) === -1) {
        delete axis[key];
      }
    });
    this.eventOptions = eventOptions;
  };
  Axis2.prototype.drawCrosshair = function(e2, point) {
    var options = this.crosshair, snap = pick14(options && options.snap, true), chart = this.chart;
    var path, pos, categorized, graphic = this.cross, crossOptions;
    fireEvent4(this, "drawCrosshair", { e: e2, point });
    if (!e2) {
      e2 = this.cross && this.cross.e;
    }
    if (!options || (defined10(point) || !snap) === false) {
      this.hideCrosshair();
    } else {
      if (!snap) {
        pos = e2 && (this.horiz ? e2.chartX - this.pos : this.len - e2.chartY + this.pos);
      } else if (defined10(point)) {
        pos = pick14(this.coll !== "colorAxis" ? point.crosshairPos : null, this.isXAxis ? point.plotX : this.len - point.plotY);
      }
      if (defined10(pos)) {
        crossOptions = {
          value: point && (this.isXAxis ? point.x : pick14(point.stackY, point.y)),
          translatedValue: pos
        };
        if (chart.polar) {
          extend9(crossOptions, {
            isCrosshair: true,
            chartX: e2 && e2.chartX,
            chartY: e2 && e2.chartY,
            point
          });
        }
        path = this.getPlotLinePath(crossOptions) || null;
      }
      if (!defined10(path)) {
        this.hideCrosshair();
        return;
      }
      categorized = this.categories && !this.isRadial;
      if (!graphic) {
        this.cross = graphic = chart.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (categorized ? "category " : "thin ") + (options.className || "")).attr({
          zIndex: pick14(options.zIndex, 2)
        }).add();
        if (!chart.styledMode) {
          graphic.attr({
            stroke: options.color || (categorized ? Color_default.parse(Palette_default.highlightColor20).setOpacity(0.25).get() : Palette_default.neutralColor20),
            "stroke-width": pick14(options.width, 1)
          }).css({
            "pointer-events": "none"
          });
          if (options.dashStyle) {
            graphic.attr({
              dashstyle: options.dashStyle
            });
          }
        }
      }
      graphic.show().attr({
        d: path
      });
      if (categorized && !options.width) {
        graphic.attr({
          "stroke-width": this.transA
        });
      }
      this.cross.e = e2;
    }
    fireEvent4(this, "afterDrawCrosshair", { e: e2, point });
  };
  Axis2.prototype.hideCrosshair = function() {
    if (this.cross) {
      this.cross.hide();
    }
    fireEvent4(this, "afterHideCrosshair");
  };
  Axis2.prototype.hasVerticalPanning = function() {
    var panningOptions = this.chart.options.chart.panning;
    return Boolean(panningOptions && panningOptions.enabled && /y/.test(panningOptions.type));
  };
  Axis2.prototype.validatePositiveValue = function(value) {
    return isNumber11(value) && value > 0;
  };
  Axis2.prototype.update = function(options, redraw) {
    var chart = this.chart;
    options = merge10(this.userOptions, options);
    this.destroy(true);
    this.init(chart, options);
    chart.isDirtyBox = true;
    if (pick14(redraw, true)) {
      chart.redraw();
    }
  };
  Axis2.prototype.remove = function(redraw) {
    var chart = this.chart, key = this.coll, axisSeries = this.series;
    var i = axisSeries.length;
    while (i--) {
      if (axisSeries[i]) {
        axisSeries[i].remove(false);
      }
    }
    erase3(chart.axes, this);
    erase3(chart[key], this);
    chart[key].forEach(function(axis, i2) {
      axis.options.index = axis.userOptions.index = i2;
    });
    this.destroy();
    chart.isDirtyBox = true;
    if (pick14(redraw, true)) {
      chart.redraw();
    }
  };
  Axis2.prototype.setTitle = function(titleOptions, redraw) {
    this.update({ title: titleOptions }, redraw);
  };
  Axis2.prototype.setCategories = function(categories, redraw) {
    this.update({ categories }, redraw);
  };
  Axis2.defaultOptions = AxisDefaults_default.defaultXAxisOptions;
  Axis2.keepProps = ["extKey", "hcEvents", "names", "series", "userMax", "userMin"];
  return Axis2;
}();
var Axis_default = Axis;

// node_modules/highcharts/es-modules/Core/Axis/DateTimeAxis.js
var addEvent5 = Utilities_default.addEvent;
var getMagnitude3 = Utilities_default.getMagnitude;
var normalizeTickInterval3 = Utilities_default.normalizeTickInterval;
var timeUnits3 = Utilities_default.timeUnits;
var DateTimeAxis;
(function(DateTimeAxis2) {
  var composedClasses2 = [];
  function compose(AxisClass) {
    if (composedClasses2.indexOf(AxisClass) === -1) {
      composedClasses2.push(AxisClass);
      AxisClass.keepProps.push("dateTime");
      var axisProto = AxisClass.prototype;
      axisProto.getTimeTicks = getTimeTicks;
      addEvent5(AxisClass, "init", onInit);
    }
    return AxisClass;
  }
  DateTimeAxis2.compose = compose;
  function getTimeTicks() {
    return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
  }
  function onInit(e2) {
    var axis = this;
    var options = e2.userOptions;
    if (options.type !== "datetime") {
      axis.dateTime = void 0;
      return;
    }
    if (!axis.dateTime) {
      axis.dateTime = new Additions(axis);
    }
  }
  var Additions = function() {
    function Additions2(axis) {
      this.axis = axis;
    }
    Additions2.prototype.normalizeTimeTickInterval = function(tickInterval, unitsOption) {
      var units = unitsOption || [[
        "millisecond",
        [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]
      ], [
        "second",
        [1, 2, 5, 10, 15, 30]
      ], [
        "minute",
        [1, 2, 5, 10, 15, 30]
      ], [
        "hour",
        [1, 2, 3, 4, 6, 8, 12]
      ], [
        "day",
        [1, 2]
      ], [
        "week",
        [1, 2]
      ], [
        "month",
        [1, 2, 3, 4, 6]
      ], [
        "year",
        null
      ]];
      var unit = units[units.length - 1], interval = timeUnits3[unit[0]], multiples = unit[1], i;
      for (i = 0; i < units.length; i++) {
        unit = units[i];
        interval = timeUnits3[unit[0]];
        multiples = unit[1];
        if (units[i + 1]) {
          var lessThan = (interval * multiples[multiples.length - 1] + timeUnits3[units[i + 1][0]]) / 2;
          if (tickInterval <= lessThan) {
            break;
          }
        }
      }
      if (interval === timeUnits3.year && tickInterval < 5 * interval) {
        multiples = [1, 2, 5];
      }
      var count = normalizeTickInterval3(tickInterval / interval, multiples, unit[0] === "year" ? Math.max(getMagnitude3(tickInterval / interval), 1) : 1);
      return {
        unitRange: interval,
        count,
        unitName: unit[0]
      };
    };
    Additions2.prototype.getXDateFormat = function(x, dateTimeLabelFormats) {
      var axis = this.axis;
      return axis.closestPointRange ? axis.chart.time.getDateFormat(axis.closestPointRange, x, axis.options.startOfWeek, dateTimeLabelFormats) || dateTimeLabelFormats.year : dateTimeLabelFormats.day;
    };
    return Additions2;
  }();
  DateTimeAxis2.Additions = Additions;
})(DateTimeAxis || (DateTimeAxis = {}));
var DateTimeAxis_default = DateTimeAxis;

// node_modules/highcharts/es-modules/Core/Axis/LogarithmicAxis.js
var addEvent6 = Utilities_default.addEvent;
var getMagnitude4 = Utilities_default.getMagnitude;
var normalizeTickInterval4 = Utilities_default.normalizeTickInterval;
var pick15 = Utilities_default.pick;
var LogarithmicAxis;
(function(LogarithmicAxis2) {
  var composedClasses2 = [];
  function compose(AxisClass) {
    if (composedClasses2.indexOf(AxisClass) === -1) {
      composedClasses2.push(AxisClass);
      AxisClass.keepProps.push("logarithmic");
      addEvent6(AxisClass, "init", onInit);
      addEvent6(AxisClass, "afterInit", onAfterInit);
    }
    return AxisClass;
  }
  LogarithmicAxis2.compose = compose;
  function onInit(e2) {
    var axis = this;
    var options = e2.userOptions;
    var logarithmic = axis.logarithmic;
    if (options.type !== "logarithmic") {
      axis.logarithmic = void 0;
    } else {
      if (!logarithmic) {
        logarithmic = axis.logarithmic = new Additions(axis);
      }
    }
  }
  function onAfterInit() {
    var axis = this;
    var log = axis.logarithmic;
    if (log) {
      axis.lin2val = function(num) {
        return log.lin2log(num);
      };
      axis.val2lin = function(num) {
        return log.log2lin(num);
      };
    }
  }
  var Additions = function() {
    function Additions2(axis) {
      this.axis = axis;
    }
    Additions2.prototype.getLogTickPositions = function(interval, min, max, minor) {
      var log = this;
      var axis = log.axis;
      var axisLength = axis.len;
      var options = axis.options;
      var positions = [];
      if (!minor) {
        log.minorAutoInterval = void 0;
      }
      if (interval >= 0.5) {
        interval = Math.round(interval);
        positions = axis.getLinearTickPositions(interval, min, max);
      } else if (interval >= 0.08) {
        var roundedMin = Math.floor(min);
        var intermediate = void 0, i = void 0, j = void 0, len = void 0, pos = void 0, lastPos = void 0, break2 = void 0;
        if (interval > 0.3) {
          intermediate = [1, 2, 4];
        } else if (interval > 0.15) {
          intermediate = [1, 2, 4, 6, 8];
        } else {
          intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];
        }
        for (i = roundedMin; i < max + 1 && !break2; i++) {
          len = intermediate.length;
          for (j = 0; j < len && !break2; j++) {
            pos = log.log2lin(log.lin2log(i) * intermediate[j]);
            if (pos > min && (!minor || lastPos <= max) && typeof lastPos !== "undefined") {
              positions.push(lastPos);
            }
            if (lastPos > max) {
              break2 = true;
            }
            lastPos = pos;
          }
        }
      } else {
        var realMin = log.lin2log(min), realMax = log.lin2log(max), tickIntervalOption = minor ? axis.getMinorTickInterval() : options.tickInterval, filteredTickIntervalOption = tickIntervalOption === "auto" ? null : tickIntervalOption, tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1), totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;
        interval = pick15(filteredTickIntervalOption, log.minorAutoInterval, (realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1));
        interval = normalizeTickInterval4(interval, void 0, getMagnitude4(interval));
        positions = axis.getLinearTickPositions(interval, realMin, realMax).map(log.log2lin);
        if (!minor) {
          log.minorAutoInterval = interval / 5;
        }
      }
      if (!minor) {
        axis.tickInterval = interval;
      }
      return positions;
    };
    Additions2.prototype.lin2log = function(num) {
      return Math.pow(10, num);
    };
    Additions2.prototype.log2lin = function(num) {
      return Math.log(num) / Math.LN10;
    };
    return Additions2;
  }();
  LogarithmicAxis2.Additions = Additions;
})(LogarithmicAxis || (LogarithmicAxis = {}));
var LogarithmicAxis_default = LogarithmicAxis;

// node_modules/highcharts/es-modules/Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js
var erase4 = Utilities_default.erase;
var extend10 = Utilities_default.extend;
var isNumber12 = Utilities_default.isNumber;
var PlotLineOrBandAxis;
(function(PlotLineOrBandAxis2) {
  var composedClasses2 = [];
  var PlotLineOrBandClass;
  function compose(PlotLineOrBandType, AxisClass) {
    if (!PlotLineOrBandClass) {
      PlotLineOrBandClass = PlotLineOrBandType;
    }
    if (composedClasses2.indexOf(AxisClass) === -1) {
      composedClasses2.push(AxisClass);
      extend10(AxisClass.prototype, Additions.prototype);
    }
    return AxisClass;
  }
  PlotLineOrBandAxis2.compose = compose;
  var Additions = function() {
    function Additions2() {
    }
    Additions2.prototype.getPlotBandPath = function(from, to, options) {
      if (options === void 0) {
        options = this.options;
      }
      var toPath = this.getPlotLinePath({
        value: to,
        force: true,
        acrossPanes: options.acrossPanes
      }), result2 = [], horiz = this.horiz, outside = !isNumber12(this.min) || !isNumber12(this.max) || from < this.min && to < this.min || from > this.max && to > this.max;
      var path = this.getPlotLinePath({
        value: from,
        force: true,
        acrossPanes: options.acrossPanes
      }), i, plus = 1, isFlat;
      if (path && toPath) {
        if (outside) {
          isFlat = path.toString() === toPath.toString();
          plus = 0;
        }
        for (i = 0; i < path.length; i += 2) {
          var pathStart = path[i], pathEnd = path[i + 1], toPathStart = toPath[i], toPathEnd = toPath[i + 1];
          if ((pathStart[0] === "M" || pathStart[0] === "L") && (pathEnd[0] === "M" || pathEnd[0] === "L") && (toPathStart[0] === "M" || toPathStart[0] === "L") && (toPathEnd[0] === "M" || toPathEnd[0] === "L")) {
            if (horiz && toPathStart[1] === pathStart[1]) {
              toPathStart[1] += plus;
              toPathEnd[1] += plus;
            } else if (!horiz && toPathStart[2] === pathStart[2]) {
              toPathStart[2] += plus;
              toPathEnd[2] += plus;
            }
            result2.push(["M", pathStart[1], pathStart[2]], ["L", pathEnd[1], pathEnd[2]], ["L", toPathEnd[1], toPathEnd[2]], ["L", toPathStart[1], toPathStart[2]], ["Z"]);
          }
          result2.isFlat = isFlat;
        }
      } else {
        path = null;
      }
      return result2;
    };
    Additions2.prototype.addPlotBand = function(options) {
      return this.addPlotBandOrLine(options, "plotBands");
    };
    Additions2.prototype.addPlotLine = function(options) {
      return this.addPlotBandOrLine(options, "plotLines");
    };
    Additions2.prototype.addPlotBandOrLine = function(options, coll) {
      var _this = this;
      var userOptions = this.userOptions;
      var obj = new PlotLineOrBandClass(this, options);
      if (this.visible) {
        obj = obj.render();
      }
      if (obj) {
        if (!this._addedPlotLB) {
          this._addedPlotLB = true;
          (userOptions.plotLines || []).concat(userOptions.plotBands || []).forEach(function(plotLineOptions) {
            _this.addPlotBandOrLine(plotLineOptions);
          });
        }
        if (coll) {
          var updatedOptions = userOptions[coll] || [];
          updatedOptions.push(options);
          userOptions[coll] = updatedOptions;
        }
        this.plotLinesAndBands.push(obj);
      }
      return obj;
    };
    Additions2.prototype.removePlotBandOrLine = function(id) {
      var plotLinesAndBands = this.plotLinesAndBands, options = this.options, userOptions = this.userOptions;
      if (plotLinesAndBands) {
        var i_1 = plotLinesAndBands.length;
        while (i_1--) {
          if (plotLinesAndBands[i_1].id === id) {
            plotLinesAndBands[i_1].destroy();
          }
        }
        [
          options.plotLines || [],
          userOptions.plotLines || [],
          options.plotBands || [],
          userOptions.plotBands || []
        ].forEach(function(arr) {
          i_1 = arr.length;
          while (i_1--) {
            if ((arr[i_1] || {}).id === id) {
              erase4(arr, arr[i_1]);
            }
          }
        });
      }
    };
    Additions2.prototype.removePlotBand = function(id) {
      this.removePlotBandOrLine(id);
    };
    Additions2.prototype.removePlotLine = function(id) {
      this.removePlotBandOrLine(id);
    };
    return Additions2;
  }();
})(PlotLineOrBandAxis || (PlotLineOrBandAxis = {}));
var PlotLineOrBandAxis_default = PlotLineOrBandAxis;

// node_modules/highcharts/es-modules/Core/Axis/PlotLineOrBand/PlotLineOrBand.js
var arrayMax3 = Utilities_default.arrayMax;
var arrayMin3 = Utilities_default.arrayMin;
var defined11 = Utilities_default.defined;
var destroyObjectProperties5 = Utilities_default.destroyObjectProperties;
var erase5 = Utilities_default.erase;
var fireEvent5 = Utilities_default.fireEvent;
var merge11 = Utilities_default.merge;
var objectEach11 = Utilities_default.objectEach;
var pick16 = Utilities_default.pick;
var PlotLineOrBand = function() {
  function PlotLineOrBand2(axis, options) {
    this.axis = axis;
    if (options) {
      this.options = options;
      this.id = options.id;
    }
  }
  PlotLineOrBand2.compose = function(AxisClass) {
    return PlotLineOrBandAxis_default.compose(PlotLineOrBand2, AxisClass);
  };
  PlotLineOrBand2.prototype.render = function() {
    fireEvent5(this, "render");
    var plotLine = this, axis = plotLine.axis, horiz = axis.horiz, log = axis.logarithmic, options = plotLine.options, color18 = options.color, zIndex = pick16(options.zIndex, 0), events = options.events, groupAttribs = {}, renderer = axis.chart.renderer;
    var optionsLabel = options.label, label = plotLine.label, to = options.to, from = options.from, value = options.value, svgElem = plotLine.svgElem, path = [], group;
    var isBand = defined11(from) && defined11(to), isLine = defined11(value), isNew = !svgElem, attribs = {
      "class": "highcharts-plot-" + (isBand ? "band " : "line ") + (options.className || "")
    };
    var groupName = isBand ? "bands" : "lines";
    if (log) {
      from = log.log2lin(from);
      to = log.log2lin(to);
      value = log.log2lin(value);
    }
    if (!axis.chart.styledMode) {
      if (isLine) {
        attribs.stroke = color18 || Palette_default.neutralColor40;
        attribs["stroke-width"] = pick16(options.width, 1);
        if (options.dashStyle) {
          attribs.dashstyle = options.dashStyle;
        }
      } else if (isBand) {
        attribs.fill = color18 || Palette_default.highlightColor10;
        if (options.borderWidth) {
          attribs.stroke = options.borderColor;
          attribs["stroke-width"] = options.borderWidth;
        }
      }
    }
    groupAttribs.zIndex = zIndex;
    groupName += "-" + zIndex;
    group = axis.plotLinesAndBandsGroups[groupName];
    if (!group) {
      axis.plotLinesAndBandsGroups[groupName] = group = renderer.g("plot-" + groupName).attr(groupAttribs).add();
    }
    if (isNew) {
      plotLine.svgElem = svgElem = renderer.path().attr(attribs).add(group);
    }
    if (isLine) {
      path = axis.getPlotLinePath({
        value,
        lineWidth: svgElem.strokeWidth(),
        acrossPanes: options.acrossPanes
      });
    } else if (isBand) {
      path = axis.getPlotBandPath(from, to, options);
    } else {
      return;
    }
    if (!plotLine.eventsAdded && events) {
      objectEach11(events, function(event, eventType) {
        svgElem.on(eventType, function(e2) {
          events[eventType].apply(plotLine, [e2]);
        });
      });
      plotLine.eventsAdded = true;
    }
    if ((isNew || !svgElem.d) && path && path.length) {
      svgElem.attr({ d: path });
    } else if (svgElem) {
      if (path) {
        svgElem.show(true);
        svgElem.animate({ d: path });
      } else if (svgElem.d) {
        svgElem.hide();
        if (label) {
          plotLine.label = label = label.destroy();
        }
      }
    }
    if (optionsLabel && (defined11(optionsLabel.text) || defined11(optionsLabel.formatter)) && path && path.length && axis.width > 0 && axis.height > 0 && !path.isFlat) {
      optionsLabel = merge11({
        align: horiz && isBand && "center",
        x: horiz ? !isBand && 4 : 10,
        verticalAlign: !horiz && isBand && "middle",
        y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,
        rotation: horiz && !isBand && 90
      }, optionsLabel);
      this.renderLabel(optionsLabel, path, isBand, zIndex);
    } else if (label) {
      label.hide();
    }
    return plotLine;
  };
  PlotLineOrBand2.prototype.renderLabel = function(optionsLabel, path, isBand, zIndex) {
    var plotLine = this, axis = plotLine.axis, renderer = axis.chart.renderer;
    var label = plotLine.label;
    if (!label) {
      plotLine.label = label = renderer.text(this.getLabelText(optionsLabel), 0, 0, optionsLabel.useHTML).attr({
        align: optionsLabel.textAlign || optionsLabel.align,
        rotation: optionsLabel.rotation,
        "class": "highcharts-plot-" + (isBand ? "band" : "line") + "-label " + (optionsLabel.className || ""),
        zIndex
      }).add();
      if (!axis.chart.styledMode) {
        label.css(merge11({
          textOverflow: "ellipsis"
        }, optionsLabel.style));
      }
    }
    var xBounds = path.xBounds || [path[0][1], path[1][1], isBand ? path[2][1] : path[0][1]];
    var yBounds = path.yBounds || [path[0][2], path[1][2], isBand ? path[2][2] : path[0][2]];
    var x = arrayMin3(xBounds);
    var y = arrayMin3(yBounds);
    label.align(optionsLabel, false, {
      x,
      y,
      width: arrayMax3(xBounds) - x,
      height: arrayMax3(yBounds) - y
    });
    if (!label.alignValue || label.alignValue === "left") {
      label.css({
        width: (label.rotation === 90 ? axis.height - (label.alignAttr.y - axis.top) : axis.width - (label.alignAttr.x - axis.left)) + "px"
      });
    }
    label.show(true);
  };
  PlotLineOrBand2.prototype.getLabelText = function(optionsLabel) {
    return defined11(optionsLabel.formatter) ? optionsLabel.formatter.call(this) : optionsLabel.text;
  };
  PlotLineOrBand2.prototype.destroy = function() {
    erase5(this.axis.plotLinesAndBands, this);
    delete this.axis;
    destroyObjectProperties5(this);
  };
  return PlotLineOrBand2;
}();
var PlotLineOrBand_default = PlotLineOrBand;

// node_modules/highcharts/es-modules/Core/Tooltip.js
var format2 = FormatUtilities_default.format;
var doc5 = Globals_default.doc;
var distribute = RendererUtilities_default.distribute;
var addEvent7 = Utilities_default.addEvent;
var clamp5 = Utilities_default.clamp;
var css6 = Utilities_default.css;
var defined12 = Utilities_default.defined;
var discardElement3 = Utilities_default.discardElement;
var extend11 = Utilities_default.extend;
var fireEvent6 = Utilities_default.fireEvent;
var isArray6 = Utilities_default.isArray;
var isNumber13 = Utilities_default.isNumber;
var isString7 = Utilities_default.isString;
var merge12 = Utilities_default.merge;
var pick17 = Utilities_default.pick;
var splat5 = Utilities_default.splat;
var syncTimeout4 = Utilities_default.syncTimeout;
var Tooltip = function() {
  function Tooltip2(chart, options) {
    this.container = void 0;
    this.crosshairs = [];
    this.distance = 0;
    this.isHidden = true;
    this.isSticky = false;
    this.now = {};
    this.options = {};
    this.outside = false;
    this.chart = chart;
    this.init(chart, options);
  }
  Tooltip2.prototype.applyFilter = function() {
    var chart = this.chart;
    chart.renderer.definition({
      tagName: "filter",
      attributes: {
        id: "drop-shadow-" + chart.index,
        opacity: 0.5
      },
      children: [{
        tagName: "feGaussianBlur",
        attributes: {
          "in": "SourceAlpha",
          stdDeviation: 1
        }
      }, {
        tagName: "feOffset",
        attributes: {
          dx: 1,
          dy: 1
        }
      }, {
        tagName: "feComponentTransfer",
        children: [{
          tagName: "feFuncA",
          attributes: {
            type: "linear",
            slope: 0.3
          }
        }]
      }, {
        tagName: "feMerge",
        children: [{
          tagName: "feMergeNode"
        }, {
          tagName: "feMergeNode",
          attributes: {
            "in": "SourceGraphic"
          }
        }]
      }]
    });
  };
  Tooltip2.prototype.bodyFormatter = function(items) {
    return items.map(function(item) {
      var tooltipOptions = item.series.tooltipOptions;
      return (tooltipOptions[(item.point.formatPrefix || "point") + "Formatter"] || item.point.tooltipFormatter).call(item.point, tooltipOptions[(item.point.formatPrefix || "point") + "Format"] || "");
    });
  };
  Tooltip2.prototype.cleanSplit = function(force) {
    this.chart.series.forEach(function(series) {
      var tt = series && series.tt;
      if (tt) {
        if (!tt.isActive || force) {
          series.tt = tt.destroy();
        } else {
          tt.isActive = false;
        }
      }
    });
  };
  Tooltip2.prototype.defaultFormatter = function(tooltip) {
    var items = this.points || splat5(this);
    var s;
    s = [tooltip.tooltipFooterHeaderFormatter(items[0])];
    s = s.concat(tooltip.bodyFormatter(items));
    s.push(tooltip.tooltipFooterHeaderFormatter(items[0], true));
    return s;
  };
  Tooltip2.prototype.destroy = function() {
    if (this.label) {
      this.label = this.label.destroy();
    }
    if (this.split && this.tt) {
      this.cleanSplit(this.chart, true);
      this.tt = this.tt.destroy();
    }
    if (this.renderer) {
      this.renderer = this.renderer.destroy();
      discardElement3(this.container);
    }
    Utilities_default.clearTimeout(this.hideTimer);
    Utilities_default.clearTimeout(this.tooltipTimeout);
  };
  Tooltip2.prototype.getAnchor = function(points, mouseEvent) {
    var chart = this.chart, pointer = chart.pointer, inverted = chart.inverted, plotTop = chart.plotTop, plotLeft = chart.plotLeft;
    var ret, yAxis, xAxis, plotX = 0, plotY = 0;
    points = splat5(points);
    if (this.followPointer && mouseEvent) {
      if (typeof mouseEvent.chartX === "undefined") {
        mouseEvent = pointer.normalize(mouseEvent);
      }
      ret = [
        mouseEvent.chartX - plotLeft,
        mouseEvent.chartY - plotTop
      ];
    } else if (points[0].tooltipPos) {
      ret = points[0].tooltipPos;
    } else {
      points.forEach(function(point) {
        yAxis = point.series.yAxis;
        xAxis = point.series.xAxis;
        plotX += point.plotX || 0;
        plotY += point.plotLow ? (point.plotLow + (point.plotHigh || 0)) / 2 : point.plotY || 0;
        if (xAxis && yAxis) {
          if (!inverted) {
            plotX += xAxis.pos - plotLeft;
            plotY += yAxis.pos - plotTop;
          } else {
            plotX += plotTop + chart.plotHeight - xAxis.len - xAxis.pos;
            plotY += plotLeft + chart.plotWidth - yAxis.len - yAxis.pos;
          }
        }
      });
      plotX /= points.length;
      plotY /= points.length;
      ret = [
        inverted ? chart.plotWidth - plotY : plotX,
        inverted ? chart.plotHeight - plotX : plotY
      ];
      if (this.shared && points.length > 1 && mouseEvent) {
        if (inverted) {
          ret[0] = mouseEvent.chartX - plotLeft;
        } else {
          ret[1] = mouseEvent.chartY - plotTop;
        }
      }
    }
    return ret.map(Math.round);
  };
  Tooltip2.prototype.getLabel = function() {
    var tooltip = this, styledMode = this.chart.styledMode, options = this.options, className = "tooltip" + (defined12(options.className) ? " " + options.className : ""), pointerEvents = options.style.pointerEvents || (!this.followPointer && options.stickOnContact ? "auto" : "none"), onMouseEnter = function() {
      tooltip.inContact = true;
    }, onMouseLeave = function(e2) {
      var series = tooltip.chart.hoverSeries;
      tooltip.inContact = tooltip.shouldStickOnContact() && tooltip.chart.pointer.inClass(e2.relatedTarget, "highcharts-tooltip");
      if (!tooltip.inContact && series && series.onMouseOut) {
        series.onMouseOut();
      }
    };
    var container, renderer = this.chart.renderer;
    if (!this.label) {
      if (this.outside) {
        var chartStyle = this.chart.options.chart.style, Renderer2 = RendererRegistry_default.getRendererType();
        this.container = container = Globals_default.doc.createElement("div");
        container.className = "highcharts-tooltip-container";
        css6(container, {
          position: "absolute",
          top: "1px",
          pointerEvents,
          zIndex: Math.max(this.options.style.zIndex || 0, (chartStyle && chartStyle.zIndex || 0) + 3)
        });
        addEvent7(container, "mouseenter", onMouseEnter);
        addEvent7(container, "mouseleave", onMouseLeave);
        Globals_default.doc.body.appendChild(container);
        this.renderer = renderer = new Renderer2(container, 0, 0, chartStyle, void 0, void 0, renderer.styledMode);
      }
      if (this.split) {
        this.label = renderer.g(className);
      } else {
        this.label = renderer.label("", 0, 0, options.shape, void 0, void 0, options.useHTML, void 0, className).attr({
          padding: options.padding,
          r: options.borderRadius
        });
        if (!styledMode) {
          this.label.attr({
            fill: options.backgroundColor,
            "stroke-width": options.borderWidth
          }).css(options.style).css({ pointerEvents }).shadow(options.shadow);
        }
      }
      if (styledMode && options.shadow) {
        this.applyFilter();
        this.label.attr({
          filter: "url(#drop-shadow-" + this.chart.index + ")"
        });
      }
      if (tooltip.outside && !tooltip.split) {
        var label_1 = this.label;
        var xSetter_1 = label_1.xSetter, ySetter_1 = label_1.ySetter;
        label_1.xSetter = function(value) {
          xSetter_1.call(label_1, tooltip.distance);
          container.style.left = value + "px";
        };
        label_1.ySetter = function(value) {
          ySetter_1.call(label_1, tooltip.distance);
          container.style.top = value + "px";
        };
      }
      this.label.on("mouseenter", onMouseEnter).on("mouseleave", onMouseLeave).attr({ zIndex: 8 }).add();
    }
    return this.label;
  };
  Tooltip2.prototype.getPosition = function(boxWidth, boxHeight, point) {
    var chart = this.chart, distance = this.distance, ret = {}, h = chart.inverted && point.h || 0, outside = this.outside, outerWidth = outside ? doc5.documentElement.clientWidth - 2 * distance : chart.chartWidth, outerHeight = outside ? Math.max(doc5.body.scrollHeight, doc5.documentElement.scrollHeight, doc5.body.offsetHeight, doc5.documentElement.offsetHeight, doc5.documentElement.clientHeight) : chart.chartHeight, chartPosition = chart.pointer.getChartPosition(), scaleX = function(val) {
      return val * chartPosition.scaleX;
    }, scaleY = function(val) {
      return val * chartPosition.scaleY;
    }, buildDimensionArray = function(dim) {
      var isX = dim === "x";
      return [
        dim,
        isX ? outerWidth : outerHeight,
        isX ? boxWidth : boxHeight
      ].concat(outside ? [
        isX ? scaleX(boxWidth) : scaleY(boxHeight),
        isX ? chartPosition.left - distance + scaleX(point.plotX + chart.plotLeft) : chartPosition.top - distance + scaleY(point.plotY + chart.plotTop),
        0,
        isX ? outerWidth : outerHeight
      ] : [
        isX ? boxWidth : boxHeight,
        isX ? point.plotX + chart.plotLeft : point.plotY + chart.plotTop,
        isX ? chart.plotLeft : chart.plotTop,
        isX ? chart.plotLeft + chart.plotWidth : chart.plotTop + chart.plotHeight
      ]);
    };
    var first = buildDimensionArray("y"), second = buildDimensionArray("x"), swapped;
    var preferFarSide = !this.followPointer && pick17(point.ttBelow, !chart.inverted === !!point.negative), firstDimension = function(dim, outerSize, innerSize, scaledInnerSize, point2, min, max) {
      var scaledDist = outside ? dim === "y" ? scaleY(distance) : scaleX(distance) : distance, scaleDiff = (innerSize - scaledInnerSize) / 2, roomLeft = scaledInnerSize < point2 - distance, roomRight = point2 + distance + scaledInnerSize < outerSize, alignedLeft = point2 - scaledDist - innerSize + scaleDiff, alignedRight = point2 + scaledDist - scaleDiff;
      if (preferFarSide && roomRight) {
        ret[dim] = alignedRight;
      } else if (!preferFarSide && roomLeft) {
        ret[dim] = alignedLeft;
      } else if (roomLeft) {
        ret[dim] = Math.min(max - scaledInnerSize, alignedLeft - h < 0 ? alignedLeft : alignedLeft - h);
      } else if (roomRight) {
        ret[dim] = Math.max(min, alignedRight + h + innerSize > outerSize ? alignedRight : alignedRight + h);
      } else {
        return false;
      }
    }, secondDimension = function(dim, outerSize, innerSize, scaledInnerSize, point2) {
      var retVal;
      if (point2 < distance || point2 > outerSize - distance) {
        retVal = false;
      } else if (point2 < innerSize / 2) {
        ret[dim] = 1;
      } else if (point2 > outerSize - scaledInnerSize / 2) {
        ret[dim] = outerSize - scaledInnerSize - 2;
      } else {
        ret[dim] = point2 - innerSize / 2;
      }
      return retVal;
    }, swap = function(count) {
      var temp = first;
      first = second;
      second = temp;
      swapped = count;
    }, run = function() {
      if (firstDimension.apply(0, first) !== false) {
        if (secondDimension.apply(0, second) === false && !swapped) {
          swap(true);
          run();
        }
      } else if (!swapped) {
        swap(true);
        run();
      } else {
        ret.x = ret.y = 0;
      }
    };
    if (chart.inverted || this.len > 1) {
      swap();
    }
    run();
    return ret;
  };
  Tooltip2.prototype.hide = function(delay) {
    var tooltip = this;
    Utilities_default.clearTimeout(this.hideTimer);
    delay = pick17(delay, this.options.hideDelay);
    if (!this.isHidden) {
      this.hideTimer = syncTimeout4(function() {
        tooltip.getLabel().fadeOut(delay ? void 0 : delay);
        tooltip.isHidden = true;
      }, delay);
    }
  };
  Tooltip2.prototype.init = function(chart, options) {
    this.chart = chart;
    this.options = options;
    this.crosshairs = [];
    this.now = { x: 0, y: 0 };
    this.isHidden = true;
    this.split = options.split && !chart.inverted && !chart.polar;
    this.shared = options.shared || this.split;
    this.outside = pick17(options.outside, Boolean(chart.scrollablePixelsX || chart.scrollablePixelsY));
  };
  Tooltip2.prototype.shouldStickOnContact = function() {
    return !!(!this.followPointer && this.options.stickOnContact);
  };
  Tooltip2.prototype.isStickyOnContact = function() {
    return !!(this.shouldStickOnContact() && this.inContact);
  };
  Tooltip2.prototype.move = function(x, y, anchorX, anchorY) {
    var tooltip = this, now = tooltip.now, animate4 = tooltip.options.animation !== false && !tooltip.isHidden && (Math.abs(x - now.x) > 1 || Math.abs(y - now.y) > 1), skipAnchor = tooltip.followPointer || tooltip.len > 1;
    extend11(now, {
      x: animate4 ? (2 * now.x + x) / 3 : x,
      y: animate4 ? (now.y + y) / 2 : y,
      anchorX: skipAnchor ? void 0 : animate4 ? (2 * now.anchorX + anchorX) / 3 : anchorX,
      anchorY: skipAnchor ? void 0 : animate4 ? (now.anchorY + anchorY) / 2 : anchorY
    });
    tooltip.getLabel().attr(now);
    tooltip.drawTracker();
    if (animate4) {
      Utilities_default.clearTimeout(this.tooltipTimeout);
      this.tooltipTimeout = setTimeout(function() {
        if (tooltip) {
          tooltip.move(x, y, anchorX, anchorY);
        }
      }, 32);
    }
  };
  Tooltip2.prototype.refresh = function(pointOrPoints, mouseEvent) {
    var tooltip = this, chart = this.chart, options = tooltip.options, points = splat5(pointOrPoints), point = points[0], pointConfig = [], formatter = options.formatter || tooltip.defaultFormatter, shared = tooltip.shared, styledMode = chart.styledMode;
    var textConfig = {};
    if (!options.enabled) {
      return;
    }
    Utilities_default.clearTimeout(this.hideTimer);
    tooltip.followPointer = !tooltip.split && point.series.tooltipOptions.followPointer;
    var anchor = tooltip.getAnchor(pointOrPoints, mouseEvent), x = anchor[0], y = anchor[1];
    if (shared && !(!isArray6(pointOrPoints) && pointOrPoints.series && pointOrPoints.series.noSharedTooltip)) {
      chart.pointer.applyInactiveState(points);
      points.forEach(function(item) {
        item.setState("hover");
        pointConfig.push(item.getLabelConfig());
      });
      textConfig = {
        x: point.category,
        y: point.y
      };
      textConfig.points = pointConfig;
    } else {
      textConfig = point.getLabelConfig();
    }
    this.len = pointConfig.length;
    var text = formatter.call(textConfig, tooltip);
    var currentSeries = point.series;
    this.distance = pick17(currentSeries.tooltipOptions.distance, 16);
    if (text === false) {
      this.hide();
    } else {
      if (tooltip.split) {
        this.renderSplit(text, points);
      } else {
        var checkX = x;
        var checkY = y;
        if (mouseEvent && chart.pointer.isDirectTouch) {
          checkX = mouseEvent.chartX - chart.plotLeft;
          checkY = mouseEvent.chartY - chart.plotTop;
        }
        if (chart.polar || currentSeries.options.clip === false || currentSeries.shouldShowTooltip(checkX, checkY)) {
          var label = tooltip.getLabel();
          if (!options.style.width || styledMode) {
            label.css({
              width: this.chart.spacingBox.width + "px"
            });
          }
          label.attr({
            text: text && text.join ? text.join("") : text
          });
          label.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-" + pick17(point.colorIndex, currentSeries.colorIndex));
          if (!styledMode) {
            label.attr({
              stroke: options.borderColor || point.color || currentSeries.color || Palette_default.neutralColor60
            });
          }
          tooltip.updatePosition({
            plotX: x,
            plotY: y,
            negative: point.negative,
            ttBelow: point.ttBelow,
            h: anchor[2] || 0
          });
        } else {
          tooltip.hide();
          return;
        }
      }
      if (tooltip.isHidden && tooltip.label) {
        tooltip.label.attr({
          opacity: 1
        }).show();
      }
      tooltip.isHidden = false;
    }
    fireEvent6(this, "refresh");
  };
  Tooltip2.prototype.renderSplit = function(labels, points) {
    var tooltip = this;
    var chart = tooltip.chart, _a15 = tooltip.chart, chartWidth = _a15.chartWidth, chartHeight = _a15.chartHeight, plotHeight = _a15.plotHeight, plotLeft = _a15.plotLeft, plotTop = _a15.plotTop, pointer = _a15.pointer, _b = _a15.scrollablePixelsY, scrollablePixelsY = _b === void 0 ? 0 : _b, scrollablePixelsX = _a15.scrollablePixelsX, _c = _a15.scrollingContainer, _d = _c === void 0 ? { scrollLeft: 0, scrollTop: 0 } : _c, scrollLeft = _d.scrollLeft, scrollTop = _d.scrollTop, styledMode = _a15.styledMode, distance = tooltip.distance, options = tooltip.options, positioner = tooltip.options.positioner;
    var bounds = tooltip.outside && typeof scrollablePixelsX !== "number" ? doc5.documentElement.getBoundingClientRect() : {
      left: scrollLeft,
      right: scrollLeft + chartWidth,
      top: scrollTop,
      bottom: scrollTop + chartHeight
    };
    var tooltipLabel = tooltip.getLabel();
    var ren = this.renderer || chart.renderer;
    var headerTop = Boolean(chart.xAxis[0] && chart.xAxis[0].opposite);
    var _e = pointer.getChartPosition(), chartLeft = _e.left, chartTop = _e.top;
    var distributionBoxTop = plotTop + scrollTop;
    var headerHeight = 0;
    var adjustedPlotHeight = plotHeight - scrollablePixelsY;
    function getAnchor(point) {
      var isHeader = point.isHeader, _a16 = point.plotX, plotX = _a16 === void 0 ? 0 : _a16, _b2 = point.plotY, plotY = _b2 === void 0 ? 0 : _b2, series = point.series;
      var anchorX;
      var anchorY;
      if (isHeader) {
        anchorX = plotLeft + plotX;
        anchorY = plotTop + plotHeight / 2;
      } else {
        var xAxis = series.xAxis, yAxis = series.yAxis;
        anchorX = xAxis.pos + clamp5(plotX, -distance, xAxis.len + distance);
        if (series.shouldShowTooltip(0, yAxis.pos - plotTop + plotY, {
          ignoreX: true
        })) {
          anchorY = yAxis.pos + plotY;
        }
      }
      anchorX = clamp5(anchorX, bounds.left - distance, bounds.right + distance);
      return { anchorX, anchorY };
    }
    function defaultPositioner(anchorX, anchorY, isHeader, boxWidth, alignedLeft) {
      if (alignedLeft === void 0) {
        alignedLeft = true;
      }
      var y2;
      var x2;
      if (isHeader) {
        y2 = headerTop ? 0 : adjustedPlotHeight;
        x2 = clamp5(anchorX - boxWidth / 2, bounds.left, bounds.right - boxWidth - (tooltip.outside ? chartLeft : 0));
      } else {
        y2 = anchorY - distributionBoxTop;
        x2 = alignedLeft ? anchorX - boxWidth - distance : anchorX + distance;
        x2 = clamp5(x2, alignedLeft ? x2 : bounds.left, bounds.right);
      }
      return { x: x2, y: y2 };
    }
    function updatePartialTooltip(partialTooltip, point, str) {
      var tt = partialTooltip;
      var isHeader = point.isHeader, series = point.series;
      var colorClass = "highcharts-color-" + pick17(point.colorIndex, series.colorIndex, "none");
      if (!tt) {
        var attribs = {
          padding: options.padding,
          r: options.borderRadius
        };
        if (!styledMode) {
          attribs.fill = options.backgroundColor;
          attribs["stroke-width"] = options.borderWidth;
        }
        tt = ren.label("", 0, 0, options[isHeader ? "headerShape" : "shape"], void 0, void 0, options.useHTML).addClass((isHeader ? "highcharts-tooltip-header " : "") + "highcharts-tooltip-box " + colorClass).attr(attribs).add(tooltipLabel);
      }
      tt.isActive = true;
      tt.attr({
        text: str
      });
      if (!styledMode) {
        tt.css(options.style).shadow(options.shadow).attr({
          stroke: options.borderColor || point.color || series.color || Palette_default.neutralColor80
        });
      }
      return tt;
    }
    if (isString7(labels)) {
      labels = [false, labels];
    }
    var boxes = labels.slice(0, points.length + 1).reduce(function(boxes2, str, i) {
      if (str !== false && str !== "") {
        var point = points[i - 1] || {
          isHeader: true,
          plotX: points[0].plotX,
          plotY: plotHeight,
          series: {}
        };
        var isHeader = point.isHeader;
        var owner = isHeader ? tooltip : point.series;
        var tt = owner.tt = updatePartialTooltip(owner.tt, point, str.toString());
        var bBox = tt.getBBox();
        var boxWidth = bBox.width + tt.strokeWidth();
        if (isHeader) {
          headerHeight = bBox.height;
          adjustedPlotHeight += headerHeight;
          if (headerTop) {
            distributionBoxTop -= headerHeight;
          }
        }
        var _a16 = getAnchor(point), anchorX = _a16.anchorX, anchorY = _a16.anchorY;
        if (typeof anchorY === "number") {
          var size = bBox.height + 1;
          var boxPosition = positioner ? positioner.call(tooltip, boxWidth, size, point) : defaultPositioner(anchorX, anchorY, isHeader, boxWidth);
          boxes2.push({
            align: positioner ? 0 : void 0,
            anchorX,
            anchorY,
            boxWidth,
            point,
            rank: pick17(boxPosition.rank, isHeader ? 1 : 0),
            size,
            target: boxPosition.y,
            tt,
            x: boxPosition.x
          });
        } else {
          tt.isActive = false;
        }
      }
      return boxes2;
    }, []);
    if (!positioner && boxes.some(function(box) {
      var outside2 = tooltip.outside;
      var boxStart = (outside2 ? chartLeft : 0) + box.anchorX;
      if (boxStart < bounds.left && boxStart + box.boxWidth < bounds.right) {
        return true;
      }
      return boxStart < chartLeft - bounds.left + box.boxWidth && bounds.right - boxStart > boxStart;
    })) {
      boxes = boxes.map(function(box) {
        var _a16 = defaultPositioner(box.anchorX, box.anchorY, box.point.isHeader, box.boxWidth, false), x2 = _a16.x, y2 = _a16.y;
        return extend11(box, {
          target: y2,
          x: x2
        });
      });
    }
    tooltip.cleanSplit();
    distribute(boxes, adjustedPlotHeight);
    var boxExtremes = {
      left: chartLeft,
      right: chartLeft
    };
    boxes.forEach(function(box) {
      var x2 = box.x, boxWidth = box.boxWidth, isHeader = box.isHeader;
      if (!isHeader) {
        if (tooltip.outside && chartLeft + x2 < boxExtremes.left) {
          boxExtremes.left = chartLeft + x2;
        }
        if (!isHeader && tooltip.outside && boxExtremes.left + boxWidth > boxExtremes.right) {
          boxExtremes.right = chartLeft + x2;
        }
      }
    });
    boxes.forEach(function(box) {
      var x2 = box.x, anchorX = box.anchorX, anchorY = box.anchorY, pos = box.pos, isHeader = box.point.isHeader;
      var attributes = {
        visibility: typeof pos === "undefined" ? "hidden" : "inherit",
        x: x2,
        y: pos + distributionBoxTop,
        anchorX,
        anchorY
      };
      if (tooltip.outside && x2 < anchorX) {
        var offset3 = chartLeft - boxExtremes.left;
        if (offset3 > 0) {
          if (!isHeader) {
            attributes.x = x2 + offset3;
            attributes.anchorX = anchorX + offset3;
          }
          if (isHeader) {
            attributes.x = (boxExtremes.right - boxExtremes.left) / 2;
            attributes.anchorX = anchorX + offset3;
          }
        }
      }
      box.tt.attr(attributes);
    });
    var container = tooltip.container, outside = tooltip.outside, renderer = tooltip.renderer;
    if (outside && container && renderer) {
      var _f = tooltipLabel.getBBox(), width = _f.width, height = _f.height, x = _f.x, y = _f.y;
      renderer.setSize(width + x, height + y, false);
      container.style.left = boxExtremes.left + "px";
      container.style.top = chartTop + "px";
    }
  };
  Tooltip2.prototype.drawTracker = function() {
    var tooltip = this;
    if (tooltip.followPointer || !tooltip.options.stickOnContact) {
      if (tooltip.tracker) {
        tooltip.tracker.destroy();
      }
      return;
    }
    var chart = tooltip.chart;
    var label = tooltip.label;
    var points = tooltip.shared ? chart.hoverPoints : chart.hoverPoint;
    if (!label || !points) {
      return;
    }
    var box = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    var anchorPos = this.getAnchor(points);
    var labelBBox = label.getBBox();
    anchorPos[0] += chart.plotLeft - label.translateX;
    anchorPos[1] += chart.plotTop - label.translateY;
    box.x = Math.min(0, anchorPos[0]);
    box.y = Math.min(0, anchorPos[1]);
    box.width = anchorPos[0] < 0 ? Math.max(Math.abs(anchorPos[0]), labelBBox.width - anchorPos[0]) : Math.max(Math.abs(anchorPos[0]), labelBBox.width);
    box.height = anchorPos[1] < 0 ? Math.max(Math.abs(anchorPos[1]), labelBBox.height - Math.abs(anchorPos[1])) : Math.max(Math.abs(anchorPos[1]), labelBBox.height);
    if (tooltip.tracker) {
      tooltip.tracker.attr(box);
    } else {
      tooltip.tracker = label.renderer.rect(box).addClass("highcharts-tracker").add(label);
      if (!chart.styledMode) {
        tooltip.tracker.attr({
          fill: "rgba(0,0,0,0)"
        });
      }
    }
  };
  Tooltip2.prototype.styledModeFormat = function(formatString) {
    return formatString.replace('style="font-size: 10px"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex}"');
  };
  Tooltip2.prototype.tooltipFooterHeaderFormatter = function(labelConfig, isFooter) {
    var series = labelConfig.series, tooltipOptions = series.tooltipOptions, xAxis = series.xAxis, dateTime = xAxis && xAxis.dateTime, e2 = {
      isFooter,
      labelConfig
    };
    var xDateFormat = tooltipOptions.xDateFormat, formatString = tooltipOptions[isFooter ? "footerFormat" : "headerFormat"];
    fireEvent6(this, "headerFormatter", e2, function(e3) {
      if (dateTime && !xDateFormat && isNumber13(labelConfig.key)) {
        xDateFormat = dateTime.getXDateFormat(labelConfig.key, tooltipOptions.dateTimeLabelFormats);
      }
      if (dateTime && xDateFormat) {
        (labelConfig.point && labelConfig.point.tooltipDateKeys || ["key"]).forEach(function(key) {
          formatString = formatString.replace("{point." + key + "}", "{point." + key + ":" + xDateFormat + "}");
        });
      }
      if (series.chart.styledMode) {
        formatString = this.styledModeFormat(formatString);
      }
      e3.text = format2(formatString, {
        point: labelConfig,
        series
      }, this.chart);
    });
    return e2.text;
  };
  Tooltip2.prototype.update = function(options) {
    this.destroy();
    merge12(true, this.chart.options.tooltip.userOptions, options);
    this.init(this.chart, merge12(true, this.options, options));
  };
  Tooltip2.prototype.updatePosition = function(point) {
    var chart = this.chart, options = this.options, pointer = chart.pointer, label = this.getLabel(), chartPosition = pointer.getChartPosition(), pos = (options.positioner || this.getPosition).call(this, label.width, label.height, point);
    var anchorX = point.plotX + chart.plotLeft, anchorY = point.plotY + chart.plotTop, pad4;
    if (this.outside) {
      pad4 = options.borderWidth + 2 * this.distance;
      this.renderer.setSize(label.width + pad4, label.height + pad4, false);
      if (chartPosition.scaleX !== 1 || chartPosition.scaleY !== 1) {
        css6(this.container, {
          transform: "scale(" + chartPosition.scaleX + ", " + chartPosition.scaleY + ")"
        });
        anchorX *= chartPosition.scaleX;
        anchorY *= chartPosition.scaleY;
      }
      anchorX += chartPosition.left - pos.x;
      anchorY += chartPosition.top - pos.y;
    }
    this.move(Math.round(pos.x), Math.round(pos.y || 0), anchorX, anchorY);
  };
  return Tooltip2;
}();
var Tooltip_default = Tooltip;

// node_modules/highcharts/es-modules/Core/Series/Point.js
var animObject4 = AnimationUtilities_default.animObject;
var defaultOptions4 = DefaultOptions_default.defaultOptions;
var format3 = FormatUtilities_default.format;
var addEvent8 = Utilities_default.addEvent;
var defined13 = Utilities_default.defined;
var erase6 = Utilities_default.erase;
var extend12 = Utilities_default.extend;
var fireEvent7 = Utilities_default.fireEvent;
var getNestedProperty3 = Utilities_default.getNestedProperty;
var isArray7 = Utilities_default.isArray;
var isFunction4 = Utilities_default.isFunction;
var isNumber14 = Utilities_default.isNumber;
var isObject5 = Utilities_default.isObject;
var merge13 = Utilities_default.merge;
var objectEach12 = Utilities_default.objectEach;
var pick18 = Utilities_default.pick;
var syncTimeout5 = Utilities_default.syncTimeout;
var removeEvent5 = Utilities_default.removeEvent;
var uniqueKey4 = Utilities_default.uniqueKey;
var Point = function() {
  function Point4() {
    this.category = void 0;
    this.colorIndex = void 0;
    this.formatPrefix = "point";
    this.id = void 0;
    this.isNull = false;
    this.name = void 0;
    this.options = void 0;
    this.percentage = void 0;
    this.selected = false;
    this.series = void 0;
    this.total = void 0;
    this.visible = true;
    this.x = void 0;
  }
  Point4.prototype.animateBeforeDestroy = function() {
    var point = this, animateParams = { x: point.startXPos, opacity: 0 }, graphicalProps = point.getGraphicalProps();
    graphicalProps.singular.forEach(function(prop) {
      var isDataLabel = prop === "dataLabel";
      point[prop] = point[prop].animate(isDataLabel ? {
        x: point[prop].startXPos,
        y: point[prop].startYPos,
        opacity: 0
      } : animateParams);
    });
    graphicalProps.plural.forEach(function(plural) {
      point[plural].forEach(function(item) {
        if (item.element) {
          item.animate(extend12({ x: point.startXPos }, item.startYPos ? {
            x: item.startXPos,
            y: item.startYPos
          } : {}));
        }
      });
    });
  };
  Point4.prototype.applyOptions = function(options, x) {
    var point = this, series = point.series, pointValKey = series.options.pointValKey || series.pointValKey;
    options = Point4.prototype.optionsToObject.call(this, options);
    extend12(point, options);
    point.options = point.options ? extend12(point.options, options) : options;
    if (options.group) {
      delete point.group;
    }
    if (options.dataLabels) {
      delete point.dataLabels;
    }
    if (pointValKey) {
      point.y = Point4.prototype.getNestedProperty.call(point, pointValKey);
    }
    point.isNull = pick18(point.isValid && !point.isValid(), point.x === null || !isNumber14(point.y));
    point.formatPrefix = point.isNull ? "null" : "point";
    if (point.selected) {
      point.state = "select";
    }
    if ("name" in point && typeof x === "undefined" && series.xAxis && series.xAxis.hasNames) {
      point.x = series.xAxis.nameToX(point);
    }
    if (typeof point.x === "undefined" && series) {
      if (typeof x === "undefined") {
        point.x = series.autoIncrement();
      } else {
        point.x = x;
      }
    } else if (isNumber14(options.x) && series.options.relativeXValue) {
      point.x = series.autoIncrement(options.x);
    }
    return point;
  };
  Point4.prototype.destroy = function() {
    var point = this, series = point.series, chart = series.chart, dataSorting = series.options.dataSorting, hoverPoints = chart.hoverPoints, globalAnimation = point.series.chart.renderer.globalAnimation, animation = animObject4(globalAnimation);
    var prop;
    function destroyPoint() {
      if (point.graphic || point.dataLabel || point.dataLabels) {
        removeEvent5(point);
        point.destroyElements();
      }
      for (prop in point) {
        point[prop] = null;
      }
    }
    if (point.legendItem) {
      chart.legend.destroyItem(point);
    }
    if (hoverPoints) {
      point.setState();
      erase6(hoverPoints, point);
      if (!hoverPoints.length) {
        chart.hoverPoints = null;
      }
    }
    if (point === chart.hoverPoint) {
      point.onMouseOut();
    }
    if (!dataSorting || !dataSorting.enabled) {
      destroyPoint();
    } else {
      this.animateBeforeDestroy();
      syncTimeout5(destroyPoint, animation.duration);
    }
    chart.pointCount--;
  };
  Point4.prototype.destroyElements = function(kinds) {
    var point = this, props = point.getGraphicalProps(kinds);
    props.singular.forEach(function(prop) {
      point[prop] = point[prop].destroy();
    });
    props.plural.forEach(function(plural) {
      point[plural].forEach(function(item) {
        if (item.element) {
          item.destroy();
        }
      });
      delete point[plural];
    });
  };
  Point4.prototype.firePointEvent = function(eventType, eventArgs, defaultFunction) {
    var point = this, series = this.series, seriesOptions = series.options;
    if (seriesOptions.point.events[eventType] || point.options && point.options.events && point.options.events[eventType]) {
      point.importEvents();
    }
    if (eventType === "click" && seriesOptions.allowPointSelect) {
      defaultFunction = function(event) {
        if (point.select) {
          point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
        }
      };
    }
    fireEvent7(point, eventType, eventArgs, defaultFunction);
  };
  Point4.prototype.getClassName = function() {
    var point = this;
    return "highcharts-point" + (point.selected ? " highcharts-point-select" : "") + (point.negative ? " highcharts-negative" : "") + (point.isNull ? " highcharts-null-point" : "") + (typeof point.colorIndex !== "undefined" ? " highcharts-color-" + point.colorIndex : "") + (point.options.className ? " " + point.options.className : "") + (point.zone && point.zone.className ? " " + point.zone.className.replace("highcharts-negative", "") : "");
  };
  Point4.prototype.getGraphicalProps = function(kinds) {
    var point = this, props = [], graphicalProps = { singular: [], plural: [] };
    var prop, i;
    kinds = kinds || { graphic: 1, dataLabel: 1 };
    if (kinds.graphic) {
      props.push("graphic", "upperGraphic", "shadowGroup");
    }
    if (kinds.dataLabel) {
      props.push("dataLabel", "dataLabelUpper", "connector");
    }
    i = props.length;
    while (i--) {
      prop = props[i];
      if (point[prop]) {
        graphicalProps.singular.push(prop);
      }
    }
    ["dataLabel", "connector"].forEach(function(prop2) {
      var plural = prop2 + "s";
      if (kinds[prop2] && point[plural]) {
        graphicalProps.plural.push(plural);
      }
    });
    return graphicalProps;
  };
  Point4.prototype.getLabelConfig = function() {
    return {
      x: this.category,
      y: this.y,
      color: this.color,
      colorIndex: this.colorIndex,
      key: this.name || this.category,
      series: this.series,
      point: this,
      percentage: this.percentage,
      total: this.total || this.stackTotal
    };
  };
  Point4.prototype.getNestedProperty = function(key) {
    if (!key) {
      return;
    }
    if (key.indexOf("custom.") === 0) {
      return getNestedProperty3(key, this.options);
    }
    return this[key];
  };
  Point4.prototype.getZone = function() {
    var series = this.series, zones = series.zones, zoneAxis = series.zoneAxis || "y";
    var zone, i = 0;
    zone = zones[i];
    while (this[zoneAxis] >= zone.value) {
      zone = zones[++i];
    }
    if (!this.nonZonedColor) {
      this.nonZonedColor = this.color;
    }
    if (zone && zone.color && !this.options.color) {
      this.color = zone.color;
    } else {
      this.color = this.nonZonedColor;
    }
    return zone;
  };
  Point4.prototype.hasNewShapeType = function() {
    var point = this;
    var oldShapeType = point.graphic && (point.graphic.symbolName || point.graphic.element.nodeName);
    return oldShapeType !== this.shapeType;
  };
  Point4.prototype.init = function(series, options, x) {
    this.series = series;
    this.applyOptions(options, x);
    this.id = defined13(this.id) ? this.id : uniqueKey4();
    this.resolveColor();
    series.chart.pointCount++;
    fireEvent7(this, "afterInit");
    return this;
  };
  Point4.prototype.optionsToObject = function(options) {
    var series = this.series, keys2 = series.options.keys, pointArrayMap = keys2 || series.pointArrayMap || ["y"], valueCount = pointArrayMap.length;
    var ret = {}, firstItemType, i = 0, j = 0;
    if (isNumber14(options) || options === null) {
      ret[pointArrayMap[0]] = options;
    } else if (isArray7(options)) {
      if (!keys2 && options.length > valueCount) {
        firstItemType = typeof options[0];
        if (firstItemType === "string") {
          ret.name = options[0];
        } else if (firstItemType === "number") {
          ret.x = options[0];
        }
        i++;
      }
      while (j < valueCount) {
        if (!keys2 || typeof options[i] !== "undefined") {
          if (pointArrayMap[j].indexOf(".") > 0) {
            Point4.prototype.setNestedProperty(ret, options[i], pointArrayMap[j]);
          } else {
            ret[pointArrayMap[j]] = options[i];
          }
        }
        i++;
        j++;
      }
    } else if (typeof options === "object") {
      ret = options;
      if (options.dataLabels) {
        series._hasPointLabels = true;
      }
      if (options.marker) {
        series._hasPointMarkers = true;
      }
    }
    return ret;
  };
  Point4.prototype.resolveColor = function() {
    var series = this.series, optionsChart = series.chart.options.chart, styledMode = series.chart.styledMode;
    var color18, colors, colorCount = optionsChart.colorCount, colorIndex;
    delete this.nonZonedColor;
    if (series.options.colorByPoint) {
      if (!styledMode) {
        colors = series.options.colors || series.chart.options.colors;
        color18 = colors[series.colorCounter];
        colorCount = colors.length;
      }
      colorIndex = series.colorCounter;
      series.colorCounter++;
      if (series.colorCounter === colorCount) {
        series.colorCounter = 0;
      }
    } else {
      if (!styledMode) {
        color18 = series.color;
      }
      colorIndex = series.colorIndex;
    }
    this.colorIndex = pick18(this.options.colorIndex, colorIndex);
    this.color = pick18(this.options.color, color18);
  };
  Point4.prototype.setNestedProperty = function(object, value, key) {
    var nestedKeys = key.split(".");
    nestedKeys.reduce(function(result2, key2, i, arr) {
      var isLastKey = arr.length - 1 === i;
      result2[key2] = isLastKey ? value : isObject5(result2[key2], true) ? result2[key2] : {};
      return result2[key2];
    }, object);
    return object;
  };
  Point4.prototype.tooltipFormatter = function(pointFormat) {
    var series = this.series, seriesTooltipOptions = series.tooltipOptions, valueDecimals = pick18(seriesTooltipOptions.valueDecimals, ""), valuePrefix = seriesTooltipOptions.valuePrefix || "", valueSuffix = seriesTooltipOptions.valueSuffix || "";
    if (series.chart.styledMode) {
      pointFormat = series.chart.tooltip.styledModeFormat(pointFormat);
    }
    (series.pointArrayMap || ["y"]).forEach(function(key) {
      key = "{point." + key;
      if (valuePrefix || valueSuffix) {
        pointFormat = pointFormat.replace(RegExp(key + "}", "g"), valuePrefix + key + "}" + valueSuffix);
      }
      pointFormat = pointFormat.replace(RegExp(key + "}", "g"), key + ":,." + valueDecimals + "f}");
    });
    return format3(pointFormat, {
      point: this,
      series: this.series
    }, series.chart);
  };
  Point4.prototype.update = function(options, redraw, animation, runEvent) {
    var point = this, series = point.series, graphic = point.graphic, chart = series.chart, seriesOptions = series.options;
    var i;
    redraw = pick18(redraw, true);
    function update() {
      point.applyOptions(options);
      var hasDummyGraphic = graphic && point.hasDummyGraphic;
      var shouldDestroyGraphic = point.y === null ? !hasDummyGraphic : hasDummyGraphic;
      if (graphic && shouldDestroyGraphic) {
        point.graphic = graphic.destroy();
        delete point.hasDummyGraphic;
      }
      if (isObject5(options, true)) {
        if (graphic && graphic.element) {
          if (options && options.marker && typeof options.marker.symbol !== "undefined") {
            point.graphic = graphic.destroy();
          }
        }
        if (options && options.dataLabels && point.dataLabel) {
          point.dataLabel = point.dataLabel.destroy();
        }
        if (point.connector) {
          point.connector = point.connector.destroy();
        }
      }
      i = point.index;
      series.updateParallelArrays(point, i);
      seriesOptions.data[i] = isObject5(seriesOptions.data[i], true) || isObject5(options, true) ? point.options : pick18(options, seriesOptions.data[i]);
      series.isDirty = series.isDirtyData = true;
      if (!series.fixedBox && series.hasCartesianSeries) {
        chart.isDirtyBox = true;
      }
      if (seriesOptions.legendType === "point") {
        chart.isDirtyLegend = true;
      }
      if (redraw) {
        chart.redraw(animation);
      }
    }
    if (runEvent === false) {
      update();
    } else {
      point.firePointEvent("update", { options }, update);
    }
  };
  Point4.prototype.remove = function(redraw, animation) {
    this.series.removePoint(this.series.data.indexOf(this), redraw, animation);
  };
  Point4.prototype.select = function(selected, accumulate) {
    var point = this, series = point.series, chart = series.chart;
    selected = pick18(selected, !point.selected);
    this.selectedStaging = selected;
    point.firePointEvent(selected ? "select" : "unselect", { accumulate }, function() {
      point.selected = point.options.selected = selected;
      series.options.data[series.data.indexOf(point)] = point.options;
      point.setState(selected && "select");
      if (!accumulate) {
        chart.getSelectedPoints().forEach(function(loopPoint) {
          var loopSeries = loopPoint.series;
          if (loopPoint.selected && loopPoint !== point) {
            loopPoint.selected = loopPoint.options.selected = false;
            loopSeries.options.data[loopSeries.data.indexOf(loopPoint)] = loopPoint.options;
            loopPoint.setState(chart.hoverPoints && loopSeries.options.inactiveOtherPoints ? "inactive" : "");
            loopPoint.firePointEvent("unselect");
          }
        });
      }
    });
    delete this.selectedStaging;
  };
  Point4.prototype.onMouseOver = function(e2) {
    var point = this, series = point.series, chart = series.chart, pointer = chart.pointer;
    e2 = e2 ? pointer.normalize(e2) : pointer.getChartCoordinatesFromPoint(point, chart.inverted);
    pointer.runPointActions(e2, point);
  };
  Point4.prototype.onMouseOut = function() {
    var point = this, chart = point.series.chart;
    point.firePointEvent("mouseOut");
    if (!point.series.options.inactiveOtherPoints) {
      (chart.hoverPoints || []).forEach(function(p) {
        p.setState();
      });
    }
    chart.hoverPoints = chart.hoverPoint = null;
  };
  Point4.prototype.importEvents = function() {
    if (!this.hasImportedEvents) {
      var point_1 = this, options = merge13(point_1.series.options.point, point_1.options), events = options.events;
      point_1.events = events;
      objectEach12(events, function(event, eventType) {
        if (isFunction4(event)) {
          addEvent8(point_1, eventType, event);
        }
      });
      this.hasImportedEvents = true;
    }
  };
  Point4.prototype.setState = function(state, move) {
    var point = this, series = point.series, previousState = point.state, stateOptions = series.options.states[state || "normal"] || {}, markerOptions = defaultOptions4.plotOptions[series.type].marker && series.options.marker, normalDisabled = markerOptions && markerOptions.enabled === false, markerStateOptions = markerOptions && markerOptions.states && markerOptions.states[state || "normal"] || {}, stateDisabled = markerStateOptions.enabled === false, pointMarker = point.marker || {}, chart = series.chart, hasMarkers = markerOptions && series.markerAttribs;
    var halo = series.halo, markerAttribs, pointAttribs2, pointAttribsAnimation, stateMarkerGraphic = series.stateMarkerGraphic, newSymbol;
    state = state || "";
    if (state === point.state && !move || point.selected && state !== "select" || stateOptions.enabled === false || state && (stateDisabled || normalDisabled && markerStateOptions.enabled === false) || state && pointMarker.states && pointMarker.states[state] && pointMarker.states[state].enabled === false) {
      return;
    }
    point.state = state;
    if (hasMarkers) {
      markerAttribs = series.markerAttribs(point, state);
    }
    if (point.graphic && !point.hasDummyGraphic) {
      if (previousState) {
        point.graphic.removeClass("highcharts-point-" + previousState);
      }
      if (state) {
        point.graphic.addClass("highcharts-point-" + state);
      }
      if (!chart.styledMode) {
        pointAttribs2 = series.pointAttribs(point, state);
        pointAttribsAnimation = pick18(chart.options.chart.animation, stateOptions.animation);
        if (series.options.inactiveOtherPoints && isNumber14(pointAttribs2.opacity)) {
          (point.dataLabels || []).forEach(function(label) {
            if (label) {
              label.animate({
                opacity: pointAttribs2.opacity
              }, pointAttribsAnimation);
            }
          });
          if (point.connector) {
            point.connector.animate({
              opacity: pointAttribs2.opacity
            }, pointAttribsAnimation);
          }
        }
        point.graphic.animate(pointAttribs2, pointAttribsAnimation);
      }
      if (markerAttribs) {
        point.graphic.animate(markerAttribs, pick18(chart.options.chart.animation, markerStateOptions.animation, markerOptions.animation));
      }
      if (stateMarkerGraphic) {
        stateMarkerGraphic.hide();
      }
    } else {
      if (state && markerStateOptions) {
        newSymbol = pointMarker.symbol || series.symbol;
        if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {
          stateMarkerGraphic = stateMarkerGraphic.destroy();
        }
        if (markerAttribs) {
          if (!stateMarkerGraphic) {
            if (newSymbol) {
              series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(newSymbol, markerAttribs.x, markerAttribs.y, markerAttribs.width, markerAttribs.height).add(series.markerGroup);
              stateMarkerGraphic.currentSymbol = newSymbol;
            }
          } else {
            stateMarkerGraphic[move ? "animate" : "attr"]({
              x: markerAttribs.x,
              y: markerAttribs.y
            });
          }
        }
        if (!chart.styledMode && stateMarkerGraphic) {
          stateMarkerGraphic.attr(series.pointAttribs(point, state));
        }
      }
      if (stateMarkerGraphic) {
        stateMarkerGraphic[state && point.isInside ? "show" : "hide"]();
        stateMarkerGraphic.element.point = point;
        stateMarkerGraphic.addClass(point.getClassName(), true);
      }
    }
    var haloOptions = stateOptions.halo;
    var markerGraphic = point.graphic || stateMarkerGraphic;
    var markerVisibility = markerGraphic && markerGraphic.visibility || "inherit";
    if (haloOptions && haloOptions.size && markerGraphic && markerVisibility !== "hidden" && !point.isCluster) {
      if (!halo) {
        series.halo = halo = chart.renderer.path().add(markerGraphic.parentGroup);
      }
      halo.show()[move ? "animate" : "attr"]({
        d: point.haloPath(haloOptions.size)
      });
      halo.attr({
        "class": "highcharts-halo highcharts-color-" + pick18(point.colorIndex, series.colorIndex) + (point.className ? " " + point.className : ""),
        "visibility": markerVisibility,
        "zIndex": -1
      });
      halo.point = point;
      if (!chart.styledMode) {
        halo.attr(extend12({
          "fill": point.color || series.color,
          "fill-opacity": haloOptions.opacity
        }, AST_default.filterUserAttributes(haloOptions.attributes || {})));
      }
    } else if (halo && halo.point && halo.point.haloPath) {
      halo.animate({ d: halo.point.haloPath(0) }, null, halo.hide);
    }
    fireEvent7(point, "afterSetState", { state });
  };
  Point4.prototype.haloPath = function(size) {
    var series = this.series, chart = series.chart;
    return chart.renderer.symbols.circle(Math.floor(this.plotX) - size, this.plotY - size, size * 2, size * 2);
  };
  return Point4;
}();
var Point_default = Point;

// node_modules/highcharts/es-modules/Core/Pointer.js
var color3 = Color_default.parse;
var charts3 = Globals_default.charts;
var noop3 = Globals_default.noop;
var addEvent9 = Utilities_default.addEvent;
var attr8 = Utilities_default.attr;
var css7 = Utilities_default.css;
var defined14 = Utilities_default.defined;
var extend13 = Utilities_default.extend;
var find2 = Utilities_default.find;
var fireEvent8 = Utilities_default.fireEvent;
var isNumber15 = Utilities_default.isNumber;
var isObject6 = Utilities_default.isObject;
var objectEach13 = Utilities_default.objectEach;
var offset2 = Utilities_default.offset;
var pick19 = Utilities_default.pick;
var splat6 = Utilities_default.splat;
var Pointer = function() {
  function Pointer2(chart, options) {
    this.lastValidTouch = {};
    this.pinchDown = [];
    this.runChartClick = false;
    this.eventsToUnbind = [];
    this.chart = chart;
    this.hasDragged = false;
    this.options = options;
    this.init(chart, options);
  }
  Pointer2.prototype.applyInactiveState = function(points) {
    var activeSeries = [], series;
    (points || []).forEach(function(item) {
      series = item.series;
      activeSeries.push(series);
      if (series.linkedParent) {
        activeSeries.push(series.linkedParent);
      }
      if (series.linkedSeries) {
        activeSeries = activeSeries.concat(series.linkedSeries);
      }
      if (series.navigatorSeries) {
        activeSeries.push(series.navigatorSeries);
      }
    });
    this.chart.series.forEach(function(inactiveSeries) {
      if (activeSeries.indexOf(inactiveSeries) === -1) {
        inactiveSeries.setState("inactive", true);
      } else if (inactiveSeries.options.inactiveOtherPoints) {
        inactiveSeries.setAllPointsToState("inactive");
      }
    });
  };
  Pointer2.prototype.destroy = function() {
    var pointer = this;
    this.eventsToUnbind.forEach(function(unbind) {
      return unbind();
    });
    this.eventsToUnbind = [];
    if (!Globals_default.chartCount) {
      if (Pointer2.unbindDocumentMouseUp) {
        Pointer2.unbindDocumentMouseUp = Pointer2.unbindDocumentMouseUp();
      }
      if (Pointer2.unbindDocumentTouchEnd) {
        Pointer2.unbindDocumentTouchEnd = Pointer2.unbindDocumentTouchEnd();
      }
    }
    clearInterval(pointer.tooltipTimeout);
    objectEach13(pointer, function(_val, prop) {
      pointer[prop] = void 0;
    });
  };
  Pointer2.prototype.drag = function(e2) {
    var chart = this.chart, chartOptions = chart.options.chart, zoomHor = this.zoomHor, zoomVert = this.zoomVert, plotLeft = chart.plotLeft, plotTop = chart.plotTop, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, mouseDownX = this.mouseDownX || 0, mouseDownY = this.mouseDownY || 0, panningEnabled = isObject6(chartOptions.panning) ? chartOptions.panning && chartOptions.panning.enabled : chartOptions.panning, panKey = chartOptions.panKey && e2[chartOptions.panKey + "Key"];
    var chartX = e2.chartX, chartY = e2.chartY, clickedInside, size, selectionMarker = this.selectionMarker;
    if (selectionMarker && selectionMarker.touch) {
      return;
    }
    if (chartX < plotLeft) {
      chartX = plotLeft;
    } else if (chartX > plotLeft + plotWidth) {
      chartX = plotLeft + plotWidth;
    }
    if (chartY < plotTop) {
      chartY = plotTop;
    } else if (chartY > plotTop + plotHeight) {
      chartY = plotTop + plotHeight;
    }
    this.hasDragged = Math.sqrt(Math.pow(mouseDownX - chartX, 2) + Math.pow(mouseDownY - chartY, 2));
    if (this.hasDragged > 10) {
      clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop, {
        visiblePlotOnly: true
      });
      if (chart.hasCartesianSeries && (this.zoomX || this.zoomY) && clickedInside && !panKey) {
        if (!selectionMarker) {
          this.selectionMarker = selectionMarker = chart.renderer.rect(plotLeft, plotTop, zoomHor ? 1 : plotWidth, zoomVert ? 1 : plotHeight, 0).attr({
            "class": "highcharts-selection-marker",
            zIndex: 7
          }).add();
          if (!chart.styledMode) {
            selectionMarker.attr({
              fill: chartOptions.selectionMarkerFill || color3(Palette_default.highlightColor80).setOpacity(0.25).get()
            });
          }
        }
      }
      if (selectionMarker && zoomHor) {
        size = chartX - mouseDownX;
        selectionMarker.attr({
          width: Math.abs(size),
          x: (size > 0 ? 0 : size) + mouseDownX
        });
      }
      if (selectionMarker && zoomVert) {
        size = chartY - mouseDownY;
        selectionMarker.attr({
          height: Math.abs(size),
          y: (size > 0 ? 0 : size) + mouseDownY
        });
      }
      if (clickedInside && !selectionMarker && panningEnabled) {
        chart.pan(e2, chartOptions.panning);
      }
    }
  };
  Pointer2.prototype.dragStart = function(e2) {
    var chart = this.chart;
    chart.mouseIsDown = e2.type;
    chart.cancelClick = false;
    chart.mouseDownX = this.mouseDownX = e2.chartX;
    chart.mouseDownY = this.mouseDownY = e2.chartY;
  };
  Pointer2.prototype.drop = function(e2) {
    var pointer = this, chart = this.chart, hasPinched = this.hasPinched;
    if (this.selectionMarker) {
      var selectionData_1 = {
        originalEvent: e2,
        xAxis: [],
        yAxis: []
      }, selectionBox = this.selectionMarker, selectionLeft_1 = selectionBox.attr ? selectionBox.attr("x") : selectionBox.x, selectionTop_1 = selectionBox.attr ? selectionBox.attr("y") : selectionBox.y, selectionWidth_1 = selectionBox.attr ? selectionBox.attr("width") : selectionBox.width, selectionHeight_1 = selectionBox.attr ? selectionBox.attr("height") : selectionBox.height;
      var runZoom_1;
      if (this.hasDragged || hasPinched) {
        chart.axes.forEach(function(axis) {
          if (axis.zoomEnabled && defined14(axis.min) && (hasPinched || pointer[{
            xAxis: "zoomX",
            yAxis: "zoomY"
          }[axis.coll]]) && isNumber15(selectionLeft_1) && isNumber15(selectionTop_1)) {
            var horiz = axis.horiz, minPixelPadding = e2.type === "touchend" ? axis.minPixelPadding : 0, selectionMin = axis.toValue((horiz ? selectionLeft_1 : selectionTop_1) + minPixelPadding), selectionMax = axis.toValue((horiz ? selectionLeft_1 + selectionWidth_1 : selectionTop_1 + selectionHeight_1) - minPixelPadding);
            selectionData_1[axis.coll].push({
              axis,
              min: Math.min(selectionMin, selectionMax),
              max: Math.max(selectionMin, selectionMax)
            });
            runZoom_1 = true;
          }
        });
        if (runZoom_1) {
          fireEvent8(chart, "selection", selectionData_1, function(args) {
            chart.zoom(extend13(args, hasPinched ? { animation: false } : null));
          });
        }
      }
      if (isNumber15(chart.index)) {
        this.selectionMarker = this.selectionMarker.destroy();
      }
      if (hasPinched) {
        this.scaleGroups();
      }
    }
    if (chart && isNumber15(chart.index)) {
      css7(chart.container, { cursor: chart._cursor });
      chart.cancelClick = this.hasDragged > 10;
      chart.mouseIsDown = this.hasDragged = this.hasPinched = false;
      this.pinchDown = [];
    }
  };
  Pointer2.prototype.findNearestKDPoint = function(series, shared, e2) {
    var chart = this.chart;
    var hoverPoint = chart.hoverPoint;
    var tooltip = chart.tooltip;
    if (hoverPoint && tooltip && tooltip.isStickyOnContact()) {
      return hoverPoint;
    }
    var closest;
    function sort(p1, p2) {
      var isCloserX = p1.distX - p2.distX, isCloser = p1.dist - p2.dist, isAbove = (p2.series.group && p2.series.group.zIndex) - (p1.series.group && p1.series.group.zIndex);
      var result2;
      if (isCloserX !== 0 && shared) {
        result2 = isCloserX;
      } else if (isCloser !== 0) {
        result2 = isCloser;
      } else if (isAbove !== 0) {
        result2 = isAbove;
      } else {
        result2 = p1.series.index > p2.series.index ? -1 : 1;
      }
      return result2;
    }
    series.forEach(function(s) {
      var noSharedTooltip = s.noSharedTooltip && shared, compareX = !noSharedTooltip && s.options.findNearestPointBy.indexOf("y") < 0, point = s.searchPoint(e2, compareX);
      if (isObject6(point, true) && point.series && (!isObject6(closest, true) || sort(closest, point) > 0)) {
        closest = point;
      }
    });
    return closest;
  };
  Pointer2.prototype.getChartCoordinatesFromPoint = function(point, inverted) {
    var series = point.series, xAxis = series.xAxis, yAxis = series.yAxis, shapeArgs = point.shapeArgs;
    if (xAxis && yAxis) {
      var x = pick19(point.clientX, point.plotX);
      var y = point.plotY || 0;
      if (point.isNode && shapeArgs && isNumber15(shapeArgs.x) && isNumber15(shapeArgs.y)) {
        x = shapeArgs.x;
        y = shapeArgs.y;
      }
      return inverted ? {
        chartX: yAxis.len + yAxis.pos - y,
        chartY: xAxis.len + xAxis.pos - x
      } : {
        chartX: x + xAxis.pos,
        chartY: y + yAxis.pos
      };
    }
    if (shapeArgs && shapeArgs.x && shapeArgs.y) {
      return {
        chartX: shapeArgs.x,
        chartY: shapeArgs.y
      };
    }
  };
  Pointer2.prototype.getChartPosition = function() {
    if (this.chartPosition) {
      return this.chartPosition;
    }
    var container = this.chart.container;
    var pos = offset2(container);
    this.chartPosition = {
      left: pos.left,
      top: pos.top,
      scaleX: 1,
      scaleY: 1
    };
    var offsetWidth = container.offsetWidth;
    var offsetHeight = container.offsetHeight;
    if (offsetWidth > 2 && offsetHeight > 2) {
      this.chartPosition.scaleX = pos.width / offsetWidth;
      this.chartPosition.scaleY = pos.height / offsetHeight;
    }
    return this.chartPosition;
  };
  Pointer2.prototype.getCoordinates = function(e2) {
    var coordinates = {
      xAxis: [],
      yAxis: []
    };
    this.chart.axes.forEach(function(axis) {
      coordinates[axis.isXAxis ? "xAxis" : "yAxis"].push({
        axis,
        value: axis.toValue(e2[axis.horiz ? "chartX" : "chartY"])
      });
    });
    return coordinates;
  };
  Pointer2.prototype.getHoverData = function(existingHoverPoint, existingHoverSeries, series, isDirectTouch, shared, e2) {
    var hoverPoints = [], useExisting = !!(isDirectTouch && existingHoverPoint), filter = function(s) {
      return s.visible && !(!shared && s.directTouch) && pick19(s.options.enableMouseTracking, true);
    };
    var hoverSeries = existingHoverSeries, searchSeries, eventArgs = {
      chartX: e2 ? e2.chartX : void 0,
      chartY: e2 ? e2.chartY : void 0,
      shared
    };
    fireEvent8(this, "beforeGetHoverData", eventArgs);
    var notSticky = hoverSeries && !hoverSeries.stickyTracking;
    searchSeries = notSticky ? [hoverSeries] : series.filter(function(s) {
      return eventArgs.filter ? eventArgs.filter(s) : filter(s) && s.stickyTracking;
    });
    var hoverPoint = useExisting || !e2 ? existingHoverPoint : this.findNearestKDPoint(searchSeries, shared, e2);
    hoverSeries = hoverPoint && hoverPoint.series;
    if (hoverPoint) {
      if (shared && !hoverSeries.noSharedTooltip) {
        searchSeries = series.filter(function(s) {
          return eventArgs.filter ? eventArgs.filter(s) : filter(s) && !s.noSharedTooltip;
        });
        searchSeries.forEach(function(s) {
          var point = find2(s.points, function(p) {
            return p.x === hoverPoint.x && !p.isNull;
          });
          if (isObject6(point)) {
            if (s.chart.isBoosting) {
              point = s.getPoint(point);
            }
            hoverPoints.push(point);
          }
        });
      } else {
        hoverPoints.push(hoverPoint);
      }
    }
    eventArgs = { hoverPoint };
    fireEvent8(this, "afterGetHoverData", eventArgs);
    return {
      hoverPoint: eventArgs.hoverPoint,
      hoverSeries,
      hoverPoints
    };
  };
  Pointer2.prototype.getPointFromEvent = function(e2) {
    var target = e2.target, point;
    while (target && !point) {
      point = target.point;
      target = target.parentNode;
    }
    return point;
  };
  Pointer2.prototype.onTrackerMouseOut = function(e2) {
    var chart = this.chart;
    var relatedTarget = e2.relatedTarget || e2.toElement;
    var series = chart.hoverSeries;
    this.isDirectTouch = false;
    if (series && relatedTarget && !series.stickyTracking && !this.inClass(relatedTarget, "highcharts-tooltip") && (!this.inClass(relatedTarget, "highcharts-series-" + series.index) || !this.inClass(relatedTarget, "highcharts-tracker"))) {
      series.onMouseOut();
    }
  };
  Pointer2.prototype.inClass = function(element, className) {
    var elemClassName;
    while (element) {
      elemClassName = attr8(element, "class");
      if (elemClassName) {
        if (elemClassName.indexOf(className) !== -1) {
          return true;
        }
        if (elemClassName.indexOf("highcharts-container") !== -1) {
          return false;
        }
      }
      element = element.parentNode;
    }
  };
  Pointer2.prototype.init = function(chart, options) {
    this.options = options;
    this.chart = chart;
    this.runChartClick = Boolean(options.chart.events && options.chart.events.click);
    this.pinchDown = [];
    this.lastValidTouch = {};
    if (Tooltip_default) {
      chart.tooltip = new Tooltip_default(chart, options.tooltip);
      this.followTouchMove = pick19(options.tooltip.followTouchMove, true);
    }
    this.setDOMEvents();
  };
  Pointer2.prototype.normalize = function(e2, chartPosition) {
    var touches2 = e2.touches;
    var ePos = touches2 ? touches2.length ? touches2.item(0) : pick19(touches2.changedTouches, e2.changedTouches)[0] : e2;
    if (!chartPosition) {
      chartPosition = this.getChartPosition();
    }
    var chartX = ePos.pageX - chartPosition.left, chartY = ePos.pageY - chartPosition.top;
    chartX /= chartPosition.scaleX;
    chartY /= chartPosition.scaleY;
    return extend13(e2, {
      chartX: Math.round(chartX),
      chartY: Math.round(chartY)
    });
  };
  Pointer2.prototype.onContainerClick = function(e2) {
    var chart = this.chart;
    var hoverPoint = chart.hoverPoint;
    var pEvt = this.normalize(e2);
    var plotLeft = chart.plotLeft;
    var plotTop = chart.plotTop;
    if (!chart.cancelClick) {
      if (hoverPoint && this.inClass(pEvt.target, "highcharts-tracker")) {
        fireEvent8(hoverPoint.series, "click", extend13(pEvt, {
          point: hoverPoint
        }));
        if (chart.hoverPoint) {
          hoverPoint.firePointEvent("click", pEvt);
        }
      } else {
        extend13(pEvt, this.getCoordinates(pEvt));
        if (chart.isInsidePlot(pEvt.chartX - plotLeft, pEvt.chartY - plotTop, {
          visiblePlotOnly: true
        })) {
          fireEvent8(chart, "click", pEvt);
        }
      }
    }
  };
  Pointer2.prototype.onContainerMouseDown = function(e2) {
    var isPrimaryButton = ((e2.buttons || e2.button) & 1) === 1;
    e2 = this.normalize(e2);
    if (Globals_default.isFirefox && e2.button !== 0) {
      this.onContainerMouseMove(e2);
    }
    if (typeof e2.button === "undefined" || isPrimaryButton) {
      this.zoomOption(e2);
      if (isPrimaryButton && e2.preventDefault) {
        e2.preventDefault();
      }
      this.dragStart(e2);
    }
  };
  Pointer2.prototype.onContainerMouseLeave = function(e2) {
    var chart = charts3[pick19(Pointer2.hoverChartIndex, -1)];
    var tooltip = this.chart.tooltip;
    if (tooltip && tooltip.shouldStickOnContact() && this.inClass(e2.relatedTarget, "highcharts-tooltip-container")) {
      return;
    }
    e2 = this.normalize(e2);
    if (chart && (e2.relatedTarget || e2.toElement)) {
      chart.pointer.reset();
      chart.pointer.chartPosition = void 0;
    }
    if (tooltip && !tooltip.isHidden) {
      this.reset();
    }
  };
  Pointer2.prototype.onContainerMouseEnter = function(e2) {
    delete this.chartPosition;
  };
  Pointer2.prototype.onContainerMouseMove = function(e2) {
    var chart = this.chart;
    var pEvt = this.normalize(e2);
    this.setHoverChartIndex();
    if (!pEvt.preventDefault) {
      pEvt.returnValue = false;
    }
    if (chart.mouseIsDown === "mousedown" || this.touchSelect(pEvt)) {
      this.drag(pEvt);
    }
    if (!chart.openMenu && (this.inClass(pEvt.target, "highcharts-tracker") || chart.isInsidePlot(pEvt.chartX - chart.plotLeft, pEvt.chartY - chart.plotTop, {
      visiblePlotOnly: true
    }))) {
      if (this.inClass(pEvt.target, "highcharts-no-tooltip")) {
        this.reset(false, 0);
      } else {
        this.runPointActions(pEvt);
      }
    }
  };
  Pointer2.prototype.onDocumentTouchEnd = function(e2) {
    var hoverChart = charts3[pick19(Pointer2.hoverChartIndex, -1)];
    if (hoverChart) {
      hoverChart.pointer.drop(e2);
    }
  };
  Pointer2.prototype.onContainerTouchMove = function(e2) {
    if (this.touchSelect(e2)) {
      this.onContainerMouseMove(e2);
    } else {
      this.touch(e2);
    }
  };
  Pointer2.prototype.onContainerTouchStart = function(e2) {
    if (this.touchSelect(e2)) {
      this.onContainerMouseDown(e2);
    } else {
      this.zoomOption(e2);
      this.touch(e2, true);
    }
  };
  Pointer2.prototype.onDocumentMouseMove = function(e2) {
    var chart = this.chart;
    var chartPosition = this.chartPosition;
    var pEvt = this.normalize(e2, chartPosition);
    var tooltip = chart.tooltip;
    if (chartPosition && (!tooltip || !tooltip.isStickyOnContact()) && !chart.isInsidePlot(pEvt.chartX - chart.plotLeft, pEvt.chartY - chart.plotTop, {
      visiblePlotOnly: true
    }) && !this.inClass(pEvt.target, "highcharts-tracker")) {
      this.reset();
    }
  };
  Pointer2.prototype.onDocumentMouseUp = function(e2) {
    var chart = charts3[pick19(Pointer2.hoverChartIndex, -1)];
    if (chart) {
      chart.pointer.drop(e2);
    }
  };
  Pointer2.prototype.pinch = function(e2) {
    var self = this, chart = self.chart, pinchDown = self.pinchDown, touches2 = e2.touches || [], touchesLength = touches2.length, lastValidTouch = self.lastValidTouch, hasZoom = self.hasZoom, transform = {}, fireClickEvent = touchesLength === 1 && (self.inClass(e2.target, "highcharts-tracker") && chart.runTrackerClick || self.runChartClick), clip = {};
    var selectionMarker = self.selectionMarker;
    if (touchesLength > 1) {
      self.initiated = true;
    } else if (touchesLength === 1 && this.followTouchMove) {
      self.initiated = false;
    }
    if (hasZoom && self.initiated && !fireClickEvent && e2.cancelable !== false) {
      e2.preventDefault();
    }
    [].map.call(touches2, function(e3) {
      return self.normalize(e3);
    });
    if (e2.type === "touchstart") {
      [].forEach.call(touches2, function(e3, i) {
        pinchDown[i] = { chartX: e3.chartX, chartY: e3.chartY };
      });
      lastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] && pinchDown[1].chartX];
      lastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] && pinchDown[1].chartY];
      chart.axes.forEach(function(axis) {
        if (axis.zoomEnabled) {
          var bounds = chart.bounds[axis.horiz ? "h" : "v"], minPixelPadding = axis.minPixelPadding, min = axis.toPixels(Math.min(pick19(axis.options.min, axis.dataMin), axis.dataMin)), max = axis.toPixels(Math.max(pick19(axis.options.max, axis.dataMax), axis.dataMax)), absMin = Math.min(min, max), absMax = Math.max(min, max);
          bounds.min = Math.min(axis.pos, absMin - minPixelPadding);
          bounds.max = Math.max(axis.pos + axis.len, absMax + minPixelPadding);
        }
      });
      self.res = true;
    } else if (self.followTouchMove && touchesLength === 1) {
      this.runPointActions(self.normalize(e2));
    } else if (pinchDown.length) {
      if (!selectionMarker) {
        self.selectionMarker = selectionMarker = extend13({
          destroy: noop3,
          touch: true
        }, chart.plotBox);
      }
      self.pinchTranslate(pinchDown, touches2, transform, selectionMarker, clip, lastValidTouch);
      self.hasPinched = hasZoom;
      self.scaleGroups(transform, clip);
      if (self.res) {
        self.res = false;
        this.reset(false, 0);
      }
    }
  };
  Pointer2.prototype.pinchTranslate = function(pinchDown, touches2, transform, selectionMarker, clip, lastValidTouch) {
    if (this.zoomHor) {
      this.pinchTranslateDirection(true, pinchDown, touches2, transform, selectionMarker, clip, lastValidTouch);
    }
    if (this.zoomVert) {
      this.pinchTranslateDirection(false, pinchDown, touches2, transform, selectionMarker, clip, lastValidTouch);
    }
  };
  Pointer2.prototype.pinchTranslateDirection = function(horiz, pinchDown, touches2, transform, selectionMarker, clip, lastValidTouch, forcedScale) {
    var chart = this.chart, xy = horiz ? "x" : "y", XY = horiz ? "X" : "Y", sChartXY = "chart" + XY, wh = horiz ? "width" : "height", plotLeftTop = chart["plot" + (horiz ? "Left" : "Top")], inverted = chart.inverted, bounds = chart.bounds[horiz ? "h" : "v"], singleTouch = pinchDown.length === 1, touch0Start = pinchDown[0][sChartXY], touch1Start = !singleTouch && pinchDown[1][sChartXY], setScale = function() {
      if (typeof touch1Now === "number" && Math.abs(touch0Start - touch1Start) > 20) {
        scale = forcedScale || Math.abs(touch0Now - touch1Now) / Math.abs(touch0Start - touch1Start);
      }
      clipXY = (plotLeftTop - touch0Now) / scale + touch0Start;
      selectionWH = chart["plot" + (horiz ? "Width" : "Height")] / scale;
    };
    var selectionWH, selectionXY, clipXY, scale = forcedScale || 1, touch0Now = touches2[0][sChartXY], touch1Now = !singleTouch && touches2[1][sChartXY], outOfBounds;
    setScale();
    selectionXY = clipXY;
    if (selectionXY < bounds.min) {
      selectionXY = bounds.min;
      outOfBounds = true;
    } else if (selectionXY + selectionWH > bounds.max) {
      selectionXY = bounds.max - selectionWH;
      outOfBounds = true;
    }
    if (outOfBounds) {
      touch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);
      if (typeof touch1Now === "number") {
        touch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);
      }
      setScale();
    } else {
      lastValidTouch[xy] = [touch0Now, touch1Now];
    }
    if (!inverted) {
      clip[xy] = clipXY - plotLeftTop;
      clip[wh] = selectionWH;
    }
    var scaleKey = inverted ? horiz ? "scaleY" : "scaleX" : "scale" + XY;
    var transformScale = inverted ? 1 / scale : scale;
    selectionMarker[wh] = selectionWH;
    selectionMarker[xy] = selectionXY;
    transform[scaleKey] = scale;
    transform["translate" + XY] = transformScale * plotLeftTop + (touch0Now - transformScale * touch0Start);
  };
  Pointer2.prototype.reset = function(allowMove, delay) {
    var pointer = this, chart = pointer.chart, hoverSeries = chart.hoverSeries, hoverPoint = chart.hoverPoint, hoverPoints = chart.hoverPoints, tooltip = chart.tooltip, tooltipPoints = tooltip && tooltip.shared ? hoverPoints : hoverPoint;
    if (allowMove && tooltipPoints) {
      splat6(tooltipPoints).forEach(function(point) {
        if (point.series.isCartesian && typeof point.plotX === "undefined") {
          allowMove = false;
        }
      });
    }
    if (allowMove) {
      if (tooltip && tooltipPoints && splat6(tooltipPoints).length) {
        tooltip.refresh(tooltipPoints);
        if (tooltip.shared && hoverPoints) {
          hoverPoints.forEach(function(point) {
            point.setState(point.state, true);
            if (point.series.isCartesian) {
              if (point.series.xAxis.crosshair) {
                point.series.xAxis.drawCrosshair(null, point);
              }
              if (point.series.yAxis.crosshair) {
                point.series.yAxis.drawCrosshair(null, point);
              }
            }
          });
        } else if (hoverPoint) {
          hoverPoint.setState(hoverPoint.state, true);
          chart.axes.forEach(function(axis) {
            if (axis.crosshair && hoverPoint.series[axis.coll] === axis) {
              axis.drawCrosshair(null, hoverPoint);
            }
          });
        }
      }
    } else {
      if (hoverPoint) {
        hoverPoint.onMouseOut();
      }
      if (hoverPoints) {
        hoverPoints.forEach(function(point) {
          point.setState();
        });
      }
      if (hoverSeries) {
        hoverSeries.onMouseOut();
      }
      if (tooltip) {
        tooltip.hide(delay);
      }
      if (pointer.unDocMouseMove) {
        pointer.unDocMouseMove = pointer.unDocMouseMove();
      }
      chart.axes.forEach(function(axis) {
        axis.hideCrosshair();
      });
      pointer.hoverX = chart.hoverPoints = chart.hoverPoint = null;
    }
  };
  Pointer2.prototype.runPointActions = function(e2, p) {
    var pointer = this, chart = pointer.chart, series = chart.series, tooltip = chart.tooltip && chart.tooltip.options.enabled ? chart.tooltip : void 0, shared = tooltip ? tooltip.shared : false;
    var hoverPoint = p || chart.hoverPoint, hoverSeries = hoverPoint && hoverPoint.series || chart.hoverSeries;
    var isDirectTouch = (!e2 || e2.type !== "touchmove") && (!!p || hoverSeries && hoverSeries.directTouch && pointer.isDirectTouch), hoverData = this.getHoverData(hoverPoint, hoverSeries, series, isDirectTouch, shared, e2);
    hoverPoint = hoverData.hoverPoint;
    hoverSeries = hoverData.hoverSeries;
    var points = hoverData.hoverPoints, followPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer && !hoverSeries.tooltipOptions.split, useSharedTooltip = shared && hoverSeries && !hoverSeries.noSharedTooltip;
    if (hoverPoint && (hoverPoint !== chart.hoverPoint || tooltip && tooltip.isHidden)) {
      (chart.hoverPoints || []).forEach(function(p2) {
        if (points.indexOf(p2) === -1) {
          p2.setState();
        }
      });
      if (chart.hoverSeries !== hoverSeries) {
        hoverSeries.onMouseOver();
      }
      pointer.applyInactiveState(points);
      (points || []).forEach(function(p2) {
        p2.setState("hover");
      });
      if (chart.hoverPoint) {
        chart.hoverPoint.firePointEvent("mouseOut");
      }
      if (!hoverPoint.series) {
        return;
      }
      chart.hoverPoints = points;
      chart.hoverPoint = hoverPoint;
      hoverPoint.firePointEvent("mouseOver");
      if (tooltip) {
        tooltip.refresh(useSharedTooltip ? points : hoverPoint, e2);
      }
    } else if (followPointer && tooltip && !tooltip.isHidden) {
      var anchor = tooltip.getAnchor([{}], e2);
      if (chart.isInsidePlot(anchor[0], anchor[1], {
        visiblePlotOnly: true
      })) {
        tooltip.updatePosition({ plotX: anchor[0], plotY: anchor[1] });
      }
    }
    if (!pointer.unDocMouseMove) {
      pointer.unDocMouseMove = addEvent9(chart.container.ownerDocument, "mousemove", function(e3) {
        var chart2 = charts3[Pointer2.hoverChartIndex];
        if (chart2) {
          chart2.pointer.onDocumentMouseMove(e3);
        }
      });
      pointer.eventsToUnbind.push(pointer.unDocMouseMove);
    }
    chart.axes.forEach(function drawAxisCrosshair(axis) {
      var snap = pick19((axis.crosshair || {}).snap, true);
      var point;
      if (snap) {
        point = chart.hoverPoint;
        if (!point || point.series[axis.coll] !== axis) {
          point = find2(points, function(p2) {
            return p2.series[axis.coll] === axis;
          });
        }
      }
      if (point || !snap) {
        axis.drawCrosshair(e2, point);
      } else {
        axis.hideCrosshair();
      }
    });
  };
  Pointer2.prototype.scaleGroups = function(attribs, clip) {
    var chart = this.chart;
    chart.series.forEach(function(series) {
      var seriesAttribs = attribs || series.getPlotBox();
      if (series.xAxis && series.xAxis.zoomEnabled && series.group) {
        series.group.attr(seriesAttribs);
        if (series.markerGroup) {
          series.markerGroup.attr(seriesAttribs);
          series.markerGroup.clip(clip ? chart.clipRect : null);
        }
        if (series.dataLabelsGroup) {
          series.dataLabelsGroup.attr(seriesAttribs);
        }
      }
    });
    chart.clipRect.attr(clip || chart.clipBox);
  };
  Pointer2.prototype.setDOMEvents = function() {
    var _this = this;
    var container = this.chart.container, ownerDoc = container.ownerDocument;
    container.onmousedown = this.onContainerMouseDown.bind(this);
    container.onmousemove = this.onContainerMouseMove.bind(this);
    container.onclick = this.onContainerClick.bind(this);
    this.eventsToUnbind.push(addEvent9(container, "mouseenter", this.onContainerMouseEnter.bind(this)));
    this.eventsToUnbind.push(addEvent9(container, "mouseleave", this.onContainerMouseLeave.bind(this)));
    if (!Pointer2.unbindDocumentMouseUp) {
      Pointer2.unbindDocumentMouseUp = addEvent9(ownerDoc, "mouseup", this.onDocumentMouseUp.bind(this));
    }
    var parent = this.chart.renderTo.parentElement;
    while (parent && parent.tagName !== "BODY") {
      this.eventsToUnbind.push(addEvent9(parent, "scroll", function() {
        delete _this.chartPosition;
      }));
      parent = parent.parentElement;
    }
    if (Globals_default.hasTouch) {
      this.eventsToUnbind.push(addEvent9(container, "touchstart", this.onContainerTouchStart.bind(this), { passive: false }));
      this.eventsToUnbind.push(addEvent9(container, "touchmove", this.onContainerTouchMove.bind(this), { passive: false }));
      if (!Pointer2.unbindDocumentTouchEnd) {
        Pointer2.unbindDocumentTouchEnd = addEvent9(ownerDoc, "touchend", this.onDocumentTouchEnd.bind(this), { passive: false });
      }
    }
  };
  Pointer2.prototype.setHoverChartIndex = function() {
    var chart = this.chart;
    var hoverChart = Globals_default.charts[pick19(Pointer2.hoverChartIndex, -1)];
    if (hoverChart && hoverChart !== chart) {
      hoverChart.pointer.onContainerMouseLeave({ relatedTarget: true });
    }
    if (!hoverChart || !hoverChart.mouseIsDown) {
      Pointer2.hoverChartIndex = chart.index;
    }
  };
  Pointer2.prototype.touch = function(e2, start) {
    var chart = this.chart;
    var hasMoved, pinchDown, isInside;
    this.setHoverChartIndex();
    if (e2.touches.length === 1) {
      e2 = this.normalize(e2);
      isInside = chart.isInsidePlot(e2.chartX - chart.plotLeft, e2.chartY - chart.plotTop, {
        visiblePlotOnly: true
      });
      if (isInside && !chart.openMenu) {
        if (start) {
          this.runPointActions(e2);
        }
        if (e2.type === "touchmove") {
          pinchDown = this.pinchDown;
          hasMoved = pinchDown[0] ? Math.sqrt(Math.pow(pinchDown[0].chartX - e2.chartX, 2) + Math.pow(pinchDown[0].chartY - e2.chartY, 2)) >= 4 : false;
        }
        if (pick19(hasMoved, true)) {
          this.pinch(e2);
        }
      } else if (start) {
        this.reset();
      }
    } else if (e2.touches.length === 2) {
      this.pinch(e2);
    }
  };
  Pointer2.prototype.touchSelect = function(e2) {
    return Boolean(this.chart.options.chart.zoomBySingleTouch && e2.touches && e2.touches.length === 1);
  };
  Pointer2.prototype.zoomOption = function(e2) {
    var chart = this.chart, options = chart.options.chart, inverted = chart.inverted;
    var zoomType = options.zoomType || "", zoomX, zoomY;
    if (/touch/.test(e2.type)) {
      zoomType = pick19(options.pinchType, zoomType);
    }
    this.zoomX = zoomX = /x/.test(zoomType);
    this.zoomY = zoomY = /y/.test(zoomType);
    this.zoomHor = zoomX && !inverted || zoomY && inverted;
    this.zoomVert = zoomY && !inverted || zoomX && inverted;
    this.hasZoom = zoomX || zoomY;
  };
  return Pointer2;
}();
var Pointer_default = Pointer;

// node_modules/highcharts/es-modules/Core/MSPointer.js
var __extends4 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var charts4 = Globals_default.charts;
var doc6 = Globals_default.doc;
var noop4 = Globals_default.noop;
var win8 = Globals_default.win;
var addEvent10 = Utilities_default.addEvent;
var css8 = Utilities_default.css;
var objectEach14 = Utilities_default.objectEach;
var removeEvent6 = Utilities_default.removeEvent;
var touches = {};
var hasPointerEvent = !!win8.PointerEvent;
function getWebkitTouches() {
  var fake = [];
  fake.item = function(i) {
    return this[i];
  };
  objectEach14(touches, function(touch) {
    fake.push({
      pageX: touch.pageX,
      pageY: touch.pageY,
      target: touch.target
    });
  });
  return fake;
}
function translateMSPointer(e2, method, wktype, func) {
  var chart = charts4[Pointer_default.hoverChartIndex || NaN];
  if ((e2.pointerType === "touch" || e2.pointerType === e2.MSPOINTER_TYPE_TOUCH) && chart) {
    var p = chart.pointer;
    func(e2);
    p[method]({
      type: wktype,
      target: e2.currentTarget,
      preventDefault: noop4,
      touches: getWebkitTouches()
    });
  }
}
var MSPointer = function(_super) {
  __extends4(MSPointer2, _super);
  function MSPointer2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MSPointer2.isRequired = function() {
    return !!(!Globals_default.hasTouch && (win8.PointerEvent || win8.MSPointerEvent));
  };
  MSPointer2.prototype.batchMSEvents = function(fn) {
    fn(this.chart.container, hasPointerEvent ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);
    fn(this.chart.container, hasPointerEvent ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);
    fn(doc6, hasPointerEvent ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp);
  };
  MSPointer2.prototype.destroy = function() {
    this.batchMSEvents(removeEvent6);
    _super.prototype.destroy.call(this);
  };
  MSPointer2.prototype.init = function(chart, options) {
    _super.prototype.init.call(this, chart, options);
    if (this.hasZoom) {
      css8(chart.container, {
        "-ms-touch-action": "none",
        "touch-action": "none"
      });
    }
  };
  MSPointer2.prototype.onContainerPointerDown = function(e2) {
    translateMSPointer(e2, "onContainerTouchStart", "touchstart", function(e3) {
      touches[e3.pointerId] = {
        pageX: e3.pageX,
        pageY: e3.pageY,
        target: e3.currentTarget
      };
    });
  };
  MSPointer2.prototype.onContainerPointerMove = function(e2) {
    translateMSPointer(e2, "onContainerTouchMove", "touchmove", function(e3) {
      touches[e3.pointerId] = { pageX: e3.pageX, pageY: e3.pageY };
      if (!touches[e3.pointerId].target) {
        touches[e3.pointerId].target = e3.currentTarget;
      }
    });
  };
  MSPointer2.prototype.onDocumentPointerUp = function(e2) {
    translateMSPointer(e2, "onDocumentTouchEnd", "touchend", function(e3) {
      delete touches[e3.pointerId];
    });
  };
  MSPointer2.prototype.setDOMEvents = function() {
    _super.prototype.setDOMEvents.call(this);
    if (this.hasZoom || this.followTouchMove) {
      this.batchMSEvents(addEvent10);
    }
  };
  return MSPointer2;
}(Pointer_default);
var MSPointer_default = MSPointer;

// node_modules/highcharts/es-modules/Core/Legend/Legend.js
var animObject5 = AnimationUtilities_default.animObject;
var setAnimation2 = AnimationUtilities_default.setAnimation;
var format4 = FormatUtilities_default.format;
var isFirefox3 = Globals_default.isFirefox;
var marginNames = Globals_default.marginNames;
var win9 = Globals_default.win;
var distribute2 = RendererUtilities_default.distribute;
var addEvent11 = Utilities_default.addEvent;
var createElement6 = Utilities_default.createElement;
var css9 = Utilities_default.css;
var defined15 = Utilities_default.defined;
var discardElement4 = Utilities_default.discardElement;
var find3 = Utilities_default.find;
var fireEvent9 = Utilities_default.fireEvent;
var isNumber16 = Utilities_default.isNumber;
var merge14 = Utilities_default.merge;
var pick20 = Utilities_default.pick;
var relativeLength3 = Utilities_default.relativeLength;
var stableSort3 = Utilities_default.stableSort;
var syncTimeout6 = Utilities_default.syncTimeout;
var wrap2 = Utilities_default.wrap;
var Legend = function() {
  function Legend2(chart, options) {
    this.allItems = [];
    this.box = void 0;
    this.contentGroup = void 0;
    this.display = false;
    this.group = void 0;
    this.initialItemY = 0;
    this.itemHeight = 0;
    this.itemMarginBottom = 0;
    this.itemMarginTop = 0;
    this.itemX = 0;
    this.itemY = 0;
    this.lastItemY = 0;
    this.lastLineHeight = 0;
    this.legendHeight = 0;
    this.legendWidth = 0;
    this.maxItemWidth = 0;
    this.maxLegendWidth = 0;
    this.offsetWidth = 0;
    this.options = {};
    this.padding = 0;
    this.pages = [];
    this.proximate = false;
    this.scrollGroup = void 0;
    this.symbolHeight = 0;
    this.symbolWidth = 0;
    this.titleHeight = 0;
    this.totalItemWidth = 0;
    this.widthOption = 0;
    this.chart = chart;
    this.init(chart, options);
  }
  Legend2.prototype.init = function(chart, options) {
    this.chart = chart;
    this.setOptions(options);
    if (options.enabled) {
      this.render();
      addEvent11(this.chart, "endResize", function() {
        this.legend.positionCheckboxes();
      });
      if (this.proximate) {
        this.unchartrender = addEvent11(this.chart, "render", function() {
          this.legend.proximatePositions();
          this.legend.positionItems();
        });
      } else if (this.unchartrender) {
        this.unchartrender();
      }
    }
  };
  Legend2.prototype.setOptions = function(options) {
    var padding = pick20(options.padding, 8);
    this.options = options;
    if (!this.chart.styledMode) {
      this.itemStyle = options.itemStyle;
      this.itemHiddenStyle = merge14(this.itemStyle, options.itemHiddenStyle);
    }
    this.itemMarginTop = options.itemMarginTop || 0;
    this.itemMarginBottom = options.itemMarginBottom || 0;
    this.padding = padding;
    this.initialItemY = padding - 5;
    this.symbolWidth = pick20(options.symbolWidth, 16);
    this.pages = [];
    this.proximate = options.layout === "proximate" && !this.chart.inverted;
    this.baseline = void 0;
  };
  Legend2.prototype.update = function(options, redraw) {
    var chart = this.chart;
    this.setOptions(merge14(true, this.options, options));
    this.destroy();
    chart.isDirtyLegend = chart.isDirtyBox = true;
    if (pick20(redraw, true)) {
      chart.redraw();
    }
    fireEvent9(this, "afterUpdate");
  };
  Legend2.prototype.colorizeItem = function(item, visible) {
    item.legendGroup[visible ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");
    if (!this.chart.styledMode) {
      var legend = this, options = legend.options, legendItem = item.legendItem, legendLine = item.legendLine, legendSymbol = item.legendSymbol, hiddenColor = legend.itemHiddenStyle.color, textColor = visible ? options.itemStyle.color : hiddenColor, symbolColor = visible ? item.color || hiddenColor : hiddenColor, markerOptions = item.options && item.options.marker;
      var symbolAttr = { fill: symbolColor };
      if (legendItem) {
        legendItem.css({
          fill: textColor,
          color: textColor
        });
      }
      if (legendLine) {
        legendLine.attr({ stroke: symbolColor });
      }
      if (legendSymbol) {
        if (markerOptions && legendSymbol.isMarker) {
          symbolAttr = item.pointAttribs();
          if (!visible) {
            symbolAttr.stroke = symbolAttr.fill = hiddenColor;
          }
        }
        legendSymbol.attr(symbolAttr);
      }
    }
    fireEvent9(this, "afterColorizeItem", { item, visible });
  };
  Legend2.prototype.positionItems = function() {
    this.allItems.forEach(this.positionItem, this);
    if (!this.chart.isResizing) {
      this.positionCheckboxes();
    }
  };
  Legend2.prototype.positionItem = function(item) {
    var _this = this;
    var legend = this, options = legend.options, symbolPadding = options.symbolPadding, ltr = !options.rtl, legendItemPos = item._legendItemPos, itemX = legendItemPos[0], itemY = legendItemPos[1], checkbox = item.checkbox, legendGroup = item.legendGroup;
    if (legendGroup && legendGroup.element) {
      var attribs = {
        translateX: ltr ? itemX : legend.legendWidth - itemX - 2 * symbolPadding - 4,
        translateY: itemY
      };
      var complete = function() {
        fireEvent9(_this, "afterPositionItem", { item });
      };
      if (defined15(legendGroup.translateY)) {
        legendGroup.animate(attribs, void 0, complete);
      } else {
        legendGroup.attr(attribs);
        complete();
      }
    }
    if (checkbox) {
      checkbox.x = itemX;
      checkbox.y = itemY;
    }
  };
  Legend2.prototype.destroyItem = function(item) {
    var checkbox = item.checkbox;
    ["legendItem", "legendLine", "legendSymbol", "legendGroup"].forEach(function(key) {
      if (item[key]) {
        item[key] = item[key].destroy();
      }
    });
    if (checkbox) {
      discardElement4(item.checkbox);
    }
  };
  Legend2.prototype.destroy = function() {
    function destroyItems(key) {
      if (this[key]) {
        this[key] = this[key].destroy();
      }
    }
    this.getAllItems().forEach(function(item) {
      ["legendItem", "legendGroup"].forEach(destroyItems, item);
    });
    [
      "clipRect",
      "up",
      "down",
      "pager",
      "nav",
      "box",
      "title",
      "group"
    ].forEach(destroyItems, this);
    this.display = null;
  };
  Legend2.prototype.positionCheckboxes = function() {
    var alignAttr = this.group && this.group.alignAttr, clipHeight = this.clipHeight || this.legendHeight, titleHeight = this.titleHeight;
    var translateY;
    if (alignAttr) {
      translateY = alignAttr.translateY;
      this.allItems.forEach(function(item) {
        var checkbox = item.checkbox;
        var top;
        if (checkbox) {
          top = translateY + titleHeight + checkbox.y + (this.scrollOffset || 0) + 3;
          css9(checkbox, {
            left: alignAttr.translateX + item.checkboxOffset + checkbox.x - 20 + "px",
            top: top + "px",
            display: this.proximate || top > translateY - 6 && top < translateY + clipHeight - 6 ? "" : "none"
          });
        }
      }, this);
    }
  };
  Legend2.prototype.renderTitle = function() {
    var options = this.options, padding = this.padding, titleOptions = options.title;
    var bBox, titleHeight = 0;
    if (titleOptions.text) {
      if (!this.title) {
        this.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, null, null, null, options.useHTML, null, "legend-title").attr({ zIndex: 1 });
        if (!this.chart.styledMode) {
          this.title.css(titleOptions.style);
        }
        this.title.add(this.group);
      }
      if (!titleOptions.width) {
        this.title.css({
          width: this.maxLegendWidth + "px"
        });
      }
      bBox = this.title.getBBox();
      titleHeight = bBox.height;
      this.offsetWidth = bBox.width;
      this.contentGroup.attr({ translateY: titleHeight });
    }
    this.titleHeight = titleHeight;
  };
  Legend2.prototype.setText = function(item) {
    var options = this.options;
    item.legendItem.attr({
      text: options.labelFormat ? format4(options.labelFormat, item, this.chart) : options.labelFormatter.call(item)
    });
  };
  Legend2.prototype.renderItem = function(item) {
    var legend = this, chart = legend.chart, renderer = chart.renderer, options = legend.options, horizontal = options.layout === "horizontal", symbolWidth = legend.symbolWidth, symbolPadding = options.symbolPadding || 0, itemStyle = legend.itemStyle, itemHiddenStyle = legend.itemHiddenStyle, itemDistance = horizontal ? pick20(options.itemDistance, 20) : 0, ltr = !options.rtl, isSeries = !item.series, series = !isSeries && item.series.drawLegendSymbol ? item.series : item, seriesOptions = series.options, showCheckbox = legend.createCheckboxForItem && seriesOptions && seriesOptions.showCheckbox, useHTML = options.useHTML, itemClassName = item.options.className;
    var li = item.legendItem, itemExtraWidth = symbolWidth + symbolPadding + itemDistance + (showCheckbox ? 20 : 0);
    if (!li) {
      item.legendGroup = renderer.g("legend-item").addClass("highcharts-" + series.type + "-series highcharts-color-" + item.colorIndex + (itemClassName ? " " + itemClassName : "") + (isSeries ? " highcharts-series-" + item.index : "")).attr({ zIndex: 1 }).add(legend.scrollGroup);
      item.legendItem = li = renderer.text("", ltr ? symbolWidth + symbolPadding : -symbolPadding, legend.baseline || 0, useHTML);
      if (!chart.styledMode) {
        li.css(merge14(item.visible ? itemStyle : itemHiddenStyle));
      }
      li.attr({
        align: ltr ? "left" : "right",
        zIndex: 2
      }).add(item.legendGroup);
      if (!legend.baseline) {
        legend.fontMetrics = renderer.fontMetrics(chart.styledMode ? 12 : itemStyle.fontSize, li);
        legend.baseline = legend.fontMetrics.f + 3 + legend.itemMarginTop;
        li.attr("y", legend.baseline);
        legend.symbolHeight = options.symbolHeight || legend.fontMetrics.f;
        if (options.squareSymbol) {
          legend.symbolWidth = pick20(options.symbolWidth, Math.max(legend.symbolHeight, 16));
          itemExtraWidth = legend.symbolWidth + symbolPadding + itemDistance + (showCheckbox ? 20 : 0);
          if (ltr) {
            li.attr("x", legend.symbolWidth + symbolPadding);
          }
        }
      }
      series.drawLegendSymbol(legend, item);
      if (legend.setItemEvents) {
        legend.setItemEvents(item, li, useHTML);
      }
    }
    if (showCheckbox && !item.checkbox && legend.createCheckboxForItem) {
      legend.createCheckboxForItem(item);
    }
    legend.colorizeItem(item, item.visible);
    if (chart.styledMode || !itemStyle.width) {
      li.css({
        width: (options.itemWidth || legend.widthOption || chart.spacingBox.width) - itemExtraWidth + "px"
      });
    }
    legend.setText(item);
    var bBox = li.getBBox();
    item.itemWidth = item.checkboxOffset = options.itemWidth || item.legendItemWidth || bBox.width + itemExtraWidth;
    legend.maxItemWidth = Math.max(legend.maxItemWidth, item.itemWidth);
    legend.totalItemWidth += item.itemWidth;
    legend.itemHeight = item.itemHeight = Math.round(item.legendItemHeight || bBox.height || legend.symbolHeight);
  };
  Legend2.prototype.layoutItem = function(item) {
    var options = this.options, padding = this.padding, horizontal = options.layout === "horizontal", itemHeight = item.itemHeight, itemMarginBottom = this.itemMarginBottom, itemMarginTop = this.itemMarginTop, itemDistance = horizontal ? pick20(options.itemDistance, 20) : 0, maxLegendWidth = this.maxLegendWidth, itemWidth = options.alignColumns && this.totalItemWidth > maxLegendWidth ? this.maxItemWidth : item.itemWidth;
    if (horizontal && this.itemX - padding + itemWidth > maxLegendWidth) {
      this.itemX = padding;
      if (this.lastLineHeight) {
        this.itemY += itemMarginTop + this.lastLineHeight + itemMarginBottom;
      }
      this.lastLineHeight = 0;
    }
    this.lastItemY = itemMarginTop + this.itemY + itemMarginBottom;
    this.lastLineHeight = Math.max(itemHeight, this.lastLineHeight);
    item._legendItemPos = [this.itemX, this.itemY];
    if (horizontal) {
      this.itemX += itemWidth;
    } else {
      this.itemY += itemMarginTop + itemHeight + itemMarginBottom;
      this.lastLineHeight = itemHeight;
    }
    this.offsetWidth = this.widthOption || Math.max((horizontal ? this.itemX - padding - (item.checkbox ? 0 : itemDistance) : itemWidth) + padding, this.offsetWidth);
  };
  Legend2.prototype.getAllItems = function() {
    var allItems = [];
    this.chart.series.forEach(function(series) {
      var seriesOptions = series && series.options;
      if (series && pick20(seriesOptions.showInLegend, !defined15(seriesOptions.linkedTo) ? void 0 : false, true)) {
        allItems = allItems.concat(series.legendItems || (seriesOptions.legendType === "point" ? series.data : series));
      }
    });
    fireEvent9(this, "afterGetAllItems", { allItems });
    return allItems;
  };
  Legend2.prototype.getAlignment = function() {
    var options = this.options;
    if (this.proximate) {
      return options.align.charAt(0) + "tv";
    }
    return options.floating ? "" : options.align.charAt(0) + options.verticalAlign.charAt(0) + options.layout.charAt(0);
  };
  Legend2.prototype.adjustMargins = function(margin, spacing) {
    var chart = this.chart, options = this.options, alignment = this.getAlignment();
    if (alignment) {
      [
        /(lth|ct|rth)/,
        /(rtv|rm|rbv)/,
        /(rbh|cb|lbh)/,
        /(lbv|lm|ltv)/
      ].forEach(function(alignments, side) {
        if (alignments.test(alignment) && !defined15(margin[side])) {
          chart[marginNames[side]] = Math.max(chart[marginNames[side]], chart.legend[(side + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][side] * options[side % 2 ? "x" : "y"] + pick20(options.margin, 12) + spacing[side] + (chart.titleOffset[side] || 0));
        }
      });
    }
  };
  Legend2.prototype.proximatePositions = function() {
    var chart = this.chart, boxes = [], alignLeft = this.options.align === "left";
    this.allItems.forEach(function(item) {
      var lastPoint, height, useFirstPoint = alignLeft, target, top;
      if (item.yAxis) {
        if (item.xAxis.options.reversed) {
          useFirstPoint = !useFirstPoint;
        }
        if (item.points) {
          lastPoint = find3(useFirstPoint ? item.points : item.points.slice(0).reverse(), function(item2) {
            return isNumber16(item2.plotY);
          });
        }
        height = this.itemMarginTop + item.legendItem.getBBox().height + this.itemMarginBottom;
        top = item.yAxis.top - chart.plotTop;
        if (item.visible) {
          target = lastPoint ? lastPoint.plotY : item.yAxis.height;
          target += top - 0.3 * height;
        } else {
          target = top + item.yAxis.height;
        }
        boxes.push({
          target,
          size: height,
          item
        });
      }
    }, this);
    distribute2(boxes, chart.plotHeight).forEach(function(box) {
      if (box.item._legendItemPos) {
        box.item._legendItemPos[1] = chart.plotTop - chart.spacing[0] + box.pos;
      }
    });
  };
  Legend2.prototype.render = function() {
    var legend = this, chart = legend.chart, renderer = chart.renderer, options = legend.options, padding = legend.padding, allItems = legend.getAllItems();
    var display, legendWidth, legendHeight, legendGroup = legend.group, allowedWidth, box = legend.box;
    legend.itemX = padding;
    legend.itemY = legend.initialItemY;
    legend.offsetWidth = 0;
    legend.lastItemY = 0;
    legend.widthOption = relativeLength3(options.width, chart.spacingBox.width - padding);
    allowedWidth = chart.spacingBox.width - 2 * padding - options.x;
    if (["rm", "lm"].indexOf(legend.getAlignment().substring(0, 2)) > -1) {
      allowedWidth /= 2;
    }
    legend.maxLegendWidth = legend.widthOption || allowedWidth;
    if (!legendGroup) {
      legend.group = legendGroup = renderer.g("legend").addClass(options.className || "").attr({ zIndex: 7 }).add();
      legend.contentGroup = renderer.g().attr({ zIndex: 1 }).add(legendGroup);
      legend.scrollGroup = renderer.g().add(legend.contentGroup);
    }
    legend.renderTitle();
    stableSort3(allItems, function(a, b) {
      return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0);
    });
    if (options.reversed) {
      allItems.reverse();
    }
    legend.allItems = allItems;
    legend.display = display = !!allItems.length;
    legend.lastLineHeight = 0;
    legend.maxItemWidth = 0;
    legend.totalItemWidth = 0;
    legend.itemHeight = 0;
    allItems.forEach(legend.renderItem, legend);
    allItems.forEach(legend.layoutItem, legend);
    legendWidth = (legend.widthOption || legend.offsetWidth) + padding;
    legendHeight = legend.lastItemY + legend.lastLineHeight + legend.titleHeight;
    legendHeight = legend.handleOverflow(legendHeight);
    legendHeight += padding;
    if (!box) {
      legend.box = box = renderer.rect().addClass("highcharts-legend-box").attr({
        r: options.borderRadius
      }).add(legendGroup);
      box.isNew = true;
    }
    if (!chart.styledMode) {
      box.attr({
        stroke: options.borderColor,
        "stroke-width": options.borderWidth || 0,
        fill: options.backgroundColor || "none"
      }).shadow(options.shadow);
    }
    if (legendWidth > 0 && legendHeight > 0) {
      box[box.isNew ? "attr" : "animate"](box.crisp.call({}, {
        x: 0,
        y: 0,
        width: legendWidth,
        height: legendHeight
      }, box.strokeWidth()));
      box.isNew = false;
    }
    box[display ? "show" : "hide"]();
    if (chart.styledMode && legendGroup.getStyle("display") === "none") {
      legendWidth = legendHeight = 0;
    }
    legend.legendWidth = legendWidth;
    legend.legendHeight = legendHeight;
    if (display) {
      legend.align();
    }
    if (!this.proximate) {
      this.positionItems();
    }
    fireEvent9(this, "afterRender");
  };
  Legend2.prototype.align = function(alignTo) {
    if (alignTo === void 0) {
      alignTo = this.chart.spacingBox;
    }
    var chart = this.chart, options = this.options;
    var y = alignTo.y;
    if (/(lth|ct|rth)/.test(this.getAlignment()) && chart.titleOffset[0] > 0) {
      y += chart.titleOffset[0];
    } else if (/(lbh|cb|rbh)/.test(this.getAlignment()) && chart.titleOffset[2] > 0) {
      y -= chart.titleOffset[2];
    }
    if (y !== alignTo.y) {
      alignTo = merge14(alignTo, { y });
    }
    this.group.align(merge14(options, {
      width: this.legendWidth,
      height: this.legendHeight,
      verticalAlign: this.proximate ? "top" : options.verticalAlign
    }), true, alignTo);
  };
  Legend2.prototype.handleOverflow = function(legendHeight) {
    var legend = this, chart = this.chart, renderer = chart.renderer, options = this.options, optionsY = options.y, alignTop = options.verticalAlign === "top", padding = this.padding, maxHeight = options.maxHeight, navOptions = options.navigation, animation = pick20(navOptions.animation, true), arrowSize = navOptions.arrowSize || 12, pages = this.pages, allItems = this.allItems, clipToHeight = function(height) {
      if (typeof height === "number") {
        clipRect.attr({
          height
        });
      } else if (clipRect) {
        legend.clipRect = clipRect.destroy();
        legend.contentGroup.clip();
      }
      if (legend.contentGroup.div) {
        legend.contentGroup.div.style.clip = height ? "rect(" + padding + "px,9999px," + (padding + height) + "px,0)" : "auto";
      }
    }, addTracker = function(key) {
      legend[key] = renderer.circle(0, 0, arrowSize * 1.3).translate(arrowSize / 2, arrowSize / 2).add(nav);
      if (!chart.styledMode) {
        legend[key].attr("fill", "rgba(0,0,0,0.0001)");
      }
      return legend[key];
    };
    var clipHeight, lastY, spaceHeight = chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - padding, nav = this.nav, clipRect = this.clipRect;
    if (options.layout === "horizontal" && options.verticalAlign !== "middle" && !options.floating) {
      spaceHeight /= 2;
    }
    if (maxHeight) {
      spaceHeight = Math.min(spaceHeight, maxHeight);
    }
    pages.length = 0;
    if (legendHeight && spaceHeight > 0 && legendHeight > spaceHeight && navOptions.enabled !== false) {
      this.clipHeight = clipHeight = Math.max(spaceHeight - 20 - this.titleHeight - padding, 0);
      this.currentPage = pick20(this.currentPage, 1);
      this.fullHeight = legendHeight;
      allItems.forEach(function(item, i) {
        var y = item._legendItemPos[1], h = Math.round(item.legendItem.getBBox().height);
        var len = pages.length;
        if (!len || y - pages[len - 1] > clipHeight && (lastY || y) !== pages[len - 1]) {
          pages.push(lastY || y);
          len++;
        }
        item.pageIx = len - 1;
        if (lastY) {
          allItems[i - 1].pageIx = len - 1;
        }
        if (i === allItems.length - 1 && y + h - pages[len - 1] > clipHeight && y !== lastY) {
          pages.push(y);
          item.pageIx = len;
        }
        if (y !== lastY) {
          lastY = y;
        }
      });
      if (!clipRect) {
        clipRect = legend.clipRect = renderer.clipRect(0, padding, 9999, 0);
        legend.contentGroup.clip(clipRect);
      }
      clipToHeight(clipHeight);
      if (!nav) {
        this.nav = nav = renderer.g().attr({ zIndex: 1 }).add(this.group);
        this.up = renderer.symbol("triangle", 0, 0, arrowSize, arrowSize).add(nav);
        addTracker("upTracker").on("click", function() {
          legend.scroll(-1, animation);
        });
        this.pager = renderer.text("", 15, 10).addClass("highcharts-legend-navigation");
        if (!chart.styledMode) {
          this.pager.css(navOptions.style);
        }
        this.pager.add(nav);
        this.down = renderer.symbol("triangle-down", 0, 0, arrowSize, arrowSize).add(nav);
        addTracker("downTracker").on("click", function() {
          legend.scroll(1, animation);
        });
      }
      legend.scroll(0);
      legendHeight = spaceHeight;
    } else if (nav) {
      clipToHeight();
      this.nav = nav.destroy();
      this.scrollGroup.attr({
        translateY: 1
      });
      this.clipHeight = 0;
    }
    return legendHeight;
  };
  Legend2.prototype.scroll = function(scrollBy, animation) {
    var _this = this;
    var chart = this.chart, pages = this.pages, pageCount = pages.length, clipHeight = this.clipHeight, navOptions = this.options.navigation, pager = this.pager, padding = this.padding;
    var currentPage = this.currentPage + scrollBy;
    if (currentPage > pageCount) {
      currentPage = pageCount;
    }
    if (currentPage > 0) {
      if (typeof animation !== "undefined") {
        setAnimation2(animation, chart);
      }
      this.nav.attr({
        translateX: padding,
        translateY: clipHeight + this.padding + 7 + this.titleHeight,
        visibility: "visible"
      });
      [this.up, this.upTracker].forEach(function(elem) {
        elem.attr({
          "class": currentPage === 1 ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
        });
      });
      pager.attr({
        text: currentPage + "/" + pageCount
      });
      [this.down, this.downTracker].forEach(function(elem) {
        elem.attr({
          x: 18 + this.pager.getBBox().width,
          "class": currentPage === pageCount ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
        });
      }, this);
      if (!chart.styledMode) {
        this.up.attr({
          fill: currentPage === 1 ? navOptions.inactiveColor : navOptions.activeColor
        });
        this.upTracker.css({
          cursor: currentPage === 1 ? "default" : "pointer"
        });
        this.down.attr({
          fill: currentPage === pageCount ? navOptions.inactiveColor : navOptions.activeColor
        });
        this.downTracker.css({
          cursor: currentPage === pageCount ? "default" : "pointer"
        });
      }
      this.scrollOffset = -pages[currentPage - 1] + this.initialItemY;
      this.scrollGroup.animate({
        translateY: this.scrollOffset
      });
      this.currentPage = currentPage;
      this.positionCheckboxes();
      var animOptions = animObject5(pick20(animation, chart.renderer.globalAnimation, true));
      syncTimeout6(function() {
        fireEvent9(_this, "afterScroll", { currentPage });
      }, animOptions.duration);
    }
  };
  Legend2.prototype.setItemEvents = function(item, legendItem, useHTML) {
    var legend = this, boxWrapper = legend.chart.renderer.boxWrapper, isPoint = item instanceof Point_default, activeClass = "highcharts-legend-" + (isPoint ? "point" : "series") + "-active", styledMode = legend.chart.styledMode, legendItems = useHTML ? [legendItem, item.legendSymbol] : [item.legendGroup];
    var setOtherItemsState = function(state) {
      legend.allItems.forEach(function(otherItem) {
        if (item !== otherItem) {
          [otherItem].concat(otherItem.linkedSeries || []).forEach(function(otherItem2) {
            otherItem2.setState(state, !isPoint);
          });
        }
      });
    };
    legendItems.forEach(function(element) {
      if (element) {
        element.on("mouseover", function() {
          if (item.visible) {
            setOtherItemsState("inactive");
          }
          item.setState("hover");
          if (item.visible) {
            boxWrapper.addClass(activeClass);
          }
          if (!styledMode) {
            legendItem.css(legend.options.itemHoverStyle);
          }
        }).on("mouseout", function() {
          if (!legend.chart.styledMode) {
            legendItem.css(merge14(item.visible ? legend.itemStyle : legend.itemHiddenStyle));
          }
          setOtherItemsState("");
          boxWrapper.removeClass(activeClass);
          item.setState();
        }).on("click", function(event) {
          var strLegendItemClick = "legendItemClick", fnLegendItemClick = function() {
            if (item.setVisible) {
              item.setVisible();
            }
            setOtherItemsState(item.visible ? "inactive" : "");
          };
          boxWrapper.removeClass(activeClass);
          event = {
            browserEvent: event
          };
          if (item.firePointEvent) {
            item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);
          } else {
            fireEvent9(item, strLegendItemClick, event, fnLegendItemClick);
          }
        });
      }
    });
  };
  Legend2.prototype.createCheckboxForItem = function(item) {
    var legend = this;
    item.checkbox = createElement6("input", {
      type: "checkbox",
      className: "highcharts-legend-checkbox",
      checked: item.selected,
      defaultChecked: item.selected
    }, legend.options.itemCheckboxStyle, legend.chart.container);
    addEvent11(item.checkbox, "click", function(event) {
      var target = event.target;
      fireEvent9(item.series || item, "checkboxClick", {
        checked: target.checked,
        item
      }, function() {
        item.select();
      });
    });
  };
  return Legend2;
}();
if (/Trident\/7\.0/.test(win9.navigator && win9.navigator.userAgent) || isFirefox3) {
  wrap2(Legend.prototype, "positionItem", function(proceed, item) {
    var legend = this, runPositionItem = function() {
      if (item._legendItemPos) {
        proceed.call(legend, item);
      }
    };
    runPositionItem();
    if (!legend.bubbleLegend) {
      setTimeout(runPositionItem);
    }
  });
}
var Legend_default = Legend;

// node_modules/highcharts/es-modules/Core/Series/SeriesRegistry.js
var defaultOptions5 = DefaultOptions_default.defaultOptions;
var error5 = Utilities_default.error;
var extendClass2 = Utilities_default.extendClass;
var merge15 = Utilities_default.merge;
var SeriesRegistry;
(function(SeriesRegistry2) {
  SeriesRegistry2.seriesTypes = Globals_default.seriesTypes;
  function getSeries(chart, options) {
    if (options === void 0) {
      options = {};
    }
    var optionsChart = chart.options.chart, type = options.type || optionsChart.type || optionsChart.defaultSeriesType || "", SeriesClass = SeriesRegistry2.seriesTypes[type];
    if (!SeriesRegistry2) {
      error5(17, true, chart, { missingModuleFor: type });
    }
    var series = new SeriesClass();
    if (typeof series.init === "function") {
      series.init(chart, options);
    }
    return series;
  }
  SeriesRegistry2.getSeries = getSeries;
  function registerSeriesType(seriesType2, seriesClass) {
    var defaultPlotOptions = defaultOptions5.plotOptions || {}, seriesOptions = seriesClass.defaultOptions;
    if (!seriesClass.prototype.pointClass) {
      seriesClass.prototype.pointClass = Point_default;
    }
    seriesClass.prototype.type = seriesType2;
    if (seriesOptions) {
      defaultPlotOptions[seriesType2] = seriesOptions;
    }
    SeriesRegistry2.seriesTypes[seriesType2] = seriesClass;
  }
  SeriesRegistry2.registerSeriesType = registerSeriesType;
  function seriesType(type, parent, options, seriesProto5, pointProto2) {
    var defaultPlotOptions = defaultOptions5.plotOptions || {};
    parent = parent || "";
    defaultPlotOptions[type] = merge15(defaultPlotOptions[parent], options);
    registerSeriesType(type, extendClass2(SeriesRegistry2.seriesTypes[parent] || function() {
    }, seriesProto5));
    SeriesRegistry2.seriesTypes[type].prototype.type = type;
    if (pointProto2) {
      SeriesRegistry2.seriesTypes[type].prototype.pointClass = extendClass2(Point_default, pointProto2);
    }
    return SeriesRegistry2.seriesTypes[type];
  }
  SeriesRegistry2.seriesType = seriesType;
})(SeriesRegistry || (SeriesRegistry = {}));
var SeriesRegistry_default = SeriesRegistry;

// node_modules/highcharts/es-modules/Core/Chart/Chart.js
var animate3 = AnimationUtilities_default.animate;
var animObject6 = AnimationUtilities_default.animObject;
var setAnimation3 = AnimationUtilities_default.setAnimation;
var numberFormat2 = FormatUtilities_default.numberFormat;
var registerEventOptions3 = Foundation_default.registerEventOptions;
var charts5 = Globals_default.charts;
var doc7 = Globals_default.doc;
var marginNames2 = Globals_default.marginNames;
var svg3 = Globals_default.svg;
var win10 = Globals_default.win;
var defaultOptions6 = DefaultOptions_default.defaultOptions;
var defaultTime3 = DefaultOptions_default.defaultTime;
var seriesTypes = SeriesRegistry_default.seriesTypes;
var addEvent12 = Utilities_default.addEvent;
var attr9 = Utilities_default.attr;
var cleanRecursively2 = Utilities_default.cleanRecursively;
var createElement7 = Utilities_default.createElement;
var css10 = Utilities_default.css;
var defined16 = Utilities_default.defined;
var discardElement5 = Utilities_default.discardElement;
var erase7 = Utilities_default.erase;
var error6 = Utilities_default.error;
var extend14 = Utilities_default.extend;
var find4 = Utilities_default.find;
var fireEvent10 = Utilities_default.fireEvent;
var getStyle3 = Utilities_default.getStyle;
var isArray8 = Utilities_default.isArray;
var isFunction5 = Utilities_default.isFunction;
var isNumber17 = Utilities_default.isNumber;
var isObject7 = Utilities_default.isObject;
var isString8 = Utilities_default.isString;
var merge16 = Utilities_default.merge;
var objectEach15 = Utilities_default.objectEach;
var pick21 = Utilities_default.pick;
var pInt7 = Utilities_default.pInt;
var relativeLength4 = Utilities_default.relativeLength;
var removeEvent7 = Utilities_default.removeEvent;
var splat7 = Utilities_default.splat;
var syncTimeout7 = Utilities_default.syncTimeout;
var uniqueKey5 = Utilities_default.uniqueKey;
var Chart = function() {
  function Chart2(a, b, c) {
    this.axes = void 0;
    this.axisOffset = void 0;
    this.bounds = void 0;
    this.chartHeight = void 0;
    this.chartWidth = void 0;
    this.clipBox = void 0;
    this.colorCounter = void 0;
    this.container = void 0;
    this.eventOptions = void 0;
    this.index = void 0;
    this.isResizing = void 0;
    this.labelCollectors = void 0;
    this.legend = void 0;
    this.margin = void 0;
    this.numberFormatter = void 0;
    this.options = void 0;
    this.plotBox = void 0;
    this.plotHeight = void 0;
    this.plotLeft = void 0;
    this.plotTop = void 0;
    this.plotWidth = void 0;
    this.pointCount = void 0;
    this.pointer = void 0;
    this.renderer = void 0;
    this.renderTo = void 0;
    this.series = void 0;
    this.sharedClips = {};
    this.spacing = void 0;
    this.spacingBox = void 0;
    this.symbolCounter = void 0;
    this.time = void 0;
    this.titleOffset = void 0;
    this.userOptions = void 0;
    this.xAxis = void 0;
    this.yAxis = void 0;
    this.getArgs(a, b, c);
  }
  Chart2.chart = function(a, b, c) {
    return new Chart2(a, b, c);
  };
  Chart2.prototype.getArgs = function(a, b, c) {
    if (isString8(a) || a.nodeName) {
      this.renderTo = a;
      this.init(b, c);
    } else {
      this.init(a, b);
    }
  };
  Chart2.prototype.init = function(userOptions, callback) {
    var userPlotOptions = userOptions.plotOptions || {};
    fireEvent10(this, "init", { args: arguments }, function() {
      var options = merge16(defaultOptions6, userOptions);
      var optionsChart = options.chart;
      objectEach15(options.plotOptions, function(typeOptions, type) {
        if (isObject7(typeOptions)) {
          typeOptions.tooltip = userPlotOptions[type] && merge16(userPlotOptions[type].tooltip) || void 0;
        }
      });
      options.tooltip.userOptions = userOptions.chart && userOptions.chart.forExport && userOptions.tooltip.userOptions || userOptions.tooltip;
      this.userOptions = userOptions;
      this.margin = [];
      this.spacing = [];
      this.bounds = { h: {}, v: {} };
      this.labelCollectors = [];
      this.callback = callback;
      this.isResizing = 0;
      this.options = options;
      this.axes = [];
      this.series = [];
      this.time = userOptions.time && Object.keys(userOptions.time).length ? new Time_default(userOptions.time) : Globals_default.time;
      this.numberFormatter = optionsChart.numberFormatter || numberFormat2;
      this.styledMode = optionsChart.styledMode;
      this.hasCartesianSeries = optionsChart.showAxes;
      var chart = this;
      chart.index = charts5.length;
      charts5.push(chart);
      Globals_default.chartCount++;
      registerEventOptions3(this, optionsChart);
      chart.xAxis = [];
      chart.yAxis = [];
      chart.pointCount = chart.colorCounter = chart.symbolCounter = 0;
      fireEvent10(chart, "afterInit");
      chart.firstRender();
    });
  };
  Chart2.prototype.initSeries = function(options) {
    var chart = this, optionsChart = chart.options.chart, type = options.type || optionsChart.type || optionsChart.defaultSeriesType, SeriesClass = seriesTypes[type];
    if (!SeriesClass) {
      error6(17, true, chart, { missingModuleFor: type });
    }
    var series = new SeriesClass();
    if (typeof series.init === "function") {
      series.init(chart, options);
    }
    return series;
  };
  Chart2.prototype.setSeriesData = function() {
    this.getSeriesOrderByLinks().forEach(function(series) {
      if (!series.points && !series.data && series.enabledDataSorting) {
        series.setData(series.options.data, false);
      }
    });
  };
  Chart2.prototype.getSeriesOrderByLinks = function() {
    return this.series.concat().sort(function(a, b) {
      if (a.linkedSeries.length || b.linkedSeries.length) {
        return b.linkedSeries.length - a.linkedSeries.length;
      }
      return 0;
    });
  };
  Chart2.prototype.orderSeries = function(fromIndex) {
    var series = this.series;
    for (var i = fromIndex || 0, iEnd = series.length; i < iEnd; ++i) {
      if (series[i]) {
        series[i].index = i;
        series[i].name = series[i].getName();
      }
    }
  };
  Chart2.prototype.isInsidePlot = function(plotX, plotY, options) {
    var _a15;
    if (options === void 0) {
      options = {};
    }
    var _b = this, inverted = _b.inverted, plotBox = _b.plotBox, plotLeft = _b.plotLeft, plotTop = _b.plotTop, scrollablePlotBox = _b.scrollablePlotBox;
    var scrollLeft = 0, scrollTop = 0;
    if (options.visiblePlotOnly && this.scrollingContainer) {
      _a15 = this.scrollingContainer, scrollLeft = _a15.scrollLeft, scrollTop = _a15.scrollTop;
    }
    var series = options.series, box = options.visiblePlotOnly && scrollablePlotBox || plotBox, x = options.inverted ? plotY : plotX, y = options.inverted ? plotX : plotY, e2 = {
      x,
      y,
      isInsidePlot: true
    };
    if (!options.ignoreX) {
      var xAxis = series && (inverted ? series.yAxis : series.xAxis) || {
        pos: plotLeft,
        len: Infinity
      };
      var chartX = options.paneCoordinates ? xAxis.pos + x : plotLeft + x;
      if (!(chartX >= Math.max(scrollLeft + plotLeft, xAxis.pos) && chartX <= Math.min(scrollLeft + plotLeft + box.width, xAxis.pos + xAxis.len))) {
        e2.isInsidePlot = false;
      }
    }
    if (!options.ignoreY && e2.isInsidePlot) {
      var yAxis = series && (inverted ? series.xAxis : series.yAxis) || {
        pos: plotTop,
        len: Infinity
      };
      var chartY = options.paneCoordinates ? yAxis.pos + y : plotTop + y;
      if (!(chartY >= Math.max(scrollTop + plotTop, yAxis.pos) && chartY <= Math.min(scrollTop + plotTop + box.height, yAxis.pos + yAxis.len))) {
        e2.isInsidePlot = false;
      }
    }
    fireEvent10(this, "afterIsInsidePlot", e2);
    return e2.isInsidePlot;
  };
  Chart2.prototype.redraw = function(animation) {
    fireEvent10(this, "beforeRedraw");
    var chart = this, axes = chart.hasCartesianSeries ? chart.axes : chart.colorAxis || [], series = chart.series, pointer = chart.pointer, legend = chart.legend, legendUserOptions = chart.userOptions.legend, renderer = chart.renderer, isHiddenChart = renderer.isHidden(), afterRedraw = [];
    var hasDirtyStacks, hasStackedSeries, i, isDirtyBox = chart.isDirtyBox, redrawLegend = chart.isDirtyLegend, serie;
    if (chart.setResponsive) {
      chart.setResponsive(false);
    }
    setAnimation3(chart.hasRendered ? animation : false, chart);
    if (isHiddenChart) {
      chart.temporaryDisplay();
    }
    chart.layOutTitles();
    i = series.length;
    while (i--) {
      serie = series[i];
      if (serie.options.stacking || serie.options.centerInCategory) {
        hasStackedSeries = true;
        if (serie.isDirty) {
          hasDirtyStacks = true;
          break;
        }
      }
    }
    if (hasDirtyStacks) {
      i = series.length;
      while (i--) {
        serie = series[i];
        if (serie.options.stacking) {
          serie.isDirty = true;
        }
      }
    }
    series.forEach(function(serie2) {
      if (serie2.isDirty) {
        if (serie2.options.legendType === "point") {
          if (typeof serie2.updateTotals === "function") {
            serie2.updateTotals();
          }
          redrawLegend = true;
        } else if (legendUserOptions && (legendUserOptions.labelFormatter || legendUserOptions.labelFormat)) {
          redrawLegend = true;
        }
      }
      if (serie2.isDirtyData) {
        fireEvent10(serie2, "updatedData");
      }
    });
    if (redrawLegend && legend && legend.options.enabled) {
      legend.render();
      chart.isDirtyLegend = false;
    }
    if (hasStackedSeries) {
      chart.getStacks();
    }
    axes.forEach(function(axis) {
      axis.updateNames();
      axis.setScale();
    });
    chart.getMargins();
    axes.forEach(function(axis) {
      if (axis.isDirty) {
        isDirtyBox = true;
      }
    });
    axes.forEach(function(axis) {
      var key = axis.min + "," + axis.max;
      if (axis.extKey !== key) {
        axis.extKey = key;
        afterRedraw.push(function() {
          fireEvent10(axis, "afterSetExtremes", extend14(axis.eventArgs, axis.getExtremes()));
          delete axis.eventArgs;
        });
      }
      if (isDirtyBox || hasStackedSeries) {
        axis.redraw();
      }
    });
    if (isDirtyBox) {
      chart.drawChartBox();
    }
    fireEvent10(chart, "predraw");
    series.forEach(function(serie2) {
      if ((isDirtyBox || serie2.isDirty) && serie2.visible) {
        serie2.redraw();
      }
      serie2.isDirtyData = false;
    });
    if (pointer) {
      pointer.reset(true);
    }
    renderer.draw();
    fireEvent10(chart, "redraw");
    fireEvent10(chart, "render");
    if (isHiddenChart) {
      chart.temporaryDisplay(true);
    }
    afterRedraw.forEach(function(callback) {
      callback.call();
    });
  };
  Chart2.prototype.get = function(id) {
    var series = this.series;
    function itemById(item) {
      return item.id === id || item.options && item.options.id === id;
    }
    var ret = find4(this.axes, itemById) || find4(this.series, itemById);
    for (var i = 0; !ret && i < series.length; i++) {
      ret = find4(series[i].points || [], itemById);
    }
    return ret;
  };
  Chart2.prototype.getAxes = function() {
    var chart = this, options = this.options, xAxisOptions = options.xAxis = splat7(options.xAxis || {}), yAxisOptions = options.yAxis = splat7(options.yAxis || {});
    fireEvent10(this, "getAxes");
    xAxisOptions.forEach(function(axis, i) {
      axis.index = i;
      axis.isX = true;
    });
    yAxisOptions.forEach(function(axis, i) {
      axis.index = i;
    });
    var optionsArray = xAxisOptions.concat(yAxisOptions);
    optionsArray.forEach(function(axisOptions) {
      new Axis_default(chart, axisOptions);
    });
    fireEvent10(this, "afterGetAxes");
  };
  Chart2.prototype.getSelectedPoints = function() {
    return this.series.reduce(function(acc, series) {
      series.getPointsCollection().forEach(function(point) {
        if (pick21(point.selectedStaging, point.selected)) {
          acc.push(point);
        }
      });
      return acc;
    }, []);
  };
  Chart2.prototype.getSelectedSeries = function() {
    return this.series.filter(function(serie) {
      return serie.selected;
    });
  };
  Chart2.prototype.setTitle = function(titleOptions, subtitleOptions, redraw) {
    this.applyDescription("title", titleOptions);
    this.applyDescription("subtitle", subtitleOptions);
    this.applyDescription("caption", void 0);
    this.layOutTitles(redraw);
  };
  Chart2.prototype.applyDescription = function(name, explicitOptions) {
    var chart = this;
    var style = name === "title" ? {
      color: Palette_default.neutralColor80,
      fontSize: this.options.isStock ? "16px" : "18px"
    } : {
      color: Palette_default.neutralColor60
    };
    var options = this.options[name] = merge16(!this.styledMode && { style }, this.options[name], explicitOptions);
    var elem = this[name];
    if (elem && explicitOptions) {
      this[name] = elem = elem.destroy();
    }
    if (options && !elem) {
      elem = this.renderer.text(options.text, 0, 0, options.useHTML).attr({
        align: options.align,
        "class": "highcharts-" + name,
        zIndex: options.zIndex || 4
      }).add();
      elem.update = function(updateOptions) {
        var fn = {
          title: "setTitle",
          subtitle: "setSubtitle",
          caption: "setCaption"
        }[name];
        chart[fn](updateOptions);
      };
      if (!this.styledMode) {
        elem.css(options.style);
      }
      this[name] = elem;
    }
  };
  Chart2.prototype.layOutTitles = function(redraw) {
    var titleOffset = [0, 0, 0], renderer = this.renderer, spacingBox = this.spacingBox;
    ["title", "subtitle", "caption"].forEach(function(key) {
      var title = this[key], titleOptions = this.options[key], verticalAlign = titleOptions.verticalAlign || "top", offset3 = key === "title" ? verticalAlign === "top" ? -3 : 0 : verticalAlign === "top" ? titleOffset[0] + 2 : 0;
      var titleSize, height;
      if (title) {
        if (!this.styledMode) {
          titleSize = titleOptions.style && titleOptions.style.fontSize;
        }
        titleSize = renderer.fontMetrics(titleSize, title).b;
        title.css({
          width: (titleOptions.width || spacingBox.width + (titleOptions.widthAdjust || 0)) + "px"
        });
        height = Math.round(title.getBBox(titleOptions.useHTML).height);
        title.align(extend14({
          y: verticalAlign === "bottom" ? titleSize : offset3 + titleSize,
          height
        }, titleOptions), false, "spacingBox");
        if (!titleOptions.floating) {
          if (verticalAlign === "top") {
            titleOffset[0] = Math.ceil(titleOffset[0] + height);
          } else if (verticalAlign === "bottom") {
            titleOffset[2] = Math.ceil(titleOffset[2] + height);
          }
        }
      }
    }, this);
    if (titleOffset[0] && (this.options.title.verticalAlign || "top") === "top") {
      titleOffset[0] += this.options.title.margin;
    }
    if (titleOffset[2] && this.options.caption.verticalAlign === "bottom") {
      titleOffset[2] += this.options.caption.margin;
    }
    var requiresDirtyBox = !this.titleOffset || this.titleOffset.join(",") !== titleOffset.join(",");
    this.titleOffset = titleOffset;
    fireEvent10(this, "afterLayOutTitles");
    if (!this.isDirtyBox && requiresDirtyBox) {
      this.isDirtyBox = this.isDirtyLegend = requiresDirtyBox;
      if (this.hasRendered && pick21(redraw, true) && this.isDirtyBox) {
        this.redraw();
      }
    }
  };
  Chart2.prototype.getChartSize = function() {
    var chart = this, optionsChart = chart.options.chart, widthOption = optionsChart.width, heightOption = optionsChart.height, renderTo = chart.renderTo;
    if (!defined16(widthOption)) {
      chart.containerWidth = getStyle3(renderTo, "width");
    }
    if (!defined16(heightOption)) {
      chart.containerHeight = getStyle3(renderTo, "height");
    }
    chart.chartWidth = Math.max(0, widthOption || chart.containerWidth || 600);
    chart.chartHeight = Math.max(0, relativeLength4(heightOption, chart.chartWidth) || (chart.containerHeight > 1 ? chart.containerHeight : 400));
  };
  Chart2.prototype.temporaryDisplay = function(revert) {
    var node = this.renderTo, tempStyle;
    if (!revert) {
      while (node && node.style) {
        if (!doc7.body.contains(node) && !node.parentNode) {
          node.hcOrigDetached = true;
          doc7.body.appendChild(node);
        }
        if (getStyle3(node, "display", false) === "none" || node.hcOricDetached) {
          node.hcOrigStyle = {
            display: node.style.display,
            height: node.style.height,
            overflow: node.style.overflow
          };
          tempStyle = {
            display: "block",
            overflow: "hidden"
          };
          if (node !== this.renderTo) {
            tempStyle.height = 0;
          }
          css10(node, tempStyle);
          if (!node.offsetWidth) {
            node.style.setProperty("display", "block", "important");
          }
        }
        node = node.parentNode;
        if (node === doc7.body) {
          break;
        }
      }
    } else {
      while (node && node.style) {
        if (node.hcOrigStyle) {
          css10(node, node.hcOrigStyle);
          delete node.hcOrigStyle;
        }
        if (node.hcOrigDetached) {
          doc7.body.removeChild(node);
          node.hcOrigDetached = false;
        }
        node = node.parentNode;
      }
    }
  };
  Chart2.prototype.setClassName = function(className) {
    this.container.className = "highcharts-container " + (className || "");
  };
  Chart2.prototype.getContainer = function() {
    var chart = this, options = chart.options, optionsChart = options.chart, indexAttrName = "data-highcharts-chart", containerId = uniqueKey5();
    var containerStyle, renderTo = chart.renderTo;
    if (!renderTo) {
      chart.renderTo = renderTo = optionsChart.renderTo;
    }
    if (isString8(renderTo)) {
      chart.renderTo = renderTo = doc7.getElementById(renderTo);
    }
    if (!renderTo) {
      error6(13, true, chart);
    }
    var oldChartIndex = pInt7(attr9(renderTo, indexAttrName));
    if (isNumber17(oldChartIndex) && charts5[oldChartIndex] && charts5[oldChartIndex].hasRendered) {
      charts5[oldChartIndex].destroy();
    }
    attr9(renderTo, indexAttrName, chart.index);
    renderTo.innerHTML = "";
    if (!optionsChart.skipClone && !renderTo.offsetWidth) {
      chart.temporaryDisplay();
    }
    chart.getChartSize();
    var chartWidth = chart.chartWidth;
    var chartHeight = chart.chartHeight;
    css10(renderTo, { overflow: "hidden" });
    if (!chart.styledMode) {
      containerStyle = extend14({
        position: "relative",
        overflow: "hidden",
        width: chartWidth + "px",
        height: chartHeight + "px",
        textAlign: "left",
        lineHeight: "normal",
        zIndex: 0,
        "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
        userSelect: "none",
        "touch-action": "manipulation",
        outline: "none"
      }, optionsChart.style || {});
    }
    var container = createElement7("div", {
      id: containerId
    }, containerStyle, renderTo);
    chart.container = container;
    chart._cursor = container.style.cursor;
    var Renderer2 = optionsChart.renderer || !svg3 ? RendererRegistry_default.getRendererType(optionsChart.renderer) : SVGRenderer_default;
    chart.renderer = new Renderer2(container, chartWidth, chartHeight, void 0, optionsChart.forExport, options.exporting && options.exporting.allowHTML, chart.styledMode);
    setAnimation3(void 0, chart);
    chart.setClassName(optionsChart.className);
    if (!chart.styledMode) {
      chart.renderer.setStyle(optionsChart.style);
    } else {
      for (var key in options.defs) {
        this.renderer.definition(options.defs[key]);
      }
    }
    chart.renderer.chartIndex = chart.index;
    fireEvent10(this, "afterGetContainer");
  };
  Chart2.prototype.getMargins = function(skipAxes) {
    var _a15 = this, spacing = _a15.spacing, margin = _a15.margin, titleOffset = _a15.titleOffset;
    this.resetMargins();
    if (titleOffset[0] && !defined16(margin[0])) {
      this.plotTop = Math.max(this.plotTop, titleOffset[0] + spacing[0]);
    }
    if (titleOffset[2] && !defined16(margin[2])) {
      this.marginBottom = Math.max(this.marginBottom, titleOffset[2] + spacing[2]);
    }
    if (this.legend && this.legend.display) {
      this.legend.adjustMargins(margin, spacing);
    }
    fireEvent10(this, "getMargins");
    if (!skipAxes) {
      this.getAxisMargins();
    }
  };
  Chart2.prototype.getAxisMargins = function() {
    var chart = this, axisOffset = chart.axisOffset = [0, 0, 0, 0], colorAxis = chart.colorAxis, margin = chart.margin, getOffset = function(axes) {
      axes.forEach(function(axis) {
        if (axis.visible) {
          axis.getOffset();
        }
      });
    };
    if (chart.hasCartesianSeries) {
      getOffset(chart.axes);
    } else if (colorAxis && colorAxis.length) {
      getOffset(colorAxis);
    }
    marginNames2.forEach(function(m, side) {
      if (!defined16(margin[side])) {
        chart[m] += axisOffset[side];
      }
    });
    chart.setChartSize();
  };
  Chart2.prototype.reflow = function(e2) {
    var chart = this, optionsChart = chart.options.chart, renderTo = chart.renderTo, hasUserSize = defined16(optionsChart.width) && defined16(optionsChart.height), width = optionsChart.width || getStyle3(renderTo, "width"), height = optionsChart.height || getStyle3(renderTo, "height"), target = e2 ? e2.target : win10;
    delete chart.pointer.chartPosition;
    if (!hasUserSize && !chart.isPrinting && width && height && (target === win10 || target === doc7)) {
      if (width !== chart.containerWidth || height !== chart.containerHeight) {
        Utilities_default.clearTimeout(chart.reflowTimeout);
        chart.reflowTimeout = syncTimeout7(function() {
          if (chart.container) {
            chart.setSize(void 0, void 0, false);
          }
        }, e2 ? 100 : 0);
      }
      chart.containerWidth = width;
      chart.containerHeight = height;
    }
  };
  Chart2.prototype.setReflow = function(reflow) {
    var chart = this;
    if (reflow !== false && !this.unbindReflow) {
      this.unbindReflow = addEvent12(win10, "resize", function(e2) {
        if (chart.options) {
          chart.reflow(e2);
        }
      });
      addEvent12(this, "destroy", this.unbindReflow);
    } else if (reflow === false && this.unbindReflow) {
      this.unbindReflow = this.unbindReflow();
    }
  };
  Chart2.prototype.setSize = function(width, height, animation) {
    var chart = this, renderer = chart.renderer;
    chart.isResizing += 1;
    setAnimation3(animation, chart);
    var globalAnimation = renderer.globalAnimation;
    chart.oldChartHeight = chart.chartHeight;
    chart.oldChartWidth = chart.chartWidth;
    if (typeof width !== "undefined") {
      chart.options.chart.width = width;
    }
    if (typeof height !== "undefined") {
      chart.options.chart.height = height;
    }
    chart.getChartSize();
    if (!chart.styledMode) {
      (globalAnimation ? animate3 : css10)(chart.container, {
        width: chart.chartWidth + "px",
        height: chart.chartHeight + "px"
      }, globalAnimation);
    }
    chart.setChartSize(true);
    renderer.setSize(chart.chartWidth, chart.chartHeight, globalAnimation);
    chart.axes.forEach(function(axis) {
      axis.isDirty = true;
      axis.setScale();
    });
    chart.isDirtyLegend = true;
    chart.isDirtyBox = true;
    chart.layOutTitles();
    chart.getMargins();
    chart.redraw(globalAnimation);
    chart.oldChartHeight = null;
    fireEvent10(chart, "resize");
    syncTimeout7(function() {
      if (chart) {
        fireEvent10(chart, "endResize", null, function() {
          chart.isResizing -= 1;
        });
      }
    }, animObject6(globalAnimation).duration);
  };
  Chart2.prototype.setChartSize = function(skipAxes) {
    var chart = this, inverted = chart.inverted, renderer = chart.renderer, chartWidth = chart.chartWidth, chartHeight = chart.chartHeight, optionsChart = chart.options.chart, spacing = chart.spacing, clipOffset = chart.clipOffset;
    var plotLeft, plotTop, plotWidth, plotHeight;
    chart.plotLeft = plotLeft = Math.round(chart.plotLeft);
    chart.plotTop = plotTop = Math.round(chart.plotTop);
    chart.plotWidth = plotWidth = Math.max(0, Math.round(chartWidth - plotLeft - chart.marginRight));
    chart.plotHeight = plotHeight = Math.max(0, Math.round(chartHeight - plotTop - chart.marginBottom));
    chart.plotSizeX = inverted ? plotHeight : plotWidth;
    chart.plotSizeY = inverted ? plotWidth : plotHeight;
    chart.plotBorderWidth = optionsChart.plotBorderWidth || 0;
    chart.spacingBox = renderer.spacingBox = {
      x: spacing[3],
      y: spacing[0],
      width: chartWidth - spacing[3] - spacing[1],
      height: chartHeight - spacing[0] - spacing[2]
    };
    chart.plotBox = renderer.plotBox = {
      x: plotLeft,
      y: plotTop,
      width: plotWidth,
      height: plotHeight
    };
    var plotBorderWidth = 2 * Math.floor(chart.plotBorderWidth / 2), clipX = Math.ceil(Math.max(plotBorderWidth, clipOffset[3]) / 2), clipY = Math.ceil(Math.max(plotBorderWidth, clipOffset[0]) / 2);
    chart.clipBox = {
      x: clipX,
      y: clipY,
      width: Math.floor(chart.plotSizeX - Math.max(plotBorderWidth, clipOffset[1]) / 2 - clipX),
      height: Math.max(0, Math.floor(chart.plotSizeY - Math.max(plotBorderWidth, clipOffset[2]) / 2 - clipY))
    };
    if (!skipAxes) {
      chart.axes.forEach(function(axis) {
        axis.setAxisSize();
        axis.setAxisTranslation();
      });
      renderer.alignElements();
    }
    fireEvent10(chart, "afterSetChartSize", { skipAxes });
  };
  Chart2.prototype.resetMargins = function() {
    fireEvent10(this, "resetMargins");
    var chart = this, chartOptions = chart.options.chart;
    ["margin", "spacing"].forEach(function splashArrays(target) {
      var value = chartOptions[target], values = isObject7(value) ? value : [value, value, value, value];
      [
        "Top",
        "Right",
        "Bottom",
        "Left"
      ].forEach(function(sideName, side) {
        chart[target][side] = pick21(chartOptions[target + sideName], values[side]);
      });
    });
    marginNames2.forEach(function(m, side) {
      chart[m] = pick21(chart.margin[side], chart.spacing[side]);
    });
    chart.axisOffset = [0, 0, 0, 0];
    chart.clipOffset = [0, 0, 0, 0];
  };
  Chart2.prototype.drawChartBox = function() {
    var chart = this, optionsChart = chart.options.chart, renderer = chart.renderer, chartWidth = chart.chartWidth, chartHeight = chart.chartHeight, styledMode = chart.styledMode, plotBGImage = chart.plotBGImage, chartBackgroundColor = optionsChart.backgroundColor, plotBackgroundColor = optionsChart.plotBackgroundColor, plotBackgroundImage = optionsChart.plotBackgroundImage, plotLeft = chart.plotLeft, plotTop = chart.plotTop, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, plotBox = chart.plotBox, clipRect = chart.clipRect, clipBox = chart.clipBox;
    var chartBackground = chart.chartBackground, plotBackground = chart.plotBackground, plotBorder = chart.plotBorder, chartBorderWidth, mgn, bgAttr, verb = "animate";
    if (!chartBackground) {
      chart.chartBackground = chartBackground = renderer.rect().addClass("highcharts-background").add();
      verb = "attr";
    }
    if (!styledMode) {
      chartBorderWidth = optionsChart.borderWidth || 0;
      mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);
      bgAttr = {
        fill: chartBackgroundColor || "none"
      };
      if (chartBorderWidth || chartBackground["stroke-width"]) {
        bgAttr.stroke = optionsChart.borderColor;
        bgAttr["stroke-width"] = chartBorderWidth;
      }
      chartBackground.attr(bgAttr).shadow(optionsChart.shadow);
    } else {
      chartBorderWidth = mgn = chartBackground.strokeWidth();
    }
    chartBackground[verb]({
      x: mgn / 2,
      y: mgn / 2,
      width: chartWidth - mgn - chartBorderWidth % 2,
      height: chartHeight - mgn - chartBorderWidth % 2,
      r: optionsChart.borderRadius
    });
    verb = "animate";
    if (!plotBackground) {
      verb = "attr";
      chart.plotBackground = plotBackground = renderer.rect().addClass("highcharts-plot-background").add();
    }
    plotBackground[verb](plotBox);
    if (!styledMode) {
      plotBackground.attr({
        fill: plotBackgroundColor || "none"
      }).shadow(optionsChart.plotShadow);
      if (plotBackgroundImage) {
        if (!plotBGImage) {
          chart.plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight).add();
        } else {
          if (plotBackgroundImage !== plotBGImage.attr("href")) {
            plotBGImage.attr("href", plotBackgroundImage);
          }
          plotBGImage.animate(plotBox);
        }
      }
    }
    if (!clipRect) {
      chart.clipRect = renderer.clipRect(clipBox);
    } else {
      clipRect.animate({
        width: clipBox.width,
        height: clipBox.height
      });
    }
    verb = "animate";
    if (!plotBorder) {
      verb = "attr";
      chart.plotBorder = plotBorder = renderer.rect().addClass("highcharts-plot-border").attr({
        zIndex: 1
      }).add();
    }
    if (!styledMode) {
      plotBorder.attr({
        stroke: optionsChart.plotBorderColor,
        "stroke-width": optionsChart.plotBorderWidth || 0,
        fill: "none"
      });
    }
    plotBorder[verb](plotBorder.crisp({
      x: plotLeft,
      y: plotTop,
      width: plotWidth,
      height: plotHeight
    }, -plotBorder.strokeWidth()));
    chart.isDirtyBox = false;
    fireEvent10(this, "afterDrawChartBox");
  };
  Chart2.prototype.propFromSeries = function() {
    var chart = this, optionsChart = chart.options.chart, seriesOptions = chart.options.series;
    var i, klass, value;
    ["inverted", "angular", "polar"].forEach(function(key) {
      klass = seriesTypes[optionsChart.type || optionsChart.defaultSeriesType];
      value = optionsChart[key] || klass && klass.prototype[key];
      i = seriesOptions && seriesOptions.length;
      while (!value && i--) {
        klass = seriesTypes[seriesOptions[i].type];
        if (klass && klass.prototype[key]) {
          value = true;
        }
      }
      chart[key] = value;
    });
  };
  Chart2.prototype.linkSeries = function() {
    var chart = this, chartSeries = chart.series;
    chartSeries.forEach(function(series) {
      series.linkedSeries.length = 0;
    });
    chartSeries.forEach(function(series) {
      var linkedTo = series.options.linkedTo;
      if (isString8(linkedTo)) {
        if (linkedTo === ":previous") {
          linkedTo = chart.series[series.index - 1];
        } else {
          linkedTo = chart.get(linkedTo);
        }
        if (linkedTo && linkedTo.linkedParent !== series) {
          linkedTo.linkedSeries.push(series);
          series.linkedParent = linkedTo;
          if (linkedTo.enabledDataSorting) {
            series.setDataSortingOptions();
          }
          series.visible = pick21(series.options.visible, linkedTo.options.visible, series.visible);
        }
      }
    });
    fireEvent10(this, "afterLinkSeries");
  };
  Chart2.prototype.renderSeries = function() {
    this.series.forEach(function(serie) {
      serie.translate();
      serie.render();
    });
  };
  Chart2.prototype.renderLabels = function() {
    var chart = this, labels = chart.options.labels;
    if (labels.items) {
      labels.items.forEach(function(label) {
        var style = extend14(labels.style, label.style), x = pInt7(style.left) + chart.plotLeft, y = pInt7(style.top) + chart.plotTop + 12;
        delete style.left;
        delete style.top;
        chart.renderer.text(label.html, x, y).attr({ zIndex: 2 }).css(style).add();
      });
    }
  };
  Chart2.prototype.render = function() {
    var chart = this, axes = chart.axes, colorAxis = chart.colorAxis, renderer = chart.renderer, options = chart.options, renderAxes = function(axes2) {
      axes2.forEach(function(axis) {
        if (axis.visible) {
          axis.render();
        }
      });
    };
    var correction = 0;
    chart.setTitle();
    chart.legend = new Legend_default(chart, options.legend);
    if (chart.getStacks) {
      chart.getStacks();
    }
    chart.getMargins(true);
    chart.setChartSize();
    var tempWidth = chart.plotWidth;
    axes.some(function(axis) {
      if (axis.horiz && axis.visible && axis.options.labels.enabled && axis.series.length) {
        correction = 21;
        return true;
      }
    });
    chart.plotHeight = Math.max(chart.plotHeight - correction, 0);
    var tempHeight = chart.plotHeight;
    axes.forEach(function(axis) {
      axis.setScale();
    });
    chart.getAxisMargins();
    var redoHorizontal = tempWidth / chart.plotWidth > 1.1;
    var redoVertical = tempHeight / chart.plotHeight > 1.05;
    if (redoHorizontal || redoVertical) {
      axes.forEach(function(axis) {
        if (axis.horiz && redoHorizontal || !axis.horiz && redoVertical) {
          axis.setTickInterval(true);
        }
      });
      chart.getMargins();
    }
    chart.drawChartBox();
    if (chart.hasCartesianSeries) {
      renderAxes(axes);
    } else if (colorAxis && colorAxis.length) {
      renderAxes(colorAxis);
    }
    if (!chart.seriesGroup) {
      chart.seriesGroup = renderer.g("series-group").attr({ zIndex: 3 }).add();
    }
    chart.renderSeries();
    chart.renderLabels();
    chart.addCredits();
    if (chart.setResponsive) {
      chart.setResponsive();
    }
    chart.hasRendered = true;
  };
  Chart2.prototype.addCredits = function(credits) {
    var chart = this, creds = merge16(true, this.options.credits, credits);
    if (creds.enabled && !this.credits) {
      this.credits = this.renderer.text(creds.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function() {
        if (creds.href) {
          win10.location.href = creds.href;
        }
      }).attr({
        align: creds.position.align,
        zIndex: 8
      });
      if (!chart.styledMode) {
        this.credits.css(creds.style);
      }
      this.credits.add().align(creds.position);
      this.credits.update = function(options) {
        chart.credits = chart.credits.destroy();
        chart.addCredits(options);
      };
    }
  };
  Chart2.prototype.destroy = function() {
    var chart = this, axes = chart.axes, series = chart.series, container = chart.container, parentNode = container && container.parentNode;
    var i;
    fireEvent10(chart, "destroy");
    if (chart.renderer.forExport) {
      erase7(charts5, chart);
    } else {
      charts5[chart.index] = void 0;
    }
    Globals_default.chartCount--;
    chart.renderTo.removeAttribute("data-highcharts-chart");
    removeEvent7(chart);
    i = axes.length;
    while (i--) {
      axes[i] = axes[i].destroy();
    }
    if (this.scroller && this.scroller.destroy) {
      this.scroller.destroy();
    }
    i = series.length;
    while (i--) {
      series[i] = series[i].destroy();
    }
    [
      "title",
      "subtitle",
      "chartBackground",
      "plotBackground",
      "plotBGImage",
      "plotBorder",
      "seriesGroup",
      "clipRect",
      "credits",
      "pointer",
      "rangeSelector",
      "legend",
      "resetZoomButton",
      "tooltip",
      "renderer"
    ].forEach(function(name) {
      var prop = chart[name];
      if (prop && prop.destroy) {
        chart[name] = prop.destroy();
      }
    });
    if (container) {
      container.innerHTML = "";
      removeEvent7(container);
      if (parentNode) {
        discardElement5(container);
      }
    }
    objectEach15(chart, function(val, key) {
      delete chart[key];
    });
  };
  Chart2.prototype.firstRender = function() {
    var chart = this, options = chart.options;
    if (chart.isReadyToRender && !chart.isReadyToRender()) {
      return;
    }
    chart.getContainer();
    chart.resetMargins();
    chart.setChartSize();
    chart.propFromSeries();
    chart.getAxes();
    (isArray8(options.series) ? options.series : []).forEach(function(serieOptions) {
      chart.initSeries(serieOptions);
    });
    chart.linkSeries();
    chart.setSeriesData();
    fireEvent10(chart, "beforeRender");
    if (Pointer_default) {
      if (MSPointer_default.isRequired()) {
        chart.pointer = new MSPointer_default(chart, options);
      } else {
        chart.pointer = new Pointer_default(chart, options);
      }
    }
    chart.render();
    chart.pointer.getChartPosition();
    if (!chart.renderer.imgCount && !chart.hasLoaded) {
      chart.onload();
    }
    chart.temporaryDisplay(true);
  };
  Chart2.prototype.onload = function() {
    this.callbacks.concat([this.callback]).forEach(function(fn) {
      if (fn && typeof this.index !== "undefined") {
        fn.apply(this, [this]);
      }
    }, this);
    fireEvent10(this, "load");
    fireEvent10(this, "render");
    if (defined16(this.index)) {
      this.setReflow(this.options.chart.reflow);
    }
    this.hasLoaded = true;
  };
  Chart2.prototype.addSeries = function(options, redraw, animation) {
    var chart = this;
    var series;
    if (options) {
      redraw = pick21(redraw, true);
      fireEvent10(chart, "addSeries", { options }, function() {
        series = chart.initSeries(options);
        chart.isDirtyLegend = true;
        chart.linkSeries();
        if (series.enabledDataSorting) {
          series.setData(options.data, false);
        }
        fireEvent10(chart, "afterAddSeries", { series });
        if (redraw) {
          chart.redraw(animation);
        }
      });
    }
    return series;
  };
  Chart2.prototype.addAxis = function(options, isX, redraw, animation) {
    return this.createAxis(isX ? "xAxis" : "yAxis", { axis: options, redraw, animation });
  };
  Chart2.prototype.addColorAxis = function(options, redraw, animation) {
    return this.createAxis("colorAxis", { axis: options, redraw, animation });
  };
  Chart2.prototype.createAxis = function(type, options) {
    var axis = new Axis_default(this, merge16(options.axis, {
      index: this[type].length,
      isX: type === "xAxis"
    }));
    if (pick21(options.redraw, true)) {
      this.redraw(options.animation);
    }
    return axis;
  };
  Chart2.prototype.showLoading = function(str) {
    var chart = this, options = chart.options, loadingOptions = options.loading, setLoadingSize = function() {
      if (loadingDiv) {
        css10(loadingDiv, {
          left: chart.plotLeft + "px",
          top: chart.plotTop + "px",
          width: chart.plotWidth + "px",
          height: chart.plotHeight + "px"
        });
      }
    };
    var loadingDiv = chart.loadingDiv, loadingSpan = chart.loadingSpan;
    if (!loadingDiv) {
      chart.loadingDiv = loadingDiv = createElement7("div", {
        className: "highcharts-loading highcharts-loading-hidden"
      }, null, chart.container);
    }
    if (!loadingSpan) {
      chart.loadingSpan = loadingSpan = createElement7("span", { className: "highcharts-loading-inner" }, null, loadingDiv);
      addEvent12(chart, "redraw", setLoadingSize);
    }
    loadingDiv.className = "highcharts-loading";
    AST_default.setElementHTML(loadingSpan, pick21(str, options.lang.loading, ""));
    if (!chart.styledMode) {
      css10(loadingDiv, extend14(loadingOptions.style, {
        zIndex: 10
      }));
      css10(loadingSpan, loadingOptions.labelStyle);
      if (!chart.loadingShown) {
        css10(loadingDiv, {
          opacity: 0,
          display: ""
        });
        animate3(loadingDiv, {
          opacity: loadingOptions.style.opacity || 0.5
        }, {
          duration: loadingOptions.showDuration || 0
        });
      }
    }
    chart.loadingShown = true;
    setLoadingSize();
  };
  Chart2.prototype.hideLoading = function() {
    var options = this.options, loadingDiv = this.loadingDiv;
    if (loadingDiv) {
      loadingDiv.className = "highcharts-loading highcharts-loading-hidden";
      if (!this.styledMode) {
        animate3(loadingDiv, {
          opacity: 0
        }, {
          duration: options.loading.hideDuration || 100,
          complete: function() {
            css10(loadingDiv, { display: "none" });
          }
        });
      }
    }
    this.loadingShown = false;
  };
  Chart2.prototype.update = function(options, redraw, oneToOne, animation) {
    var chart = this, adders = {
      credits: "addCredits",
      title: "setTitle",
      subtitle: "setSubtitle",
      caption: "setCaption"
    }, isResponsiveOptions = options.isResponsiveOptions, itemsForRemoval = [];
    var updateAllAxes, updateAllSeries, runSetSize;
    fireEvent10(chart, "update", { options });
    if (!isResponsiveOptions) {
      chart.setResponsive(false, true);
    }
    options = cleanRecursively2(options, chart.options);
    chart.userOptions = merge16(chart.userOptions, options);
    var optionsChart = options.chart;
    if (optionsChart) {
      merge16(true, chart.options.chart, optionsChart);
      if ("className" in optionsChart) {
        chart.setClassName(optionsChart.className);
      }
      if ("reflow" in optionsChart) {
        chart.setReflow(optionsChart.reflow);
      }
      if ("inverted" in optionsChart || "polar" in optionsChart || "type" in optionsChart) {
        chart.propFromSeries();
        updateAllAxes = true;
      }
      if ("alignTicks" in optionsChart) {
        updateAllAxes = true;
      }
      if ("events" in optionsChart) {
        registerEventOptions3(this, optionsChart);
      }
      objectEach15(optionsChart, function(val, key) {
        if (chart.propsRequireUpdateSeries.indexOf("chart." + key) !== -1) {
          updateAllSeries = true;
        }
        if (chart.propsRequireDirtyBox.indexOf(key) !== -1) {
          chart.isDirtyBox = true;
        }
        if (chart.propsRequireReflow.indexOf(key) !== -1) {
          if (isResponsiveOptions) {
            chart.isDirtyBox = true;
          } else {
            runSetSize = true;
          }
        }
      });
      if (!chart.styledMode && optionsChart.style) {
        chart.renderer.setStyle(chart.options.chart.style || {});
      }
    }
    if (!chart.styledMode && options.colors) {
      this.options.colors = options.colors;
    }
    if (options.time) {
      if (this.time === defaultTime3) {
        this.time = new Time_default(options.time);
      }
      merge16(true, chart.options.time, options.time);
    }
    objectEach15(options, function(val, key) {
      if (chart[key] && typeof chart[key].update === "function") {
        chart[key].update(val, false);
      } else if (typeof chart[adders[key]] === "function") {
        chart[adders[key]](val);
      } else if (key !== "colors" && chart.collectionsWithUpdate.indexOf(key) === -1) {
        merge16(true, chart.options[key], options[key]);
      }
      if (key !== "chart" && chart.propsRequireUpdateSeries.indexOf(key) !== -1) {
        updateAllSeries = true;
      }
    });
    this.collectionsWithUpdate.forEach(function(coll) {
      var indexMap;
      if (options[coll]) {
        indexMap = [];
        chart[coll].forEach(function(s, i) {
          if (!s.options.isInternal) {
            indexMap.push(pick21(s.options.index, i));
          }
        });
        splat7(options[coll]).forEach(function(newOptions, i) {
          var hasId = defined16(newOptions.id);
          var item;
          if (hasId) {
            item = chart.get(newOptions.id);
          }
          if (!item && chart[coll]) {
            item = chart[coll][indexMap ? indexMap[i] : i];
            if (item && hasId && defined16(item.options.id)) {
              item = void 0;
            }
          }
          if (item && item.coll === coll) {
            item.update(newOptions, false);
            if (oneToOne) {
              item.touched = true;
            }
          }
          if (!item && oneToOne && chart.collectionsWithInit[coll]) {
            chart.collectionsWithInit[coll][0].apply(chart, [
              newOptions
            ].concat(chart.collectionsWithInit[coll][1] || []).concat([
              false
            ])).touched = true;
          }
        });
        if (oneToOne) {
          chart[coll].forEach(function(item) {
            if (!item.touched && !item.options.isInternal) {
              itemsForRemoval.push(item);
            } else {
              delete item.touched;
            }
          });
        }
      }
    });
    itemsForRemoval.forEach(function(item) {
      if (item.chart && item.remove) {
        item.remove(false);
      }
    });
    if (updateAllAxes) {
      chart.axes.forEach(function(axis) {
        axis.update({}, false);
      });
    }
    if (updateAllSeries) {
      chart.getSeriesOrderByLinks().forEach(function(series) {
        if (series.chart) {
          series.update({}, false);
        }
      }, this);
    }
    var newWidth = optionsChart && optionsChart.width;
    var newHeight = optionsChart && (isString8(optionsChart.height) ? relativeLength4(optionsChart.height, newWidth || chart.chartWidth) : optionsChart.height);
    if (runSetSize || isNumber17(newWidth) && newWidth !== chart.chartWidth || isNumber17(newHeight) && newHeight !== chart.chartHeight) {
      chart.setSize(newWidth, newHeight, animation);
    } else if (pick21(redraw, true)) {
      chart.redraw(animation);
    }
    fireEvent10(chart, "afterUpdate", {
      options,
      redraw,
      animation
    });
  };
  Chart2.prototype.setSubtitle = function(options, redraw) {
    this.applyDescription("subtitle", options);
    this.layOutTitles(redraw);
  };
  Chart2.prototype.setCaption = function(options, redraw) {
    this.applyDescription("caption", options);
    this.layOutTitles(redraw);
  };
  Chart2.prototype.showResetZoom = function() {
    var chart = this, lang2 = defaultOptions6.lang, btnOptions = chart.options.chart.resetZoomButton, theme2 = btnOptions.theme, states = theme2.states, alignTo = btnOptions.relativeTo === "chart" || btnOptions.relativeTo === "spacingBox" ? null : "scrollablePlotBox";
    function zoomOut() {
      chart.zoomOut();
    }
    fireEvent10(this, "beforeShowResetZoom", null, function() {
      chart.resetZoomButton = chart.renderer.button(lang2.resetZoom, null, null, zoomOut, theme2, states && states.hover).attr({
        align: btnOptions.position.align,
        title: lang2.resetZoomTitle
      }).addClass("highcharts-reset-zoom").add().align(btnOptions.position, false, alignTo);
    });
    fireEvent10(this, "afterShowResetZoom");
  };
  Chart2.prototype.zoomOut = function() {
    fireEvent10(this, "selection", { resetSelection: true }, this.zoom);
  };
  Chart2.prototype.zoom = function(event) {
    var chart = this, pointer = chart.pointer, mouseDownPos = chart.inverted ? pointer.mouseDownX : pointer.mouseDownY;
    var displayButton = false, hasZoomed;
    if (!event || event.resetSelection) {
      chart.axes.forEach(function(axis) {
        hasZoomed = axis.zoom();
      });
      pointer.initiated = false;
    } else {
      event.xAxis.concat(event.yAxis).forEach(function(axisData) {
        var axis = axisData.axis, axisStartPos = chart.inverted ? axis.left : axis.top, axisEndPos = chart.inverted ? axisStartPos + axis.width : axisStartPos + axis.height, isXAxis = axis.isXAxis;
        var isWithinPane = false;
        if (!isXAxis && mouseDownPos >= axisStartPos && mouseDownPos <= axisEndPos || isXAxis || !defined16(mouseDownPos)) {
          isWithinPane = true;
        }
        if (pointer[isXAxis ? "zoomX" : "zoomY"] && isWithinPane) {
          hasZoomed = axis.zoom(axisData.min, axisData.max);
          if (axis.displayBtn) {
            displayButton = true;
          }
        }
      });
    }
    var resetZoomButton = chart.resetZoomButton;
    if (displayButton && !resetZoomButton) {
      chart.showResetZoom();
    } else if (!displayButton && isObject7(resetZoomButton)) {
      chart.resetZoomButton = resetZoomButton.destroy();
    }
    if (hasZoomed) {
      chart.redraw(pick21(chart.options.chart.animation, event && event.animation, chart.pointCount < 100));
    }
  };
  Chart2.prototype.pan = function(e2, panning) {
    var chart = this, hoverPoints = chart.hoverPoints, panningOptions = typeof panning === "object" ? panning : {
      enabled: panning,
      type: "x"
    }, chartOptions = chart.options.chart, hasMapNavigation = chart.options.mapNavigation && chart.options.mapNavigation.enabled;
    if (chartOptions && chartOptions.panning) {
      chartOptions.panning = panningOptions;
    }
    var type = panningOptions.type;
    var doRedraw;
    fireEvent10(this, "pan", { originalEvent: e2 }, function() {
      if (hoverPoints) {
        hoverPoints.forEach(function(point) {
          point.setState();
        });
      }
      var axes = chart.xAxis;
      if (type === "xy") {
        axes = axes.concat(chart.yAxis);
      } else if (type === "y") {
        axes = chart.yAxis;
      }
      var nextMousePos = {};
      axes.forEach(function(axis) {
        if (!axis.options.panningEnabled || axis.options.isInternal) {
          return;
        }
        var horiz = axis.horiz, mousePos = e2[horiz ? "chartX" : "chartY"], mouseDown = horiz ? "mouseDownX" : "mouseDownY", startPos = chart[mouseDown], halfPointRange = axis.minPointOffset || 0, pointRangeDirection = axis.reversed && !chart.inverted || !axis.reversed && chart.inverted ? -1 : 1, extremes = axis.getExtremes(), panMin = axis.toValue(startPos - mousePos, true) + halfPointRange * pointRangeDirection, panMax = axis.toValue(startPos + axis.len - mousePos, true) - (halfPointRange * pointRangeDirection || axis.isXAxis && axis.pointRangePadding || 0), flipped = panMax < panMin, hasVerticalPanning = axis.hasVerticalPanning();
        var newMin = flipped ? panMax : panMin, newMax = flipped ? panMin : panMax, panningState = axis.panningState, spill;
        if (hasVerticalPanning && !axis.isXAxis && (!panningState || panningState.isDirty)) {
          axis.series.forEach(function(series) {
            var processedData = series.getProcessedData(true), dataExtremes = series.getExtremes(processedData.yData, true);
            if (!panningState) {
              panningState = {
                startMin: Number.MAX_VALUE,
                startMax: -Number.MAX_VALUE
              };
            }
            if (isNumber17(dataExtremes.dataMin) && isNumber17(dataExtremes.dataMax)) {
              panningState.startMin = Math.min(pick21(series.options.threshold, Infinity), dataExtremes.dataMin, panningState.startMin);
              panningState.startMax = Math.max(pick21(series.options.threshold, -Infinity), dataExtremes.dataMax, panningState.startMax);
            }
          });
        }
        var paddedMin = Math.min(pick21(panningState && panningState.startMin, extremes.dataMin), halfPointRange ? extremes.min : axis.toValue(axis.toPixels(extremes.min) - axis.minPixelPadding));
        var paddedMax = Math.max(pick21(panningState && panningState.startMax, extremes.dataMax), halfPointRange ? extremes.max : axis.toValue(axis.toPixels(extremes.max) + axis.minPixelPadding));
        axis.panningState = panningState;
        if (!axis.isOrdinal) {
          spill = paddedMin - newMin;
          if (spill > 0) {
            newMax += spill;
            newMin = paddedMin;
          }
          spill = newMax - paddedMax;
          if (spill > 0) {
            newMax = paddedMax;
            newMin -= spill;
          }
          if (axis.series.length && newMin !== extremes.min && newMax !== extremes.max && newMin >= paddedMin && newMax <= paddedMax) {
            axis.setExtremes(newMin, newMax, false, false, { trigger: "pan" });
            if (!chart.resetZoomButton && !hasMapNavigation && newMin !== paddedMin && newMax !== paddedMax && type.match("y")) {
              chart.showResetZoom();
              axis.displayBtn = false;
            }
            doRedraw = true;
          }
          nextMousePos[mouseDown] = mousePos;
        }
      });
      objectEach15(nextMousePos, function(pos, down) {
        chart[down] = pos;
      });
      if (doRedraw) {
        chart.redraw(false);
      }
      css10(chart.container, { cursor: "move" });
    });
  };
  return Chart2;
}();
extend14(Chart.prototype, {
  callbacks: [],
  collectionsWithInit: {
    xAxis: [Chart.prototype.addAxis, [true]],
    yAxis: [Chart.prototype.addAxis, [false]],
    series: [Chart.prototype.addSeries]
  },
  collectionsWithUpdate: [
    "xAxis",
    "yAxis",
    "series"
  ],
  propsRequireDirtyBox: [
    "backgroundColor",
    "borderColor",
    "borderWidth",
    "borderRadius",
    "plotBackgroundColor",
    "plotBackgroundImage",
    "plotBorderColor",
    "plotBorderWidth",
    "plotShadow",
    "shadow"
  ],
  propsRequireReflow: [
    "margin",
    "marginTop",
    "marginRight",
    "marginBottom",
    "marginLeft",
    "spacing",
    "spacingTop",
    "spacingRight",
    "spacingBottom",
    "spacingLeft"
  ],
  propsRequireUpdateSeries: [
    "chart.inverted",
    "chart.polar",
    "chart.ignoreHiddenSeries",
    "chart.type",
    "colors",
    "plotOptions",
    "time",
    "tooltip"
  ]
});
var Chart_default = Chart;

// node_modules/highcharts/es-modules/Core/Legend/LegendSymbol.js
var merge17 = Utilities_default.merge;
var pick22 = Utilities_default.pick;
var LegendSymbol;
(function(LegendSymbol2) {
  function drawLineMarker(legend) {
    var options = this.options, symbolWidth = legend.symbolWidth, symbolHeight = legend.symbolHeight, generalRadius = symbolHeight / 2, renderer = this.chart.renderer, legendItemGroup = this.legendGroup, verticalCenter = legend.baseline - Math.round(legend.fontMetrics.b * 0.3);
    var attr10 = {}, legendSymbol, markerOptions = options.marker;
    if (!this.chart.styledMode) {
      attr10 = {
        "stroke-width": options.lineWidth || 0
      };
      if (options.dashStyle) {
        attr10.dashstyle = options.dashStyle;
      }
    }
    this.legendLine = renderer.path([
      ["M", 0, verticalCenter],
      ["L", symbolWidth, verticalCenter]
    ]).addClass("highcharts-graph").attr(attr10).add(legendItemGroup);
    if (markerOptions && markerOptions.enabled !== false && symbolWidth) {
      var radius = Math.min(pick22(markerOptions.radius, generalRadius), generalRadius);
      if (this.symbol.indexOf("url") === 0) {
        markerOptions = merge17(markerOptions, {
          width: symbolHeight,
          height: symbolHeight
        });
        radius = 0;
      }
      this.legendSymbol = legendSymbol = renderer.symbol(this.symbol, symbolWidth / 2 - radius, verticalCenter - radius, 2 * radius, 2 * radius, markerOptions).addClass("highcharts-point").add(legendItemGroup);
      legendSymbol.isMarker = true;
    }
  }
  LegendSymbol2.drawLineMarker = drawLineMarker;
  function drawRectangle(legend, item) {
    var options = legend.options, symbolHeight = legend.symbolHeight, square = options.squareSymbol, symbolWidth = square ? symbolHeight : legend.symbolWidth;
    item.legendSymbol = this.chart.renderer.rect(square ? (legend.symbolWidth - symbolHeight) / 2 : 0, legend.baseline - symbolHeight + 1, symbolWidth, symbolHeight, pick22(legend.options.symbolRadius, symbolHeight / 2)).addClass("highcharts-point").attr({
      zIndex: 3
    }).add(item.legendGroup);
  }
  LegendSymbol2.drawRectangle = drawRectangle;
})(LegendSymbol || (LegendSymbol = {}));
var LegendSymbol_default = LegendSymbol;

// node_modules/highcharts/es-modules/Core/Series/SeriesDefaults.js
var seriesDefaults = {
  lineWidth: 2,
  allowPointSelect: false,
  crisp: true,
  showCheckbox: false,
  animation: {
    duration: 1e3
  },
  events: {},
  marker: {
    enabledThreshold: 2,
    lineColor: Palette_default.backgroundColor,
    lineWidth: 0,
    radius: 4,
    states: {
      normal: {
        animation: true
      },
      hover: {
        animation: {
          duration: 50
        },
        enabled: true,
        radiusPlus: 2,
        lineWidthPlus: 1
      },
      select: {
        fillColor: Palette_default.neutralColor20,
        lineColor: Palette_default.neutralColor100,
        lineWidth: 2
      }
    }
  },
  point: {
    events: {}
  },
  dataLabels: {
    animation: {},
    align: "center",
    defer: true,
    formatter: function() {
      var numberFormatter = this.series.chart.numberFormatter;
      return typeof this.y !== "number" ? "" : numberFormatter(this.y, -1);
    },
    padding: 5,
    style: {
      fontSize: "11px",
      fontWeight: "bold",
      color: "contrast",
      textOutline: "1px contrast"
    },
    verticalAlign: "bottom",
    x: 0,
    y: 0
  },
  cropThreshold: 300,
  opacity: 1,
  pointRange: 0,
  softThreshold: true,
  states: {
    normal: {
      animation: true
    },
    hover: {
      animation: {
        duration: 50
      },
      lineWidthPlus: 1,
      marker: {},
      halo: {
        size: 10,
        opacity: 0.25
      }
    },
    select: {
      animation: {
        duration: 0
      }
    },
    inactive: {
      animation: {
        duration: 50
      },
      opacity: 0.2
    }
  },
  stickyTracking: true,
  turboThreshold: 1e3,
  findNearestPointBy: "x"
};
var SeriesDefaults_default = seriesDefaults;

// node_modules/highcharts/es-modules/Core/Series/Series.js
var animObject7 = AnimationUtilities_default.animObject;
var setAnimation4 = AnimationUtilities_default.setAnimation;
var defaultOptions7 = DefaultOptions_default.defaultOptions;
var registerEventOptions4 = Foundation_default.registerEventOptions;
var hasTouch = Globals_default.hasTouch;
var svg4 = Globals_default.svg;
var win11 = Globals_default.win;
var seriesTypes2 = SeriesRegistry_default.seriesTypes;
var addEvent13 = Utilities_default.addEvent;
var arrayMax4 = Utilities_default.arrayMax;
var arrayMin4 = Utilities_default.arrayMin;
var clamp6 = Utilities_default.clamp;
var cleanRecursively3 = Utilities_default.cleanRecursively;
var correctFloat4 = Utilities_default.correctFloat;
var defined17 = Utilities_default.defined;
var erase8 = Utilities_default.erase;
var error7 = Utilities_default.error;
var extend15 = Utilities_default.extend;
var find5 = Utilities_default.find;
var fireEvent11 = Utilities_default.fireEvent;
var getNestedProperty4 = Utilities_default.getNestedProperty;
var isArray9 = Utilities_default.isArray;
var isNumber18 = Utilities_default.isNumber;
var isString9 = Utilities_default.isString;
var merge18 = Utilities_default.merge;
var objectEach16 = Utilities_default.objectEach;
var pick23 = Utilities_default.pick;
var removeEvent8 = Utilities_default.removeEvent;
var splat8 = Utilities_default.splat;
var syncTimeout8 = Utilities_default.syncTimeout;
var Series = function() {
  function Series16() {
    this._i = void 0;
    this.chart = void 0;
    this.data = void 0;
    this.eventOptions = void 0;
    this.eventsToUnbind = void 0;
    this.index = void 0;
    this.linkedSeries = void 0;
    this.options = void 0;
    this.points = void 0;
    this.processedXData = void 0;
    this.processedYData = void 0;
    this.tooltipOptions = void 0;
    this.userOptions = void 0;
    this.xAxis = void 0;
    this.yAxis = void 0;
    this.zones = void 0;
  }
  Series16.prototype.init = function(chart, userOptions) {
    fireEvent11(this, "init", { options: userOptions });
    var series = this, chartSeries = chart.series;
    this.eventsToUnbind = [];
    series.chart = chart;
    series.options = series.setOptions(userOptions);
    var options = series.options;
    series.linkedSeries = [];
    series.bindAxes();
    extend15(series, {
      name: options.name,
      state: "",
      visible: options.visible !== false,
      selected: options.selected === true
    });
    registerEventOptions4(this, options);
    var events = options.events;
    if (events && events.click || options.point && options.point.events && options.point.events.click || options.allowPointSelect) {
      chart.runTrackerClick = true;
    }
    series.getColor();
    series.getSymbol();
    series.parallelArrays.forEach(function(key) {
      if (!series[key + "Data"]) {
        series[key + "Data"] = [];
      }
    });
    if (series.isCartesian) {
      chart.hasCartesianSeries = true;
    }
    var lastSeries;
    if (chartSeries.length) {
      lastSeries = chartSeries[chartSeries.length - 1];
    }
    series._i = pick23(lastSeries && lastSeries._i, -1) + 1;
    series.opacity = series.options.opacity;
    chart.orderSeries(this.insert(chartSeries));
    if (options.dataSorting && options.dataSorting.enabled) {
      series.setDataSortingOptions();
    } else if (!series.points && !series.data) {
      series.setData(options.data, false);
    }
    fireEvent11(this, "afterInit");
  };
  Series16.prototype.is = function(type) {
    return seriesTypes2[type] && this instanceof seriesTypes2[type];
  };
  Series16.prototype.insert = function(collection) {
    var indexOption = this.options.index;
    var i;
    if (isNumber18(indexOption)) {
      i = collection.length;
      while (i--) {
        if (indexOption >= pick23(collection[i].options.index, collection[i]._i)) {
          collection.splice(i + 1, 0, this);
          break;
        }
      }
      if (i === -1) {
        collection.unshift(this);
      }
      i = i + 1;
    } else {
      collection.push(this);
    }
    return pick23(i, collection.length - 1);
  };
  Series16.prototype.bindAxes = function() {
    var series = this, seriesOptions = series.options, chart = series.chart;
    var axisOptions;
    fireEvent11(this, "bindAxes", null, function() {
      (series.axisTypes || []).forEach(function(AXIS) {
        var index = 0;
        chart[AXIS].forEach(function(axis) {
          axisOptions = axis.options;
          if (seriesOptions[AXIS] === index && !axisOptions.isInternal || typeof seriesOptions[AXIS] !== "undefined" && seriesOptions[AXIS] === axisOptions.id || typeof seriesOptions[AXIS] === "undefined" && axisOptions.index === 0) {
            series.insert(axis.series);
            series[AXIS] = axis;
            axis.isDirty = true;
          }
          if (!axisOptions.isInternal) {
            index++;
          }
        });
        if (!series[AXIS] && series.optionalAxis !== AXIS) {
          error7(18, true, chart);
        }
      });
    });
    fireEvent11(this, "afterBindAxes");
  };
  Series16.prototype.updateParallelArrays = function(point, i) {
    var series = point.series, args = arguments, fn = isNumber18(i) ? function(key) {
      var val = key === "y" && series.toYData ? series.toYData(point) : point[key];
      series[key + "Data"][i] = val;
    } : function(key) {
      Array.prototype[i].apply(series[key + "Data"], Array.prototype.slice.call(args, 2));
    };
    series.parallelArrays.forEach(fn);
  };
  Series16.prototype.hasData = function() {
    return this.visible && typeof this.dataMax !== "undefined" && typeof this.dataMin !== "undefined" || this.visible && this.yData && this.yData.length > 0;
  };
  Series16.prototype.autoIncrement = function(x) {
    var options = this.options, pointIntervalUnit = options.pointIntervalUnit, relativeXValue = options.relativeXValue, time = this.chart.time;
    var xIncrement = this.xIncrement, date, pointInterval;
    xIncrement = pick23(xIncrement, options.pointStart, 0);
    this.pointInterval = pointInterval = pick23(this.pointInterval, options.pointInterval, 1);
    if (relativeXValue && isNumber18(x)) {
      pointInterval *= x;
    }
    if (pointIntervalUnit) {
      date = new time.Date(xIncrement);
      if (pointIntervalUnit === "day") {
        time.set("Date", date, time.get("Date", date) + pointInterval);
      } else if (pointIntervalUnit === "month") {
        time.set("Month", date, time.get("Month", date) + pointInterval);
      } else if (pointIntervalUnit === "year") {
        time.set("FullYear", date, time.get("FullYear", date) + pointInterval);
      }
      pointInterval = date.getTime() - xIncrement;
    }
    if (relativeXValue && isNumber18(x)) {
      return xIncrement + pointInterval;
    }
    this.xIncrement = xIncrement + pointInterval;
    return xIncrement;
  };
  Series16.prototype.setDataSortingOptions = function() {
    var options = this.options;
    extend15(this, {
      requireSorting: false,
      sorted: false,
      enabledDataSorting: true,
      allowDG: false
    });
    if (!defined17(options.pointRange)) {
      options.pointRange = 1;
    }
  };
  Series16.prototype.setOptions = function(itemOptions) {
    var chart = this.chart, chartOptions = chart.options, plotOptions = chartOptions.plotOptions, userOptions = chart.userOptions || {}, seriesUserOptions = merge18(itemOptions), styledMode = chart.styledMode, e2 = {
      plotOptions,
      userOptions: seriesUserOptions
    };
    var zone;
    fireEvent11(this, "setOptions", e2);
    var typeOptions = e2.plotOptions[this.type], userPlotOptions = userOptions.plotOptions || {};
    this.userOptions = e2.userOptions;
    var options = merge18(typeOptions, plotOptions.series, userOptions.plotOptions && userOptions.plotOptions[this.type], seriesUserOptions);
    this.tooltipOptions = merge18(defaultOptions7.tooltip, defaultOptions7.plotOptions.series && defaultOptions7.plotOptions.series.tooltip, defaultOptions7.plotOptions[this.type].tooltip, chartOptions.tooltip.userOptions, plotOptions.series && plotOptions.series.tooltip, plotOptions[this.type].tooltip, seriesUserOptions.tooltip);
    this.stickyTracking = pick23(seriesUserOptions.stickyTracking, userPlotOptions[this.type] && userPlotOptions[this.type].stickyTracking, userPlotOptions.series && userPlotOptions.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? true : options.stickyTracking);
    if (typeOptions.marker === null) {
      delete options.marker;
    }
    this.zoneAxis = options.zoneAxis;
    var zones = this.zones = (options.zones || []).slice();
    if ((options.negativeColor || options.negativeFillColor) && !options.zones) {
      zone = {
        value: options[this.zoneAxis + "Threshold"] || options.threshold || 0,
        className: "highcharts-negative"
      };
      if (!styledMode) {
        zone.color = options.negativeColor;
        zone.fillColor = options.negativeFillColor;
      }
      zones.push(zone);
    }
    if (zones.length) {
      if (defined17(zones[zones.length - 1].value)) {
        zones.push(styledMode ? {} : {
          color: this.color,
          fillColor: this.fillColor
        });
      }
    }
    fireEvent11(this, "afterSetOptions", { options });
    return options;
  };
  Series16.prototype.getName = function() {
    return pick23(this.options.name, "Series " + (this.index + 1));
  };
  Series16.prototype.getCyclic = function(prop, value, defaults) {
    var chart = this.chart, userOptions = this.userOptions, indexName = prop + "Index", counterName = prop + "Counter", len = defaults ? defaults.length : pick23(chart.options.chart[prop + "Count"], chart[prop + "Count"]);
    var i, setting;
    if (!value) {
      setting = pick23(userOptions[indexName], userOptions["_" + indexName]);
      if (defined17(setting)) {
        i = setting;
      } else {
        if (!chart.series.length) {
          chart[counterName] = 0;
        }
        userOptions["_" + indexName] = i = chart[counterName] % len;
        chart[counterName] += 1;
      }
      if (defaults) {
        value = defaults[i];
      }
    }
    if (typeof i !== "undefined") {
      this[indexName] = i;
    }
    this[prop] = value;
  };
  Series16.prototype.getColor = function() {
    if (this.chart.styledMode) {
      this.getCyclic("color");
    } else if (this.options.colorByPoint) {
      this.color = Palette_default.neutralColor20;
    } else {
      this.getCyclic("color", this.options.color || defaultOptions7.plotOptions[this.type].color, this.chart.options.colors);
    }
  };
  Series16.prototype.getPointsCollection = function() {
    return (this.hasGroupedData ? this.points : this.data) || [];
  };
  Series16.prototype.getSymbol = function() {
    var seriesMarkerOption = this.options.marker;
    this.getCyclic("symbol", seriesMarkerOption.symbol, this.chart.options.symbols);
  };
  Series16.prototype.findPointIndex = function(optionsObject, fromIndex) {
    var id = optionsObject.id, x = optionsObject.x, oldData = this.points, dataSorting = this.options.dataSorting;
    var matchingPoint, matchedById, pointIndex;
    if (id) {
      var item = this.chart.get(id);
      if (item instanceof Point_default) {
        matchingPoint = item;
      }
    } else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) {
      var matcher = function(oldPoint) {
        return !oldPoint.touched && oldPoint.index === optionsObject.index;
      };
      if (dataSorting && dataSorting.matchByName) {
        matcher = function(oldPoint) {
          return !oldPoint.touched && oldPoint.name === optionsObject.name;
        };
      } else if (this.options.relativeXValue) {
        matcher = function(oldPoint) {
          return !oldPoint.touched && oldPoint.options.x === optionsObject.x;
        };
      }
      matchingPoint = find5(oldData, matcher);
      if (!matchingPoint) {
        return void 0;
      }
    }
    if (matchingPoint) {
      pointIndex = matchingPoint && matchingPoint.index;
      if (typeof pointIndex !== "undefined") {
        matchedById = true;
      }
    }
    if (typeof pointIndex === "undefined" && isNumber18(x)) {
      pointIndex = this.xData.indexOf(x, fromIndex);
    }
    if (pointIndex !== -1 && typeof pointIndex !== "undefined" && this.cropped) {
      pointIndex = pointIndex >= this.cropStart ? pointIndex - this.cropStart : pointIndex;
    }
    if (!matchedById && isNumber18(pointIndex) && oldData[pointIndex] && oldData[pointIndex].touched) {
      pointIndex = void 0;
    }
    return pointIndex;
  };
  Series16.prototype.updateData = function(data, animation) {
    var options = this.options, dataSorting = options.dataSorting, oldData = this.points, pointsToAdd = [], requireSorting = this.requireSorting, equalLength = data.length === oldData.length;
    var hasUpdatedByKey, i, point, lastIndex, succeeded = true;
    this.xIncrement = null;
    data.forEach(function(pointOptions, i2) {
      var optionsObject = defined17(pointOptions) && this.pointClass.prototype.optionsToObject.call({ series: this }, pointOptions) || {};
      var pointIndex;
      var x = optionsObject.x, id = optionsObject.id;
      if (id || isNumber18(x)) {
        pointIndex = this.findPointIndex(optionsObject, lastIndex);
        if (pointIndex === -1 || typeof pointIndex === "undefined") {
          pointsToAdd.push(pointOptions);
        } else if (oldData[pointIndex] && pointOptions !== options.data[pointIndex]) {
          oldData[pointIndex].update(pointOptions, false, null, false);
          oldData[pointIndex].touched = true;
          if (requireSorting) {
            lastIndex = pointIndex + 1;
          }
        } else if (oldData[pointIndex]) {
          oldData[pointIndex].touched = true;
        }
        if (!equalLength || i2 !== pointIndex || dataSorting && dataSorting.enabled || this.hasDerivedData) {
          hasUpdatedByKey = true;
        }
      } else {
        pointsToAdd.push(pointOptions);
      }
    }, this);
    if (hasUpdatedByKey) {
      i = oldData.length;
      while (i--) {
        point = oldData[i];
        if (point && !point.touched && point.remove) {
          point.remove(false, animation);
        }
      }
    } else if (equalLength && (!dataSorting || !dataSorting.enabled)) {
      data.forEach(function(point2, i2) {
        if (point2 !== oldData[i2].y && oldData[i2].update) {
          oldData[i2].update(point2, false, null, false);
        }
      });
      pointsToAdd.length = 0;
    } else {
      succeeded = false;
    }
    oldData.forEach(function(point2) {
      if (point2) {
        point2.touched = false;
      }
    });
    if (!succeeded) {
      return false;
    }
    pointsToAdd.forEach(function(point2) {
      this.addPoint(point2, false, null, null, false);
    }, this);
    if (this.xIncrement === null && this.xData && this.xData.length) {
      this.xIncrement = arrayMax4(this.xData);
      this.autoIncrement();
    }
    return true;
  };
  Series16.prototype.setData = function(data, redraw, animation, updatePoints) {
    var series = this, oldData = series.points, oldDataLength = oldData && oldData.length || 0, options = series.options, chart = series.chart, dataSorting = options.dataSorting, xAxis = series.xAxis, turboThreshold = options.turboThreshold, xData = this.xData, yData = this.yData, pointArrayMap = series.pointArrayMap, valueCount = pointArrayMap && pointArrayMap.length, keys2 = options.keys;
    var i, pt, updatedData, indexOfX = 0, indexOfY = 1, firstPoint = null;
    data = data || [];
    var dataLength = data.length;
    redraw = pick23(redraw, true);
    if (dataSorting && dataSorting.enabled) {
      data = this.sortData(data);
    }
    if (updatePoints !== false && dataLength && oldDataLength && !series.cropped && !series.hasGroupedData && series.visible && !series.isSeriesBoosting) {
      updatedData = this.updateData(data, animation);
    }
    if (!updatedData) {
      series.xIncrement = null;
      series.colorCounter = 0;
      this.parallelArrays.forEach(function(key) {
        series[key + "Data"].length = 0;
      });
      if (turboThreshold && dataLength > turboThreshold) {
        firstPoint = series.getFirstValidPoint(data);
        if (isNumber18(firstPoint)) {
          for (i = 0; i < dataLength; i++) {
            xData[i] = this.autoIncrement();
            yData[i] = data[i];
          }
        } else if (isArray9(firstPoint)) {
          if (valueCount) {
            for (i = 0; i < dataLength; i++) {
              pt = data[i];
              xData[i] = pt[0];
              yData[i] = pt.slice(1, valueCount + 1);
            }
          } else {
            if (keys2) {
              indexOfX = keys2.indexOf("x");
              indexOfY = keys2.indexOf("y");
              indexOfX = indexOfX >= 0 ? indexOfX : 0;
              indexOfY = indexOfY >= 0 ? indexOfY : 1;
            }
            for (i = 0; i < dataLength; i++) {
              pt = data[i];
              xData[i] = pt[indexOfX];
              yData[i] = pt[indexOfY];
            }
          }
        } else {
          error7(12, false, chart);
        }
      } else {
        for (i = 0; i < dataLength; i++) {
          if (typeof data[i] !== "undefined") {
            pt = { series };
            series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);
            series.updateParallelArrays(pt, i);
          }
        }
      }
      if (yData && isString9(yData[0])) {
        error7(14, true, chart);
      }
      series.data = [];
      series.options.data = series.userOptions.data = data;
      i = oldDataLength;
      while (i--) {
        if (oldData[i] && oldData[i].destroy) {
          oldData[i].destroy();
        }
      }
      if (xAxis) {
        xAxis.minRange = xAxis.userMinRange;
      }
      series.isDirty = chart.isDirtyBox = true;
      series.isDirtyData = !!oldData;
      animation = false;
    }
    if (options.legendType === "point") {
      this.processData();
      this.generatePoints();
    }
    if (redraw) {
      chart.redraw(animation);
    }
  };
  Series16.prototype.sortData = function(data) {
    var series = this, options = series.options, dataSorting = options.dataSorting, sortKey = dataSorting.sortKey || "y", getPointOptionsObject = function(series2, pointOptions) {
      return defined17(pointOptions) && series2.pointClass.prototype.optionsToObject.call({
        series: series2
      }, pointOptions) || {};
    };
    data.forEach(function(pointOptions, i) {
      data[i] = getPointOptionsObject(series, pointOptions);
      data[i].index = i;
    }, this);
    var sortedData = data.concat().sort(function(a, b) {
      var aValue = getNestedProperty4(sortKey, a);
      var bValue = getNestedProperty4(sortKey, b);
      return bValue < aValue ? -1 : bValue > aValue ? 1 : 0;
    });
    sortedData.forEach(function(point, i) {
      point.x = i;
    }, this);
    if (series.linkedSeries) {
      series.linkedSeries.forEach(function(linkedSeries) {
        var options2 = linkedSeries.options, seriesData = options2.data;
        if ((!options2.dataSorting || !options2.dataSorting.enabled) && seriesData) {
          seriesData.forEach(function(pointOptions, i) {
            seriesData[i] = getPointOptionsObject(linkedSeries, pointOptions);
            if (data[i]) {
              seriesData[i].x = data[i].x;
              seriesData[i].index = i;
            }
          });
          linkedSeries.setData(seriesData, false);
        }
      });
    }
    return data;
  };
  Series16.prototype.getProcessedData = function(forceExtremesFromAll) {
    var series = this, xAxis = series.xAxis, options = series.options, cropThreshold = options.cropThreshold, getExtremesFromAll = forceExtremesFromAll || series.getExtremesFromAll || options.getExtremesFromAll, isCartesian = series.isCartesian, val2lin = xAxis && xAxis.val2lin, isLog = !!(xAxis && xAxis.logarithmic);
    var croppedData, cropped, cropStart = 0, distance, closestPointRange, i, xExtremes, min, max, processedXData = series.xData, processedYData = series.yData, throwOnUnsorted = series.requireSorting, updatingNames = false;
    var dataLength = processedXData.length;
    if (xAxis) {
      xExtremes = xAxis.getExtremes();
      min = xExtremes.min;
      max = xExtremes.max;
      updatingNames = xAxis.categories && !xAxis.names.length;
    }
    if (isCartesian && series.sorted && !getExtremesFromAll && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {
      if (processedXData[dataLength - 1] < min || processedXData[0] > max) {
        processedXData = [];
        processedYData = [];
      } else if (series.yData && (processedXData[0] < min || processedXData[dataLength - 1] > max)) {
        croppedData = this.cropData(series.xData, series.yData, min, max);
        processedXData = croppedData.xData;
        processedYData = croppedData.yData;
        cropStart = croppedData.start;
        cropped = true;
      }
    }
    i = processedXData.length || 1;
    while (--i) {
      distance = isLog ? val2lin(processedXData[i]) - val2lin(processedXData[i - 1]) : processedXData[i] - processedXData[i - 1];
      if (distance > 0 && (typeof closestPointRange === "undefined" || distance < closestPointRange)) {
        closestPointRange = distance;
      } else if (distance < 0 && throwOnUnsorted && !updatingNames) {
        error7(15, false, series.chart);
        throwOnUnsorted = false;
      }
    }
    return {
      xData: processedXData,
      yData: processedYData,
      cropped,
      cropStart,
      closestPointRange
    };
  };
  Series16.prototype.processData = function(force) {
    var series = this, xAxis = series.xAxis;
    if (series.isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {
      return false;
    }
    var processedData = series.getProcessedData();
    series.cropped = processedData.cropped;
    series.cropStart = processedData.cropStart;
    series.processedXData = processedData.xData;
    series.processedYData = processedData.yData;
    series.closestPointRange = series.basePointRange = processedData.closestPointRange;
  };
  Series16.prototype.cropData = function(xData, yData, min, max, cropShoulder) {
    var dataLength = xData.length;
    var i, j, cropStart = 0, cropEnd = dataLength;
    cropShoulder = pick23(cropShoulder, this.cropShoulder);
    for (i = 0; i < dataLength; i++) {
      if (xData[i] >= min) {
        cropStart = Math.max(0, i - cropShoulder);
        break;
      }
    }
    for (j = i; j < dataLength; j++) {
      if (xData[j] > max) {
        cropEnd = j + cropShoulder;
        break;
      }
    }
    return {
      xData: xData.slice(cropStart, cropEnd),
      yData: yData.slice(cropStart, cropEnd),
      start: cropStart,
      end: cropEnd
    };
  };
  Series16.prototype.generatePoints = function() {
    var series = this, options = series.options, dataOptions = options.data, processedXData = series.processedXData, processedYData = series.processedYData, PointClass = series.pointClass, processedDataLength = processedXData.length, cropStart = series.cropStart || 0, hasGroupedData = series.hasGroupedData, keys2 = options.keys, points = [], groupCropStartIndex = options.dataGrouping && options.dataGrouping.groupAll ? cropStart : 0;
    var dataLength, cursor, point, i, data = series.data;
    if (!data && !hasGroupedData) {
      var arr = [];
      arr.length = dataOptions.length;
      data = series.data = arr;
    }
    if (keys2 && hasGroupedData) {
      series.options.keys = false;
    }
    for (i = 0; i < processedDataLength; i++) {
      cursor = cropStart + i;
      if (!hasGroupedData) {
        point = data[cursor];
        if (!point && typeof dataOptions[cursor] !== "undefined") {
          data[cursor] = point = new PointClass().init(series, dataOptions[cursor], processedXData[i]);
        }
      } else {
        point = new PointClass().init(series, [processedXData[i]].concat(splat8(processedYData[i])));
        point.dataGroup = series.groupMap[groupCropStartIndex + i];
        if (point.dataGroup.options) {
          point.options = point.dataGroup.options;
          extend15(point, point.dataGroup.options);
          delete point.dataLabels;
        }
      }
      if (point) {
        point.index = hasGroupedData ? groupCropStartIndex + i : cursor;
        points[i] = point;
      }
    }
    series.options.keys = keys2;
    if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {
      for (i = 0; i < dataLength; i++) {
        if (i === cropStart && !hasGroupedData) {
          i += processedDataLength;
        }
        if (data[i]) {
          data[i].destroyElements();
          data[i].plotX = void 0;
        }
      }
    }
    series.data = data;
    series.points = points;
    fireEvent11(this, "afterGeneratePoints");
  };
  Series16.prototype.getXExtremes = function(xData) {
    return {
      min: arrayMin4(xData),
      max: arrayMax4(xData)
    };
  };
  Series16.prototype.getExtremes = function(yData, forceExtremesFromAll) {
    var xAxis = this.xAxis, yAxis = this.yAxis, xData = this.processedXData || this.xData, activeYData = [], shoulder = this.requireSorting ? this.cropShoulder : 0, positiveValuesOnly = yAxis ? yAxis.positiveValuesOnly : false;
    var xExtremes, validValue, withinRange, x, y, i, j, xMin = 0, xMax = 0, activeCounter = 0;
    yData = yData || this.stackedYData || this.processedYData || [];
    var yDataLength = yData.length;
    if (xAxis) {
      xExtremes = xAxis.getExtremes();
      xMin = xExtremes.min;
      xMax = xExtremes.max;
    }
    for (i = 0; i < yDataLength; i++) {
      x = xData[i];
      y = yData[i];
      validValue = (isNumber18(y) || isArray9(y)) && (y.length || y > 0 || !positiveValuesOnly);
      withinRange = forceExtremesFromAll || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !xAxis || (xData[i + shoulder] || x) >= xMin && (xData[i - shoulder] || x) <= xMax;
      if (validValue && withinRange) {
        j = y.length;
        if (j) {
          while (j--) {
            if (isNumber18(y[j])) {
              activeYData[activeCounter++] = y[j];
            }
          }
        } else {
          activeYData[activeCounter++] = y;
        }
      }
    }
    var dataExtremes = {
      dataMin: arrayMin4(activeYData),
      dataMax: arrayMax4(activeYData)
    };
    fireEvent11(this, "afterGetExtremes", { dataExtremes });
    return dataExtremes;
  };
  Series16.prototype.applyExtremes = function() {
    var dataExtremes = this.getExtremes();
    this.dataMin = dataExtremes.dataMin;
    this.dataMax = dataExtremes.dataMax;
    return dataExtremes;
  };
  Series16.prototype.getFirstValidPoint = function(data) {
    var dataLength = data.length;
    var i = 0, firstPoint = null;
    while (firstPoint === null && i < dataLength) {
      firstPoint = data[i];
      i++;
    }
    return firstPoint;
  };
  Series16.prototype.translate = function() {
    if (!this.processedXData) {
      this.processData();
    }
    this.generatePoints();
    var series = this, options = series.options, stacking = options.stacking, xAxis = series.xAxis, categories = xAxis.categories, enabledDataSorting = series.enabledDataSorting, yAxis = series.yAxis, points = series.points, dataLength = points.length, hasModifyValue = !!series.modifyValue, pointPlacement = series.pointPlacementToXValue(), dynamicallyPlaced = Boolean(pointPlacement), threshold = options.threshold, stackThreshold = options.startFromThreshold ? threshold : 0, zoneAxis = this.zoneAxis || "y";
    var i, plotX, lastPlotX, stackIndicator, closestPointRangePx = Number.MAX_VALUE;
    function limitedRange(val) {
      return clamp6(val, -1e5, 1e5);
    }
    for (i = 0; i < dataLength; i++) {
      var point = points[i], xValue = point.x;
      var pointStack = void 0, stackValues = void 0, yValue = point.y, yBottom = point.low;
      var stack = stacking && yAxis.stacking && yAxis.stacking.stacks[(series.negStacks && yValue < (stackThreshold ? 0 : threshold) ? "-" : "") + series.stackKey];
      if (yAxis.positiveValuesOnly && !yAxis.validatePositiveValue(yValue) || xAxis.positiveValuesOnly && !xAxis.validatePositiveValue(xValue)) {
        point.isNull = true;
      }
      point.plotX = plotX = correctFloat4(limitedRange(xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement, this.type === "flags")));
      if (stacking && series.visible && stack && stack[xValue]) {
        stackIndicator = series.getStackIndicator(stackIndicator, xValue, series.index);
        if (!point.isNull) {
          pointStack = stack[xValue];
          stackValues = pointStack.points[stackIndicator.key];
        }
      }
      if (isArray9(stackValues)) {
        yBottom = stackValues[0];
        yValue = stackValues[1];
        if (yBottom === stackThreshold && stackIndicator.key === stack[xValue].base) {
          yBottom = pick23(isNumber18(threshold) && threshold, yAxis.min);
        }
        if (yAxis.positiveValuesOnly && yBottom <= 0) {
          yBottom = null;
        }
        point.total = point.stackTotal = pointStack.total;
        point.percentage = pointStack.total && point.y / pointStack.total * 100;
        point.stackY = yValue;
        if (!series.irregularWidths) {
          pointStack.setOffset(series.pointXOffset || 0, series.barW || 0);
        }
      }
      point.yBottom = defined17(yBottom) ? limitedRange(yAxis.translate(yBottom, 0, 1, 0, 1)) : null;
      if (hasModifyValue) {
        yValue = series.modifyValue(yValue, point);
      }
      point.plotY = void 0;
      if (isNumber18(yValue)) {
        var translated = yAxis.translate(yValue, false, true, false, true);
        if (typeof translated !== "undefined") {
          point.plotY = limitedRange(translated);
        }
      }
      point.isInside = this.isPointInside(point);
      point.clientX = dynamicallyPlaced ? correctFloat4(xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement)) : plotX;
      point.negative = point[zoneAxis] < (options[zoneAxis + "Threshold"] || threshold || 0);
      point.category = categories && typeof categories[point.x] !== "undefined" ? categories[point.x] : point.x;
      if (!point.isNull && point.visible !== false) {
        if (typeof lastPlotX !== "undefined") {
          closestPointRangePx = Math.min(closestPointRangePx, Math.abs(plotX - lastPlotX));
        }
        lastPlotX = plotX;
      }
      point.zone = this.zones.length && point.getZone();
      if (!point.graphic && series.group && enabledDataSorting) {
        point.isNew = true;
      }
    }
    series.closestPointRangePx = closestPointRangePx;
    fireEvent11(this, "afterTranslate");
  };
  Series16.prototype.getValidPoints = function(points, insideOnly, allowNull) {
    var chart = this.chart;
    return (points || this.points || []).filter(function(point) {
      if (insideOnly && !chart.isInsidePlot(point.plotX, point.plotY, { inverted: chart.inverted })) {
        return false;
      }
      return point.visible !== false && (allowNull || !point.isNull);
    });
  };
  Series16.prototype.getClipBox = function(animation, finalBox) {
    var series = this, options = series.options, chart = series.chart, inverted = chart.inverted, xAxis = series.xAxis, yAxis = xAxis && series.yAxis, scrollablePlotAreaOptions = chart.options.chart.scrollablePlotArea || {};
    var clipBox;
    if (animation && options.clip === false && yAxis) {
      clipBox = inverted ? {
        y: -chart.chartWidth + yAxis.len + yAxis.pos,
        height: chart.chartWidth,
        width: chart.chartHeight,
        x: -chart.chartHeight + xAxis.len + xAxis.pos
      } : {
        y: -yAxis.pos,
        height: chart.chartHeight,
        width: chart.chartWidth,
        x: -xAxis.pos
      };
    } else {
      clipBox = series.clipBox || chart.clipBox;
      if (finalBox) {
        clipBox.width = chart.plotSizeX;
        clipBox.x = (chart.scrollablePixelsX || 0) * (scrollablePlotAreaOptions.scrollPositionX || 0);
      }
    }
    return !finalBox ? clipBox : {
      width: clipBox.width,
      x: clipBox.x
    };
  };
  Series16.prototype.getSharedClipKey = function(animation) {
    if (this.sharedClipKey) {
      return this.sharedClipKey;
    }
    var sharedClipKey = [
      animation && animation.duration,
      animation && animation.easing,
      animation && animation.defer,
      this.getClipBox(animation).height,
      this.options.xAxis,
      this.options.yAxis
    ].join(",");
    if (this.options.clip !== false || animation) {
      this.sharedClipKey = sharedClipKey;
    }
    return sharedClipKey;
  };
  Series16.prototype.setClip = function(animation) {
    var chart = this.chart, options = this.options, renderer = chart.renderer, inverted = chart.inverted, seriesClipBox = this.clipBox, clipBox = this.getClipBox(animation), sharedClipKey = this.getSharedClipKey(animation);
    var clipRect = chart.sharedClips[sharedClipKey], markerClipRect = chart.sharedClips[sharedClipKey + "m"];
    if (animation) {
      clipBox.width = 0;
      if (inverted) {
        clipBox.x = chart.plotHeight + (options.clip !== false ? 0 : chart.plotTop);
      }
    }
    if (!clipRect) {
      if (animation) {
        chart.sharedClips[sharedClipKey + "m"] = markerClipRect = renderer.clipRect(inverted ? (chart.plotSizeX || 0) + 99 : -99, inverted ? -chart.plotLeft : -chart.plotTop, 99, inverted ? chart.chartWidth : chart.chartHeight);
      }
      chart.sharedClips[sharedClipKey] = clipRect = renderer.clipRect(clipBox);
      clipRect.count = { length: 0 };
    } else if (!chart.hasLoaded) {
      clipRect.attr(clipBox);
    }
    if (animation) {
      if (!clipRect.count[this.index]) {
        clipRect.count[this.index] = true;
        clipRect.count.length += 1;
      }
    }
    if (options.clip !== false || animation) {
      this.group.clip(animation || seriesClipBox ? clipRect : chart.clipRect);
      this.markerGroup.clip(markerClipRect);
    }
    if (!animation) {
      if (clipRect.count[this.index]) {
        delete clipRect.count[this.index];
        clipRect.count.length -= 1;
      }
      if (clipRect.count.length === 0) {
        if (!seriesClipBox) {
          chart.sharedClips[sharedClipKey] = clipRect.destroy();
        }
        if (markerClipRect) {
          chart.sharedClips[sharedClipKey + "m"] = markerClipRect.destroy();
        }
      }
    }
  };
  Series16.prototype.animate = function(init) {
    var series = this, chart = series.chart, animation = animObject7(series.options.animation), sharedClipKey = this.sharedClipKey;
    if (init) {
      series.setClip(animation);
    } else if (sharedClipKey) {
      var clipRect = chart.sharedClips[sharedClipKey];
      var markerClipRect = chart.sharedClips[sharedClipKey + "m"];
      var finalBox = series.getClipBox(animation, true);
      if (clipRect) {
        clipRect.animate(finalBox, animation);
      }
      if (markerClipRect) {
        markerClipRect.animate({
          width: finalBox.width + 99,
          x: finalBox.x - (chart.inverted ? 0 : 99)
        }, animation);
      }
    }
  };
  Series16.prototype.afterAnimate = function() {
    this.setClip();
    fireEvent11(this, "afterAnimate");
    this.finishedAnimating = true;
  };
  Series16.prototype.drawPoints = function() {
    var series = this, points = series.points, chart = series.chart, options = series.options, seriesMarkerOptions = options.marker, markerGroup = series[series.specialGroup] || series.markerGroup, xAxis = series.xAxis, globallyEnabled = pick23(seriesMarkerOptions.enabled, !xAxis || xAxis.isRadial ? true : null, series.closestPointRangePx >= seriesMarkerOptions.enabledThreshold * seriesMarkerOptions.radius);
    var i, point, graphic, verb, pointMarkerOptions, hasPointMarker, markerAttribs;
    if (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {
      for (i = 0; i < points.length; i++) {
        point = points[i];
        graphic = point.graphic;
        verb = graphic ? "animate" : "attr";
        pointMarkerOptions = point.marker || {};
        hasPointMarker = !!point.marker;
        var shouldDrawMarker = (globallyEnabled && typeof pointMarkerOptions.enabled === "undefined" || pointMarkerOptions.enabled) && !point.isNull && point.visible !== false;
        if (shouldDrawMarker) {
          var symbol = pick23(pointMarkerOptions.symbol, series.symbol, "rect");
          markerAttribs = series.markerAttribs(point, point.selected && "select");
          if (series.enabledDataSorting) {
            point.startXPos = xAxis.reversed ? -(markerAttribs.width || 0) : xAxis.width;
          }
          var isInside = point.isInside !== false;
          if (graphic) {
            graphic[isInside ? "show" : "hide"](isInside).animate(markerAttribs);
          } else if (isInside && ((markerAttribs.width || 0) > 0 || point.hasImage)) {
            point.graphic = graphic = chart.renderer.symbol(symbol, markerAttribs.x, markerAttribs.y, markerAttribs.width, markerAttribs.height, hasPointMarker ? pointMarkerOptions : seriesMarkerOptions).add(markerGroup);
            if (series.enabledDataSorting && chart.hasRendered) {
              graphic.attr({
                x: point.startXPos
              });
              verb = "animate";
            }
          }
          if (graphic && verb === "animate") {
            graphic[isInside ? "show" : "hide"](isInside).animate(markerAttribs);
          }
          if (graphic && !chart.styledMode) {
            graphic[verb](series.pointAttribs(point, point.selected && "select"));
          }
          if (graphic) {
            graphic.addClass(point.getClassName(), true);
          }
        } else if (graphic) {
          point.graphic = graphic.destroy();
        }
      }
    }
  };
  Series16.prototype.markerAttribs = function(point, state) {
    var seriesOptions = this.options, seriesMarkerOptions = seriesOptions.marker, pointMarkerOptions = point.marker || {}, symbol = pointMarkerOptions.symbol || seriesMarkerOptions.symbol;
    var seriesStateOptions, pointStateOptions, radius = pick23(pointMarkerOptions.radius, seriesMarkerOptions.radius);
    if (state) {
      seriesStateOptions = seriesMarkerOptions.states[state];
      pointStateOptions = pointMarkerOptions.states && pointMarkerOptions.states[state];
      radius = pick23(pointStateOptions && pointStateOptions.radius, seriesStateOptions && seriesStateOptions.radius, radius + (seriesStateOptions && seriesStateOptions.radiusPlus || 0));
    }
    point.hasImage = symbol && symbol.indexOf("url") === 0;
    if (point.hasImage) {
      radius = 0;
    }
    var attribs = {
      x: seriesOptions.crisp ? Math.floor(point.plotX - radius) : point.plotX - radius,
      y: point.plotY - radius
    };
    if (radius) {
      attribs.width = attribs.height = 2 * radius;
    }
    return attribs;
  };
  Series16.prototype.pointAttribs = function(point, state) {
    var seriesMarkerOptions = this.options.marker, pointOptions = point && point.options, pointMarkerOptions = pointOptions && pointOptions.marker || {}, pointColorOption = pointOptions && pointOptions.color, pointColor = point && point.color, zoneColor = point && point.zone && point.zone.color;
    var seriesStateOptions, pointStateOptions, color18 = this.color, fill, stroke, strokeWidth = pick23(pointMarkerOptions.lineWidth, seriesMarkerOptions.lineWidth), opacity = 1;
    color18 = pointColorOption || zoneColor || pointColor || color18;
    fill = pointMarkerOptions.fillColor || seriesMarkerOptions.fillColor || color18;
    stroke = pointMarkerOptions.lineColor || seriesMarkerOptions.lineColor || color18;
    state = state || "normal";
    if (state) {
      seriesStateOptions = seriesMarkerOptions.states[state];
      pointStateOptions = pointMarkerOptions.states && pointMarkerOptions.states[state] || {};
      strokeWidth = pick23(pointStateOptions.lineWidth, seriesStateOptions.lineWidth, strokeWidth + pick23(pointStateOptions.lineWidthPlus, seriesStateOptions.lineWidthPlus, 0));
      fill = pointStateOptions.fillColor || seriesStateOptions.fillColor || fill;
      stroke = pointStateOptions.lineColor || seriesStateOptions.lineColor || stroke;
      opacity = pick23(pointStateOptions.opacity, seriesStateOptions.opacity, opacity);
    }
    return {
      "stroke": stroke,
      "stroke-width": strokeWidth,
      "fill": fill,
      "opacity": opacity
    };
  };
  Series16.prototype.destroy = function(keepEventsForUpdate) {
    var series = this, chart = series.chart, issue134 = /AppleWebKit\/533/.test(win11.navigator.userAgent), data = series.data || [];
    var destroy, i, point, axis;
    fireEvent11(series, "destroy");
    this.removeEvents(keepEventsForUpdate);
    (series.axisTypes || []).forEach(function(AXIS) {
      axis = series[AXIS];
      if (axis && axis.series) {
        erase8(axis.series, series);
        axis.isDirty = axis.forceRedraw = true;
      }
    });
    if (series.legendItem) {
      series.chart.legend.destroyItem(series);
    }
    i = data.length;
    while (i--) {
      point = data[i];
      if (point && point.destroy) {
        point.destroy();
      }
    }
    if (series.clips) {
      series.clips.forEach(function(clip) {
        return clip.destroy();
      });
    }
    Utilities_default.clearTimeout(series.animationTimeout);
    objectEach16(series, function(val, prop) {
      if (val instanceof SVGElement_default && !val.survive) {
        destroy = issue134 && prop === "group" ? "hide" : "destroy";
        val[destroy]();
      }
    });
    if (chart.hoverSeries === series) {
      chart.hoverSeries = void 0;
    }
    erase8(chart.series, series);
    chart.orderSeries();
    objectEach16(series, function(val, prop) {
      if (!keepEventsForUpdate || prop !== "hcEvents") {
        delete series[prop];
      }
    });
  };
  Series16.prototype.applyZones = function() {
    var series = this, chart = this.chart, renderer = chart.renderer, zones = this.zones, clips = this.clips || [], graph = this.graph, area = this.area, chartSizeMax = Math.max(chart.chartWidth, chart.chartHeight), axis = this[(this.zoneAxis || "y") + "Axis"], inverted = chart.inverted;
    var translatedFrom, translatedTo, clipAttr, extremes, reversed, horiz, pxRange, pxPosMin, pxPosMax, zoneArea, zoneGraph, ignoreZones = false;
    if (zones.length && (graph || area) && axis && typeof axis.min !== "undefined") {
      reversed = axis.reversed;
      horiz = axis.horiz;
      if (graph && !this.showLine) {
        graph.hide();
      }
      if (area) {
        area.hide();
      }
      extremes = axis.getExtremes();
      zones.forEach(function(threshold, i) {
        translatedFrom = reversed ? horiz ? chart.plotWidth : 0 : horiz ? 0 : axis.toPixels(extremes.min) || 0;
        translatedFrom = clamp6(pick23(translatedTo, translatedFrom), 0, chartSizeMax);
        translatedTo = clamp6(Math.round(axis.toPixels(pick23(threshold.value, extremes.max), true) || 0), 0, chartSizeMax);
        if (ignoreZones) {
          translatedFrom = translatedTo = axis.toPixels(extremes.max);
        }
        pxRange = Math.abs(translatedFrom - translatedTo);
        pxPosMin = Math.min(translatedFrom, translatedTo);
        pxPosMax = Math.max(translatedFrom, translatedTo);
        if (axis.isXAxis) {
          clipAttr = {
            x: inverted ? pxPosMax : pxPosMin,
            y: 0,
            width: pxRange,
            height: chartSizeMax
          };
          if (!horiz) {
            clipAttr.x = chart.plotHeight - clipAttr.x;
          }
        } else {
          clipAttr = {
            x: 0,
            y: inverted ? pxPosMax : pxPosMin,
            width: chartSizeMax,
            height: pxRange
          };
          if (horiz) {
            clipAttr.y = chart.plotWidth - clipAttr.y;
          }
        }
        if (inverted && renderer.isVML) {
          if (axis.isXAxis) {
            clipAttr = {
              x: 0,
              y: reversed ? pxPosMin : pxPosMax,
              height: clipAttr.width,
              width: chart.chartWidth
            };
          } else {
            clipAttr = {
              x: clipAttr.y - chart.plotLeft - chart.spacingBox.x,
              y: 0,
              width: clipAttr.height,
              height: chart.chartHeight
            };
          }
        }
        if (clips[i]) {
          clips[i].animate(clipAttr);
        } else {
          clips[i] = renderer.clipRect(clipAttr);
        }
        zoneArea = series["zone-area-" + i];
        zoneGraph = series["zone-graph-" + i];
        if (graph && zoneGraph) {
          zoneGraph.clip(clips[i]);
        }
        if (area && zoneArea) {
          zoneArea.clip(clips[i]);
        }
        ignoreZones = threshold.value > extremes.max;
        if (series.resetZones && translatedTo === 0) {
          translatedTo = void 0;
        }
      });
      this.clips = clips;
    } else if (series.visible) {
      if (graph) {
        graph.show(true);
      }
      if (area) {
        area.show(true);
      }
    }
  };
  Series16.prototype.invertGroups = function(inverted) {
    var series = this, chart = series.chart;
    function setInvert() {
      ["group", "markerGroup"].forEach(function(groupName) {
        if (series[groupName]) {
          if (chart.renderer.isVML) {
            series[groupName].attr({
              width: series.yAxis.len,
              height: series.xAxis.len
            });
          }
          series[groupName].width = series.yAxis.len;
          series[groupName].height = series.xAxis.len;
          series[groupName].invert(series.isRadialSeries ? false : inverted);
        }
      });
    }
    if (!series.xAxis) {
      return;
    }
    series.eventsToUnbind.push(addEvent13(chart, "resize", setInvert));
    setInvert();
    series.invertGroups = setInvert;
  };
  Series16.prototype.plotGroup = function(prop, name, visibility, zIndex, parent) {
    var group = this[prop];
    var isNew = !group, attrs = {
      visibility,
      zIndex: zIndex || 0.1
    };
    if (typeof this.opacity !== "undefined" && !this.chart.styledMode && this.state !== "inactive") {
      attrs.opacity = this.opacity;
    }
    if (isNew) {
      this[prop] = group = this.chart.renderer.g().add(parent);
    }
    group.addClass("highcharts-" + name + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (defined17(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (group.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), true);
    group.attr(attrs)[isNew ? "attr" : "animate"](this.getPlotBox());
    return group;
  };
  Series16.prototype.getPlotBox = function() {
    var chart = this.chart;
    var xAxis = this.xAxis, yAxis = this.yAxis;
    if (chart.inverted) {
      xAxis = yAxis;
      yAxis = this.xAxis;
    }
    return {
      translateX: xAxis ? xAxis.left : chart.plotLeft,
      translateY: yAxis ? yAxis.top : chart.plotTop,
      scaleX: 1,
      scaleY: 1
    };
  };
  Series16.prototype.removeEvents = function(keepEventsForUpdate) {
    var series = this;
    if (!keepEventsForUpdate) {
      removeEvent8(series);
    }
    if (series.eventsToUnbind.length) {
      series.eventsToUnbind.forEach(function(unbind) {
        unbind();
      });
      series.eventsToUnbind.length = 0;
    }
  };
  Series16.prototype.render = function() {
    var series = this, chart = series.chart, options = series.options, animOptions = animObject7(options.animation), visibility = series.visible ? "inherit" : "hidden", zIndex = options.zIndex, hasRendered = series.hasRendered, chartSeriesGroup = chart.seriesGroup, inverted = chart.inverted;
    var animDuration = !series.finishedAnimating && chart.renderer.isSVG && animOptions.duration;
    fireEvent11(this, "render");
    var group = series.plotGroup("group", "series", visibility, zIndex, chartSeriesGroup);
    series.markerGroup = series.plotGroup("markerGroup", "markers", visibility, zIndex, chartSeriesGroup);
    if (animDuration && series.animate) {
      series.animate(true);
    }
    group.inverted = pick23(series.invertible, series.isCartesian) ? inverted : false;
    if (series.drawGraph) {
      series.drawGraph();
      series.applyZones();
    }
    if (series.visible) {
      series.drawPoints();
    }
    if (series.drawDataLabels) {
      series.drawDataLabels();
    }
    if (series.redrawPoints) {
      series.redrawPoints();
    }
    if (series.drawTracker && series.options.enableMouseTracking !== false) {
      series.drawTracker();
    }
    series.invertGroups(inverted);
    if (options.clip !== false && !series.sharedClipKey && !hasRendered) {
      group.clip(chart.clipRect);
    }
    if (animDuration && series.animate) {
      series.animate();
    }
    if (!hasRendered) {
      if (animDuration && animOptions.defer) {
        animDuration += animOptions.defer;
      }
      series.animationTimeout = syncTimeout8(function() {
        series.afterAnimate();
      }, animDuration || 0);
    }
    series.isDirty = false;
    series.hasRendered = true;
    fireEvent11(series, "afterRender");
  };
  Series16.prototype.redraw = function() {
    var series = this, chart = series.chart, wasDirty = series.isDirty || series.isDirtyData, group = series.group, xAxis = series.xAxis, yAxis = series.yAxis;
    if (group) {
      if (chart.inverted) {
        group.attr({
          width: chart.plotWidth,
          height: chart.plotHeight
        });
      }
      group.animate({
        translateX: pick23(xAxis && xAxis.left, chart.plotLeft),
        translateY: pick23(yAxis && yAxis.top, chart.plotTop)
      });
    }
    series.translate();
    series.render();
    if (wasDirty) {
      delete this.kdTree;
    }
  };
  Series16.prototype.searchPoint = function(e2, compareX) {
    var series = this, xAxis = series.xAxis, yAxis = series.yAxis, inverted = series.chart.inverted;
    return this.searchKDTree({
      clientX: inverted ? xAxis.len - e2.chartY + xAxis.pos : e2.chartX - xAxis.pos,
      plotY: inverted ? yAxis.len - e2.chartX + yAxis.pos : e2.chartY - yAxis.pos
    }, compareX, e2);
  };
  Series16.prototype.buildKDTree = function(e2) {
    this.buildingKdTree = true;
    var series = this, dimensions = series.options.findNearestPointBy.indexOf("y") > -1 ? 2 : 1;
    function _kdtree(points, depth, dimensions2) {
      var length = points && points.length;
      var axis, median;
      if (length) {
        axis = series.kdAxisArray[depth % dimensions2];
        points.sort(function(a, b) {
          return a[axis] - b[axis];
        });
        median = Math.floor(length / 2);
        return {
          point: points[median],
          left: _kdtree(points.slice(0, median), depth + 1, dimensions2),
          right: _kdtree(points.slice(median + 1), depth + 1, dimensions2)
        };
      }
    }
    function startRecursive() {
      series.kdTree = _kdtree(series.getValidPoints(null, !series.directTouch), dimensions, dimensions);
      series.buildingKdTree = false;
    }
    delete series.kdTree;
    syncTimeout8(startRecursive, series.options.kdNow || e2 && e2.type === "touchstart" ? 0 : 1);
  };
  Series16.prototype.searchKDTree = function(point, compareX, e2) {
    var series = this, kdX = this.kdAxisArray[0], kdY = this.kdAxisArray[1], kdComparer = compareX ? "distX" : "dist", kdDimensions = series.options.findNearestPointBy.indexOf("y") > -1 ? 2 : 1;
    function setDistance(p1, p2) {
      var x = defined17(p1[kdX]) && defined17(p2[kdX]) ? Math.pow(p1[kdX] - p2[kdX], 2) : null, y = defined17(p1[kdY]) && defined17(p2[kdY]) ? Math.pow(p1[kdY] - p2[kdY], 2) : null, r = (x || 0) + (y || 0);
      p2.dist = defined17(r) ? Math.sqrt(r) : Number.MAX_VALUE;
      p2.distX = defined17(x) ? Math.sqrt(x) : Number.MAX_VALUE;
    }
    function _search(search, tree, depth, dimensions) {
      var point2 = tree.point, axis = series.kdAxisArray[depth % dimensions];
      var nPoint1, nPoint2, ret = point2;
      setDistance(search, point2);
      var tdist = search[axis] - point2[axis], sideA = tdist < 0 ? "left" : "right", sideB = tdist < 0 ? "right" : "left";
      if (tree[sideA]) {
        nPoint1 = _search(search, tree[sideA], depth + 1, dimensions);
        ret = nPoint1[kdComparer] < ret[kdComparer] ? nPoint1 : point2;
      }
      if (tree[sideB]) {
        if (Math.sqrt(tdist * tdist) < ret[kdComparer]) {
          nPoint2 = _search(search, tree[sideB], depth + 1, dimensions);
          ret = nPoint2[kdComparer] < ret[kdComparer] ? nPoint2 : ret;
        }
      }
      return ret;
    }
    if (!this.kdTree && !this.buildingKdTree) {
      this.buildKDTree(e2);
    }
    if (this.kdTree) {
      return _search(point, this.kdTree, kdDimensions, kdDimensions);
    }
  };
  Series16.prototype.pointPlacementToXValue = function() {
    var _a15 = this, _b = _a15.options, pointPlacement = _b.pointPlacement, pointRange = _b.pointRange, axis = _a15.xAxis;
    var factor = pointPlacement;
    if (factor === "between") {
      factor = axis.reversed ? -0.5 : 0.5;
    }
    return isNumber18(factor) ? factor * (pointRange || axis.pointRange) : 0;
  };
  Series16.prototype.isPointInside = function(point) {
    var isInside = typeof point.plotY !== "undefined" && typeof point.plotX !== "undefined" && point.plotY >= 0 && point.plotY <= this.yAxis.len && point.plotX >= 0 && point.plotX <= this.xAxis.len;
    return isInside;
  };
  Series16.prototype.drawTracker = function() {
    var series = this, options = series.options, trackByArea = options.trackByArea, trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath), chart = series.chart, pointer = chart.pointer, renderer = chart.renderer, snap = chart.options.tooltip.snap, tracker = series.tracker, onMouseOver = function(e2) {
      if (chart.hoverSeries !== series) {
        series.onMouseOver();
      }
    }, TRACKER_FILL = "rgba(192,192,192," + (svg4 ? 1e-4 : 2e-3) + ")";
    var i;
    if (tracker) {
      tracker.attr({ d: trackerPath });
    } else if (series.graph) {
      series.tracker = renderer.path(trackerPath).attr({
        visibility: series.visible ? "visible" : "hidden",
        zIndex: 2
      }).addClass(trackByArea ? "highcharts-tracker-area" : "highcharts-tracker-line").add(series.group);
      if (!chart.styledMode) {
        series.tracker.attr({
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          stroke: TRACKER_FILL,
          fill: trackByArea ? TRACKER_FILL : "none",
          "stroke-width": series.graph.strokeWidth() + (trackByArea ? 0 : 2 * snap)
        });
      }
      [
        series.tracker,
        series.markerGroup,
        series.dataLabelsGroup
      ].forEach(function(tracker2) {
        if (tracker2) {
          tracker2.addClass("highcharts-tracker").on("mouseover", onMouseOver).on("mouseout", function(e2) {
            pointer.onTrackerMouseOut(e2);
          });
          if (options.cursor && !chart.styledMode) {
            tracker2.css({ cursor: options.cursor });
          }
          if (hasTouch) {
            tracker2.on("touchstart", onMouseOver);
          }
        }
      });
    }
    fireEvent11(this, "afterDrawTracker");
  };
  Series16.prototype.addPoint = function(options, redraw, shift, animation, withEvent) {
    var series = this, seriesOptions = series.options, data = series.data, chart = series.chart, xAxis = series.xAxis, names = xAxis && xAxis.hasNames && xAxis.names, dataOptions = seriesOptions.data, xData = series.xData;
    var isInTheMiddle, i;
    redraw = pick23(redraw, true);
    var point = { series };
    series.pointClass.prototype.applyOptions.apply(point, [options]);
    var x = point.x;
    i = xData.length;
    if (series.requireSorting && x < xData[i - 1]) {
      isInTheMiddle = true;
      while (i && xData[i - 1] > x) {
        i--;
      }
    }
    series.updateParallelArrays(point, "splice", i, 0, 0);
    series.updateParallelArrays(point, i);
    if (names && point.name) {
      names[x] = point.name;
    }
    dataOptions.splice(i, 0, options);
    if (isInTheMiddle) {
      series.data.splice(i, 0, null);
      series.processData();
    }
    if (seriesOptions.legendType === "point") {
      series.generatePoints();
    }
    if (shift) {
      if (data[0] && data[0].remove) {
        data[0].remove(false);
      } else {
        data.shift();
        series.updateParallelArrays(point, "shift");
        dataOptions.shift();
      }
    }
    if (withEvent !== false) {
      fireEvent11(series, "addPoint", { point });
    }
    series.isDirty = true;
    series.isDirtyData = true;
    if (redraw) {
      chart.redraw(animation);
    }
  };
  Series16.prototype.removePoint = function(i, redraw, animation) {
    var series = this, data = series.data, point = data[i], points = series.points, chart = series.chart, remove = function() {
      if (points && points.length === data.length) {
        points.splice(i, 1);
      }
      data.splice(i, 1);
      series.options.data.splice(i, 1);
      series.updateParallelArrays(point || { series }, "splice", i, 1);
      if (point) {
        point.destroy();
      }
      series.isDirty = true;
      series.isDirtyData = true;
      if (redraw) {
        chart.redraw();
      }
    };
    setAnimation4(animation, chart);
    redraw = pick23(redraw, true);
    if (point) {
      point.firePointEvent("remove", null, remove);
    } else {
      remove();
    }
  };
  Series16.prototype.remove = function(redraw, animation, withEvent, keepEvents) {
    var series = this, chart = series.chart;
    function remove() {
      series.destroy(keepEvents);
      chart.isDirtyLegend = chart.isDirtyBox = true;
      chart.linkSeries();
      if (pick23(redraw, true)) {
        chart.redraw(animation);
      }
    }
    if (withEvent !== false) {
      fireEvent11(series, "remove", null, remove);
    } else {
      remove();
    }
  };
  Series16.prototype.update = function(options, redraw) {
    options = cleanRecursively3(options, this.userOptions);
    fireEvent11(this, "update", { options });
    var series = this, chart = series.chart, oldOptions = series.userOptions, initialType = series.initialType || series.type, plotOptions = chart.options.plotOptions, initialSeriesProto = seriesTypes2[initialType].prototype, groups = [
      "group",
      "markerGroup",
      "dataLabelsGroup",
      "transformGroup"
    ], animation = series.finishedAnimating && { animation: false }, kinds = {};
    var seriesOptions, n, preserve = [
      "eventOptions",
      "navigatorSeries",
      "baseSeries"
    ], newType = options.type || oldOptions.type || chart.options.chart.type;
    var keepPoints = !(this.hasDerivedData || newType && newType !== this.type || typeof options.pointStart !== "undefined" || typeof options.pointInterval !== "undefined" || typeof options.relativeXValue !== "undefined" || series.hasOptionChanged("dataGrouping") || series.hasOptionChanged("pointStart") || series.hasOptionChanged("pointInterval") || series.hasOptionChanged("pointIntervalUnit") || series.hasOptionChanged("keys"));
    newType = newType || initialType;
    if (keepPoints) {
      preserve.push("data", "isDirtyData", "points", "processedXData", "processedYData", "xIncrement", "cropped", "_hasPointMarkers", "_hasPointLabels", "clips", "nodes", "layout", "mapMap", "mapData", "minY", "maxY", "minX", "maxX");
      if (options.visible !== false) {
        preserve.push("area", "graph");
      }
      series.parallelArrays.forEach(function(key) {
        preserve.push(key + "Data");
      });
      if (options.data) {
        if (options.dataSorting) {
          extend15(series.options.dataSorting, options.dataSorting);
        }
        this.setData(options.data, false);
      }
    }
    options = merge18(oldOptions, animation, {
      index: typeof oldOptions.index === "undefined" ? series.index : oldOptions.index,
      pointStart: pick23(plotOptions && plotOptions.series && plotOptions.series.pointStart, oldOptions.pointStart, series.xData[0])
    }, !keepPoints && { data: series.options.data }, options);
    if (keepPoints && options.data) {
      options.data = series.options.data;
    }
    preserve = groups.concat(preserve);
    preserve.forEach(function(prop) {
      preserve[prop] = series[prop];
      delete series[prop];
    });
    var casting = false;
    if (seriesTypes2[newType]) {
      casting = newType !== series.type;
      series.remove(false, false, false, true);
      if (casting) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(series, seriesTypes2[newType].prototype);
        } else {
          var ownEvents = Object.hasOwnProperty.call(series, "hcEvents") && series.hcEvents;
          for (n in initialSeriesProto) {
            series[n] = void 0;
          }
          extend15(series, seriesTypes2[newType].prototype);
          if (ownEvents) {
            series.hcEvents = ownEvents;
          } else {
            delete series.hcEvents;
          }
        }
      }
    } else {
      error7(17, true, chart, { missingModuleFor: newType });
    }
    preserve.forEach(function(prop) {
      series[prop] = preserve[prop];
    });
    series.init(chart, options);
    if (keepPoints && this.points) {
      seriesOptions = series.options;
      if (seriesOptions.visible === false) {
        kinds.graphic = 1;
        kinds.dataLabel = 1;
      } else if (!series._hasPointLabels) {
        var marker = seriesOptions.marker, dataLabels = seriesOptions.dataLabels;
        if (marker && (marker.enabled === false || (oldOptions.marker && oldOptions.marker.symbol) !== marker.symbol)) {
          kinds.graphic = 1;
        }
        if (dataLabels && dataLabels.enabled === false) {
          kinds.dataLabel = 1;
        }
      }
      this.points.forEach(function(point) {
        if (point && point.series) {
          point.resolveColor();
          if (Object.keys(kinds).length) {
            point.destroyElements(kinds);
          }
          if (seriesOptions.showInLegend === false && point.legendItem) {
            chart.legend.destroyItem(point);
          }
        }
      }, this);
    }
    series.initialType = initialType;
    chart.linkSeries();
    if (casting && series.linkedSeries.length) {
      series.isDirtyData = true;
    }
    fireEvent11(this, "afterUpdate");
    if (pick23(redraw, true)) {
      chart.redraw(keepPoints ? void 0 : false);
    }
  };
  Series16.prototype.setName = function(name) {
    this.name = this.options.name = this.userOptions.name = name;
    this.chart.isDirtyLegend = true;
  };
  Series16.prototype.hasOptionChanged = function(optionName) {
    var chart = this.chart, option = this.options[optionName], plotOptions = chart.options.plotOptions, oldOption = this.userOptions[optionName];
    if (oldOption) {
      return option !== oldOption;
    }
    return option !== pick23(plotOptions && plotOptions[this.type] && plotOptions[this.type][optionName], plotOptions && plotOptions.series && plotOptions.series[optionName], option);
  };
  Series16.prototype.onMouseOver = function() {
    var series = this, chart = series.chart, hoverSeries = chart.hoverSeries, pointer = chart.pointer;
    pointer.setHoverChartIndex();
    if (hoverSeries && hoverSeries !== series) {
      hoverSeries.onMouseOut();
    }
    if (series.options.events.mouseOver) {
      fireEvent11(series, "mouseOver");
    }
    series.setState("hover");
    chart.hoverSeries = series;
  };
  Series16.prototype.onMouseOut = function() {
    var series = this, options = series.options, chart = series.chart, tooltip = chart.tooltip, hoverPoint = chart.hoverPoint;
    chart.hoverSeries = null;
    if (hoverPoint) {
      hoverPoint.onMouseOut();
    }
    if (series && options.events.mouseOut) {
      fireEvent11(series, "mouseOut");
    }
    if (tooltip && !series.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {
      tooltip.hide();
    }
    chart.series.forEach(function(s) {
      s.setState("", true);
    });
  };
  Series16.prototype.setState = function(state, inherit) {
    var series = this, options = series.options, graph = series.graph, inactiveOtherPoints = options.inactiveOtherPoints, stateOptions = options.states, stateAnimation = pick23(stateOptions[state || "normal"] && stateOptions[state || "normal"].animation, series.chart.options.chart.animation);
    var attribs, lineWidth = options.lineWidth, i = 0, opacity = options.opacity;
    state = state || "";
    if (series.state !== state) {
      [
        series.group,
        series.markerGroup,
        series.dataLabelsGroup
      ].forEach(function(group) {
        if (group) {
          if (series.state) {
            group.removeClass("highcharts-series-" + series.state);
          }
          if (state) {
            group.addClass("highcharts-series-" + state);
          }
        }
      });
      series.state = state;
      if (!series.chart.styledMode) {
        if (stateOptions[state] && stateOptions[state].enabled === false) {
          return;
        }
        if (state) {
          lineWidth = stateOptions[state].lineWidth || lineWidth + (stateOptions[state].lineWidthPlus || 0);
          opacity = pick23(stateOptions[state].opacity, opacity);
        }
        if (graph && !graph.dashstyle) {
          attribs = {
            "stroke-width": lineWidth
          };
          graph.animate(attribs, stateAnimation);
          while (series["zone-graph-" + i]) {
            series["zone-graph-" + i].animate(attribs, stateAnimation);
            i = i + 1;
          }
        }
        if (!inactiveOtherPoints) {
          [
            series.group,
            series.markerGroup,
            series.dataLabelsGroup,
            series.labelBySeries
          ].forEach(function(group) {
            if (group) {
              group.animate({
                opacity
              }, stateAnimation);
            }
          });
        }
      }
    }
    if (inherit && inactiveOtherPoints && series.points) {
      series.setAllPointsToState(state || void 0);
    }
  };
  Series16.prototype.setAllPointsToState = function(state) {
    this.points.forEach(function(point) {
      if (point.setState) {
        point.setState(state);
      }
    });
  };
  Series16.prototype.setVisible = function(vis, redraw) {
    var series = this, chart = series.chart, legendItem = series.legendItem, ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries, oldVisibility = series.visible;
    series.visible = vis = series.options.visible = series.userOptions.visible = typeof vis === "undefined" ? !oldVisibility : vis;
    var showOrHide = vis ? "show" : "hide";
    [
      "group",
      "dataLabelsGroup",
      "markerGroup",
      "tracker",
      "tt"
    ].forEach(function(key) {
      if (series[key]) {
        series[key][showOrHide]();
      }
    });
    if (chart.hoverSeries === series || (chart.hoverPoint && chart.hoverPoint.series) === series) {
      series.onMouseOut();
    }
    if (legendItem) {
      chart.legend.colorizeItem(series, vis);
    }
    series.isDirty = true;
    if (series.options.stacking) {
      chart.series.forEach(function(otherSeries) {
        if (otherSeries.options.stacking && otherSeries.visible) {
          otherSeries.isDirty = true;
        }
      });
    }
    series.linkedSeries.forEach(function(otherSeries) {
      otherSeries.setVisible(vis, false);
    });
    if (ignoreHiddenSeries) {
      chart.isDirtyBox = true;
    }
    fireEvent11(series, showOrHide);
    if (redraw !== false) {
      chart.redraw();
    }
  };
  Series16.prototype.show = function() {
    this.setVisible(true);
  };
  Series16.prototype.hide = function() {
    this.setVisible(false);
  };
  Series16.prototype.select = function(selected) {
    var series = this;
    series.selected = selected = this.options.selected = typeof selected === "undefined" ? !series.selected : selected;
    if (series.checkbox) {
      series.checkbox.checked = selected;
    }
    fireEvent11(series, selected ? "select" : "unselect");
  };
  Series16.prototype.shouldShowTooltip = function(plotX, plotY, options) {
    if (options === void 0) {
      options = {};
    }
    options.series = this;
    options.visiblePlotOnly = true;
    return this.chart.isInsidePlot(plotX, plotY, options);
  };
  Series16.defaultOptions = SeriesDefaults_default;
  return Series16;
}();
extend15(Series.prototype, {
  axisTypes: ["xAxis", "yAxis"],
  coll: "series",
  colorCounter: 0,
  cropShoulder: 1,
  directTouch: false,
  drawLegendSymbol: LegendSymbol_default.drawLineMarker,
  isCartesian: true,
  kdAxisArray: ["clientX", "plotY"],
  parallelArrays: ["x", "y"],
  pointClass: Point_default,
  requireSorting: true,
  sorted: true
});
SeriesRegistry_default.series = Series;
var Series_default = Series;

// node_modules/highcharts/es-modules/Extensions/ScrollablePlotArea.js
var stop3 = AnimationUtilities_default.stop;
var addEvent14 = Utilities_default.addEvent;
var createElement8 = Utilities_default.createElement;
var merge19 = Utilities_default.merge;
var pick24 = Utilities_default.pick;
addEvent14(Chart_default, "afterSetChartSize", function(e2) {
  var scrollablePlotArea = this.options.chart.scrollablePlotArea, scrollableMinWidth = scrollablePlotArea && scrollablePlotArea.minWidth, scrollableMinHeight = scrollablePlotArea && scrollablePlotArea.minHeight, scrollablePixelsX, scrollablePixelsY, corrections;
  if (!this.renderer.forExport) {
    if (scrollableMinWidth) {
      this.scrollablePixelsX = scrollablePixelsX = Math.max(0, scrollableMinWidth - this.chartWidth);
      if (scrollablePixelsX) {
        this.scrollablePlotBox = this.renderer.scrollablePlotBox = merge19(this.plotBox);
        this.plotBox.width = this.plotWidth += scrollablePixelsX;
        if (this.inverted) {
          this.clipBox.height += scrollablePixelsX;
        } else {
          this.clipBox.width += scrollablePixelsX;
        }
        corrections = {
          1: { name: "right", value: scrollablePixelsX }
        };
      }
    } else if (scrollableMinHeight) {
      this.scrollablePixelsY = scrollablePixelsY = Math.max(0, scrollableMinHeight - this.chartHeight);
      if (scrollablePixelsY) {
        this.scrollablePlotBox = this.renderer.scrollablePlotBox = merge19(this.plotBox);
        this.plotBox.height = this.plotHeight += scrollablePixelsY;
        if (this.inverted) {
          this.clipBox.width += scrollablePixelsY;
        } else {
          this.clipBox.height += scrollablePixelsY;
        }
        corrections = {
          2: { name: "bottom", value: scrollablePixelsY }
        };
      }
    }
    if (corrections && !e2.skipAxes) {
      this.axes.forEach(function(axis) {
        if (corrections[axis.side]) {
          axis.getPlotLinePath = function() {
            var marginName = corrections[axis.side].name, correctionValue = corrections[axis.side].value, margin = this[marginName], path;
            this[marginName] = margin - correctionValue;
            path = Axis_default.prototype.getPlotLinePath.apply(this, arguments);
            this[marginName] = margin;
            return path;
          };
        } else {
          axis.setAxisSize();
          axis.setAxisTranslation();
        }
      });
    }
  }
});
addEvent14(Chart_default, "render", function() {
  if (this.scrollablePixelsX || this.scrollablePixelsY) {
    if (this.setUpScrolling) {
      this.setUpScrolling();
    }
    this.applyFixed();
  } else if (this.fixedDiv) {
    this.applyFixed();
  }
});
Chart_default.prototype.setUpScrolling = function() {
  var _this = this;
  var css16 = {
    WebkitOverflowScrolling: "touch",
    overflowX: "hidden",
    overflowY: "hidden"
  };
  if (this.scrollablePixelsX) {
    css16.overflowX = "auto";
  }
  if (this.scrollablePixelsY) {
    css16.overflowY = "auto";
  }
  this.scrollingParent = createElement8("div", {
    className: "highcharts-scrolling-parent"
  }, {
    position: "relative"
  }, this.renderTo);
  this.scrollingContainer = createElement8("div", {
    "className": "highcharts-scrolling"
  }, css16, this.scrollingParent);
  addEvent14(this.scrollingContainer, "scroll", function() {
    if (_this.pointer) {
      delete _this.pointer.chartPosition;
    }
  });
  this.innerContainer = createElement8("div", {
    "className": "highcharts-inner-container"
  }, null, this.scrollingContainer);
  this.innerContainer.appendChild(this.container);
  this.setUpScrolling = null;
};
Chart_default.prototype.moveFixedElements = function() {
  var container = this.container, fixedRenderer = this.fixedRenderer, fixedSelectors = [
    ".highcharts-contextbutton",
    ".highcharts-credits",
    ".highcharts-legend",
    ".highcharts-legend-checkbox",
    ".highcharts-navigator-series",
    ".highcharts-navigator-xaxis",
    ".highcharts-navigator-yaxis",
    ".highcharts-navigator",
    ".highcharts-reset-zoom",
    ".highcharts-drillup-button",
    ".highcharts-scrollbar",
    ".highcharts-subtitle",
    ".highcharts-title"
  ], axisClass;
  if (this.scrollablePixelsX && !this.inverted) {
    axisClass = ".highcharts-yaxis";
  } else if (this.scrollablePixelsX && this.inverted) {
    axisClass = ".highcharts-xaxis";
  } else if (this.scrollablePixelsY && !this.inverted) {
    axisClass = ".highcharts-xaxis";
  } else if (this.scrollablePixelsY && this.inverted) {
    axisClass = ".highcharts-yaxis";
  }
  if (axisClass) {
    fixedSelectors.push(axisClass + ":not(.highcharts-radial-axis)", axisClass + "-labels:not(.highcharts-radial-axis-labels)");
  }
  fixedSelectors.forEach(function(className) {
    [].forEach.call(container.querySelectorAll(className), function(elem) {
      (elem.namespaceURI === fixedRenderer.SVG_NS ? fixedRenderer.box : fixedRenderer.box.parentNode).appendChild(elem);
      elem.style.pointerEvents = "auto";
    });
  });
};
Chart_default.prototype.applyFixed = function() {
  var firstTime = !this.fixedDiv, chartOptions = this.options.chart, scrollableOptions = chartOptions.scrollablePlotArea, Renderer2 = RendererRegistry_default.getRendererType();
  var fixedRenderer, scrollableWidth, scrollableHeight;
  if (firstTime) {
    this.fixedDiv = createElement8("div", {
      className: "highcharts-fixed"
    }, {
      position: "absolute",
      overflow: "hidden",
      pointerEvents: "none",
      zIndex: (chartOptions.style && chartOptions.style.zIndex || 0) + 2,
      top: 0
    }, null, true);
    if (this.scrollingContainer) {
      this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer);
    }
    this.renderTo.style.overflow = "visible";
    this.fixedRenderer = fixedRenderer = new Renderer2(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style);
    this.scrollableMask = fixedRenderer.path().attr({
      fill: this.options.chart.backgroundColor || "#fff",
      "fill-opacity": pick24(scrollableOptions.opacity, 0.85),
      zIndex: -1
    }).addClass("highcharts-scrollable-mask").add();
    addEvent14(this, "afterShowResetZoom", this.moveFixedElements);
    addEvent14(this, "afterDrilldown", this.moveFixedElements);
    addEvent14(this, "afterLayOutTitles", this.moveFixedElements);
  } else {
    this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);
  }
  if (this.scrollableDirty || firstTime) {
    this.scrollableDirty = false;
    this.moveFixedElements();
  }
  scrollableWidth = this.chartWidth + (this.scrollablePixelsX || 0);
  scrollableHeight = this.chartHeight + (this.scrollablePixelsY || 0);
  stop3(this.container);
  this.container.style.width = scrollableWidth + "px";
  this.container.style.height = scrollableHeight + "px";
  this.renderer.boxWrapper.attr({
    width: scrollableWidth,
    height: scrollableHeight,
    viewBox: [0, 0, scrollableWidth, scrollableHeight].join(" ")
  });
  this.chartBackground.attr({
    width: scrollableWidth,
    height: scrollableHeight
  });
  this.scrollingContainer.style.height = this.chartHeight + "px";
  if (firstTime) {
    if (scrollableOptions.scrollPositionX) {
      this.scrollingContainer.scrollLeft = this.scrollablePixelsX * scrollableOptions.scrollPositionX;
    }
    if (scrollableOptions.scrollPositionY) {
      this.scrollingContainer.scrollTop = this.scrollablePixelsY * scrollableOptions.scrollPositionY;
    }
  }
  var axisOffset = this.axisOffset, maskTop = this.plotTop - axisOffset[0] - 1, maskLeft = this.plotLeft - axisOffset[3] - 1, maskBottom = this.plotTop + this.plotHeight + axisOffset[2] + 1, maskRight = this.plotLeft + this.plotWidth + axisOffset[1] + 1, maskPlotRight = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0), maskPlotBottom = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0), d;
  if (this.scrollablePixelsX) {
    d = [
      ["M", 0, maskTop],
      ["L", this.plotLeft - 1, maskTop],
      ["L", this.plotLeft - 1, maskBottom],
      ["L", 0, maskBottom],
      ["Z"],
      ["M", maskPlotRight, maskTop],
      ["L", this.chartWidth, maskTop],
      ["L", this.chartWidth, maskBottom],
      ["L", maskPlotRight, maskBottom],
      ["Z"]
    ];
  } else if (this.scrollablePixelsY) {
    d = [
      ["M", maskLeft, 0],
      ["L", maskLeft, this.plotTop - 1],
      ["L", maskRight, this.plotTop - 1],
      ["L", maskRight, 0],
      ["Z"],
      ["M", maskLeft, maskPlotBottom],
      ["L", maskLeft, this.chartHeight],
      ["L", maskRight, this.chartHeight],
      ["L", maskRight, maskPlotBottom],
      ["Z"]
    ];
  } else {
    d = [["M", 0, 0]];
  }
  if (this.redrawTrigger !== "adjustHeight") {
    this.scrollableMask.attr({ d });
  }
};
addEvent14(Axis_default, "afterInit", function() {
  this.chart.scrollableDirty = true;
});
addEvent14(Series_default, "show", function() {
  this.chart.scrollableDirty = true;
});

// node_modules/highcharts/es-modules/Core/Axis/StackingAxis.js
var getDeferredAnimation2 = AnimationUtilities_default.getDeferredAnimation;
var addEvent15 = Utilities_default.addEvent;
var destroyObjectProperties6 = Utilities_default.destroyObjectProperties;
var fireEvent12 = Utilities_default.fireEvent;
var isNumber19 = Utilities_default.isNumber;
var objectEach17 = Utilities_default.objectEach;
var StackingAxis;
(function(StackingAxis2) {
  var composedClasses2 = [];
  function compose(AxisClass) {
    if (composedClasses2.indexOf(AxisClass) === -1) {
      composedClasses2.push(AxisClass);
      addEvent15(AxisClass, "init", onInit);
      addEvent15(AxisClass, "destroy", onDestroy);
    }
    return AxisClass;
  }
  StackingAxis2.compose = compose;
  function onDestroy() {
    var stacking = this.stacking;
    if (!stacking) {
      return;
    }
    var stacks = stacking.stacks;
    objectEach17(stacks, function(stack, stackKey) {
      destroyObjectProperties6(stack);
      stacks[stackKey] = null;
    });
    if (stacking && stacking.stackTotalGroup) {
      stacking.stackTotalGroup.destroy();
    }
  }
  function onInit() {
    var axis = this;
    if (!axis.stacking) {
      axis.stacking = new Additions(axis);
    }
  }
  var Additions = function() {
    function Additions2(axis) {
      this.oldStacks = {};
      this.stacks = {};
      this.stacksTouched = 0;
      this.axis = axis;
    }
    Additions2.prototype.buildStacks = function() {
      var stacking = this;
      var axis = stacking.axis;
      var axisSeries = axis.series;
      var reversedStacks = axis.options.reversedStacks;
      var len = axisSeries.length;
      var actualSeries, i;
      if (!axis.isXAxis) {
        stacking.usePercentage = false;
        i = len;
        while (i--) {
          actualSeries = axisSeries[reversedStacks ? i : len - i - 1];
          actualSeries.setStackedPoints();
          actualSeries.setGroupedPoints();
        }
        for (i = 0; i < len; i++) {
          axisSeries[i].modifyStacks();
        }
        fireEvent12(axis, "afterBuildStacks");
      }
    };
    Additions2.prototype.cleanStacks = function() {
      var stacking = this, axis = stacking.axis;
      var stacks;
      if (!axis.isXAxis) {
        if (stacking.oldStacks) {
          stacks = stacking.stacks = stacking.oldStacks;
        }
        objectEach17(stacks, function(type) {
          objectEach17(type, function(stack) {
            stack.cumulative = stack.total;
          });
        });
      }
    };
    Additions2.prototype.resetStacks = function() {
      var stacking = this, axis = stacking.axis, stacks = stacking.stacks;
      if (!axis.isXAxis) {
        objectEach17(stacks, function(type) {
          objectEach17(type, function(stack, x) {
            if (isNumber19(stack.touched) && stack.touched < stacking.stacksTouched) {
              stack.destroy();
              delete type[x];
            } else {
              stack.total = null;
              stack.cumulative = null;
            }
          });
        });
      }
    };
    Additions2.prototype.renderStackTotals = function() {
      var stacking = this, axis = stacking.axis, chart = axis.chart, renderer = chart.renderer, stacks = stacking.stacks, stackLabelsAnim = axis.options.stackLabels && axis.options.stackLabels.animation, animationConfig = getDeferredAnimation2(chart, stackLabelsAnim || false), stackTotalGroup = stacking.stackTotalGroup = stacking.stackTotalGroup || renderer.g("stack-labels").attr({
        visibility: "visible",
        zIndex: 6,
        opacity: 0
      }).add();
      stackTotalGroup.translate(chart.plotLeft, chart.plotTop);
      objectEach17(stacks, function(type) {
        objectEach17(type, function(stack) {
          stack.render(stackTotalGroup);
        });
      });
      stackTotalGroup.animate({
        opacity: 1
      }, animationConfig);
    };
    return Additions2;
  }();
  StackingAxis2.Additions = Additions;
})(StackingAxis || (StackingAxis = {}));
var StackingAxis_default = StackingAxis;

// node_modules/highcharts/es-modules/Extensions/Stacking.js
var format5 = FormatUtilities_default.format;
var correctFloat5 = Utilities_default.correctFloat;
var defined18 = Utilities_default.defined;
var destroyObjectProperties7 = Utilities_default.destroyObjectProperties;
var isArray10 = Utilities_default.isArray;
var isNumber20 = Utilities_default.isNumber;
var objectEach18 = Utilities_default.objectEach;
var pick25 = Utilities_default.pick;
var StackItem = function() {
  function StackItem2(axis, options, isNegative, x, stackOption) {
    var inverted = axis.chart.inverted;
    this.axis = axis;
    this.isNegative = isNegative;
    this.options = options = options || {};
    this.x = x;
    this.total = null;
    this.points = {};
    this.hasValidPoints = false;
    this.stack = stackOption;
    this.leftCliff = 0;
    this.rightCliff = 0;
    this.alignOptions = {
      align: options.align || (inverted ? isNegative ? "left" : "right" : "center"),
      verticalAlign: options.verticalAlign || (inverted ? "middle" : isNegative ? "bottom" : "top"),
      y: options.y,
      x: options.x
    };
    this.textAlign = options.textAlign || (inverted ? isNegative ? "right" : "left" : "center");
  }
  StackItem2.prototype.destroy = function() {
    destroyObjectProperties7(this, this.axis);
  };
  StackItem2.prototype.render = function(group) {
    var chart = this.axis.chart, options = this.options, formatOption = options.format, attr10 = {}, str = formatOption ? format5(formatOption, this, chart) : options.formatter.call(this);
    if (this.label) {
      this.label.attr({ text: str, visibility: "hidden" });
    } else {
      this.label = chart.renderer.label(str, null, null, options.shape, null, null, options.useHTML, false, "stack-labels");
      attr10 = {
        r: options.borderRadius || 0,
        text: str,
        rotation: options.rotation,
        padding: pick25(options.padding, 5),
        visibility: "hidden"
      };
      if (!chart.styledMode) {
        attr10.fill = options.backgroundColor;
        attr10.stroke = options.borderColor;
        attr10["stroke-width"] = options.borderWidth;
        this.label.css(options.style);
      }
      this.label.attr(attr10);
      if (!this.label.added) {
        this.label.add(group);
      }
    }
    this.label.labelrank = chart.plotSizeY;
  };
  StackItem2.prototype.setOffset = function(xOffset, xWidth, boxBottom, boxTop, defaultX) {
    var stackItem = this, axis = stackItem.axis, chart = axis.chart, y = axis.translate(axis.stacking.usePercentage ? 100 : boxTop ? boxTop : stackItem.total, 0, 0, 0, 1), yZero = axis.translate(boxBottom ? boxBottom : 0), h = defined18(y) && Math.abs(y - yZero), x = pick25(defaultX, chart.xAxis[0].translate(stackItem.x)) + xOffset, stackBox = defined18(y) && stackItem.getStackBox(chart, stackItem, x, y, xWidth, h, axis), label = stackItem.label, isNegative = stackItem.isNegative, isJustify = pick25(stackItem.options.overflow, "justify") === "justify", textAlign = stackItem.textAlign, visible;
    if (label && stackBox) {
      var bBox = label.getBBox(), padding = label.padding, boxOffsetX = void 0, boxOffsetY = void 0;
      if (textAlign === "left") {
        boxOffsetX = chart.inverted ? -padding : padding;
      } else if (textAlign === "right") {
        boxOffsetX = bBox.width;
      } else {
        if (chart.inverted && textAlign === "center") {
          boxOffsetX = bBox.width / 2;
        } else {
          boxOffsetX = chart.inverted ? isNegative ? bBox.width + padding : -padding : bBox.width / 2;
        }
      }
      boxOffsetY = chart.inverted ? bBox.height / 2 : isNegative ? -padding : bBox.height;
      stackItem.alignOptions.x = pick25(stackItem.options.x, 0);
      stackItem.alignOptions.y = pick25(stackItem.options.y, 0);
      stackBox.x -= boxOffsetX;
      stackBox.y -= boxOffsetY;
      label.align(stackItem.alignOptions, null, stackBox);
      if (chart.isInsidePlot(label.alignAttr.x + boxOffsetX - stackItem.alignOptions.x, label.alignAttr.y + boxOffsetY - stackItem.alignOptions.y)) {
        label.show();
      } else {
        label.alignAttr.y = -9999;
        isJustify = false;
      }
      if (isJustify) {
        Series_default.prototype.justifyDataLabel.call(this.axis, label, stackItem.alignOptions, label.alignAttr, bBox, stackBox);
      }
      label.attr({
        x: label.alignAttr.x,
        y: label.alignAttr.y
      });
      if (pick25(!isJustify && stackItem.options.crop, true)) {
        visible = isNumber20(label.x) && isNumber20(label.y) && chart.isInsidePlot(label.x - padding + label.width, label.y) && chart.isInsidePlot(label.x + padding, label.y);
        if (!visible) {
          label.hide();
        }
      }
    }
  };
  StackItem2.prototype.getStackBox = function(chart, stackItem, x, y, xWidth, h, axis) {
    var reversed = stackItem.axis.reversed, inverted = chart.inverted, axisPos = axis.height + axis.pos - (inverted ? chart.plotLeft : chart.plotTop), neg = stackItem.isNegative && !reversed || !stackItem.isNegative && reversed;
    return {
      x: inverted ? neg ? y - axis.right : y - h + axis.pos - chart.plotLeft : x + chart.xAxis[0].transB - chart.plotLeft,
      y: inverted ? axis.height - x - xWidth : neg ? axisPos - y - h : axisPos - y,
      width: inverted ? h : xWidth,
      height: inverted ? xWidth : h
    };
  };
  return StackItem2;
}();
Chart_default.prototype.getStacks = function() {
  var chart = this, inverted = chart.inverted;
  chart.yAxis.forEach(function(axis) {
    if (axis.stacking && axis.stacking.stacks && axis.hasVisibleSeries) {
      axis.stacking.oldStacks = axis.stacking.stacks;
    }
  });
  chart.series.forEach(function(series) {
    var xAxisOptions = series.xAxis && series.xAxis.options || {};
    if (series.options.stacking && (series.visible === true || chart.options.chart.ignoreHiddenSeries === false)) {
      series.stackKey = [
        series.type,
        pick25(series.options.stack, ""),
        inverted ? xAxisOptions.top : xAxisOptions.left,
        inverted ? xAxisOptions.height : xAxisOptions.width
      ].join(",");
    }
  });
};
StackingAxis_default.compose(Axis_default);
Series_default.prototype.setGroupedPoints = function() {
  var stacking = this.yAxis.stacking;
  if (this.options.centerInCategory && (this.is("column") || this.is("columnrange")) && !this.options.stacking && this.chart.series.length > 1) {
    Series_default.prototype.setStackedPoints.call(this, "group");
  } else if (stacking) {
    objectEach18(stacking.stacks, function(type, key) {
      if (key.slice(-5) === "group") {
        objectEach18(type, function(stack) {
          return stack.destroy();
        });
        delete stacking.stacks[key];
      }
    });
  }
};
Series_default.prototype.setStackedPoints = function(stackingParam) {
  var stacking = stackingParam || this.options.stacking;
  if (!stacking || this.visible !== true && this.chart.options.chart.ignoreHiddenSeries !== false) {
    return;
  }
  var series = this, xData = series.processedXData, yData = series.processedYData, stackedYData = [], yDataLength = yData.length, seriesOptions = series.options, threshold = seriesOptions.threshold, stackThreshold = pick25(seriesOptions.startFromThreshold && threshold, 0), stackOption = seriesOptions.stack, stackKey = stackingParam ? series.type + "," + stacking : series.stackKey, negKey = "-" + stackKey, negStacks = series.negStacks, yAxis = series.yAxis, stacks = yAxis.stacking.stacks, oldStacks = yAxis.stacking.oldStacks, stackIndicator, isNegative, stack, other, key, pointKey, i, x, y;
  yAxis.stacking.stacksTouched += 1;
  for (i = 0; i < yDataLength; i++) {
    x = xData[i];
    y = yData[i];
    stackIndicator = series.getStackIndicator(stackIndicator, x, series.index);
    pointKey = stackIndicator.key;
    isNegative = negStacks && y < (stackThreshold ? 0 : threshold);
    key = isNegative ? negKey : stackKey;
    if (!stacks[key]) {
      stacks[key] = {};
    }
    if (!stacks[key][x]) {
      if (oldStacks[key] && oldStacks[key][x]) {
        stacks[key][x] = oldStacks[key][x];
        stacks[key][x].total = null;
      } else {
        stacks[key][x] = new StackItem(yAxis, yAxis.options.stackLabels, isNegative, x, stackOption);
      }
    }
    stack = stacks[key][x];
    if (y !== null) {
      stack.points[pointKey] = stack.points[series.index] = [pick25(stack.cumulative, stackThreshold)];
      if (!defined18(stack.cumulative)) {
        stack.base = pointKey;
      }
      stack.touched = yAxis.stacking.stacksTouched;
      if (stackIndicator.index > 0 && series.singleStacks === false) {
        stack.points[pointKey][0] = stack.points[series.index + "," + x + ",0"][0];
      }
    } else {
      stack.points[pointKey] = stack.points[series.index] = null;
    }
    if (stacking === "percent") {
      other = isNegative ? stackKey : negKey;
      if (negStacks && stacks[other] && stacks[other][x]) {
        other = stacks[other][x];
        stack.total = other.total = Math.max(other.total, stack.total) + Math.abs(y) || 0;
      } else {
        stack.total = correctFloat5(stack.total + (Math.abs(y) || 0));
      }
    } else if (stacking === "group") {
      if (isArray10(y)) {
        y = y[0];
      }
      if (y !== null) {
        stack.total = (stack.total || 0) + 1;
      }
    } else {
      stack.total = correctFloat5(stack.total + (y || 0));
    }
    if (stacking === "group") {
      stack.cumulative = (stack.total || 1) - 1;
    } else {
      stack.cumulative = pick25(stack.cumulative, stackThreshold) + (y || 0);
    }
    if (y !== null) {
      stack.points[pointKey].push(stack.cumulative);
      stackedYData[i] = stack.cumulative;
      stack.hasValidPoints = true;
    }
  }
  if (stacking === "percent") {
    yAxis.stacking.usePercentage = true;
  }
  if (stacking !== "group") {
    this.stackedYData = stackedYData;
  }
  yAxis.stacking.oldStacks = {};
};
Series_default.prototype.modifyStacks = function() {
  var series = this, yAxis = series.yAxis, stackKey = series.stackKey, stacks = yAxis.stacking.stacks, processedXData = series.processedXData, stackIndicator, stacking = series.options.stacking;
  if (series[stacking + "Stacker"]) {
    [stackKey, "-" + stackKey].forEach(function(key) {
      var i = processedXData.length, x, stack, pointExtremes;
      while (i--) {
        x = processedXData[i];
        stackIndicator = series.getStackIndicator(stackIndicator, x, series.index, key);
        stack = stacks[key] && stacks[key][x];
        pointExtremes = stack && stack.points[stackIndicator.key];
        if (pointExtremes) {
          series[stacking + "Stacker"](pointExtremes, stack, i);
        }
      }
    });
  }
};
Series_default.prototype.percentStacker = function(pointExtremes, stack, i) {
  var totalFactor = stack.total ? 100 / stack.total : 0;
  pointExtremes[0] = correctFloat5(pointExtremes[0] * totalFactor);
  pointExtremes[1] = correctFloat5(pointExtremes[1] * totalFactor);
  this.stackedYData[i] = pointExtremes[1];
};
Series_default.prototype.getStackIndicator = function(stackIndicator, x, index, key) {
  if (!defined18(stackIndicator) || stackIndicator.x !== x || key && stackIndicator.key !== key) {
    stackIndicator = {
      x,
      index: 0,
      key
    };
  } else {
    stackIndicator.index++;
  }
  stackIndicator.key = [index, x, stackIndicator.index].join(",");
  return stackIndicator;
};
Globals_default.StackItem = StackItem;
var Stacking_default = Globals_default.StackItem;

// node_modules/highcharts/es-modules/Series/Line/LineSeries.js
var __extends5 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var defined19 = Utilities_default.defined;
var merge20 = Utilities_default.merge;
var LineSeries = function(_super) {
  __extends5(LineSeries7, _super);
  function LineSeries7() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.data = void 0;
    _this.options = void 0;
    _this.points = void 0;
    return _this;
  }
  LineSeries7.prototype.drawGraph = function() {
    var series = this, options = this.options, graphPath = (this.gappedPath || this.getGraphPath).call(this), styledMode = this.chart.styledMode;
    var props = [[
      "graph",
      "highcharts-graph"
    ]];
    if (!styledMode) {
      props[0].push(options.lineColor || this.color || Palette_default.neutralColor20, options.dashStyle);
    }
    props = series.getZonesGraphs(props);
    props.forEach(function(prop, i) {
      var graphKey = prop[0];
      var attribs, graph = series[graphKey];
      var verb = graph ? "animate" : "attr";
      if (graph) {
        graph.endX = series.preventGraphAnimation ? null : graphPath.xMap;
        graph.animate({ d: graphPath });
      } else if (graphPath.length) {
        series[graphKey] = graph = series.chart.renderer.path(graphPath).addClass(prop[1]).attr({ zIndex: 1 }).add(series.group);
      }
      if (graph && !styledMode) {
        attribs = {
          "stroke": prop[2],
          "stroke-width": options.lineWidth,
          "fill": series.fillGraph && series.color || "none"
        };
        if (prop[3]) {
          attribs.dashstyle = prop[3];
        } else if (options.linecap !== "square") {
          attribs["stroke-linecap"] = attribs["stroke-linejoin"] = "round";
        }
        graph[verb](attribs).shadow(i < 2 && options.shadow);
      }
      if (graph) {
        graph.startX = graphPath.xMap;
        graph.isArea = graphPath.isArea;
      }
    });
  };
  LineSeries7.prototype.getGraphPath = function(points, nullsAsZeroes, connectCliffs) {
    var series = this, options = series.options, graphPath = [], xMap = [];
    var gap, step = options.step;
    points = points || series.points;
    var reversed = points.reversed;
    if (reversed) {
      points.reverse();
    }
    step = {
      right: 1,
      center: 2
    }[step] || step && 3;
    if (step && reversed) {
      step = 4 - step;
    }
    points = this.getValidPoints(points, false, !(options.connectNulls && !nullsAsZeroes && !connectCliffs));
    points.forEach(function(point, i) {
      var plotX = point.plotX, plotY = point.plotY, lastPoint = points[i - 1];
      var pathToPoint;
      if ((point.leftCliff || lastPoint && lastPoint.rightCliff) && !connectCliffs) {
        gap = true;
      }
      if (point.isNull && !defined19(nullsAsZeroes) && i > 0) {
        gap = !options.connectNulls;
      } else if (point.isNull && !nullsAsZeroes) {
        gap = true;
      } else {
        if (i === 0 || gap) {
          pathToPoint = [[
            "M",
            point.plotX,
            point.plotY
          ]];
        } else if (series.getPointSpline) {
          pathToPoint = [series.getPointSpline(points, point, i)];
        } else if (step) {
          if (step === 1) {
            pathToPoint = [[
              "L",
              lastPoint.plotX,
              plotY
            ]];
          } else if (step === 2) {
            pathToPoint = [[
              "L",
              (lastPoint.plotX + plotX) / 2,
              lastPoint.plotY
            ], [
              "L",
              (lastPoint.plotX + plotX) / 2,
              plotY
            ]];
          } else {
            pathToPoint = [[
              "L",
              plotX,
              lastPoint.plotY
            ]];
          }
          pathToPoint.push([
            "L",
            plotX,
            plotY
          ]);
        } else {
          pathToPoint = [[
            "L",
            plotX,
            plotY
          ]];
        }
        xMap.push(point.x);
        if (step) {
          xMap.push(point.x);
          if (step === 2) {
            xMap.push(point.x);
          }
        }
        graphPath.push.apply(graphPath, pathToPoint);
        gap = false;
      }
    });
    graphPath.xMap = xMap;
    series.graphPath = graphPath;
    return graphPath;
  };
  LineSeries7.prototype.getZonesGraphs = function(props) {
    this.zones.forEach(function(zone, i) {
      var propset = [
        "zone-graph-" + i,
        "highcharts-graph highcharts-zone-graph-" + i + " " + (zone.className || "")
      ];
      if (!this.chart.styledMode) {
        propset.push(zone.color || this.color, zone.dashStyle || this.options.dashStyle);
      }
      props.push(propset);
    }, this);
    return props;
  };
  LineSeries7.defaultOptions = merge20(Series_default.defaultOptions, {});
  return LineSeries7;
}(Series_default);
SeriesRegistry_default.registerSeriesType("line", LineSeries);
var LineSeries_default = LineSeries;

// node_modules/highcharts/es-modules/Series/Area/AreaSeries.js
var __extends6 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var color4 = Color_default.parse;
var LineSeries2 = SeriesRegistry_default.seriesTypes.line;
var extend16 = Utilities_default.extend;
var merge21 = Utilities_default.merge;
var objectEach19 = Utilities_default.objectEach;
var pick26 = Utilities_default.pick;
var AreaSeries = function(_super) {
  __extends6(AreaSeries3, _super);
  function AreaSeries3() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.data = void 0;
    _this.options = void 0;
    _this.points = void 0;
    return _this;
  }
  AreaSeries3.prototype.drawGraph = function() {
    this.areaPath = [];
    _super.prototype.drawGraph.apply(this);
    var series = this, areaPath = this.areaPath, options = this.options, zones = this.zones, props = [[
      "area",
      "highcharts-area",
      this.color,
      options.fillColor
    ]];
    zones.forEach(function(zone, i) {
      props.push([
        "zone-area-" + i,
        "highcharts-area highcharts-zone-area-" + i + " " + zone.className,
        zone.color || series.color,
        zone.fillColor || options.fillColor
      ]);
    });
    props.forEach(function(prop) {
      var areaKey = prop[0], area = series[areaKey], verb = area ? "animate" : "attr", attribs = {};
      if (area) {
        area.endX = series.preventGraphAnimation ? null : areaPath.xMap;
        area.animate({ d: areaPath });
      } else {
        attribs.zIndex = 0;
        area = series[areaKey] = series.chart.renderer.path(areaPath).addClass(prop[1]).add(series.group);
        area.isArea = true;
      }
      if (!series.chart.styledMode) {
        attribs.fill = pick26(prop[3], color4(prop[2]).setOpacity(pick26(options.fillOpacity, 0.75)).get());
      }
      area[verb](attribs);
      area.startX = areaPath.xMap;
      area.shiftUnit = options.step ? 2 : 1;
    });
  };
  AreaSeries3.prototype.getGraphPath = function(points) {
    var getGraphPath = LineSeries2.prototype.getGraphPath, graphPath, options = this.options, stacking = options.stacking, yAxis = this.yAxis, topPath, bottomPath, bottomPoints = [], graphPoints = [], seriesIndex = this.index, i, areaPath, plotX, stacks = yAxis.stacking.stacks[this.stackKey], threshold = options.threshold, translatedThreshold = Math.round(yAxis.getThreshold(options.threshold)), isNull, yBottom, connectNulls = pick26(options.connectNulls, stacking === "percent"), addDummyPoints = function(i2, otherI, side) {
      var point = points[i2], stackedValues = stacking && stacks[point.x].points[seriesIndex], nullVal = point[side + "Null"] || 0, cliffVal = point[side + "Cliff"] || 0, top, bottom, isNull2 = true;
      if (cliffVal || nullVal) {
        top = (nullVal ? stackedValues[0] : stackedValues[1]) + cliffVal;
        bottom = stackedValues[0] + cliffVal;
        isNull2 = !!nullVal;
      } else if (!stacking && points[otherI] && points[otherI].isNull) {
        top = bottom = threshold;
      }
      if (typeof top !== "undefined") {
        graphPoints.push({
          plotX,
          plotY: top === null ? translatedThreshold : yAxis.getThreshold(top),
          isNull: isNull2,
          isCliff: true
        });
        bottomPoints.push({
          plotX,
          plotY: bottom === null ? translatedThreshold : yAxis.getThreshold(bottom),
          doCurve: false
        });
      }
    };
    points = points || this.points;
    if (stacking) {
      points = this.getStackPoints(points);
    }
    for (i = 0; i < points.length; i++) {
      if (!stacking) {
        points[i].leftCliff = points[i].rightCliff = points[i].leftNull = points[i].rightNull = void 0;
      }
      isNull = points[i].isNull;
      plotX = pick26(points[i].rectPlotX, points[i].plotX);
      yBottom = stacking ? pick26(points[i].yBottom, translatedThreshold) : translatedThreshold;
      if (!isNull || connectNulls) {
        if (!connectNulls) {
          addDummyPoints(i, i - 1, "left");
        }
        if (!(isNull && !stacking && connectNulls)) {
          graphPoints.push(points[i]);
          bottomPoints.push({
            x: i,
            plotX,
            plotY: yBottom
          });
        }
        if (!connectNulls) {
          addDummyPoints(i, i + 1, "right");
        }
      }
    }
    topPath = getGraphPath.call(this, graphPoints, true, true);
    bottomPoints.reversed = true;
    bottomPath = getGraphPath.call(this, bottomPoints, true, true);
    var firstBottomPoint = bottomPath[0];
    if (firstBottomPoint && firstBottomPoint[0] === "M") {
      bottomPath[0] = ["L", firstBottomPoint[1], firstBottomPoint[2]];
    }
    areaPath = topPath.concat(bottomPath);
    if (areaPath.length) {
      areaPath.push(["Z"]);
    }
    graphPath = getGraphPath.call(this, graphPoints, false, connectNulls);
    areaPath.xMap = topPath.xMap;
    this.areaPath = areaPath;
    return graphPath;
  };
  AreaSeries3.prototype.getStackPoints = function(points) {
    var series = this, segment = [], keys2 = [], xAxis = this.xAxis, yAxis = this.yAxis, stack = yAxis.stacking.stacks[this.stackKey], pointMap = {}, yAxisSeries = yAxis.series, seriesLength = yAxisSeries.length, upOrDown = yAxis.options.reversedStacks ? 1 : -1, seriesIndex = yAxisSeries.indexOf(series);
    points = points || this.points;
    if (this.options.stacking) {
      for (var i = 0; i < points.length; i++) {
        points[i].leftNull = points[i].rightNull = void 0;
        pointMap[points[i].x] = points[i];
      }
      objectEach19(stack, function(stackX, x) {
        if (stackX.total !== null) {
          keys2.push(x);
        }
      });
      keys2.sort(function(a, b) {
        return a - b;
      });
      var visibleSeries_1 = yAxisSeries.map(function(s) {
        return s.visible;
      });
      keys2.forEach(function(x, idx) {
        var y = 0, stackPoint, stackedValues;
        if (pointMap[x] && !pointMap[x].isNull) {
          segment.push(pointMap[x]);
          [-1, 1].forEach(function(direction) {
            var nullName = direction === 1 ? "rightNull" : "leftNull", cliffName = direction === 1 ? "rightCliff" : "leftCliff", cliff = 0, otherStack = stack[keys2[idx + direction]];
            if (otherStack) {
              var i3 = seriesIndex;
              while (i3 >= 0 && i3 < seriesLength) {
                var si2 = yAxisSeries[i3].index;
                stackPoint = otherStack.points[si2];
                if (!stackPoint) {
                  if (si2 === series.index) {
                    pointMap[x][nullName] = true;
                  } else if (visibleSeries_1[i3]) {
                    stackedValues = stack[x].points[si2];
                    if (stackedValues) {
                      cliff -= stackedValues[1] - stackedValues[0];
                    }
                  }
                }
                i3 += upOrDown;
              }
            }
            pointMap[x][cliffName] = cliff;
          });
        } else {
          var i2 = seriesIndex;
          while (i2 >= 0 && i2 < seriesLength) {
            var si = yAxisSeries[i2].index;
            stackPoint = stack[x].points[si];
            if (stackPoint) {
              y = stackPoint[1];
              break;
            }
            i2 += upOrDown;
          }
          y = pick26(y, 0);
          y = yAxis.translate(y, 0, 1, 0, 1);
          segment.push({
            isNull: true,
            plotX: xAxis.translate(x, 0, 0, 0, 1),
            x,
            plotY: y,
            yBottom: y
          });
        }
      });
    }
    return segment;
  };
  AreaSeries3.defaultOptions = merge21(LineSeries2.defaultOptions, {
    threshold: 0
  });
  return AreaSeries3;
}(LineSeries2);
extend16(AreaSeries.prototype, {
  singleStacks: false,
  drawLegendSymbol: LegendSymbol_default.drawRectangle
});
SeriesRegistry_default.registerSeriesType("area", AreaSeries);
var AreaSeries_default = AreaSeries;

// node_modules/highcharts/es-modules/Series/Spline/SplineSeries.js
var __extends7 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var LineSeries3 = SeriesRegistry_default.seriesTypes.line;
var merge22 = Utilities_default.merge;
var pick27 = Utilities_default.pick;
var SplineSeries = function(_super) {
  __extends7(SplineSeries3, _super);
  function SplineSeries3() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.data = void 0;
    _this.options = void 0;
    _this.points = void 0;
    return _this;
  }
  SplineSeries3.prototype.getPointSpline = function(points, point, i) {
    var smoothing = 1.5, denom = smoothing + 1, plotX = point.plotX || 0, plotY = point.plotY || 0, lastPoint = points[i - 1], nextPoint = points[i + 1], leftContX, leftContY, rightContX, rightContY, ret;
    function doCurve(otherPoint) {
      return otherPoint && !otherPoint.isNull && otherPoint.doCurve !== false && !point.isCliff;
    }
    if (doCurve(lastPoint) && doCurve(nextPoint)) {
      var lastX = lastPoint.plotX || 0, lastY = lastPoint.plotY || 0, nextX = nextPoint.plotX || 0, nextY = nextPoint.plotY || 0, correction = 0;
      leftContX = (smoothing * plotX + lastX) / denom;
      leftContY = (smoothing * plotY + lastY) / denom;
      rightContX = (smoothing * plotX + nextX) / denom;
      rightContY = (smoothing * plotY + nextY) / denom;
      if (rightContX !== leftContX) {
        correction = (rightContY - leftContY) * (rightContX - plotX) / (rightContX - leftContX) + plotY - rightContY;
      }
      leftContY += correction;
      rightContY += correction;
      if (leftContY > lastY && leftContY > plotY) {
        leftContY = Math.max(lastY, plotY);
        rightContY = 2 * plotY - leftContY;
      } else if (leftContY < lastY && leftContY < plotY) {
        leftContY = Math.min(lastY, plotY);
        rightContY = 2 * plotY - leftContY;
      }
      if (rightContY > nextY && rightContY > plotY) {
        rightContY = Math.max(nextY, plotY);
        leftContY = 2 * plotY - rightContY;
      } else if (rightContY < nextY && rightContY < plotY) {
        rightContY = Math.min(nextY, plotY);
        leftContY = 2 * plotY - rightContY;
      }
      point.rightContX = rightContX;
      point.rightContY = rightContY;
    }
    ret = [
      "C",
      pick27(lastPoint.rightContX, lastPoint.plotX, 0),
      pick27(lastPoint.rightContY, lastPoint.plotY, 0),
      pick27(leftContX, plotX, 0),
      pick27(leftContY, plotY, 0),
      plotX,
      plotY
    ];
    lastPoint.rightContX = lastPoint.rightContY = void 0;
    return ret;
  };
  SplineSeries3.defaultOptions = merge22(LineSeries3.defaultOptions);
  return SplineSeries3;
}(LineSeries3);
SeriesRegistry_default.registerSeriesType("spline", SplineSeries);
var SplineSeries_default = SplineSeries;

// node_modules/highcharts/es-modules/Series/AreaSpline/AreaSplineSeries.js
var __extends8 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var areaProto = AreaSeries_default.prototype;
var extend17 = Utilities_default.extend;
var merge23 = Utilities_default.merge;
var AreaSplineSeries = function(_super) {
  __extends8(AreaSplineSeries2, _super);
  function AreaSplineSeries2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.data = void 0;
    _this.points = void 0;
    _this.options = void 0;
    return _this;
  }
  AreaSplineSeries2.defaultOptions = merge23(SplineSeries_default.defaultOptions, AreaSeries_default.defaultOptions);
  return AreaSplineSeries2;
}(SplineSeries_default);
extend17(AreaSplineSeries.prototype, {
  getGraphPath: areaProto.getGraphPath,
  getStackPoints: areaProto.getStackPoints,
  drawGraph: areaProto.drawGraph,
  drawLegendSymbol: LegendSymbol_default.drawRectangle
});
SeriesRegistry_default.registerSeriesType("areaspline", AreaSplineSeries);

// node_modules/highcharts/es-modules/Series/Column/ColumnSeries.js
var __extends9 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var animObject8 = AnimationUtilities_default.animObject;
var color5 = Color_default.parse;
var hasTouch2 = Globals_default.hasTouch;
var noop5 = Globals_default.noop;
var clamp7 = Utilities_default.clamp;
var css11 = Utilities_default.css;
var defined20 = Utilities_default.defined;
var extend18 = Utilities_default.extend;
var fireEvent13 = Utilities_default.fireEvent;
var isArray11 = Utilities_default.isArray;
var isNumber21 = Utilities_default.isNumber;
var merge24 = Utilities_default.merge;
var pick28 = Utilities_default.pick;
var objectEach20 = Utilities_default.objectEach;
var ColumnSeries = function(_super) {
  __extends9(ColumnSeries19, _super);
  function ColumnSeries19() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.borderWidth = void 0;
    _this.data = void 0;
    _this.group = void 0;
    _this.options = void 0;
    _this.points = void 0;
    return _this;
  }
  ColumnSeries19.prototype.animate = function(init) {
    var series = this, yAxis = this.yAxis, options = series.options, inverted = this.chart.inverted, attr10 = {}, translateProp = inverted ? "translateX" : "translateY";
    var translateStart, translatedThreshold;
    if (init) {
      attr10.scaleY = 1e-3;
      translatedThreshold = clamp7(yAxis.toPixels(options.threshold), yAxis.pos, yAxis.pos + yAxis.len);
      if (inverted) {
        attr10.translateX = translatedThreshold - yAxis.len;
      } else {
        attr10.translateY = translatedThreshold;
      }
      if (series.clipBox) {
        series.setClip();
      }
      series.group.attr(attr10);
    } else {
      translateStart = Number(series.group.attr(translateProp));
      series.group.animate({ scaleY: 1 }, extend18(animObject8(series.options.animation), {
        step: function(val, fx) {
          if (series.group) {
            attr10[translateProp] = translateStart + fx.pos * (yAxis.pos - translateStart);
            series.group.attr(attr10);
          }
        }
      }));
    }
  };
  ColumnSeries19.prototype.init = function(chart, options) {
    _super.prototype.init.apply(this, arguments);
    var series = this;
    chart = series.chart;
    if (chart.hasRendered) {
      chart.series.forEach(function(otherSeries) {
        if (otherSeries.type === series.type) {
          otherSeries.isDirty = true;
        }
      });
    }
  };
  ColumnSeries19.prototype.getColumnMetrics = function() {
    var series = this, options = series.options, xAxis = series.xAxis, yAxis = series.yAxis, reversedStacks = xAxis.options.reversedStacks, reverseStacks = xAxis.reversed && !reversedStacks || !xAxis.reversed && reversedStacks, stackGroups = {};
    var stackKey, columnCount = 0;
    if (options.grouping === false) {
      columnCount = 1;
    } else {
      series.chart.series.forEach(function(otherSeries) {
        var otherYAxis = otherSeries.yAxis, otherOptions = otherSeries.options;
        var columnIndex;
        if (otherSeries.type === series.type && (otherSeries.visible || !series.chart.options.chart.ignoreHiddenSeries) && yAxis.len === otherYAxis.len && yAxis.pos === otherYAxis.pos) {
          if (otherOptions.stacking && otherOptions.stacking !== "group") {
            stackKey = otherSeries.stackKey;
            if (typeof stackGroups[stackKey] === "undefined") {
              stackGroups[stackKey] = columnCount++;
            }
            columnIndex = stackGroups[stackKey];
          } else if (otherOptions.grouping !== false) {
            columnIndex = columnCount++;
          }
          otherSeries.columnIndex = columnIndex;
        }
      });
    }
    var categoryWidth = Math.min(Math.abs(xAxis.transA) * (xAxis.ordinal && xAxis.ordinal.slope || options.pointRange || xAxis.closestPointRange || xAxis.tickInterval || 1), xAxis.len), groupPadding = categoryWidth * options.groupPadding, groupWidth = categoryWidth - 2 * groupPadding, pointOffsetWidth = groupWidth / (columnCount || 1), pointWidth = Math.min(options.maxPointWidth || xAxis.len, pick28(options.pointWidth, pointOffsetWidth * (1 - 2 * options.pointPadding))), pointPadding = (pointOffsetWidth - pointWidth) / 2, colIndex = (series.columnIndex || 0) + (reverseStacks ? 1 : 0), pointXOffset = pointPadding + (groupPadding + colIndex * pointOffsetWidth - categoryWidth / 2) * (reverseStacks ? -1 : 1);
    series.columnMetrics = {
      width: pointWidth,
      offset: pointXOffset,
      paddedWidth: pointOffsetWidth,
      columnCount
    };
    return series.columnMetrics;
  };
  ColumnSeries19.prototype.crispCol = function(x, y, w2, h) {
    var chart = this.chart, borderWidth = this.borderWidth, xCrisp = -(borderWidth % 2 ? 0.5 : 0);
    var right, yCrisp = borderWidth % 2 ? 0.5 : 1;
    if (chart.inverted && chart.renderer.isVML) {
      yCrisp += 1;
    }
    if (this.options.crisp) {
      right = Math.round(x + w2) + xCrisp;
      x = Math.round(x) + xCrisp;
      w2 = right - x;
    }
    var bottom = Math.round(y + h) + yCrisp, fromTop = Math.abs(y) <= 0.5 && bottom > 0.5;
    y = Math.round(y) + yCrisp;
    h = bottom - y;
    if (fromTop && h) {
      y -= 1;
      h += 1;
    }
    return {
      x,
      y,
      width: w2,
      height: h
    };
  };
  ColumnSeries19.prototype.adjustForMissingColumns = function(x, pointWidth, point, metrics) {
    var _this = this;
    var stacking = this.options.stacking;
    if (!point.isNull && metrics.columnCount > 1) {
      var indexInCategory_1 = 0;
      var totalInCategory_1 = 0;
      objectEach20(this.yAxis.stacking && this.yAxis.stacking.stacks, function(stack) {
        if (typeof point.x === "number") {
          var stackItem = stack[point.x.toString()];
          if (stackItem) {
            var pointValues = stackItem.points[_this.index], total = stackItem.total;
            if (stacking) {
              if (pointValues) {
                indexInCategory_1 = totalInCategory_1;
              }
              if (stackItem.hasValidPoints) {
                totalInCategory_1++;
              }
            } else if (isArray11(pointValues)) {
              indexInCategory_1 = pointValues[1];
              totalInCategory_1 = total || 0;
            }
          }
        }
      });
      var boxWidth = (totalInCategory_1 - 1) * metrics.paddedWidth + pointWidth;
      x = (point.plotX || 0) + boxWidth / 2 - pointWidth - indexInCategory_1 * metrics.paddedWidth;
    }
    return x;
  };
  ColumnSeries19.prototype.translate = function() {
    var series = this, chart = series.chart, options = series.options, dense = series.dense = series.closestPointRange * series.xAxis.transA < 2, borderWidth = series.borderWidth = pick28(options.borderWidth, dense ? 0 : 1), xAxis = series.xAxis, yAxis = series.yAxis, threshold = options.threshold, translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold), minPointLength = pick28(options.minPointLength, 5), metrics = series.getColumnMetrics(), seriesPointWidth = metrics.width, seriesXOffset = series.pointXOffset = metrics.offset, dataMin = series.dataMin, dataMax = series.dataMax;
    var seriesBarW = series.barW = Math.max(seriesPointWidth, 1 + 2 * borderWidth);
    if (chart.inverted) {
      translatedThreshold -= 0.5;
    }
    if (options.pointPadding) {
      seriesBarW = Math.ceil(seriesBarW);
    }
    Series_default.prototype.translate.apply(series);
    series.points.forEach(function(point) {
      var yBottom = pick28(point.yBottom, translatedThreshold), safeDistance = 999 + Math.abs(yBottom), plotX = point.plotX || 0, plotY = clamp7(point.plotY, -safeDistance, yAxis.len + safeDistance);
      var up, barY = Math.min(plotY, yBottom), barH = Math.max(plotY, yBottom) - barY, pointWidth = seriesPointWidth, barX = plotX + seriesXOffset, barW = seriesBarW;
      if (minPointLength && Math.abs(barH) < minPointLength) {
        barH = minPointLength;
        up = !yAxis.reversed && !point.negative || yAxis.reversed && point.negative;
        if (isNumber21(threshold) && isNumber21(dataMax) && point.y === threshold && dataMax <= threshold && (yAxis.min || 0) < threshold && (dataMin !== dataMax || (yAxis.max || 0) <= threshold)) {
          up = !up;
        }
        barY = Math.abs(barY - translatedThreshold) > minPointLength ? yBottom - minPointLength : translatedThreshold - (up ? minPointLength : 0);
      }
      if (defined20(point.options.pointWidth)) {
        pointWidth = barW = Math.ceil(point.options.pointWidth);
        barX -= Math.round((pointWidth - seriesPointWidth) / 2);
      }
      if (options.centerInCategory) {
        barX = series.adjustForMissingColumns(barX, pointWidth, point, metrics);
      }
      point.barX = barX;
      point.pointWidth = pointWidth;
      point.tooltipPos = chart.inverted ? [
        clamp7(yAxis.len + yAxis.pos - chart.plotLeft - plotY, yAxis.pos - chart.plotLeft, yAxis.len + yAxis.pos - chart.plotLeft),
        xAxis.len + xAxis.pos - chart.plotTop - barX - barW / 2,
        barH
      ] : [
        xAxis.left - chart.plotLeft + barX + barW / 2,
        clamp7(plotY + yAxis.pos - chart.plotTop, yAxis.pos - chart.plotTop, yAxis.len + yAxis.pos - chart.plotTop),
        barH
      ];
      point.shapeType = series.pointClass.prototype.shapeType || "rect";
      point.shapeArgs = series.crispCol.apply(series, point.isNull ? [barX, translatedThreshold, barW, 0] : [barX, barY, barW, barH]);
    });
  };
  ColumnSeries19.prototype.drawGraph = function() {
    this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
  };
  ColumnSeries19.prototype.pointAttribs = function(point, state) {
    var options = this.options, p2o = this.pointAttrToOptions || {}, strokeOption = p2o.stroke || "borderColor", strokeWidthOption = p2o["stroke-width"] || "borderWidth";
    var stateOptions, zone, brightness, fill = point && point.color || this.color, stroke = point && point[strokeOption] || options[strokeOption] || fill, dashstyle = point && point.options.dashStyle || options.dashStyle, strokeWidth = point && point[strokeWidthOption] || options[strokeWidthOption] || this[strokeWidthOption] || 0, opacity = pick28(point && point.opacity, options.opacity, 1);
    if (point && this.zones.length) {
      zone = point.getZone();
      fill = point.options.color || zone && (zone.color || point.nonZonedColor) || this.color;
      if (zone) {
        stroke = zone.borderColor || stroke;
        dashstyle = zone.dashStyle || dashstyle;
        strokeWidth = zone.borderWidth || strokeWidth;
      }
    }
    if (state && point) {
      stateOptions = merge24(options.states[state], point.options.states && point.options.states[state] || {});
      brightness = stateOptions.brightness;
      fill = stateOptions.color || typeof brightness !== "undefined" && color5(fill).brighten(stateOptions.brightness).get() || fill;
      stroke = stateOptions[strokeOption] || stroke;
      strokeWidth = stateOptions[strokeWidthOption] || strokeWidth;
      dashstyle = stateOptions.dashStyle || dashstyle;
      opacity = pick28(stateOptions.opacity, opacity);
    }
    var ret = {
      fill,
      stroke,
      "stroke-width": strokeWidth,
      opacity
    };
    if (dashstyle) {
      ret.dashstyle = dashstyle;
    }
    return ret;
  };
  ColumnSeries19.prototype.drawPoints = function() {
    var series = this, chart = this.chart, options = series.options, renderer = chart.renderer, animationLimit = options.animationLimit || 250;
    var shapeArgs;
    series.points.forEach(function(point) {
      var plotY = point.plotY;
      var graphic = point.graphic, hasGraphic = !!graphic, verb = graphic && chart.pointCount < animationLimit ? "animate" : "attr";
      if (isNumber21(plotY) && point.y !== null) {
        shapeArgs = point.shapeArgs;
        if (graphic && point.hasNewShapeType()) {
          graphic = graphic.destroy();
        }
        if (series.enabledDataSorting) {
          point.startXPos = series.xAxis.reversed ? -(shapeArgs ? shapeArgs.width || 0 : 0) : series.xAxis.width;
        }
        if (!graphic) {
          point.graphic = graphic = renderer[point.shapeType](shapeArgs).add(point.group || series.group);
          if (graphic && series.enabledDataSorting && chart.hasRendered && chart.pointCount < animationLimit) {
            graphic.attr({
              x: point.startXPos
            });
            hasGraphic = true;
            verb = "animate";
          }
        }
        if (graphic && hasGraphic) {
          graphic[verb](merge24(shapeArgs));
        }
        if (options.borderRadius) {
          graphic[verb]({
            r: options.borderRadius
          });
        }
        if (!chart.styledMode) {
          graphic[verb](series.pointAttribs(point, point.selected && "select")).shadow(point.allowShadow !== false && options.shadow, null, options.stacking && !options.borderRadius);
        }
        if (graphic) {
          graphic.addClass(point.getClassName(), true);
          graphic.attr({
            visibility: point.visible ? "inherit" : "hidden"
          });
        }
      } else if (graphic) {
        point.graphic = graphic.destroy();
      }
    });
  };
  ColumnSeries19.prototype.drawTracker = function() {
    var series = this, chart = series.chart, pointer = chart.pointer, onMouseOver = function(e2) {
      var point = pointer.getPointFromEvent(e2);
      if (typeof point !== "undefined") {
        pointer.isDirectTouch = true;
        point.onMouseOver(e2);
      }
    };
    var dataLabels;
    series.points.forEach(function(point) {
      dataLabels = isArray11(point.dataLabels) ? point.dataLabels : point.dataLabel ? [point.dataLabel] : [];
      if (point.graphic) {
        point.graphic.element.point = point;
      }
      dataLabels.forEach(function(dataLabel) {
        if (dataLabel.div) {
          dataLabel.div.point = point;
        } else {
          dataLabel.element.point = point;
        }
      });
    });
    if (!series._hasTracking) {
      series.trackerGroups.forEach(function(key) {
        if (series[key]) {
          series[key].addClass("highcharts-tracker").on("mouseover", onMouseOver).on("mouseout", function(e2) {
            pointer.onTrackerMouseOut(e2);
          });
          if (hasTouch2) {
            series[key].on("touchstart", onMouseOver);
          }
          if (!chart.styledMode && series.options.cursor) {
            series[key].css(css11).css({ cursor: series.options.cursor });
          }
        }
      });
      series._hasTracking = true;
    }
    fireEvent13(this, "afterDrawTracker");
  };
  ColumnSeries19.prototype.remove = function() {
    var series = this, chart = series.chart;
    if (chart.hasRendered) {
      chart.series.forEach(function(otherSeries) {
        if (otherSeries.type === series.type) {
          otherSeries.isDirty = true;
        }
      });
    }
    Series_default.prototype.remove.apply(series, arguments);
  };
  ColumnSeries19.defaultOptions = merge24(Series_default.defaultOptions, {
    borderRadius: 0,
    centerInCategory: false,
    groupPadding: 0.2,
    marker: null,
    pointPadding: 0.1,
    minPointLength: 0,
    cropThreshold: 50,
    pointRange: null,
    states: {
      hover: {
        halo: false,
        brightness: 0.1
      },
      select: {
        color: Palette_default.neutralColor20,
        borderColor: Palette_default.neutralColor100
      }
    },
    dataLabels: {
      align: void 0,
      verticalAlign: void 0,
      y: void 0
    },
    startFromThreshold: true,
    stickyTracking: false,
    tooltip: {
      distance: 6
    },
    threshold: 0,
    borderColor: Palette_default.backgroundColor
  });
  return ColumnSeries19;
}(Series_default);
extend18(ColumnSeries.prototype, {
  cropShoulder: 0,
  directTouch: true,
  drawLegendSymbol: LegendSymbol_default.drawRectangle,
  getSymbol: noop5,
  negStacks: true,
  trackerGroups: ["group", "dataLabelsGroup"]
});
SeriesRegistry_default.registerSeriesType("column", ColumnSeries);
var ColumnSeries_default = ColumnSeries;

// node_modules/highcharts/es-modules/Core/Series/DataLabel.js
var getDeferredAnimation3 = AnimationUtilities_default.getDeferredAnimation;
var format6 = FormatUtilities_default.format;
var defined21 = Utilities_default.defined;
var extend19 = Utilities_default.extend;
var fireEvent14 = Utilities_default.fireEvent;
var isArray12 = Utilities_default.isArray;
var merge25 = Utilities_default.merge;
var objectEach21 = Utilities_default.objectEach;
var pick29 = Utilities_default.pick;
var splat9 = Utilities_default.splat;
var DataLabel;
(function(DataLabel2) {
  var composedClasses2 = [];
  function alignDataLabel(point, dataLabel, options, alignTo, isNew) {
    var series = this, chart = this.chart, inverted = this.isCartesian && chart.inverted, enabledDataSorting = this.enabledDataSorting, plotX = pick29(point.dlBox && point.dlBox.centerX, point.plotX, -9999), plotY = pick29(point.plotY, -9999), bBox = dataLabel.getBBox(), rotation = options.rotation, align = options.align, isInsidePlot = chart.isInsidePlot(plotX, Math.round(plotY), {
      inverted,
      paneCoordinates: true,
      series
    }), setStartPos = function(alignOptions) {
      if (enabledDataSorting && series.xAxis && !justify) {
        series.setDataLabelStartPos(point, dataLabel, isNew, isInsidePlot, alignOptions);
      }
    };
    var baseline, normRotation, negRotation, rotCorr, alignAttr, justify = pick29(options.overflow, enabledDataSorting ? "none" : "justify") === "justify", visible = this.visible && point.visible !== false && (point.series.forceDL || enabledDataSorting && !justify || isInsidePlot || pick29(options.inside, !!this.options.stacking) && alignTo && chart.isInsidePlot(plotX, inverted ? alignTo.x + 1 : alignTo.y + alignTo.height - 1, {
      inverted,
      paneCoordinates: true,
      series
    }));
    if (visible) {
      baseline = chart.renderer.fontMetrics(chart.styledMode ? void 0 : options.style.fontSize, dataLabel).b;
      alignTo = extend19({
        x: inverted ? this.yAxis.len - plotY : plotX,
        y: Math.round(inverted ? this.xAxis.len - plotX : plotY),
        width: 0,
        height: 0
      }, alignTo);
      extend19(options, {
        width: bBox.width,
        height: bBox.height
      });
      if (rotation) {
        justify = false;
        rotCorr = chart.renderer.rotCorr(baseline, rotation);
        alignAttr = {
          x: alignTo.x + (options.x || 0) + alignTo.width / 2 + rotCorr.x,
          y: alignTo.y + (options.y || 0) + { top: 0, middle: 0.5, bottom: 1 }[options.verticalAlign] * alignTo.height
        };
        setStartPos(alignAttr);
        dataLabel[isNew ? "attr" : "animate"](alignAttr).attr({
          align
        });
        normRotation = (rotation + 720) % 360;
        negRotation = normRotation > 180 && normRotation < 360;
        if (align === "left") {
          alignAttr.y -= negRotation ? bBox.height : 0;
        } else if (align === "center") {
          alignAttr.x -= bBox.width / 2;
          alignAttr.y -= bBox.height / 2;
        } else if (align === "right") {
          alignAttr.x -= bBox.width;
          alignAttr.y -= negRotation ? 0 : bBox.height;
        }
        dataLabel.placed = true;
        dataLabel.alignAttr = alignAttr;
      } else {
        setStartPos(alignTo);
        dataLabel.align(options, void 0, alignTo);
        alignAttr = dataLabel.alignAttr;
      }
      if (justify && alignTo.height >= 0) {
        this.justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew);
      } else if (pick29(options.crop, true)) {
        visible = chart.isInsidePlot(alignAttr.x, alignAttr.y, {
          paneCoordinates: true,
          series
        }) && chart.isInsidePlot(alignAttr.x + bBox.width, alignAttr.y + bBox.height, {
          paneCoordinates: true,
          series
        });
      }
      if (options.shape && !rotation) {
        dataLabel[isNew ? "attr" : "animate"]({
          anchorX: inverted ? chart.plotWidth - point.plotY : point.plotX,
          anchorY: inverted ? chart.plotHeight - point.plotX : point.plotY
        });
      }
    }
    if (isNew && enabledDataSorting) {
      dataLabel.placed = false;
    }
    if (!visible && (!enabledDataSorting || justify)) {
      dataLabel.hide(true);
      dataLabel.placed = false;
    }
  }
  function applyFilter(point, options) {
    var filter = options.filter;
    if (filter) {
      var op = filter.operator;
      var prop = point[filter.property];
      var val = filter.value;
      if (op === ">" && prop > val || op === "<" && prop < val || op === ">=" && prop >= val || op === "<=" && prop <= val || op === "==" && prop == val || op === "===" && prop === val) {
        return true;
      }
      return false;
    }
    return true;
  }
  function compose(SeriesClass) {
    if (composedClasses2.indexOf(SeriesClass) === -1) {
      var seriesProto5 = SeriesClass.prototype;
      composedClasses2.push(SeriesClass);
      seriesProto5.alignDataLabel = alignDataLabel;
      seriesProto5.drawDataLabels = drawDataLabels;
      seriesProto5.justifyDataLabel = justifyDataLabel;
      seriesProto5.setDataLabelStartPos = setDataLabelStartPos;
    }
  }
  DataLabel2.compose = compose;
  function drawDataLabels() {
    var series = this, chart = series.chart, seriesOptions = series.options, points = series.points, hasRendered = series.hasRendered || 0, renderer = chart.renderer;
    var seriesDlOptions = seriesOptions.dataLabels, pointOptions, dataLabelsGroup;
    var dataLabelAnim = seriesDlOptions.animation, animationConfig = seriesDlOptions.defer ? getDeferredAnimation3(chart, dataLabelAnim, series) : { defer: 0, duration: 0 };
    seriesDlOptions = mergeArrays(mergeArrays(chart.options.plotOptions && chart.options.plotOptions.series && chart.options.plotOptions.series.dataLabels, chart.options.plotOptions && chart.options.plotOptions[series.type] && chart.options.plotOptions[series.type].dataLabels), seriesDlOptions);
    fireEvent14(this, "drawDataLabels");
    if (isArray12(seriesDlOptions) || seriesDlOptions.enabled || series._hasPointLabels) {
      dataLabelsGroup = series.plotGroup("dataLabelsGroup", "data-labels", !hasRendered ? "hidden" : "inherit", seriesDlOptions.zIndex || 6);
      dataLabelsGroup.attr({ opacity: +hasRendered });
      if (!hasRendered) {
        var group = series.dataLabelsGroup;
        if (group) {
          if (series.visible) {
            dataLabelsGroup.show(true);
          }
          group[seriesOptions.animation ? "animate" : "attr"]({ opacity: 1 }, animationConfig);
        }
      }
      points.forEach(function(point) {
        pointOptions = splat9(mergeArrays(seriesDlOptions, point.dlOptions || point.options && point.options.dataLabels));
        pointOptions.forEach(function(labelOptions, i) {
          var labelEnabled = labelOptions.enabled && (!point.isNull || point.dataLabelOnNull) && applyFilter(point, labelOptions), connector = point.connectors ? point.connectors[i] : point.connector;
          var labelConfig, formatString, labelText, style, rotation, attr10, dataLabel = point.dataLabels ? point.dataLabels[i] : point.dataLabel;
          var labelDistance = pick29(labelOptions.distance, point.labelDistance), isNew = !dataLabel;
          if (labelEnabled) {
            labelConfig = point.getLabelConfig();
            formatString = pick29(labelOptions[point.formatPrefix + "Format"], labelOptions.format);
            labelText = defined21(formatString) ? format6(formatString, labelConfig, chart) : (labelOptions[point.formatPrefix + "Formatter"] || labelOptions.formatter).call(labelConfig, labelOptions);
            style = labelOptions.style;
            rotation = labelOptions.rotation;
            if (!chart.styledMode) {
              style.color = pick29(labelOptions.color, style.color, series.color, Palette_default.neutralColor100);
              if (style.color === "contrast") {
                point.contrastColor = renderer.getContrast(point.color || series.color);
                style.color = !defined21(labelDistance) && labelOptions.inside || labelDistance < 0 || !!seriesOptions.stacking ? point.contrastColor : Palette_default.neutralColor100;
              } else {
                delete point.contrastColor;
              }
              if (seriesOptions.cursor) {
                style.cursor = seriesOptions.cursor;
              }
            }
            attr10 = {
              r: labelOptions.borderRadius || 0,
              rotation,
              padding: labelOptions.padding,
              zIndex: 1
            };
            if (!chart.styledMode) {
              attr10.fill = labelOptions.backgroundColor;
              attr10.stroke = labelOptions.borderColor;
              attr10["stroke-width"] = labelOptions.borderWidth;
            }
            objectEach21(attr10, function(val, name) {
              if (typeof val === "undefined") {
                delete attr10[name];
              }
            });
          }
          if (dataLabel && (!labelEnabled || !defined21(labelText))) {
            point.dataLabel = point.dataLabel && point.dataLabel.destroy();
            if (point.dataLabels) {
              if (point.dataLabels.length === 1) {
                delete point.dataLabels;
              } else {
                delete point.dataLabels[i];
              }
            }
            if (!i) {
              delete point.dataLabel;
            }
            if (connector) {
              point.connector = point.connector.destroy();
              if (point.connectors) {
                if (point.connectors.length === 1) {
                  delete point.connectors;
                } else {
                  delete point.connectors[i];
                }
              }
            }
          } else if (labelEnabled && defined21(labelText)) {
            if (!dataLabel) {
              point.dataLabels = point.dataLabels || [];
              dataLabel = point.dataLabels[i] = rotation ? renderer.text(labelText, 0, -9999, labelOptions.useHTML).addClass("highcharts-data-label") : renderer.label(labelText, 0, -9999, labelOptions.shape, null, null, labelOptions.useHTML, null, "data-label");
              if (!i) {
                point.dataLabel = dataLabel;
              }
              dataLabel.addClass(" highcharts-data-label-color-" + point.colorIndex + " " + (labelOptions.className || "") + (labelOptions.useHTML ? " highcharts-tracker" : ""));
            } else {
              attr10.text = labelText;
            }
            dataLabel.options = labelOptions;
            dataLabel.attr(attr10);
            if (!chart.styledMode) {
              dataLabel.css(style).shadow(labelOptions.shadow);
            }
            if (!dataLabel.added) {
              dataLabel.add(dataLabelsGroup);
            }
            if (labelOptions.textPath && !labelOptions.useHTML) {
              dataLabel.setTextPath(point.getDataLabelPath && point.getDataLabelPath(dataLabel) || point.graphic, labelOptions.textPath);
              if (point.dataLabelPath && !labelOptions.textPath.enabled) {
                point.dataLabelPath = point.dataLabelPath.destroy();
              }
            }
            series.alignDataLabel(point, dataLabel, labelOptions, null, isNew);
          }
        });
      });
    }
    fireEvent14(this, "afterDrawDataLabels");
  }
  function justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew) {
    var chart = this.chart, align = options.align, verticalAlign = options.verticalAlign, padding = dataLabel.box ? 0 : dataLabel.padding || 0;
    var _a15 = options.x, x = _a15 === void 0 ? 0 : _a15, _b = options.y, y = _b === void 0 ? 0 : _b, off, justified;
    off = (alignAttr.x || 0) + padding;
    if (off < 0) {
      if (align === "right" && x >= 0) {
        options.align = "left";
        options.inside = true;
      } else {
        x -= off;
      }
      justified = true;
    }
    off = (alignAttr.x || 0) + bBox.width - padding;
    if (off > chart.plotWidth) {
      if (align === "left" && x <= 0) {
        options.align = "right";
        options.inside = true;
      } else {
        x += chart.plotWidth - off;
      }
      justified = true;
    }
    off = alignAttr.y + padding;
    if (off < 0) {
      if (verticalAlign === "bottom" && y >= 0) {
        options.verticalAlign = "top";
        options.inside = true;
      } else {
        y -= off;
      }
      justified = true;
    }
    off = (alignAttr.y || 0) + bBox.height - padding;
    if (off > chart.plotHeight) {
      if (verticalAlign === "top" && y <= 0) {
        options.verticalAlign = "bottom";
        options.inside = true;
      } else {
        y += chart.plotHeight - off;
      }
      justified = true;
    }
    if (justified) {
      options.x = x;
      options.y = y;
      dataLabel.placed = !isNew;
      dataLabel.align(options, void 0, alignTo);
    }
    return justified;
  }
  function mergeArrays(one, two) {
    var res = [], i;
    if (isArray12(one) && !isArray12(two)) {
      res = one.map(function(el) {
        return merge25(el, two);
      });
    } else if (isArray12(two) && !isArray12(one)) {
      res = two.map(function(el) {
        return merge25(one, el);
      });
    } else if (!isArray12(one) && !isArray12(two)) {
      res = merge25(one, two);
    } else {
      i = Math.max(one.length, two.length);
      while (i--) {
        res[i] = merge25(one[i], two[i]);
      }
    }
    return res;
  }
  function setDataLabelStartPos(point, dataLabel, isNew, isInside, alignOptions) {
    var chart = this.chart, inverted = chart.inverted, xAxis = this.xAxis, reversed = xAxis.reversed, labelCenter = inverted ? dataLabel.height / 2 : dataLabel.width / 2, pointWidth = point.pointWidth, halfWidth = pointWidth ? pointWidth / 2 : 0;
    dataLabel.startXPos = inverted ? alignOptions.x : reversed ? -labelCenter - halfWidth : xAxis.width - labelCenter + halfWidth;
    dataLabel.startYPos = inverted ? reversed ? this.yAxis.height - labelCenter + halfWidth : -labelCenter - halfWidth : alignOptions.y;
    if (!isInside) {
      dataLabel.attr({ opacity: 1 }).animate({ opacity: 0 }, void 0, dataLabel.hide);
    } else if (dataLabel.visibility === "hidden") {
      dataLabel.show();
      dataLabel.attr({ opacity: 0 }).animate({ opacity: 1 });
    }
    if (!chart.hasRendered) {
      return;
    }
    if (isNew) {
      dataLabel.attr({ x: dataLabel.startXPos, y: dataLabel.startYPos });
    }
    dataLabel.placed = true;
  }
})(DataLabel || (DataLabel = {}));
var DataLabel_default = DataLabel;

// node_modules/highcharts/es-modules/Series/Column/ColumnDataLabel.js
var Series2 = SeriesRegistry_default.series;
var merge26 = Utilities_default.merge;
var pick30 = Utilities_default.pick;
var ColumnDataLabel;
(function(ColumnDataLabel3) {
  var composedClasses2 = [];
  function alignDataLabel(point, dataLabel, options, alignTo, isNew) {
    var inverted = this.chart.inverted, series = point.series, dlBox = point.dlBox || point.shapeArgs, below = pick30(point.below, point.plotY > pick30(this.translatedThreshold, series.yAxis.len)), inside = pick30(options.inside, !!this.options.stacking), overshoot;
    if (dlBox) {
      alignTo = merge26(dlBox);
      if (alignTo.y < 0) {
        alignTo.height += alignTo.y;
        alignTo.y = 0;
      }
      overshoot = alignTo.y + alignTo.height - series.yAxis.len;
      if (overshoot > 0 && overshoot < alignTo.height) {
        alignTo.height -= overshoot;
      }
      if (inverted) {
        alignTo = {
          x: series.yAxis.len - alignTo.y - alignTo.height,
          y: series.xAxis.len - alignTo.x - alignTo.width,
          width: alignTo.height,
          height: alignTo.width
        };
      }
      if (!inside) {
        if (inverted) {
          alignTo.x += below ? 0 : alignTo.width;
          alignTo.width = 0;
        } else {
          alignTo.y += below ? alignTo.height : 0;
          alignTo.height = 0;
        }
      }
    }
    options.align = pick30(options.align, !inverted || inside ? "center" : below ? "right" : "left");
    options.verticalAlign = pick30(options.verticalAlign, inverted || inside ? "middle" : below ? "top" : "bottom");
    Series2.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);
    if (options.inside && point.contrastColor) {
      dataLabel.css({
        color: point.contrastColor
      });
    }
  }
  function compose(ColumnSeriesClass) {
    DataLabel_default.compose(Series2);
    if (composedClasses2.indexOf(ColumnSeriesClass) === -1) {
      composedClasses2.push(ColumnSeriesClass);
      ColumnSeriesClass.prototype.alignDataLabel = alignDataLabel;
    }
  }
  ColumnDataLabel3.compose = compose;
})(ColumnDataLabel || (ColumnDataLabel = {}));
var ColumnDataLabel_default = ColumnDataLabel;

// node_modules/highcharts/es-modules/Series/Bar/BarSeries.js
var __extends10 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var extend20 = Utilities_default.extend;
var merge27 = Utilities_default.merge;
var BarSeries = function(_super) {
  __extends10(BarSeries2, _super);
  function BarSeries2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.data = void 0;
    _this.options = void 0;
    _this.points = void 0;
    return _this;
  }
  BarSeries2.defaultOptions = merge27(ColumnSeries_default.defaultOptions, {});
  return BarSeries2;
}(ColumnSeries_default);
extend20(BarSeries.prototype, {
  inverted: true
});
SeriesRegistry_default.registerSeriesType("bar", BarSeries);

// node_modules/highcharts/es-modules/Series/Scatter/ScatterSeries.js
var __extends11 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var addEvent16 = Utilities_default.addEvent;
var extend21 = Utilities_default.extend;
var merge28 = Utilities_default.merge;
var ScatterSeries = function(_super) {
  __extends11(ScatterSeries6, _super);
  function ScatterSeries6() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.data = void 0;
    _this.options = void 0;
    _this.points = void 0;
    return _this;
  }
  ScatterSeries6.prototype.applyJitter = function() {
    var series = this, jitter = this.options.jitter, len = this.points.length;
    function unrandom(seed) {
      var rand = Math.sin(seed) * 1e4;
      return rand - Math.floor(rand);
    }
    if (jitter) {
      this.points.forEach(function(point, i) {
        ["x", "y"].forEach(function(dim, j) {
          var axis, plotProp = "plot" + dim.toUpperCase(), min, max, translatedJitter;
          if (jitter[dim] && !point.isNull) {
            axis = series[dim + "Axis"];
            translatedJitter = jitter[dim] * axis.transA;
            if (axis && !axis.isLog) {
              min = Math.max(0, point[plotProp] - translatedJitter);
              max = Math.min(axis.len, point[plotProp] + translatedJitter);
              point[plotProp] = min + (max - min) * unrandom(i + j * len);
              if (dim === "x") {
                point.clientX = point.plotX;
              }
            }
          }
        });
      });
    }
  };
  ScatterSeries6.prototype.drawGraph = function() {
    if (this.options.lineWidth) {
      _super.prototype.drawGraph.call(this);
    } else if (this.graph) {
      this.graph = this.graph.destroy();
    }
  };
  ScatterSeries6.defaultOptions = merge28(LineSeries_default.defaultOptions, {
    lineWidth: 0,
    findNearestPointBy: "xy",
    jitter: {
      x: 0,
      y: 0
    },
    marker: {
      enabled: true
    },
    tooltip: {
      headerFormat: '<span style="color:{point.color}">\u25CF</span> <span style="font-size: 10px"> {series.name}</span><br/>',
      pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
    }
  });
  return ScatterSeries6;
}(LineSeries_default);
extend21(ScatterSeries.prototype, {
  drawTracker: ColumnSeries_default.prototype.drawTracker,
  sorted: false,
  requireSorting: false,
  noSharedTooltip: true,
  trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
  takeOrdinalPosition: false
});
addEvent16(ScatterSeries, "afterTranslate", function() {
  this.applyJitter();
});
SeriesRegistry_default.registerSeriesType("scatter", ScatterSeries);
var ScatterSeries_default = ScatterSeries;

// node_modules/highcharts/es-modules/Mixins/CenteredSeries.js
var isNumber22 = Utilities_default.isNumber;
var pick31 = Utilities_default.pick;
var relativeLength5 = Utilities_default.relativeLength;
var deg2rad5 = Globals_default.deg2rad;
var centeredSeriesMixin = Globals_default.CenteredSeriesMixin = {
  getCenter: function() {
    var options = this.options, chart = this.chart, slicingRoom = 2 * (options.slicedOffset || 0), handleSlicingRoom, plotWidth = chart.plotWidth - 2 * slicingRoom, plotHeight = chart.plotHeight - 2 * slicingRoom, centerOption = options.center, smallestSize = Math.min(plotWidth, plotHeight), size = options.size, innerSize = options.innerSize || 0, positions, i, value;
    if (typeof size === "string") {
      size = parseFloat(size);
    }
    if (typeof innerSize === "string") {
      innerSize = parseFloat(innerSize);
    }
    positions = [
      pick31(centerOption[0], "50%"),
      pick31(centerOption[1], "50%"),
      pick31(size && size < 0 ? void 0 : options.size, "100%"),
      pick31(innerSize && innerSize < 0 ? void 0 : options.innerSize || 0, "0%")
    ];
    if (chart.angular && !(this instanceof Series_default)) {
      positions[3] = 0;
    }
    for (i = 0; i < 4; ++i) {
      value = positions[i];
      handleSlicingRoom = i < 2 || i === 2 && /%$/.test(value);
      positions[i] = relativeLength5(value, [plotWidth, plotHeight, smallestSize, positions[2]][i]) + (handleSlicingRoom ? slicingRoom : 0);
    }
    if (positions[3] > positions[2]) {
      positions[3] = positions[2];
    }
    return positions;
  },
  getStartAndEndRadians: function(start, end) {
    var startAngle = isNumber22(start) ? start : 0, endAngle = isNumber22(end) && end > startAngle && end - startAngle < 360 ? end : startAngle + 360, correction = -90;
    return {
      start: deg2rad5 * (startAngle + correction),
      end: deg2rad5 * (endAngle + correction)
    };
  }
};
var CenteredSeries_default = centeredSeriesMixin;

// node_modules/highcharts/es-modules/Series/Pie/PiePoint.js
var __extends12 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var setAnimation5 = AnimationUtilities_default.setAnimation;
var addEvent17 = Utilities_default.addEvent;
var defined22 = Utilities_default.defined;
var extend22 = Utilities_default.extend;
var isNumber23 = Utilities_default.isNumber;
var pick32 = Utilities_default.pick;
var relativeLength6 = Utilities_default.relativeLength;
var PiePoint = function(_super) {
  __extends12(PiePoint5, _super);
  function PiePoint5() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.labelDistance = void 0;
    _this.options = void 0;
    _this.series = void 0;
    return _this;
  }
  PiePoint5.prototype.getConnectorPath = function() {
    var labelPosition = this.labelPosition, options = this.series.options.dataLabels, predefinedShapes = this.connectorShapes;
    var connectorShape = options.connectorShape;
    if (predefinedShapes[connectorShape]) {
      connectorShape = predefinedShapes[connectorShape];
    }
    return connectorShape.call(this, {
      x: labelPosition.final.x,
      y: labelPosition.final.y,
      alignment: labelPosition.alignment
    }, labelPosition.connectorPosition, options);
  };
  PiePoint5.prototype.getTranslate = function() {
    return this.sliced ? this.slicedTranslation : {
      translateX: 0,
      translateY: 0
    };
  };
  PiePoint5.prototype.haloPath = function(size) {
    var shapeArgs = this.shapeArgs;
    return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(shapeArgs.x, shapeArgs.y, shapeArgs.r + size, shapeArgs.r + size, {
      innerR: shapeArgs.r - 1,
      start: shapeArgs.start,
      end: shapeArgs.end
    });
  };
  PiePoint5.prototype.init = function() {
    var _this = this;
    _super.prototype.init.apply(this, arguments);
    this.name = pick32(this.name, "Slice");
    var toggleSlice = function(e2) {
      _this.slice(e2.type === "select");
    };
    addEvent17(this, "select", toggleSlice);
    addEvent17(this, "unselect", toggleSlice);
    return this;
  };
  PiePoint5.prototype.isValid = function() {
    return isNumber23(this.y) && this.y >= 0;
  };
  PiePoint5.prototype.setVisible = function(vis, redraw) {
    var _this = this;
    var series = this.series, chart = series.chart, ignoreHiddenPoint = series.options.ignoreHiddenPoint;
    redraw = pick32(redraw, ignoreHiddenPoint);
    if (vis !== this.visible) {
      this.visible = this.options.visible = vis = typeof vis === "undefined" ? !this.visible : vis;
      series.options.data[series.data.indexOf(this)] = this.options;
      ["graphic", "dataLabel", "connector", "shadowGroup"].forEach(function(key) {
        if (_this[key]) {
          _this[key][vis ? "show" : "hide"](vis);
        }
      });
      if (this.legendItem) {
        chart.legend.colorizeItem(this, vis);
      }
      if (!vis && this.state === "hover") {
        this.setState("");
      }
      if (ignoreHiddenPoint) {
        series.isDirty = true;
      }
      if (redraw) {
        chart.redraw();
      }
    }
  };
  PiePoint5.prototype.slice = function(sliced, redraw, animation) {
    var series = this.series, chart = series.chart;
    setAnimation5(animation, chart);
    redraw = pick32(redraw, true);
    this.sliced = this.options.sliced = sliced = defined22(sliced) ? sliced : !this.sliced;
    series.options.data[series.data.indexOf(this)] = this.options;
    if (this.graphic) {
      this.graphic.animate(this.getTranslate());
    }
    if (this.shadowGroup) {
      this.shadowGroup.animate(this.getTranslate());
    }
  };
  return PiePoint5;
}(Point_default);
extend22(PiePoint.prototype, {
  connectorShapes: {
    fixedOffset: function(labelPosition, connectorPosition, options) {
      var breakAt = connectorPosition.breakAt, touchingSliceAt = connectorPosition.touchingSliceAt, lineSegment = options.softConnector ? [
        "C",
        labelPosition.x + (labelPosition.alignment === "left" ? -5 : 5),
        labelPosition.y,
        2 * breakAt.x - touchingSliceAt.x,
        2 * breakAt.y - touchingSliceAt.y,
        breakAt.x,
        breakAt.y
      ] : [
        "L",
        breakAt.x,
        breakAt.y
      ];
      return [
        ["M", labelPosition.x, labelPosition.y],
        lineSegment,
        ["L", touchingSliceAt.x, touchingSliceAt.y]
      ];
    },
    straight: function(labelPosition, connectorPosition) {
      var touchingSliceAt = connectorPosition.touchingSliceAt;
      return [
        ["M", labelPosition.x, labelPosition.y],
        ["L", touchingSliceAt.x, touchingSliceAt.y]
      ];
    },
    crookedLine: function(labelPosition, connectorPosition, options) {
      var touchingSliceAt = connectorPosition.touchingSliceAt, series = this.series, pieCenterX = series.center[0], plotWidth = series.chart.plotWidth, plotLeft = series.chart.plotLeft, alignment = labelPosition.alignment, radius = this.shapeArgs.r, crookDistance = relativeLength6(options.crookDistance, 1), crookX = alignment === "left" ? pieCenterX + radius + (plotWidth + plotLeft - pieCenterX - radius) * (1 - crookDistance) : plotLeft + (pieCenterX - radius) * crookDistance, segmentWithCrook = [
        "L",
        crookX,
        labelPosition.y
      ];
      var useCrook = true;
      if (alignment === "left" ? crookX > labelPosition.x || crookX < touchingSliceAt.x : crookX < labelPosition.x || crookX > touchingSliceAt.x) {
        useCrook = false;
      }
      var path = [["M", labelPosition.x, labelPosition.y]];
      if (useCrook) {
        path.push(segmentWithCrook);
      }
      path.push(["L", touchingSliceAt.x, touchingSliceAt.y]);
      return path;
    }
  }
});
var PiePoint_default = PiePoint;

// node_modules/highcharts/es-modules/Series/Pie/PieSeries.js
var __extends13 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var getStartAndEndRadians = CenteredSeries_default.getStartAndEndRadians;
var noop6 = Globals_default.noop;
var clamp8 = Utilities_default.clamp;
var extend23 = Utilities_default.extend;
var fireEvent15 = Utilities_default.fireEvent;
var merge29 = Utilities_default.merge;
var pick33 = Utilities_default.pick;
var relativeLength7 = Utilities_default.relativeLength;
var PieSeries = function(_super) {
  __extends13(PieSeries5, _super);
  function PieSeries5() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.center = void 0;
    _this.data = void 0;
    _this.maxLabelDistance = void 0;
    _this.options = void 0;
    _this.points = void 0;
    return _this;
  }
  PieSeries5.prototype.animate = function(init) {
    var series = this, points = series.points, startAngleRad = series.startAngleRad;
    if (!init) {
      points.forEach(function(point) {
        var graphic = point.graphic, args = point.shapeArgs;
        if (graphic && args) {
          graphic.attr({
            r: pick33(point.startR, series.center && series.center[3] / 2),
            start: startAngleRad,
            end: startAngleRad
          });
          graphic.animate({
            r: args.r,
            start: args.start,
            end: args.end
          }, series.options.animation);
        }
      });
    }
  };
  PieSeries5.prototype.drawEmpty = function() {
    var start = this.startAngleRad, end = this.endAngleRad, options = this.options;
    var centerX, centerY;
    if (this.total === 0 && this.center) {
      centerX = this.center[0];
      centerY = this.center[1];
      if (!this.graph) {
        this.graph = this.chart.renderer.arc(centerX, centerY, this.center[1] / 2, 0, start, end).addClass("highcharts-empty-series").add(this.group);
      }
      this.graph.attr({
        d: Symbols_default.arc(centerX, centerY, this.center[2] / 2, 0, {
          start,
          end,
          innerR: this.center[3] / 2
        })
      });
      if (!this.chart.styledMode) {
        this.graph.attr({
          "stroke-width": options.borderWidth,
          fill: options.fillColor || "none",
          stroke: options.color || Palette_default.neutralColor20
        });
      }
    } else if (this.graph) {
      this.graph = this.graph.destroy();
    }
  };
  PieSeries5.prototype.drawPoints = function() {
    var renderer = this.chart.renderer;
    this.points.forEach(function(point) {
      if (point.graphic && point.hasNewShapeType()) {
        point.graphic = point.graphic.destroy();
      }
      if (!point.graphic) {
        point.graphic = renderer[point.shapeType](point.shapeArgs).add(point.series.group);
        point.delayedRendering = true;
      }
    });
  };
  PieSeries5.prototype.generatePoints = function() {
    _super.prototype.generatePoints.call(this);
    this.updateTotals();
  };
  PieSeries5.prototype.getX = function(y, left, point) {
    var center = this.center, radius = this.radii ? this.radii[point.index] || 0 : center[2] / 2;
    var angle = Math.asin(clamp8((y - center[1]) / (radius + point.labelDistance), -1, 1));
    var x = center[0] + (left ? -1 : 1) * (Math.cos(angle) * (radius + point.labelDistance)) + (point.labelDistance > 0 ? (left ? -1 : 1) * this.options.dataLabels.padding : 0);
    return x;
  };
  PieSeries5.prototype.hasData = function() {
    return !!this.processedXData.length;
  };
  PieSeries5.prototype.redrawPoints = function() {
    var series = this, chart = series.chart, renderer = chart.renderer, shadow = series.options.shadow;
    var groupTranslation, graphic, pointAttr, shapeArgs;
    this.drawEmpty();
    if (shadow && !series.shadowGroup && !chart.styledMode) {
      series.shadowGroup = renderer.g("shadow").attr({ zIndex: -1 }).add(series.group);
    }
    series.points.forEach(function(point) {
      var animateTo = {};
      graphic = point.graphic;
      if (!point.isNull && graphic) {
        var shadowGroup = void 0;
        shapeArgs = point.shapeArgs;
        groupTranslation = point.getTranslate();
        if (!chart.styledMode) {
          shadowGroup = point.shadowGroup;
          if (shadow && !shadowGroup) {
            shadowGroup = point.shadowGroup = renderer.g("shadow").add(series.shadowGroup);
          }
          if (shadowGroup) {
            shadowGroup.attr(groupTranslation);
          }
          pointAttr = series.pointAttribs(point, point.selected && "select");
        }
        if (!point.delayedRendering) {
          graphic.setRadialReference(series.center);
          if (!chart.styledMode) {
            merge29(true, animateTo, pointAttr);
          }
          merge29(true, animateTo, shapeArgs, groupTranslation);
          graphic.animate(animateTo);
        } else {
          graphic.setRadialReference(series.center).attr(shapeArgs).attr(groupTranslation);
          if (!chart.styledMode) {
            graphic.attr(pointAttr).attr({ "stroke-linejoin": "round" }).shadow(shadow, shadowGroup);
          }
          point.delayedRendering = false;
        }
        graphic.attr({
          visibility: point.visible ? "inherit" : "hidden"
        });
        graphic.addClass(point.getClassName(), true);
      } else if (graphic) {
        point.graphic = graphic.destroy();
      }
    });
  };
  PieSeries5.prototype.sortByAngle = function(points, sign) {
    points.sort(function(a, b) {
      return typeof a.angle !== "undefined" && (b.angle - a.angle) * sign;
    });
  };
  PieSeries5.prototype.translate = function(positions) {
    this.generatePoints();
    var series = this, precision = 1e3, options = series.options, slicedOffset = options.slicedOffset, connectorOffset = slicedOffset + (options.borderWidth || 0), radians = getStartAndEndRadians(options.startAngle, options.endAngle), startAngleRad = series.startAngleRad = radians.start, endAngleRad = series.endAngleRad = radians.end, circ = endAngleRad - startAngleRad, points = series.points, labelDistance = options.dataLabels.distance, ignoreHiddenPoint = options.ignoreHiddenPoint, len = points.length;
    var finalConnectorOffset, start, end, angle, radiusX, radiusY, i, point, cumulative = 0;
    if (!positions) {
      series.center = positions = series.getCenter();
    }
    for (i = 0; i < len; i++) {
      point = points[i];
      start = startAngleRad + cumulative * circ;
      if (point.isValid() && (!ignoreHiddenPoint || point.visible)) {
        cumulative += point.percentage / 100;
      }
      end = startAngleRad + cumulative * circ;
      var shapeArgs = {
        x: positions[0],
        y: positions[1],
        r: positions[2] / 2,
        innerR: positions[3] / 2,
        start: Math.round(start * precision) / precision,
        end: Math.round(end * precision) / precision
      };
      point.shapeType = "arc";
      point.shapeArgs = shapeArgs;
      point.labelDistance = pick33(point.options.dataLabels && point.options.dataLabels.distance, labelDistance);
      point.labelDistance = relativeLength7(point.labelDistance, shapeArgs.r);
      series.maxLabelDistance = Math.max(series.maxLabelDistance || 0, point.labelDistance);
      angle = (end + start) / 2;
      if (angle > 1.5 * Math.PI) {
        angle -= 2 * Math.PI;
      } else if (angle < -Math.PI / 2) {
        angle += 2 * Math.PI;
      }
      point.slicedTranslation = {
        translateX: Math.round(Math.cos(angle) * slicedOffset),
        translateY: Math.round(Math.sin(angle) * slicedOffset)
      };
      radiusX = Math.cos(angle) * positions[2] / 2;
      radiusY = Math.sin(angle) * positions[2] / 2;
      point.tooltipPos = [
        positions[0] + radiusX * 0.7,
        positions[1] + radiusY * 0.7
      ];
      point.half = angle < -Math.PI / 2 || angle > Math.PI / 2 ? 1 : 0;
      point.angle = angle;
      finalConnectorOffset = Math.min(connectorOffset, point.labelDistance / 5);
      point.labelPosition = {
        natural: {
          x: positions[0] + radiusX + Math.cos(angle) * point.labelDistance,
          y: positions[1] + radiusY + Math.sin(angle) * point.labelDistance
        },
        "final": {},
        alignment: point.labelDistance < 0 ? "center" : point.half ? "right" : "left",
        connectorPosition: {
          breakAt: {
            x: positions[0] + radiusX + Math.cos(angle) * finalConnectorOffset,
            y: positions[1] + radiusY + Math.sin(angle) * finalConnectorOffset
          },
          touchingSliceAt: {
            x: positions[0] + radiusX,
            y: positions[1] + radiusY
          }
        }
      };
    }
    fireEvent15(series, "afterTranslate");
  };
  PieSeries5.prototype.updateTotals = function() {
    var points = this.points, len = points.length, ignoreHiddenPoint = this.options.ignoreHiddenPoint;
    var i, point, total = 0;
    for (i = 0; i < len; i++) {
      point = points[i];
      if (point.isValid() && (!ignoreHiddenPoint || point.visible)) {
        total += point.y;
      }
    }
    this.total = total;
    for (i = 0; i < len; i++) {
      point = points[i];
      point.percentage = total > 0 && (point.visible || !ignoreHiddenPoint) ? point.y / total * 100 : 0;
      point.total = total;
    }
  };
  PieSeries5.defaultOptions = merge29(Series_default.defaultOptions, {
    center: [null, null],
    clip: false,
    colorByPoint: true,
    dataLabels: {
      allowOverlap: true,
      connectorPadding: 5,
      connectorShape: "fixedOffset",
      crookDistance: "70%",
      distance: 30,
      enabled: true,
      formatter: function() {
        return this.point.isNull ? void 0 : this.point.name;
      },
      softConnector: true,
      x: 0
    },
    fillColor: void 0,
    ignoreHiddenPoint: true,
    inactiveOtherPoints: true,
    legendType: "point",
    marker: null,
    size: null,
    showInLegend: false,
    slicedOffset: 10,
    stickyTracking: false,
    tooltip: {
      followPointer: true
    },
    borderColor: Palette_default.backgroundColor,
    borderWidth: 1,
    lineWidth: void 0,
    states: {
      hover: {
        brightness: 0.1
      }
    }
  });
  return PieSeries5;
}(Series_default);
extend23(PieSeries.prototype, {
  axisTypes: [],
  directTouch: true,
  drawGraph: void 0,
  drawLegendSymbol: LegendSymbol_default.drawRectangle,
  drawTracker: ColumnSeries_default.prototype.drawTracker,
  getCenter: CenteredSeries_default.getCenter,
  getSymbol: noop6,
  isCartesian: false,
  noSharedTooltip: true,
  pointAttribs: ColumnSeries_default.prototype.pointAttribs,
  pointClass: PiePoint_default,
  requireSorting: false,
  searchPoint: noop6,
  trackerGroups: ["group", "dataLabelsGroup"]
});
SeriesRegistry_default.registerSeriesType("pie", PieSeries);
var PieSeries_default = PieSeries;

// node_modules/highcharts/es-modules/Series/Pie/PieDataLabel.js
var noop7 = Globals_default.noop;
var distribute3 = RendererUtilities_default.distribute;
var Series3 = SeriesRegistry_default.series;
var arrayMax5 = Utilities_default.arrayMax;
var clamp9 = Utilities_default.clamp;
var defined23 = Utilities_default.defined;
var merge30 = Utilities_default.merge;
var pick34 = Utilities_default.pick;
var relativeLength8 = Utilities_default.relativeLength;
var ColumnDataLabel2;
(function(ColumnDataLabel3) {
  var composedClasses2 = [];
  var dataLabelPositioners = {
    radialDistributionY: function(point) {
      return point.top + point.distributeBox.pos;
    },
    radialDistributionX: function(series, point, y, naturalY) {
      return series.getX(y < point.top + 2 || y > point.bottom - 2 ? naturalY : y, point.half, point);
    },
    justify: function(point, radius, seriesCenter) {
      return seriesCenter[0] + (point.half ? -1 : 1) * (radius + point.labelDistance);
    },
    alignToPlotEdges: function(dataLabel, half, plotWidth, plotLeft) {
      var dataLabelWidth = dataLabel.getBBox().width;
      return half ? dataLabelWidth + plotLeft : plotWidth - dataLabelWidth - plotLeft;
    },
    alignToConnectors: function(points, half, plotWidth, plotLeft) {
      var maxDataLabelWidth = 0, dataLabelWidth;
      points.forEach(function(point) {
        dataLabelWidth = point.dataLabel.getBBox().width;
        if (dataLabelWidth > maxDataLabelWidth) {
          maxDataLabelWidth = dataLabelWidth;
        }
      });
      return half ? maxDataLabelWidth + plotLeft : plotWidth - maxDataLabelWidth - plotLeft;
    }
  };
  function compose(PieSeriesClass) {
    DataLabel_default.compose(Series3);
    if (composedClasses2.indexOf(PieSeriesClass) === -1) {
      composedClasses2.push(PieSeriesClass);
      var pieProto2 = PieSeriesClass.prototype;
      pieProto2.dataLabelPositioners = dataLabelPositioners;
      pieProto2.alignDataLabel = noop7;
      pieProto2.drawDataLabels = drawDataLabels;
      pieProto2.placeDataLabels = placeDataLabels;
      pieProto2.verifyDataLabelOverflow = verifyDataLabelOverflow;
    }
  }
  ColumnDataLabel3.compose = compose;
  function drawDataLabels() {
    var series = this, data = series.data, chart = series.chart, options = series.options.dataLabels || {}, connectorPadding = options.connectorPadding, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, plotLeft = chart.plotLeft, maxWidth = Math.round(chart.chartWidth / 3), seriesCenter = series.center, radius = seriesCenter[2] / 2, centerY = seriesCenter[1], halves = [
      [],
      []
    ], overflow = [0, 0, 0, 0], dataLabelPositioners2 = series.dataLabelPositioners;
    var point, connectorWidth, connector, dataLabel, dataLabelWidth, labelPosition, labelHeight, x, y, visibility, j, pointDataLabelsOptions;
    if (!series.visible || !options.enabled && !series._hasPointLabels) {
      return;
    }
    data.forEach(function(point2) {
      if (point2.dataLabel && point2.visible && point2.dataLabel.shortened) {
        point2.dataLabel.attr({
          width: "auto"
        }).css({
          width: "auto",
          textOverflow: "clip"
        });
        point2.dataLabel.shortened = false;
      }
    });
    Series3.prototype.drawDataLabels.apply(series);
    data.forEach(function(point2) {
      if (point2.dataLabel) {
        if (point2.visible) {
          halves[point2.half].push(point2);
          point2.dataLabel._pos = null;
          if (!defined23(options.style.width) && !defined23(point2.options.dataLabels && point2.options.dataLabels.style && point2.options.dataLabels.style.width)) {
            if (point2.dataLabel.getBBox().width > maxWidth) {
              point2.dataLabel.css({
                width: Math.round(maxWidth * 0.7) + "px"
              });
              point2.dataLabel.shortened = true;
            }
          }
        } else {
          point2.dataLabel = point2.dataLabel.destroy();
          if (point2.dataLabels && point2.dataLabels.length === 1) {
            delete point2.dataLabels;
          }
        }
      }
    });
    halves.forEach(function(points, i) {
      var length = points.length, positions = [];
      var top, bottom, naturalY, sideOverflow, size, distributionLength;
      if (!length) {
        return;
      }
      series.sortByAngle(points, i - 0.5);
      if (series.maxLabelDistance > 0) {
        top = Math.max(0, centerY - radius - series.maxLabelDistance);
        bottom = Math.min(centerY + radius + series.maxLabelDistance, chart.plotHeight);
        points.forEach(function(point2) {
          if (point2.labelDistance > 0 && point2.dataLabel) {
            point2.top = Math.max(0, centerY - radius - point2.labelDistance);
            point2.bottom = Math.min(centerY + radius + point2.labelDistance, chart.plotHeight);
            size = point2.dataLabel.getBBox().height || 21;
            point2.distributeBox = {
              target: point2.labelPosition.natural.y - point2.top + size / 2,
              size,
              rank: point2.y
            };
            positions.push(point2.distributeBox);
          }
        });
        distributionLength = bottom + size - top;
        distribute3(positions, distributionLength, distributionLength / 5);
      }
      for (j = 0; j < length; j++) {
        point = points[j];
        labelPosition = point.labelPosition;
        dataLabel = point.dataLabel;
        visibility = point.visible === false ? "hidden" : "inherit";
        naturalY = labelPosition.natural.y;
        y = naturalY;
        if (positions && defined23(point.distributeBox)) {
          if (typeof point.distributeBox.pos === "undefined") {
            visibility = "hidden";
          } else {
            labelHeight = point.distributeBox.size;
            y = dataLabelPositioners2.radialDistributionY(point);
          }
        }
        delete point.positionIndex;
        if (options.justify) {
          x = dataLabelPositioners2.justify(point, radius, seriesCenter);
        } else {
          switch (options.alignTo) {
            case "connectors":
              x = dataLabelPositioners2.alignToConnectors(points, i, plotWidth, plotLeft);
              break;
            case "plotEdges":
              x = dataLabelPositioners2.alignToPlotEdges(dataLabel, i, plotWidth, plotLeft);
              break;
            default:
              x = dataLabelPositioners2.radialDistributionX(series, point, y, naturalY);
          }
        }
        dataLabel._attr = {
          visibility,
          align: labelPosition.alignment
        };
        pointDataLabelsOptions = point.options.dataLabels || {};
        dataLabel._pos = {
          x: x + pick34(pointDataLabelsOptions.x, options.x) + ({
            left: connectorPadding,
            right: -connectorPadding
          }[labelPosition.alignment] || 0),
          y: y + pick34(pointDataLabelsOptions.y, options.y) - 10
        };
        labelPosition.final.x = x;
        labelPosition.final.y = y;
        if (pick34(options.crop, true)) {
          dataLabelWidth = dataLabel.getBBox().width;
          sideOverflow = null;
          if (x - dataLabelWidth < connectorPadding && i === 1) {
            sideOverflow = Math.round(dataLabelWidth - x + connectorPadding);
            overflow[3] = Math.max(sideOverflow, overflow[3]);
          } else if (x + dataLabelWidth > plotWidth - connectorPadding && i === 0) {
            sideOverflow = Math.round(x + dataLabelWidth - plotWidth + connectorPadding);
            overflow[1] = Math.max(sideOverflow, overflow[1]);
          }
          if (y - labelHeight / 2 < 0) {
            overflow[0] = Math.max(Math.round(-y + labelHeight / 2), overflow[0]);
          } else if (y + labelHeight / 2 > plotHeight) {
            overflow[2] = Math.max(Math.round(y + labelHeight / 2 - plotHeight), overflow[2]);
          }
          dataLabel.sideOverflow = sideOverflow;
        }
      }
    });
    if (arrayMax5(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {
      this.placeDataLabels();
      this.points.forEach(function(point2) {
        pointDataLabelsOptions = merge30(options, point2.options.dataLabels);
        connectorWidth = pick34(pointDataLabelsOptions.connectorWidth, 1);
        if (connectorWidth) {
          var isNew = void 0;
          connector = point2.connector;
          dataLabel = point2.dataLabel;
          if (dataLabel && dataLabel._pos && point2.visible && point2.labelDistance > 0) {
            visibility = dataLabel._attr.visibility;
            isNew = !connector;
            if (isNew) {
              point2.connector = connector = chart.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + point2.colorIndex + (point2.className ? " " + point2.className : "")).add(series.dataLabelsGroup);
              if (!chart.styledMode) {
                connector.attr({
                  "stroke-width": connectorWidth,
                  "stroke": pointDataLabelsOptions.connectorColor || point2.color || Palette_default.neutralColor60
                });
              }
            }
            connector[isNew ? "attr" : "animate"]({
              d: point2.getConnectorPath()
            });
            connector.attr("visibility", visibility);
          } else if (connector) {
            point2.connector = connector.destroy();
          }
        }
      });
    }
  }
  function placeDataLabels() {
    this.points.forEach(function(point) {
      var dataLabel = point.dataLabel, _pos;
      if (dataLabel && point.visible) {
        _pos = dataLabel._pos;
        if (_pos) {
          if (dataLabel.sideOverflow) {
            dataLabel._attr.width = Math.max(dataLabel.getBBox().width - dataLabel.sideOverflow, 0);
            dataLabel.css({
              width: dataLabel._attr.width + "px",
              textOverflow: (this.options.dataLabels.style || {}).textOverflow || "ellipsis"
            });
            dataLabel.shortened = true;
          }
          dataLabel.attr(dataLabel._attr);
          dataLabel[dataLabel.moved ? "animate" : "attr"](_pos);
          dataLabel.moved = true;
        } else if (dataLabel) {
          dataLabel.attr({ y: -9999 });
        }
      }
      delete point.distributeBox;
    }, this);
  }
  function verifyDataLabelOverflow(overflow) {
    var center = this.center, options = this.options, centerOption = options.center, minSize = options.minSize || 80, newSize = minSize, ret = options.size !== null;
    if (!ret) {
      if (centerOption[0] !== null) {
        newSize = Math.max(center[2] - Math.max(overflow[1], overflow[3]), minSize);
      } else {
        newSize = Math.max(center[2] - overflow[1] - overflow[3], minSize);
        center[0] += (overflow[3] - overflow[1]) / 2;
      }
      if (centerOption[1] !== null) {
        newSize = clamp9(newSize, minSize, center[2] - Math.max(overflow[0], overflow[2]));
      } else {
        newSize = clamp9(newSize, minSize, center[2] - overflow[0] - overflow[2]);
        center[1] += (overflow[0] - overflow[2]) / 2;
      }
      if (newSize < center[2]) {
        center[2] = newSize;
        center[3] = Math.min(relativeLength8(options.innerSize || 0, newSize), newSize);
        this.translate(center);
        if (this.drawDataLabels) {
          this.drawDataLabels();
        }
      } else {
        ret = true;
      }
    }
    return ret;
  }
})(ColumnDataLabel2 || (ColumnDataLabel2 = {}));
var PieDataLabel_default = ColumnDataLabel2;

// node_modules/highcharts/es-modules/Extensions/OverlappingDataLabels.js
var addEvent18 = Utilities_default.addEvent;
var fireEvent16 = Utilities_default.fireEvent;
var isArray13 = Utilities_default.isArray;
var isNumber24 = Utilities_default.isNumber;
var objectEach22 = Utilities_default.objectEach;
var pick35 = Utilities_default.pick;
addEvent18(Chart_default, "render", function collectAndHide() {
  var chart = this, labels = [];
  (this.labelCollectors || []).forEach(function(collector) {
    labels = labels.concat(collector());
  });
  (this.yAxis || []).forEach(function(yAxis) {
    if (yAxis.stacking && yAxis.options.stackLabels && !yAxis.options.stackLabels.allowOverlap) {
      objectEach22(yAxis.stacking.stacks, function(stack) {
        objectEach22(stack, function(stackItem) {
          if (stackItem.label && stackItem.label.visibility !== "hidden") {
            labels.push(stackItem.label);
          }
        });
      });
    }
  });
  (this.series || []).forEach(function(series) {
    var dlOptions = series.options.dataLabels;
    if (series.visible && !(dlOptions.enabled === false && !series._hasPointLabels)) {
      var push = function(points) {
        return points.forEach(function(point) {
          if (point.visible) {
            var dataLabels = isArray13(point.dataLabels) ? point.dataLabels : point.dataLabel ? [point.dataLabel] : [];
            dataLabels.forEach(function(label) {
              var options = label.options;
              label.labelrank = pick35(options.labelrank, point.labelrank, point.shapeArgs && point.shapeArgs.height);
              if (!options.allowOverlap) {
                labels.push(label);
              } else {
                label.oldOpacity = label.opacity;
                label.newOpacity = 1;
                hideOrShow(label, chart);
              }
            });
          }
        });
      };
      push(series.nodes || []);
      push(series.points);
    }
  });
  this.hideOverlappingLabels(labels);
});
Chart_default.prototype.hideOverlappingLabels = function(labels) {
  var chart = this, len = labels.length, ren = chart.renderer, label, i, j, label1, label2, box1, box2, isLabelAffected = false, isIntersectRect = function(box12, box22) {
    return !(box22.x >= box12.x + box12.width || box22.x + box22.width <= box12.x || box22.y >= box12.y + box12.height || box22.y + box22.height <= box12.y);
  }, getAbsoluteBox = function(label3) {
    var pos, parent, bBox, padding = label3.box ? 0 : label3.padding || 0, lineHeightCorrection = 0, xOffset = 0, boxWidth, alignValue;
    if (label3 && (!label3.alignAttr || label3.placed)) {
      pos = label3.alignAttr || {
        x: label3.attr("x"),
        y: label3.attr("y")
      };
      parent = label3.parentGroup;
      if (!label3.width) {
        bBox = label3.getBBox();
        label3.width = bBox.width;
        label3.height = bBox.height;
        lineHeightCorrection = ren.fontMetrics(null, label3.element).h;
      }
      boxWidth = label3.width - 2 * padding;
      alignValue = {
        left: "0",
        center: "0.5",
        right: "1"
      }[label3.alignValue];
      if (alignValue) {
        xOffset = +alignValue * boxWidth;
      } else if (isNumber24(label3.x) && Math.round(label3.x) !== label3.translateX) {
        xOffset = label3.x - label3.translateX;
      }
      return {
        x: pos.x + (parent.translateX || 0) + padding - (xOffset || 0),
        y: pos.y + (parent.translateY || 0) + padding - lineHeightCorrection,
        width: label3.width - 2 * padding,
        height: label3.height - 2 * padding
      };
    }
  };
  for (i = 0; i < len; i++) {
    label = labels[i];
    if (label) {
      label.oldOpacity = label.opacity;
      label.newOpacity = 1;
      label.absoluteBox = getAbsoluteBox(label);
    }
  }
  labels.sort(function(a, b) {
    return (b.labelrank || 0) - (a.labelrank || 0);
  });
  for (i = 0; i < len; i++) {
    label1 = labels[i];
    box1 = label1 && label1.absoluteBox;
    for (j = i + 1; j < len; ++j) {
      label2 = labels[j];
      box2 = label2 && label2.absoluteBox;
      if (box1 && box2 && label1 !== label2 && label1.newOpacity !== 0 && label2.newOpacity !== 0) {
        if (isIntersectRect(box1, box2)) {
          (label1.labelrank < label2.labelrank ? label1 : label2).newOpacity = 0;
        }
      }
    }
  }
  labels.forEach(function(label3) {
    if (hideOrShow(label3, chart)) {
      isLabelAffected = true;
    }
  });
  if (isLabelAffected) {
    fireEvent16(chart, "afterHideAllOverlappingLabels");
  }
};
function hideOrShow(label, chart) {
  var complete, newOpacity, isLabelAffected = false;
  if (label) {
    newOpacity = label.newOpacity;
    if (label.oldOpacity !== newOpacity) {
      if (label.alignAttr && label.placed) {
        label[newOpacity ? "removeClass" : "addClass"]("highcharts-data-label-hidden");
        complete = function() {
          if (!chart.styledMode) {
            label.css({ pointerEvents: newOpacity ? "auto" : "none" });
          }
        };
        isLabelAffected = true;
        label.alignAttr.opacity = newOpacity;
        label[label.isOld ? "animate" : "attr"](label.alignAttr, null, complete);
        fireEvent16(chart, "afterHideOverlappingLabel");
      } else {
        label.attr({
          opacity: newOpacity
        });
      }
    }
    label.isOld = true;
  }
  return isLabelAffected;
}

// node_modules/highcharts/es-modules/Core/Responsive.js
var extend24 = Utilities_default.extend;
var find6 = Utilities_default.find;
var isArray14 = Utilities_default.isArray;
var isObject8 = Utilities_default.isObject;
var merge31 = Utilities_default.merge;
var objectEach23 = Utilities_default.objectEach;
var pick36 = Utilities_default.pick;
var splat10 = Utilities_default.splat;
var uniqueKey6 = Utilities_default.uniqueKey;
var Responsive;
(function(Responsive2) {
  var composedClasses2 = [];
  function compose(ChartClass) {
    if (composedClasses2.indexOf(ChartClass) === -1) {
      composedClasses2.push(ChartClass);
      extend24(ChartClass.prototype, Additions.prototype);
    }
    return ChartClass;
  }
  Responsive2.compose = compose;
  var Additions = function() {
    function Additions2() {
    }
    Additions2.prototype.currentOptions = function(options) {
      var chart = this, ret = {};
      function getCurrent(options2, curr, ret2, depth) {
        var i;
        objectEach23(options2, function(val, key) {
          if (!depth && chart.collectionsWithUpdate.indexOf(key) > -1 && curr[key]) {
            val = splat10(val);
            ret2[key] = [];
            for (i = 0; i < Math.max(val.length, curr[key].length); i++) {
              if (curr[key][i]) {
                if (val[i] === void 0) {
                  ret2[key][i] = curr[key][i];
                } else {
                  ret2[key][i] = {};
                  getCurrent(val[i], curr[key][i], ret2[key][i], depth + 1);
                }
              }
            }
          } else if (isObject8(val)) {
            ret2[key] = isArray14(val) ? [] : {};
            getCurrent(val, curr[key] || {}, ret2[key], depth + 1);
          } else if (typeof curr[key] === "undefined") {
            ret2[key] = null;
          } else {
            ret2[key] = curr[key];
          }
        });
      }
      getCurrent(options, this.options, ret, 0);
      return ret;
    };
    Additions2.prototype.matchResponsiveRule = function(rule, matches) {
      var condition = rule.condition, fn = condition.callback || function() {
        return this.chartWidth <= pick36(condition.maxWidth, Number.MAX_VALUE) && this.chartHeight <= pick36(condition.maxHeight, Number.MAX_VALUE) && this.chartWidth >= pick36(condition.minWidth, 0) && this.chartHeight >= pick36(condition.minHeight, 0);
      };
      if (fn.call(this)) {
        matches.push(rule._id);
      }
    };
    Additions2.prototype.setResponsive = function(redraw, reset) {
      var _this = this;
      var options = this.options.responsive, currentResponsive = this.currentResponsive;
      var ruleIds = [], undoOptions;
      if (!reset && options && options.rules) {
        options.rules.forEach(function(rule) {
          if (typeof rule._id === "undefined") {
            rule._id = uniqueKey6();
          }
          _this.matchResponsiveRule(rule, ruleIds);
        }, this);
      }
      var mergedOptions = merge31.apply(void 0, ruleIds.map(function(ruleId) {
        return find6((options || {}).rules || [], function(rule) {
          return rule._id === ruleId;
        });
      }).map(function(rule) {
        return rule && rule.chartOptions;
      }));
      mergedOptions.isResponsiveOptions = true;
      ruleIds = ruleIds.toString() || void 0;
      var currentRuleIds = currentResponsive && currentResponsive.ruleIds;
      if (ruleIds !== currentRuleIds) {
        if (currentResponsive) {
          this.update(currentResponsive.undoOptions, redraw, true);
        }
        if (ruleIds) {
          undoOptions = this.currentOptions(mergedOptions);
          undoOptions.isResponsiveOptions = true;
          this.currentResponsive = {
            ruleIds,
            mergedOptions,
            undoOptions
          };
          this.update(mergedOptions, redraw, true);
        } else {
          this.currentResponsive = void 0;
        }
      }
    };
    return Additions2;
  }();
})(Responsive || (Responsive = {}));
var Responsive_default = Responsive;

// node_modules/highcharts/es-modules/masters/highcharts.src.js
var G = Globals_default;
G.animate = AnimationUtilities_default.animate;
G.animObject = AnimationUtilities_default.animObject;
G.getDeferredAnimation = AnimationUtilities_default.getDeferredAnimation;
G.setAnimation = AnimationUtilities_default.setAnimation;
G.stop = AnimationUtilities_default.stop;
G.timers = Fx_default.timers;
G.AST = AST_default;
G.Axis = Axis_default;
G.Chart = Chart_default;
G.chart = Chart_default.chart;
G.Fx = Fx_default;
G.Legend = Legend_default;
G.PlotLineOrBand = PlotLineOrBand_default;
G.Point = Point_default;
G.Pointer = MSPointer_default.isRequired() ? MSPointer_default : Pointer_default;
G.Series = Series_default;
G.SVGElement = SVGElement_default;
G.SVGRenderer = SVGRenderer_default;
G.Tick = Tick_default;
G.Time = Time_default;
G.Tooltip = Tooltip_default;
G.Color = Color_default;
G.color = Color_default.parse;
HTMLRenderer_default.compose(SVGRenderer_default);
HTMLElement_default.compose(SVGElement_default);
G.defaultOptions = DefaultOptions_default.defaultOptions;
G.getOptions = DefaultOptions_default.getOptions;
G.time = DefaultOptions_default.defaultTime;
G.setOptions = DefaultOptions_default.setOptions;
G.dateFormat = FormatUtilities_default.dateFormat;
G.format = FormatUtilities_default.format;
G.numberFormat = FormatUtilities_default.numberFormat;
G.addEvent = Utilities_default.addEvent;
G.arrayMax = Utilities_default.arrayMax;
G.arrayMin = Utilities_default.arrayMin;
G.attr = Utilities_default.attr;
G.clearTimeout = Utilities_default.clearTimeout;
G.correctFloat = Utilities_default.correctFloat;
G.createElement = Utilities_default.createElement;
G.css = Utilities_default.css;
G.defined = Utilities_default.defined;
G.destroyObjectProperties = Utilities_default.destroyObjectProperties;
G.discardElement = Utilities_default.discardElement;
G.distribute = RendererUtilities_default.distribute;
G.erase = Utilities_default.erase;
G.error = Utilities_default.error;
G.extend = Utilities_default.extend;
G.extendClass = Utilities_default.extendClass;
G.find = Utilities_default.find;
G.fireEvent = Utilities_default.fireEvent;
G.getMagnitude = Utilities_default.getMagnitude;
G.getStyle = Utilities_default.getStyle;
G.inArray = Utilities_default.inArray;
G.isArray = Utilities_default.isArray;
G.isClass = Utilities_default.isClass;
G.isDOMElement = Utilities_default.isDOMElement;
G.isFunction = Utilities_default.isFunction;
G.isNumber = Utilities_default.isNumber;
G.isObject = Utilities_default.isObject;
G.isString = Utilities_default.isString;
G.keys = Utilities_default.keys;
G.merge = Utilities_default.merge;
G.normalizeTickInterval = Utilities_default.normalizeTickInterval;
G.objectEach = Utilities_default.objectEach;
G.offset = Utilities_default.offset;
G.pad = Utilities_default.pad;
G.pick = Utilities_default.pick;
G.pInt = Utilities_default.pInt;
G.relativeLength = Utilities_default.relativeLength;
G.removeEvent = Utilities_default.removeEvent;
G.seriesType = SeriesRegistry_default.seriesType;
G.splat = Utilities_default.splat;
G.stableSort = Utilities_default.stableSort;
G.syncTimeout = Utilities_default.syncTimeout;
G.timeUnits = Utilities_default.timeUnits;
G.uniqueKey = Utilities_default.uniqueKey;
G.useSerialIds = Utilities_default.useSerialIds;
G.wrap = Utilities_default.wrap;
ColumnDataLabel_default.compose(ColumnSeries_default);
DataLabel_default.compose(Series_default);
DateTimeAxis_default.compose(Axis_default);
LogarithmicAxis_default.compose(Axis_default);
PieDataLabel_default.compose(PieSeries_default);
PlotLineOrBand_default.compose(Axis_default);
Responsive_default.compose(Chart_default);
var highcharts_src_default = G;

// node_modules/highcharts/es-modules/Core/Axis/OrdinalAxis.js
var addEvent19 = Utilities_default.addEvent;
var correctFloat6 = Utilities_default.correctFloat;
var css12 = Utilities_default.css;
var defined24 = Utilities_default.defined;
var error8 = Utilities_default.error;
var pick37 = Utilities_default.pick;
var timeUnits4 = Utilities_default.timeUnits;
var composedClasses = [];
var OrdinalAxis;
(function(OrdinalAxis2) {
  function compose(AxisClass, SeriesClass, ChartClass) {
    if (composedClasses.indexOf(AxisClass) === -1) {
      composedClasses.push(AxisClass);
      var axisProto = AxisClass.prototype;
      axisProto.getTimeTicks = getTimeTicks;
      axisProto.index2val = index2val;
      axisProto.lin2val = lin2val;
      axisProto.val2lin = val2lin;
      axisProto.ordinal2lin = axisProto.val2lin;
      addEvent19(AxisClass, "afterInit", onAxisAfterInit);
      addEvent19(AxisClass, "foundExtremes", onAxisFoundExtremes);
      addEvent19(AxisClass, "afterSetScale", onAxisAfterSetScale);
      addEvent19(AxisClass, "initialAxisTranslation", onAxisInitialAxisTranslation);
    }
    if (composedClasses.indexOf(ChartClass) === -1) {
      composedClasses.push(ChartClass);
      addEvent19(ChartClass, "pan", onChartPan);
    }
    if (composedClasses.indexOf(SeriesClass) === -1) {
      composedClasses.push(SeriesClass);
      addEvent19(SeriesClass, "updatedData", onSeriesUpdatedData);
    }
    return AxisClass;
  }
  OrdinalAxis2.compose = compose;
  function getTimeTicks(normalizedInterval, min, max, startOfWeek, positions, closestDistance, findHigherRanks) {
    if (positions === void 0) {
      positions = [];
    }
    if (closestDistance === void 0) {
      closestDistance = 0;
    }
    var higherRanks = {}, tickPixelIntervalOption = this.options.tickPixelInterval, time = this.chart.time, segmentStarts = [];
    var end, segmentPositions, hasCrossedHigherRank, info, outsideMax, start = 0, groupPositions = [], lastGroupPosition = -Number.MAX_VALUE;
    if (!this.options.ordinal && !this.options.breaks || !positions || positions.length < 3 || typeof min === "undefined") {
      return time.getTimeTicks.apply(time, arguments);
    }
    var posLength = positions.length;
    for (end = 0; end < posLength; end++) {
      outsideMax = end && positions[end - 1] > max;
      if (positions[end] < min) {
        start = end;
      }
      if (end === posLength - 1 || positions[end + 1] - positions[end] > closestDistance * 5 || outsideMax) {
        if (positions[end] > lastGroupPosition) {
          segmentPositions = time.getTimeTicks(normalizedInterval, positions[start], positions[end], startOfWeek);
          while (segmentPositions.length && segmentPositions[0] <= lastGroupPosition) {
            segmentPositions.shift();
          }
          if (segmentPositions.length) {
            lastGroupPosition = segmentPositions[segmentPositions.length - 1];
          }
          segmentStarts.push(groupPositions.length);
          groupPositions = groupPositions.concat(segmentPositions);
        }
        start = end + 1;
      }
      if (outsideMax) {
        break;
      }
    }
    if (segmentPositions) {
      info = segmentPositions.info;
      if (findHigherRanks && info.unitRange <= timeUnits4.hour) {
        end = groupPositions.length - 1;
        for (start = 1; start < end; start++) {
          if (time.dateFormat("%d", groupPositions[start]) !== time.dateFormat("%d", groupPositions[start - 1])) {
            higherRanks[groupPositions[start]] = "day";
            hasCrossedHigherRank = true;
          }
        }
        if (hasCrossedHigherRank) {
          higherRanks[groupPositions[0]] = "day";
        }
        info.higherRanks = higherRanks;
      }
      info.segmentStarts = segmentStarts;
      groupPositions.info = info;
    } else {
      error8(12, false, this.chart);
    }
    if (findHigherRanks && defined24(tickPixelIntervalOption)) {
      var length_1 = groupPositions.length, translatedArr = [], distances = [];
      var itemToRemove = void 0, translated = void 0, lastTranslated = void 0, medianDistance = void 0, distance = void 0, i = length_1;
      while (i--) {
        translated = this.translate(groupPositions[i]);
        if (lastTranslated) {
          distances[i] = lastTranslated - translated;
        }
        translatedArr[i] = lastTranslated = translated;
      }
      distances.sort();
      medianDistance = distances[Math.floor(distances.length / 2)];
      if (medianDistance < tickPixelIntervalOption * 0.6) {
        medianDistance = null;
      }
      i = groupPositions[length_1 - 1] > max ? length_1 - 1 : length_1;
      lastTranslated = void 0;
      while (i--) {
        translated = translatedArr[i];
        distance = Math.abs(lastTranslated - translated);
        if (lastTranslated && distance < tickPixelIntervalOption * 0.8 && (medianDistance === null || distance < medianDistance * 0.8)) {
          if (higherRanks[groupPositions[i]] && !higherRanks[groupPositions[i + 1]]) {
            itemToRemove = i + 1;
            lastTranslated = translated;
          } else {
            itemToRemove = i;
          }
          groupPositions.splice(itemToRemove, 1);
        } else {
          lastTranslated = translated;
        }
      }
    }
    return groupPositions;
  }
  function index2val(index) {
    var axis = this, ordinal = axis.ordinal, ordinalPositions = ordinal.positions;
    if (!ordinalPositions) {
      return index;
    }
    var i = ordinalPositions.length - 1, distance;
    if (index < 0) {
      index = ordinalPositions[0];
    } else if (index > i) {
      index = ordinalPositions[i];
    } else {
      i = Math.floor(index);
      distance = index - i;
    }
    if (typeof distance !== "undefined" && typeof ordinalPositions[i] !== "undefined") {
      return ordinalPositions[i] + (distance ? distance * (ordinalPositions[i + 1] - ordinalPositions[i]) : 0);
    }
    return index;
  }
  function lin2val(val) {
    var axis = this, ordinal = axis.ordinal, localMin = axis.old ? axis.old.min : axis.min, localA = axis.old ? axis.old.transA : axis.transA;
    var positions = ordinal.positions;
    if (!positions) {
      return val;
    }
    var pixelVal = (val - localMin) * localA + axis.minPixelPadding, isInside = pixelVal > 0 && pixelVal < axis.left + axis.len;
    if (!isInside) {
      if (!ordinal.extendedOrdinalPositions) {
        ordinal.extendedOrdinalPositions = ordinal.getExtendedPositions();
      }
      positions = ordinal.extendedOrdinalPositions;
    }
    if (positions && positions.length) {
      var index = ordinal.getIndexOfPoint(pixelVal, positions), mantissa = correctFloat6(index % 1);
      if (index >= 0 && index < positions.length) {
        var leftNeighbour = positions[Math.floor(index)], rightNeighbour = positions[Math.ceil(index)], distance = rightNeighbour - leftNeighbour;
        return positions[Math.floor(index)] + mantissa * distance;
      }
      var positionsLength = positions.length, firstPositionsValue = positions[0], lastPositionsValue = positions[positionsLength - 1], slope = (lastPositionsValue - firstPositionsValue) / (positionsLength - 1);
      if (index < 0) {
        return firstPositionsValue + slope * index;
      }
      return lastPositionsValue + slope * (index - positionsLength);
    }
    return val;
  }
  function getIndexInArray(ordinalPositions, val) {
    var index = OrdinalAxis2.Additions.findIndexOf(ordinalPositions, val, true);
    if (ordinalPositions[index] === val) {
      return index;
    }
    var percent = (val - ordinalPositions[index]) / (ordinalPositions[index + 1] - ordinalPositions[index]);
    return index + percent;
  }
  function onAxisAfterInit() {
    var axis = this;
    if (!axis.ordinal) {
      axis.ordinal = new OrdinalAxis2.Additions(axis);
    }
  }
  function onAxisFoundExtremes() {
    var axis = this;
    if (axis.isXAxis && defined24(axis.options.overscroll) && axis.max === axis.dataMax && (!axis.chart.mouseIsDown || axis.isInternal) && (!axis.eventArgs || axis.eventArgs && axis.eventArgs.trigger !== "navigator")) {
      axis.max += axis.options.overscroll;
      if (!axis.isInternal && defined24(axis.userMin)) {
        axis.min += axis.options.overscroll;
      }
    }
  }
  function onAxisAfterSetScale() {
    var axis = this;
    if (axis.horiz && !axis.isDirty) {
      axis.isDirty = axis.isOrdinal && axis.chart.navigator && !axis.chart.navigator.adaptToUpdatedData;
    }
  }
  function onAxisInitialAxisTranslation() {
    var axis = this;
    if (axis.ordinal) {
      axis.ordinal.beforeSetTickPositions();
      axis.tickInterval = axis.ordinal.postProcessTickInterval(axis.tickInterval);
    }
  }
  function onChartPan(e2) {
    var chart = this, xAxis = chart.xAxis[0], overscroll = xAxis.options.overscroll, chartX = e2.originalEvent.chartX, panning = chart.options.chart.panning;
    var runBase = false;
    if (panning && panning.type !== "y" && xAxis.options.ordinal && xAxis.series.length) {
      var mouseDownX = chart.mouseDownX, extremes = xAxis.getExtremes(), dataMax = extremes.dataMax, min = extremes.min, max = extremes.max, hoverPoints = chart.hoverPoints, closestPointRange = xAxis.closestPointRange || xAxis.ordinal && xAxis.ordinal.overscrollPointsRange, pointPixelWidth = xAxis.translationSlope * (xAxis.ordinal.slope || closestPointRange), movedUnits = (mouseDownX - chartX) / pointPixelWidth, extendedAxis = { ordinal: { positions: xAxis.ordinal.getExtendedPositions() } }, index2val_1 = xAxis.index2val, val2lin_1 = xAxis.val2lin;
      var trimmedRange = void 0, ordinalPositions = void 0, searchAxisLeft = void 0, searchAxisRight = void 0;
      if (!extendedAxis.ordinal.positions) {
        runBase = true;
      } else if (Math.abs(movedUnits) > 1) {
        if (hoverPoints) {
          hoverPoints.forEach(function(point) {
            point.setState();
          });
        }
        if (movedUnits < 0) {
          searchAxisLeft = extendedAxis;
          searchAxisRight = xAxis.ordinal.positions ? xAxis : extendedAxis;
        } else {
          searchAxisLeft = xAxis.ordinal.positions ? xAxis : extendedAxis;
          searchAxisRight = extendedAxis;
        }
        ordinalPositions = searchAxisRight.ordinal.positions;
        if (dataMax > ordinalPositions[ordinalPositions.length - 1]) {
          ordinalPositions.push(dataMax);
        }
        chart.fixedRange = max - min;
        trimmedRange = xAxis.navigatorAxis.toFixedRange(null, null, index2val_1.apply(searchAxisLeft, [
          val2lin_1.apply(searchAxisLeft, [min, true]) + movedUnits
        ]), index2val_1.apply(searchAxisRight, [
          val2lin_1.apply(searchAxisRight, [max, true]) + movedUnits
        ]));
        if (trimmedRange.min >= Math.min(extremes.dataMin, min) && trimmedRange.max <= Math.max(dataMax, max) + overscroll) {
          xAxis.setExtremes(trimmedRange.min, trimmedRange.max, true, false, { trigger: "pan" });
        }
        chart.mouseDownX = chartX;
        css12(chart.container, { cursor: "move" });
      }
    } else {
      runBase = true;
    }
    if (runBase || panning && /y/.test(panning.type)) {
      if (overscroll) {
        xAxis.max = xAxis.dataMax + overscroll;
      }
    } else {
      e2.preventDefault();
    }
  }
  function onSeriesUpdatedData() {
    var xAxis = this.xAxis;
    if (xAxis && xAxis.options.ordinal) {
      delete xAxis.ordinal.index;
      delete xAxis.ordinal.extendedOrdinalPositions;
    }
  }
  function val2lin(val, toIndex) {
    var axis = this, ordinal = axis.ordinal, ordinalPositions = ordinal.positions;
    var slope = ordinal.slope, extendedOrdinalPositions = ordinal.extendedOrdinalPositions;
    if (!ordinalPositions) {
      return val;
    }
    var ordinalLength = ordinalPositions.length;
    var ordinalIndex;
    if (ordinalPositions[0] <= val && ordinalPositions[ordinalLength - 1] >= val) {
      ordinalIndex = getIndexInArray(ordinalPositions, val);
    } else {
      if (!extendedOrdinalPositions) {
        extendedOrdinalPositions = ordinal.getExtendedPositions && ordinal.getExtendedPositions();
        ordinal.extendedOrdinalPositions = extendedOrdinalPositions;
      }
      if (!(extendedOrdinalPositions && extendedOrdinalPositions.length)) {
        return val;
      }
      var length_2 = extendedOrdinalPositions.length;
      if (!slope) {
        slope = (extendedOrdinalPositions[length_2 - 1] - extendedOrdinalPositions[0]) / length_2;
      }
      var originalPositionsReference = getIndexInArray(extendedOrdinalPositions, ordinalPositions[0]);
      if (val >= extendedOrdinalPositions[0] && val <= extendedOrdinalPositions[length_2 - 1]) {
        ordinalIndex = getIndexInArray(extendedOrdinalPositions, val) - originalPositionsReference;
      } else {
        if (val < extendedOrdinalPositions[0]) {
          var diff = extendedOrdinalPositions[0] - val, approximateIndexOffset = diff / slope;
          ordinalIndex = -originalPositionsReference - approximateIndexOffset;
        } else {
          var diff = val - extendedOrdinalPositions[length_2 - 1], approximateIndexOffset = diff / slope;
          ordinalIndex = approximateIndexOffset + length_2 - originalPositionsReference;
        }
      }
    }
    return toIndex ? ordinalIndex : slope * (ordinalIndex || 0) + ordinal.offset;
  }
  var Additions = function() {
    function Additions2(axis) {
      this.index = {};
      this.axis = axis;
    }
    Additions2.prototype.beforeSetTickPositions = function() {
      var axis = this.axis, ordinal = axis.ordinal, extremes = axis.getExtremes(), min = extremes.min, max = extremes.max, hasBreaks = axis.isXAxis && !!axis.options.breaks, isOrdinal = axis.options.ordinal, ignoreHiddenSeries = axis.chart.options.chart.ignoreHiddenSeries;
      var len, uniqueOrdinalPositions, dist, minIndex, maxIndex, slope, i, hasBoostedSeries, ordinalPositions = [], overscrollPointsRange = Number.MAX_VALUE, useOrdinal = false;
      if (isOrdinal || hasBreaks) {
        axis.series.forEach(function(series, i2) {
          uniqueOrdinalPositions = [];
          if ((!ignoreHiddenSeries || series.visible !== false) && (series.takeOrdinalPosition !== false || hasBreaks)) {
            ordinalPositions = ordinalPositions.concat(series.processedXData);
            len = ordinalPositions.length;
            ordinalPositions.sort(function(a, b) {
              return a - b;
            });
            overscrollPointsRange = Math.min(overscrollPointsRange, pick37(series.closestPointRange, overscrollPointsRange));
            if (len) {
              i2 = 0;
              while (i2 < len - 1) {
                if (ordinalPositions[i2] !== ordinalPositions[i2 + 1]) {
                  uniqueOrdinalPositions.push(ordinalPositions[i2 + 1]);
                }
                i2++;
              }
              if (uniqueOrdinalPositions[0] !== ordinalPositions[0]) {
                uniqueOrdinalPositions.unshift(ordinalPositions[0]);
              }
              ordinalPositions = uniqueOrdinalPositions;
            }
          }
          if (series.isSeriesBoosting) {
            hasBoostedSeries = true;
          }
        });
        if (hasBoostedSeries) {
          ordinalPositions.length = 0;
        }
        len = ordinalPositions.length;
        if (len > 2) {
          dist = ordinalPositions[1] - ordinalPositions[0];
          i = len - 1;
          while (i-- && !useOrdinal) {
            if (ordinalPositions[i + 1] - ordinalPositions[i] !== dist) {
              useOrdinal = true;
            }
          }
          if (!axis.options.keepOrdinalPadding && (ordinalPositions[0] - min > dist || max - ordinalPositions[ordinalPositions.length - 1] > dist)) {
            useOrdinal = true;
          }
        } else if (axis.options.overscroll) {
          if (len === 2) {
            overscrollPointsRange = ordinalPositions[1] - ordinalPositions[0];
          } else if (len === 1) {
            overscrollPointsRange = axis.options.overscroll;
            ordinalPositions = [
              ordinalPositions[0],
              ordinalPositions[0] + overscrollPointsRange
            ];
          } else {
            overscrollPointsRange = ordinal.overscrollPointsRange;
          }
        }
        if (useOrdinal || axis.forceOrdinal) {
          if (axis.options.overscroll) {
            ordinal.overscrollPointsRange = overscrollPointsRange;
            ordinalPositions = ordinalPositions.concat(ordinal.getOverscrollPositions());
          }
          ordinal.positions = ordinalPositions;
          minIndex = axis.ordinal2lin(Math.max(min, ordinalPositions[0]), true);
          maxIndex = Math.max(axis.ordinal2lin(Math.min(max, ordinalPositions[ordinalPositions.length - 1]), true), 1);
          ordinal.slope = slope = (max - min) / (maxIndex - minIndex);
          ordinal.offset = min - minIndex * slope;
        } else {
          ordinal.overscrollPointsRange = pick37(axis.closestPointRange, ordinal.overscrollPointsRange);
          ordinal.positions = axis.ordinal.slope = ordinal.offset = void 0;
        }
      }
      axis.isOrdinal = isOrdinal && useOrdinal;
      ordinal.groupIntervalFactor = null;
    };
    Additions2.findIndexOf = function(sortedArray, key, indirectSearch) {
      var start = 0, end = sortedArray.length - 1, middle;
      while (start < end) {
        middle = Math.ceil((start + end) / 2);
        if (sortedArray[middle] <= key) {
          start = middle;
        } else {
          end = middle - 1;
        }
      }
      if (sortedArray[start] === key) {
        return start;
      }
      return !indirectSearch ? -1 : start;
    };
    Additions2.prototype.getExtendedPositions = function() {
      var ordinal = this, axis = ordinal.axis, axisProto = axis.constructor.prototype, chart = axis.chart, grouping = axis.series[0].currentDataGrouping, key = grouping ? grouping.count + grouping.unitName : "raw", overscroll = axis.options.overscroll, extremes = axis.getExtremes();
      var fakeAxis, fakeSeries = void 0, ordinalIndex = ordinal.index;
      if (!ordinalIndex) {
        ordinalIndex = ordinal.index = {};
      }
      if (!ordinalIndex[key]) {
        fakeAxis = {
          series: [],
          chart,
          forceOrdinal: false,
          getExtremes: function() {
            return {
              min: extremes.dataMin,
              max: extremes.dataMax + overscroll
            };
          },
          getGroupPixelWidth: axisProto.getGroupPixelWidth,
          getTimeTicks: axisProto.getTimeTicks,
          options: {
            ordinal: true
          },
          ordinal: {
            getGroupIntervalFactor: this.getGroupIntervalFactor
          },
          ordinal2lin: axisProto.ordinal2lin,
          getIndexOfPoint: axisProto.getIndexOfPoint,
          val2lin: axisProto.val2lin
        };
        fakeAxis.ordinal.axis = fakeAxis;
        axis.series.forEach(function(series) {
          fakeSeries = {
            xAxis: fakeAxis,
            xData: series.xData.slice(),
            chart,
            destroyGroupedData: Globals_default.noop,
            getProcessedData: Series_default.prototype.getProcessedData,
            applyGrouping: Series_default.prototype.applyGrouping
          };
          fakeSeries.xData = fakeSeries.xData.concat(ordinal.getOverscrollPositions());
          fakeSeries.options = {
            dataGrouping: grouping ? {
              firstAnchor: "firstPoint",
              anchor: "middle",
              lastAnchor: "lastPoint",
              enabled: true,
              forced: true,
              approximation: "open",
              units: [[
                grouping.unitName,
                [grouping.count]
              ]]
            } : {
              enabled: false
            }
          };
          fakeAxis.series.push(fakeSeries);
          series.processData.apply(fakeSeries);
        });
        axis.applyGrouping.call(fakeAxis);
        if (fakeSeries.closestPointRange !== fakeSeries.basePointRange && fakeSeries.currentDataGrouping) {
          fakeAxis.forceOrdinal = true;
        }
        axis.ordinal.beforeSetTickPositions.apply({ axis: fakeAxis });
        ordinalIndex[key] = fakeAxis.ordinal.positions;
      }
      return ordinalIndex[key];
    };
    Additions2.prototype.getGroupIntervalFactor = function(xMin, xMax, series) {
      var ordinal = this, axis = ordinal.axis, processedXData = series.processedXData, len = processedXData.length, distances = [];
      var median, i, groupIntervalFactor = ordinal.groupIntervalFactor;
      if (!groupIntervalFactor) {
        for (i = 0; i < len - 1; i++) {
          distances[i] = processedXData[i + 1] - processedXData[i];
        }
        distances.sort(function(a, b) {
          return a - b;
        });
        median = distances[Math.floor(len / 2)];
        xMin = Math.max(xMin, processedXData[0]);
        xMax = Math.min(xMax, processedXData[len - 1]);
        ordinal.groupIntervalFactor = groupIntervalFactor = len * median / (xMax - xMin);
      }
      return groupIntervalFactor;
    };
    Additions2.prototype.getIndexOfPoint = function(val, ordinalArray) {
      var ordinal = this, axis = ordinal.axis, firstPointVal = ordinal.positions ? ordinal.positions[0] : 0;
      var firstPointX = axis.series[0].points && axis.series[0].points[0] && axis.series[0].points[0].plotX || axis.minPixelPadding;
      if (axis.series.length > 1) {
        axis.series.forEach(function(series) {
          if (defined24(series.points[0]) && defined24(series.points[0].plotX) && series.points[0].plotX < firstPointX) {
            firstPointX = series.points[0].plotX;
          }
        });
      }
      var ordinalPointPixelInterval = axis.translationSlope * (ordinal.slope || axis.closestPointRange || ordinal.overscrollPointsRange), shiftIndex = (val - firstPointX) / ordinalPointPixelInterval;
      return Additions2.findIndexOf(ordinalArray, firstPointVal) + shiftIndex;
    };
    Additions2.prototype.getOverscrollPositions = function() {
      var ordinal = this, axis = ordinal.axis, extraRange = axis.options.overscroll, distance = ordinal.overscrollPointsRange, positions = [], max = axis.dataMax;
      if (defined24(distance)) {
        while (max <= axis.dataMax + extraRange) {
          max += distance;
          positions.push(max);
        }
      }
      return positions;
    };
    Additions2.prototype.postProcessTickInterval = function(tickInterval) {
      var ordinal = this, axis = ordinal.axis, ordinalSlope = ordinal.slope;
      var ret;
      if (ordinalSlope) {
        if (!axis.options.breaks) {
          ret = tickInterval / (ordinalSlope / axis.closestPointRange);
        } else {
          ret = axis.closestPointRange || tickInterval;
        }
      } else {
        ret = tickInterval;
      }
      return ret;
    };
    return Additions2;
  }();
  OrdinalAxis2.Additions = Additions;
})(OrdinalAxis || (OrdinalAxis = {}));
var OrdinalAxis_default = OrdinalAxis;

// node_modules/highcharts/es-modules/Core/Axis/BrokenAxis.js
var addEvent20 = Utilities_default.addEvent;
var find7 = Utilities_default.find;
var fireEvent17 = Utilities_default.fireEvent;
var isArray15 = Utilities_default.isArray;
var isNumber25 = Utilities_default.isNumber;
var pick38 = Utilities_default.pick;
var BrokenAxis;
(function(BrokenAxis2) {
  var composedClasses2 = [];
  function compose(AxisClass, SeriesClass) {
    if (composedClasses2.indexOf(AxisClass) === -1) {
      composedClasses2.push(AxisClass);
      AxisClass.keepProps.push("brokenAxis");
      addEvent20(AxisClass, "init", onAxisInit);
      addEvent20(AxisClass, "afterInit", onAxisAfterInit);
      addEvent20(AxisClass, "afterSetTickPositions", onAxisAfterSetTickPositions);
      addEvent20(AxisClass, "afterSetOptions", onAxisAfterSetOptions);
    }
    if (composedClasses2.indexOf(SeriesClass) === -1) {
      composedClasses2.push(SeriesClass);
      var seriesProto5 = SeriesClass.prototype;
      seriesProto5.drawBreaks = seriesDrawBreaks;
      seriesProto5.gappedPath = seriesGappedPath;
      addEvent20(SeriesClass, "afterGeneratePoints", onSeriesAfterGeneratePoints);
      addEvent20(SeriesClass, "afterRender", onSeriesAfterRender);
    }
    return AxisClass;
  }
  BrokenAxis2.compose = compose;
  function onAxisAfterInit() {
    if (typeof this.brokenAxis !== "undefined") {
      this.brokenAxis.setBreaks(this.options.breaks, false);
    }
  }
  function onAxisAfterSetOptions() {
    var axis = this;
    if (axis.brokenAxis && axis.brokenAxis.hasBreaks) {
      axis.options.ordinal = false;
    }
  }
  function onAxisAfterSetTickPositions() {
    var axis = this, brokenAxis = axis.brokenAxis;
    if (brokenAxis && brokenAxis.hasBreaks) {
      var tickPositions = axis.tickPositions, info = axis.tickPositions.info, newPositions = [];
      for (var i = 0; i < tickPositions.length; i++) {
        if (!brokenAxis.isInAnyBreak(tickPositions[i])) {
          newPositions.push(tickPositions[i]);
        }
      }
      axis.tickPositions = newPositions;
      axis.tickPositions.info = info;
    }
  }
  function onAxisInit() {
    var axis = this;
    if (!axis.brokenAxis) {
      axis.brokenAxis = new Additions(axis);
    }
  }
  function onSeriesAfterGeneratePoints() {
    var _a15 = this, isDirty = _a15.isDirty, connectNulls = _a15.options.connectNulls, points = _a15.points, xAxis = _a15.xAxis, yAxis = _a15.yAxis;
    if (isDirty) {
      var i = points.length;
      while (i--) {
        var point = points[i];
        var nullGap = point.y === null && connectNulls === false;
        var isPointInBreak = !nullGap && (xAxis && xAxis.brokenAxis && xAxis.brokenAxis.isInAnyBreak(point.x, true) || yAxis && yAxis.brokenAxis && yAxis.brokenAxis.isInAnyBreak(point.y, true));
        point.visible = isPointInBreak ? false : point.options.visible !== false;
      }
    }
  }
  function onSeriesAfterRender() {
    this.drawBreaks(this.xAxis, ["x"]);
    this.drawBreaks(this.yAxis, pick38(this.pointArrayMap, ["y"]));
  }
  function seriesDrawBreaks(axis, keys2) {
    var series = this, points = series.points;
    var breaks, threshold, eventName, y;
    if (axis && axis.brokenAxis && axis.brokenAxis.hasBreaks) {
      var brokenAxis_1 = axis.brokenAxis;
      keys2.forEach(function(key) {
        breaks = brokenAxis_1 && brokenAxis_1.breakArray || [];
        threshold = axis.isXAxis ? axis.min : pick38(series.options.threshold, axis.min);
        points.forEach(function(point) {
          y = pick38(point["stack" + key.toUpperCase()], point[key]);
          breaks.forEach(function(brk) {
            if (isNumber25(threshold) && isNumber25(y)) {
              eventName = false;
              if (threshold < brk.from && y > brk.to || threshold > brk.from && y < brk.from) {
                eventName = "pointBreak";
              } else if (threshold < brk.from && y > brk.from && y < brk.to || threshold > brk.from && y > brk.to && y < brk.from) {
                eventName = "pointInBreak";
              }
              if (eventName) {
                fireEvent17(axis, eventName, { point, brk });
              }
            }
          });
        });
      });
    }
  }
  function seriesGappedPath() {
    var currentDataGrouping = this.currentDataGrouping, groupingSize = currentDataGrouping && currentDataGrouping.gapSize, points = this.points.slice(), yAxis = this.yAxis;
    var gapSize = this.options.gapSize, i = points.length - 1, stack;
    if (gapSize && i > 0) {
      if (this.options.gapUnit !== "value") {
        gapSize *= this.basePointRange;
      }
      if (groupingSize && groupingSize > gapSize && groupingSize >= this.basePointRange) {
        gapSize = groupingSize;
      }
      var current = void 0, next = void 0;
      while (i--) {
        if (!(next && next.visible !== false)) {
          next = points[i + 1];
        }
        current = points[i];
        if (next.visible === false || current.visible === false) {
          continue;
        }
        if (next.x - current.x > gapSize) {
          var xRange = (current.x + next.x) / 2;
          points.splice(i + 1, 0, {
            isNull: true,
            x: xRange
          });
          if (yAxis.stacking && this.options.stacking) {
            stack = yAxis.stacking.stacks[this.stackKey][xRange] = new Stacking_default(yAxis, yAxis.options.stackLabels, false, xRange, this.stack);
            stack.total = 0;
          }
        }
        next = current;
      }
    }
    return this.getGraphPath(points);
  }
  var Additions = function() {
    function Additions2(axis) {
      this.hasBreaks = false;
      this.axis = axis;
    }
    Additions2.isInBreak = function(brk, val) {
      var repeat = brk.repeat || Infinity, from = brk.from, length = brk.to - brk.from, test = val >= from ? (val - from) % repeat : repeat - (from - val) % repeat;
      var ret;
      if (!brk.inclusive) {
        ret = test < length && test !== 0;
      } else {
        ret = test <= length;
      }
      return ret;
    };
    Additions2.lin2Val = function(val) {
      var axis = this;
      var brokenAxis = axis.brokenAxis;
      var breakArray = brokenAxis && brokenAxis.breakArray;
      if (!breakArray || !isNumber25(val)) {
        return val;
      }
      var nval = val, brk, i;
      for (i = 0; i < breakArray.length; i++) {
        brk = breakArray[i];
        if (brk.from >= nval) {
          break;
        } else if (brk.to < nval) {
          nval += brk.len;
        } else if (Additions2.isInBreak(brk, nval)) {
          nval += brk.len;
        }
      }
      return nval;
    };
    Additions2.val2Lin = function(val) {
      var axis = this;
      var brokenAxis = axis.brokenAxis;
      var breakArray = brokenAxis && brokenAxis.breakArray;
      if (!breakArray || !isNumber25(val)) {
        return val;
      }
      var nval = val, brk, i;
      for (i = 0; i < breakArray.length; i++) {
        brk = breakArray[i];
        if (brk.to <= val) {
          nval -= brk.len;
        } else if (brk.from >= val) {
          break;
        } else if (Additions2.isInBreak(brk, val)) {
          nval -= val - brk.from;
          break;
        }
      }
      return nval;
    };
    Additions2.prototype.findBreakAt = function(x, breaks) {
      return find7(breaks, function(b) {
        return b.from < x && x < b.to;
      });
    };
    Additions2.prototype.isInAnyBreak = function(val, testKeep) {
      var brokenAxis = this, axis = brokenAxis.axis, breaks = axis.options.breaks || [];
      var i = breaks.length, inbrk, keep, ret;
      if (i && isNumber25(val)) {
        while (i--) {
          if (Additions2.isInBreak(breaks[i], val)) {
            inbrk = true;
            if (!keep) {
              keep = pick38(breaks[i].showPoints, !axis.isXAxis);
            }
          }
        }
        if (inbrk && testKeep) {
          ret = inbrk && !keep;
        } else {
          ret = inbrk;
        }
      }
      return ret;
    };
    Additions2.prototype.setBreaks = function(breaks, redraw) {
      var brokenAxis = this;
      var axis = brokenAxis.axis;
      var hasBreaks = isArray15(breaks) && !!breaks.length;
      axis.isDirty = brokenAxis.hasBreaks !== hasBreaks;
      brokenAxis.hasBreaks = hasBreaks;
      axis.options.breaks = axis.userOptions.breaks = breaks;
      axis.forceRedraw = true;
      axis.series.forEach(function(series) {
        series.isDirty = true;
      });
      if (!hasBreaks && axis.val2lin === Additions2.val2Lin) {
        delete axis.val2lin;
        delete axis.lin2val;
      }
      if (hasBreaks) {
        axis.userOptions.ordinal = false;
        axis.lin2val = Additions2.lin2Val;
        axis.val2lin = Additions2.val2Lin;
        axis.setExtremes = function(newMin, newMax, redraw2, animation, eventArguments) {
          if (brokenAxis.hasBreaks) {
            var breaks_1 = this.options.breaks || [];
            var axisBreak = void 0;
            while (axisBreak = brokenAxis.findBreakAt(newMin, breaks_1)) {
              newMin = axisBreak.to;
            }
            while (axisBreak = brokenAxis.findBreakAt(newMax, breaks_1)) {
              newMax = axisBreak.from;
            }
            if (newMax < newMin) {
              newMax = newMin;
            }
          }
          axis.constructor.prototype.setExtremes.call(this, newMin, newMax, redraw2, animation, eventArguments);
        };
        axis.setAxisTranslation = function() {
          axis.constructor.prototype.setAxisTranslation.call(this);
          brokenAxis.unitLength = void 0;
          if (brokenAxis.hasBreaks) {
            var breaks_2 = axis.options.breaks || [], breakArrayT_1 = [], breakArray_1 = [], pointRangePadding = pick38(axis.pointRangePadding, 0);
            var length_1 = 0, inBrk_1, repeat_1, min_1 = axis.userMin || axis.min, max_1 = axis.userMax || axis.max, start_1, i_1;
            breaks_2.forEach(function(brk) {
              repeat_1 = brk.repeat || Infinity;
              if (isNumber25(min_1) && isNumber25(max_1)) {
                if (Additions2.isInBreak(brk, min_1)) {
                  min_1 += brk.to % repeat_1 - min_1 % repeat_1;
                }
                if (Additions2.isInBreak(brk, max_1)) {
                  max_1 -= max_1 % repeat_1 - brk.from % repeat_1;
                }
              }
            });
            breaks_2.forEach(function(brk) {
              start_1 = brk.from;
              repeat_1 = brk.repeat || Infinity;
              if (isNumber25(min_1) && isNumber25(max_1)) {
                while (start_1 - repeat_1 > min_1) {
                  start_1 -= repeat_1;
                }
                while (start_1 < min_1) {
                  start_1 += repeat_1;
                }
                for (i_1 = start_1; i_1 < max_1; i_1 += repeat_1) {
                  breakArrayT_1.push({
                    value: i_1,
                    move: "in"
                  });
                  breakArrayT_1.push({
                    value: i_1 + brk.to - brk.from,
                    move: "out",
                    size: brk.breakSize
                  });
                }
              }
            });
            breakArrayT_1.sort(function(a, b) {
              return a.value === b.value ? (a.move === "in" ? 0 : 1) - (b.move === "in" ? 0 : 1) : a.value - b.value;
            });
            inBrk_1 = 0;
            start_1 = min_1;
            breakArrayT_1.forEach(function(brk) {
              inBrk_1 += brk.move === "in" ? 1 : -1;
              if (inBrk_1 === 1 && brk.move === "in") {
                start_1 = brk.value;
              }
              if (inBrk_1 === 0 && isNumber25(start_1)) {
                breakArray_1.push({
                  from: start_1,
                  to: brk.value,
                  len: brk.value - start_1 - (brk.size || 0)
                });
                length_1 += brk.value - start_1 - (brk.size || 0);
              }
            });
            brokenAxis.breakArray = breakArray_1;
            if (isNumber25(min_1) && isNumber25(max_1) && isNumber25(axis.min)) {
              brokenAxis.unitLength = max_1 - min_1 - length_1 + pointRangePadding;
              fireEvent17(axis, "afterBreaks");
              if (axis.staticScale) {
                axis.transA = axis.staticScale;
              } else if (brokenAxis.unitLength) {
                axis.transA *= (max_1 - axis.min + pointRangePadding) / brokenAxis.unitLength;
              }
              if (pointRangePadding) {
                axis.minPixelPadding = axis.transA * (axis.minPointOffset || 0);
              }
              axis.min = min_1;
              axis.max = max_1;
            }
          }
        };
      }
      if (pick38(redraw, true)) {
        axis.chart.redraw();
      }
    };
    return Additions2;
  }();
  BrokenAxis2.Additions = Additions;
})(BrokenAxis || (BrokenAxis = {}));
var BrokenAxis_default = BrokenAxis;

// node_modules/highcharts/es-modules/masters/modules/broken-axis.src.js
var G2 = Globals_default;
BrokenAxis_default.compose(G2.Axis, G2.Series);

// node_modules/highcharts/es-modules/Extensions/DataGrouping.js
var format7 = FormatUtilities_default.format;
var seriesProto = Series_default.prototype;
var addEvent21 = Utilities_default.addEvent;
var arrayMax6 = Utilities_default.arrayMax;
var arrayMin5 = Utilities_default.arrayMin;
var correctFloat7 = Utilities_default.correctFloat;
var defined25 = Utilities_default.defined;
var error9 = Utilities_default.error;
var extend25 = Utilities_default.extend;
var isNumber26 = Utilities_default.isNumber;
var merge32 = Utilities_default.merge;
var pick39 = Utilities_default.pick;
var approximations = Globals_default.approximations = {
  sum: function(arr) {
    var len = arr.length, ret;
    if (!len && arr.hasNulls) {
      ret = null;
    } else if (len) {
      ret = 0;
      while (len--) {
        ret += arr[len];
      }
    }
    return ret;
  },
  average: function(arr) {
    var len = arr.length, ret = approximations.sum(arr);
    if (isNumber26(ret) && len) {
      ret = correctFloat7(ret / len);
    }
    return ret;
  },
  averages: function() {
    var ret = [];
    [].forEach.call(arguments, function(arr) {
      ret.push(approximations.average(arr));
    });
    return typeof ret[0] === "undefined" ? void 0 : ret;
  },
  open: function(arr) {
    return arr.length ? arr[0] : arr.hasNulls ? null : void 0;
  },
  high: function(arr) {
    return arr.length ? arrayMax6(arr) : arr.hasNulls ? null : void 0;
  },
  low: function(arr) {
    return arr.length ? arrayMin5(arr) : arr.hasNulls ? null : void 0;
  },
  close: function(arr) {
    return arr.length ? arr[arr.length - 1] : arr.hasNulls ? null : void 0;
  },
  ohlc: function(open, high, low, close) {
    open = approximations.open(open);
    high = approximations.high(high);
    low = approximations.low(low);
    close = approximations.close(close);
    if (isNumber26(open) || isNumber26(high) || isNumber26(low) || isNumber26(close)) {
      return [open, high, low, close];
    }
  },
  range: function(low, high) {
    low = approximations.low(low);
    high = approximations.high(high);
    if (isNumber26(low) || isNumber26(high)) {
      return [low, high];
    }
    if (low === null && high === null) {
      return null;
    }
  }
};
var applyGrouping = function() {
  var series = this, chart = series.chart, options = series.options, dataGroupingOptions = options.dataGrouping, groupingEnabled = series.allowDG !== false && dataGroupingOptions && pick39(dataGroupingOptions.enabled, chart.options.isStock), visible = series.visible || !chart.options.chart.ignoreHiddenSeries, hasGroupedData, skip, lastDataGrouping = this.currentDataGrouping, currentDataGrouping, croppedData, revertRequireSorting = false;
  if (groupingEnabled && !series.requireSorting) {
    series.requireSorting = revertRequireSorting = true;
  }
  skip = skipDataGrouping(series) || !groupingEnabled;
  if (revertRequireSorting) {
    series.requireSorting = false;
  }
  if (!skip) {
    series.destroyGroupedData();
    var i = void 0, processedXData = dataGroupingOptions.groupAll ? series.xData : series.processedXData, processedYData = dataGroupingOptions.groupAll ? series.yData : series.processedYData, plotSizeX = chart.plotSizeX, xAxis = series.xAxis, ordinal = xAxis.options.ordinal, groupPixelWidth = series.groupPixelWidth;
    if (groupPixelWidth && processedXData && processedXData.length) {
      hasGroupedData = true;
      series.isDirty = true;
      series.points = null;
      var extremes = xAxis.getExtremes(), xMin = extremes.min, xMax = extremes.max, groupIntervalFactor = ordinal && xAxis.ordinal && xAxis.ordinal.getGroupIntervalFactor(xMin, xMax, series) || 1, interval = groupPixelWidth * (xMax - xMin) / plotSizeX * groupIntervalFactor, groupPositions = xAxis.getTimeTicks(DateTimeAxis_default.Additions.prototype.normalizeTimeTickInterval(interval, dataGroupingOptions.units || defaultDataGroupingUnits), Math.min(xMin, processedXData[0]), Math.max(xMax, processedXData[processedXData.length - 1]), xAxis.options.startOfWeek, processedXData, series.closestPointRange), groupedData = seriesProto.groupData.apply(series, [
        processedXData,
        processedYData,
        groupPositions,
        dataGroupingOptions.approximation
      ]), groupedXData = groupedData.groupedXData, groupedYData = groupedData.groupedYData, gapSize = 0;
      if (dataGroupingOptions && dataGroupingOptions.smoothed && groupedXData.length) {
        dataGroupingOptions.firstAnchor = "firstPoint";
        dataGroupingOptions.anchor = "middle";
        dataGroupingOptions.lastAnchor = "lastPoint";
        error9(32, false, chart, { "dataGrouping.smoothed": "use dataGrouping.anchor" });
      }
      anchorPoints(series, groupedXData, xMax);
      for (i = 1; i < groupPositions.length; i++) {
        if (!groupPositions.info.segmentStarts || groupPositions.info.segmentStarts.indexOf(i) === -1) {
          gapSize = Math.max(groupPositions[i] - groupPositions[i - 1], gapSize);
        }
      }
      currentDataGrouping = groupPositions.info;
      currentDataGrouping.gapSize = gapSize;
      series.closestPointRange = groupPositions.info.totalRange;
      series.groupMap = groupedData.groupMap;
      if (visible) {
        adjustExtremes(xAxis, groupedXData);
      }
      if (dataGroupingOptions.groupAll) {
        series.allGroupedData = groupedYData;
        croppedData = series.cropData(groupedXData, groupedYData, xAxis.min, xAxis.max, 1);
        groupedXData = croppedData.xData;
        groupedYData = croppedData.yData;
        series.cropStart = croppedData.start;
      }
      series.processedXData = groupedXData;
      series.processedYData = groupedYData;
    } else {
      series.groupMap = null;
    }
    series.hasGroupedData = hasGroupedData;
    series.currentDataGrouping = currentDataGrouping;
    series.preventGraphAnimation = (lastDataGrouping && lastDataGrouping.totalRange) !== (currentDataGrouping && currentDataGrouping.totalRange);
  }
};
var skipDataGrouping = function(series) {
  if (series.isCartesian && !series.isDirty && !series.xAxis.isDirty && !series.yAxis.isDirty) {
    return false;
  }
};
var groupData = function(xData, yData, groupPositions, approximation) {
  var series = this, data = series.data, dataOptions = series.options && series.options.data, groupedXData = [], groupedYData = [], groupMap = [], dataLength = xData.length, pointX, pointY, groupedY, handleYData = !!yData, values = [], approximationFn, pointArrayMap = series.pointArrayMap, pointArrayMapLength = pointArrayMap && pointArrayMap.length, extendedPointArrayMap = ["x"].concat(pointArrayMap || ["y"]), groupAll = this.options.dataGrouping && this.options.dataGrouping.groupAll, pos = 0, start = 0, valuesLen, i, j;
  function getApproximation(approx) {
    if (typeof approx === "function") {
      return approx;
    }
    if (approximations[approx]) {
      return approximations[approx];
    }
    return approximations[series.getDGApproximation && series.getDGApproximation() || "average"];
  }
  approximationFn = getApproximation(approximation);
  if (pointArrayMapLength) {
    pointArrayMap.forEach(function() {
      values.push([]);
    });
  } else {
    values.push([]);
  }
  valuesLen = pointArrayMapLength || 1;
  for (i = 0; i <= dataLength; i++) {
    if (xData[i] >= groupPositions[0]) {
      break;
    }
  }
  for (i; i <= dataLength; i++) {
    while (typeof groupPositions[pos + 1] !== "undefined" && xData[i] >= groupPositions[pos + 1] || i === dataLength) {
      pointX = groupPositions[pos];
      series.dataGroupInfo = {
        start: groupAll ? start : series.cropStart + start,
        length: values[0].length
      };
      groupedY = approximationFn.apply(series, values);
      if (series.pointClass && !defined25(series.dataGroupInfo.options)) {
        series.dataGroupInfo.options = merge32(series.pointClass.prototype.optionsToObject.call({ series }, series.options.data[series.cropStart + start]));
        extendedPointArrayMap.forEach(function(key) {
          delete series.dataGroupInfo.options[key];
        });
      }
      if (typeof groupedY !== "undefined") {
        groupedXData.push(pointX);
        groupedYData.push(groupedY);
        groupMap.push(series.dataGroupInfo);
      }
      start = i;
      for (j = 0; j < valuesLen; j++) {
        values[j].length = 0;
        values[j].hasNulls = false;
      }
      pos += 1;
      if (i === dataLength) {
        break;
      }
    }
    if (i === dataLength) {
      break;
    }
    if (pointArrayMap) {
      var index = series.options.dataGrouping && series.options.dataGrouping.groupAll ? i : series.cropStart + i, point = data && data[index] || series.pointClass.prototype.applyOptions.apply({
        series
      }, [dataOptions[index]]), val = void 0;
      for (j = 0; j < pointArrayMapLength; j++) {
        val = point[pointArrayMap[j]];
        if (isNumber26(val)) {
          values[j].push(val);
        } else if (val === null) {
          values[j].hasNulls = true;
        }
      }
    } else {
      pointY = handleYData ? yData[i] : null;
      if (isNumber26(pointY)) {
        values[0].push(pointY);
      } else if (pointY === null) {
        values[0].hasNulls = true;
      }
    }
  }
  return {
    groupedXData,
    groupedYData,
    groupMap
  };
};
var anchorPoints = function(series, groupedXData, xMax) {
  var options = series.options, dataGroupingOptions = options.dataGrouping, totalRange = series.currentDataGrouping && series.currentDataGrouping.gapSize;
  var i;
  if (dataGroupingOptions && series.xData && totalRange && series.groupMap) {
    var groupedDataLength = groupedXData.length - 1, anchor = dataGroupingOptions.anchor, firstAnchor = pick39(dataGroupingOptions.firstAnchor, anchor), lastAnchor = pick39(dataGroupingOptions.lastAnchor, anchor);
    if (anchor && anchor !== "start") {
      var shiftInterval = totalRange * { middle: 0.5, end: 1 }[anchor];
      i = groupedXData.length - 1;
      while (i-- && i > 0) {
        groupedXData[i] += shiftInterval;
      }
    }
    if (firstAnchor && firstAnchor !== "start" && series.xData[0] >= groupedXData[0]) {
      var groupStart = series.groupMap[0].start, groupLength = series.groupMap[0].length;
      var firstGroupstEnd = void 0;
      if (isNumber26(groupStart) && isNumber26(groupLength)) {
        firstGroupstEnd = groupStart + (groupLength - 1);
      }
      groupedXData[0] = {
        middle: groupedXData[0] + 0.5 * totalRange,
        end: groupedXData[0] + totalRange,
        firstPoint: series.xData[0],
        lastPoint: firstGroupstEnd && series.xData[firstGroupstEnd]
      }[firstAnchor];
    }
    if (lastAnchor && lastAnchor !== "start" && totalRange && groupedXData[groupedDataLength] >= xMax - totalRange) {
      var lastGroupStart = series.groupMap[series.groupMap.length - 1].start;
      groupedXData[groupedDataLength] = {
        middle: groupedXData[groupedDataLength] + 0.5 * totalRange,
        end: groupedXData[groupedDataLength] + totalRange,
        firstPoint: lastGroupStart && series.xData[lastGroupStart],
        lastPoint: series.xData[series.xData.length - 1]
      }[lastAnchor];
    }
  }
};
var adjustExtremes = function(xAxis, groupedXData) {
  if (defined25(groupedXData[0]) && isNumber26(xAxis.min) && isNumber26(xAxis.dataMin) && groupedXData[0] < xAxis.min) {
    if (!defined25(xAxis.options.min) && xAxis.min <= xAxis.dataMin || xAxis.min === xAxis.dataMin) {
      xAxis.min = Math.min(groupedXData[0], xAxis.min);
    }
    xAxis.dataMin = Math.min(groupedXData[0], xAxis.dataMin);
  }
  if (defined25(groupedXData[groupedXData.length - 1]) && isNumber26(xAxis.max) && isNumber26(xAxis.dataMax) && groupedXData[groupedXData.length - 1] > xAxis.max) {
    if (!defined25(xAxis.options.max) && isNumber26(xAxis.dataMax) && xAxis.max >= xAxis.dataMax || xAxis.max === xAxis.dataMax) {
      xAxis.max = Math.max(groupedXData[groupedXData.length - 1], xAxis.max);
    }
    xAxis.dataMax = Math.max(groupedXData[groupedXData.length - 1], xAxis.dataMax);
  }
};
var dataGrouping = {
  approximations,
  groupData
};
var baseProcessData = seriesProto.processData;
var baseGeneratePoints = seriesProto.generatePoints;
var commonOptions = {
  groupPixelWidth: 2,
  dateTimeLabelFormats: {
    millisecond: [
      "%A, %b %e, %H:%M:%S.%L",
      "%A, %b %e, %H:%M:%S.%L",
      "-%H:%M:%S.%L"
    ],
    second: [
      "%A, %b %e, %H:%M:%S",
      "%A, %b %e, %H:%M:%S",
      "-%H:%M:%S"
    ],
    minute: [
      "%A, %b %e, %H:%M",
      "%A, %b %e, %H:%M",
      "-%H:%M"
    ],
    hour: [
      "%A, %b %e, %H:%M",
      "%A, %b %e, %H:%M",
      "-%H:%M"
    ],
    day: [
      "%A, %b %e, %Y",
      "%A, %b %e",
      "-%A, %b %e, %Y"
    ],
    week: [
      "Week from %A, %b %e, %Y",
      "%A, %b %e",
      "-%A, %b %e, %Y"
    ],
    month: [
      "%B %Y",
      "%B",
      "-%B %Y"
    ],
    year: [
      "%Y",
      "%Y",
      "-%Y"
    ]
  }
};
var specificOptions = {
  line: {},
  spline: {},
  area: {},
  areaspline: {},
  arearange: {},
  column: {
    groupPixelWidth: 10
  },
  columnrange: {
    groupPixelWidth: 10
  },
  candlestick: {
    groupPixelWidth: 10
  },
  ohlc: {
    groupPixelWidth: 5
  },
  heikinashi: {
    groupPixelWidth: 10
  }
};
var defaultDataGroupingUnits = Globals_default.defaultDataGroupingUnits = [
  [
    "millisecond",
    [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]
  ],
  [
    "second",
    [1, 2, 5, 10, 15, 30]
  ],
  [
    "minute",
    [1, 2, 5, 10, 15, 30]
  ],
  [
    "hour",
    [1, 2, 3, 4, 6, 8, 12]
  ],
  [
    "day",
    [1]
  ],
  [
    "week",
    [1]
  ],
  [
    "month",
    [1, 3, 6]
  ],
  [
    "year",
    null
  ]
];
seriesProto.getDGApproximation = function() {
  if (this.is("arearange")) {
    return "range";
  }
  if (this.is("ohlc")) {
    return "ohlc";
  }
  if (this.is("column")) {
    return "sum";
  }
  return "average";
};
seriesProto.groupData = groupData;
seriesProto.applyGrouping = applyGrouping;
seriesProto.destroyGroupedData = function() {
  if (this.groupedData) {
    this.groupedData.forEach(function(point, i) {
      if (point) {
        this.groupedData[i] = point.destroy ? point.destroy() : null;
      }
    }, this);
    this.groupedData.length = 0;
  }
};
seriesProto.generatePoints = function() {
  baseGeneratePoints.apply(this);
  this.destroyGroupedData();
  this.groupedData = this.hasGroupedData ? this.points : null;
};
Axis_default.prototype.applyGrouping = function() {
  var axis = this, series = axis.series;
  series.forEach(function(series2) {
    series2.groupPixelWidth = void 0;
    series2.groupPixelWidth = axis.getGroupPixelWidth && axis.getGroupPixelWidth();
    if (series2.groupPixelWidth) {
      series2.hasProcessed = true;
    }
    series2.applyGrouping();
  });
};
Axis_default.prototype.getGroupPixelWidth = function() {
  var series = this.series, len = series.length, i, groupPixelWidth = 0, doGrouping = false, dataLength, dgOptions;
  i = len;
  while (i--) {
    dgOptions = series[i].options.dataGrouping;
    if (dgOptions) {
      groupPixelWidth = Math.max(groupPixelWidth, pick39(dgOptions.groupPixelWidth, commonOptions.groupPixelWidth));
    }
  }
  i = len;
  while (i--) {
    dgOptions = series[i].options.dataGrouping;
    if (dgOptions) {
      dataLength = (series[i].processedXData || series[i].data).length;
      if (series[i].groupPixelWidth || dataLength > this.chart.plotSizeX / groupPixelWidth || dataLength && dgOptions.forced) {
        doGrouping = true;
      }
    }
  }
  return doGrouping ? groupPixelWidth : 0;
};
Axis_default.prototype.setDataGrouping = function(dataGrouping2, redraw) {
  var axis = this;
  var i;
  redraw = pick39(redraw, true);
  if (!dataGrouping2) {
    dataGrouping2 = {
      forced: false,
      units: null
    };
  }
  if (this instanceof Axis_default) {
    i = this.series.length;
    while (i--) {
      this.series[i].update({
        dataGrouping: dataGrouping2
      }, false);
    }
  } else {
    this.chart.options.series.forEach(function(seriesOptions) {
      seriesOptions.dataGrouping = dataGrouping2;
    }, false);
  }
  if (axis.ordinal) {
    axis.ordinal.slope = void 0;
  }
  if (redraw) {
    this.chart.redraw();
  }
};
addEvent21(Axis_default, "postProcessData", Axis_default.prototype.applyGrouping);
addEvent21(Point_default, "update", function() {
  if (this.dataGroup) {
    error9(24, false, this.series.chart);
    return false;
  }
});
addEvent21(Tooltip_default, "headerFormatter", function(e2) {
  var tooltip = this, chart = this.chart, time = chart.time, labelConfig = e2.labelConfig, series = labelConfig.series, options = series.options, tooltipOptions = series.tooltipOptions, dataGroupingOptions = options.dataGrouping, xDateFormat = tooltipOptions.xDateFormat, xDateFormatEnd, xAxis = series.xAxis, currentDataGrouping, dateTimeLabelFormats, labelFormats, formattedKey, formatString = tooltipOptions[e2.isFooter ? "footerFormat" : "headerFormat"];
  if (xAxis && xAxis.options.type === "datetime" && dataGroupingOptions && isNumber26(labelConfig.key)) {
    currentDataGrouping = series.currentDataGrouping;
    dateTimeLabelFormats = dataGroupingOptions.dateTimeLabelFormats || commonOptions.dateTimeLabelFormats;
    if (currentDataGrouping) {
      labelFormats = dateTimeLabelFormats[currentDataGrouping.unitName];
      if (currentDataGrouping.count === 1) {
        xDateFormat = labelFormats[0];
      } else {
        xDateFormat = labelFormats[1];
        xDateFormatEnd = labelFormats[2];
      }
    } else if (!xDateFormat && dateTimeLabelFormats && xAxis.dateTime) {
      xDateFormat = xAxis.dateTime.getXDateFormat(labelConfig.x, tooltipOptions.dateTimeLabelFormats);
    }
    formattedKey = time.dateFormat(xDateFormat, labelConfig.key);
    if (xDateFormatEnd) {
      formattedKey += time.dateFormat(xDateFormatEnd, labelConfig.key + currentDataGrouping.totalRange - 1);
    }
    if (series.chart.styledMode) {
      formatString = this.styledModeFormat(formatString);
    }
    e2.text = format7(formatString, {
      point: extend25(labelConfig.point, { key: formattedKey }),
      series
    }, chart);
    e2.preventDefault();
  }
});
addEvent21(Series_default, "destroy", seriesProto.destroyGroupedData);
addEvent21(Series_default, "afterSetOptions", function(e2) {
  var options = e2.options, type = this.type, plotOptions = this.chart.options.plotOptions, defaultOptions17 = DefaultOptions_default.defaultOptions.plotOptions[type].dataGrouping, baseOptions = this.useCommonDataGrouping && commonOptions;
  if (specificOptions[type] || baseOptions) {
    if (!defaultOptions17) {
      defaultOptions17 = merge32(commonOptions, specificOptions[type]);
    }
    var rangeSelector = this.chart.rangeSelector;
    options.dataGrouping = merge32(baseOptions, defaultOptions17, plotOptions.series && plotOptions.series.dataGrouping, plotOptions[type].dataGrouping, this.userOptions.dataGrouping, !options.isInternal && rangeSelector && isNumber26(rangeSelector.selected) && rangeSelector.buttonOptions[rangeSelector.selected].dataGrouping);
  }
});
addEvent21(Axis_default, "afterSetScale", function() {
  this.series.forEach(function(series) {
    series.hasProcessed = false;
  });
});
Globals_default.dataGrouping = dataGrouping;

// node_modules/highcharts/es-modules/Series/OHLC/OHLCPoint.js
var __extends14 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ColumnSeries2 = SeriesRegistry_default.seriesTypes.column;
var OHLCPoint = function(_super) {
  __extends14(OHLCPoint2, _super);
  function OHLCPoint2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.close = void 0;
    _this.high = void 0;
    _this.low = void 0;
    _this.open = void 0;
    _this.options = void 0;
    _this.plotClose = void 0;
    _this.plotOpen = void 0;
    _this.series = void 0;
    return _this;
  }
  OHLCPoint2.prototype.getClassName = function() {
    return _super.prototype.getClassName.call(this) + (this.open < this.close ? " highcharts-point-up" : " highcharts-point-down");
  };
  OHLCPoint2.prototype.resolveUpColor = function() {
    if (this.open < this.close && !this.options.color && this.series.options.upColor) {
      this.color = this.series.options.upColor;
    }
  };
  OHLCPoint2.prototype.resolveColor = function() {
    _super.prototype.resolveColor.call(this);
    this.resolveUpColor();
  };
  OHLCPoint2.prototype.getZone = function() {
    var zone = _super.prototype.getZone.call(this);
    this.resolveUpColor();
    return zone;
  };
  OHLCPoint2.prototype.applyOptions = function() {
    _super.prototype.applyOptions.apply(this, arguments);
    if (this.resolveColor) {
      this.resolveColor();
    }
    return this;
  };
  return OHLCPoint2;
}(ColumnSeries2.prototype.pointClass);
var OHLCPoint_default = OHLCPoint;

// node_modules/highcharts/es-modules/Series/OHLC/OHLCSeries.js
var __extends15 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ColumnSeries3 = SeriesRegistry_default.seriesTypes.column;
var extend26 = Utilities_default.extend;
var merge33 = Utilities_default.merge;
var OHLCSeries = function(_super) {
  __extends15(OHLCSeries3, _super);
  function OHLCSeries3() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.data = void 0;
    _this.options = void 0;
    _this.points = void 0;
    _this.yData = void 0;
    return _this;
  }
  OHLCSeries3.prototype.drawPoints = function() {
    var series = this, points = series.points, chart = series.chart, extendStem = function(path, halfStrokeWidth, openOrClose) {
      var start = path[0];
      var end = path[1];
      if (typeof start[2] === "number") {
        start[2] = Math.max(openOrClose + halfStrokeWidth, start[2]);
      }
      if (typeof end[2] === "number") {
        end[2] = Math.min(openOrClose - halfStrokeWidth, end[2]);
      }
    };
    points.forEach(function(point) {
      var plotOpen, plotClose, crispCorr, halfWidth, path, graphic = point.graphic, crispX, isNew = !graphic, strokeWidth;
      if (typeof point.plotY !== "undefined") {
        if (!graphic) {
          point.graphic = graphic = chart.renderer.path().add(series.group);
        }
        if (!chart.styledMode) {
          graphic.attr(series.pointAttribs(point, point.selected && "select"));
        }
        strokeWidth = graphic.strokeWidth();
        crispCorr = strokeWidth % 2 / 2;
        crispX = Math.round(point.plotX) - crispCorr;
        halfWidth = Math.round(point.shapeArgs.width / 2);
        path = [
          ["M", crispX, Math.round(point.yBottom)],
          ["L", crispX, Math.round(point.plotHigh)]
        ];
        if (point.open !== null) {
          plotOpen = Math.round(point.plotOpen) + crispCorr;
          path.push(["M", crispX, plotOpen], ["L", crispX - halfWidth, plotOpen]);
          extendStem(path, strokeWidth / 2, plotOpen);
        }
        if (point.close !== null) {
          plotClose = Math.round(point.plotClose) + crispCorr;
          path.push(["M", crispX, plotClose], ["L", crispX + halfWidth, plotClose]);
          extendStem(path, strokeWidth / 2, plotClose);
        }
        graphic[isNew ? "attr" : "animate"]({ d: path }).addClass(point.getClassName(), true);
      }
    });
  };
  OHLCSeries3.prototype.init = function() {
    _super.prototype.init.apply(this, arguments);
    this.options.stacking = void 0;
  };
  OHLCSeries3.prototype.pointAttribs = function(point, state) {
    var attribs = _super.prototype.pointAttribs.call(this, point, state), options = this.options;
    delete attribs.fill;
    if (!point.options.color && options.upColor && point.open < point.close) {
      attribs.stroke = options.upColor;
    }
    return attribs;
  };
  OHLCSeries3.prototype.toYData = function(point) {
    return [point.open, point.high, point.low, point.close];
  };
  OHLCSeries3.prototype.translate = function() {
    var series = this, yAxis = series.yAxis, hasModifyValue = !!series.modifyValue, translated = [
      "plotOpen",
      "plotHigh",
      "plotLow",
      "plotClose",
      "yBottom"
    ];
    _super.prototype.translate.apply(series);
    series.points.forEach(function(point) {
      [point.open, point.high, point.low, point.close, point.low].forEach(function(value, i) {
        if (value !== null) {
          if (hasModifyValue) {
            value = series.modifyValue(value);
          }
          point[translated[i]] = yAxis.toPixels(value, true);
        }
      });
      point.tooltipPos[1] = point.plotHigh + yAxis.pos - series.chart.plotTop;
    });
  };
  OHLCSeries3.defaultOptions = merge33(ColumnSeries3.defaultOptions, {
    lineWidth: 1,
    tooltip: {
      pointFormat: '<span style="color:{point.color}">\u25CF</span> <b> {series.name}</b><br/>Open: {point.open}<br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>'
    },
    threshold: null,
    states: {
      hover: {
        lineWidth: 3
      }
    },
    stickyTracking: true
  });
  return OHLCSeries3;
}(ColumnSeries3);
extend26(OHLCSeries.prototype, {
  animate: null,
  directTouch: false,
  pointArrayMap: ["open", "high", "low", "close"],
  pointAttrToOptions: {
    stroke: "color",
    "stroke-width": "lineWidth"
  },
  pointValKey: "close"
});
OHLCSeries.prototype.pointClass = OHLCPoint_default;
SeriesRegistry_default.registerSeriesType("ohlc", OHLCSeries);

// node_modules/highcharts/es-modules/Series/Candlestick/CandlestickSeries.js
var __extends16 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var defaultOptions8 = DefaultOptions_default.defaultOptions;
var _a = SeriesRegistry_default.seriesTypes;
var ColumnSeries4 = _a.column;
var OHLCSeries2 = _a.ohlc;
var merge34 = Utilities_default.merge;
var CandlestickSeries = function(_super) {
  __extends16(CandlestickSeries2, _super);
  function CandlestickSeries2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.data = void 0;
    _this.options = void 0;
    _this.points = void 0;
    return _this;
  }
  CandlestickSeries2.prototype.pointAttribs = function(point, state) {
    var attribs = ColumnSeries4.prototype.pointAttribs.call(this, point, state), options = this.options, isUp = point.open < point.close, stroke = options.lineColor || this.color, color18 = point.color || this.color, stateOptions;
    attribs["stroke-width"] = options.lineWidth;
    attribs.fill = point.options.color || (isUp ? options.upColor || color18 : color18);
    attribs.stroke = point.options.lineColor || (isUp ? options.upLineColor || stroke : stroke);
    if (state) {
      stateOptions = options.states[state];
      attribs.fill = stateOptions.color || attribs.fill;
      attribs.stroke = stateOptions.lineColor || attribs.stroke;
      attribs["stroke-width"] = stateOptions.lineWidth || attribs["stroke-width"];
    }
    return attribs;
  };
  CandlestickSeries2.prototype.drawPoints = function() {
    var series = this, points = series.points, chart = series.chart, reversedYAxis = series.yAxis.reversed;
    points.forEach(function(point) {
      var graphic = point.graphic, plotOpen, plotClose, topBox, bottomBox, hasTopWhisker, hasBottomWhisker, crispCorr, crispX, path, halfWidth, isNew = !graphic;
      if (typeof point.plotY !== "undefined") {
        if (!graphic) {
          point.graphic = graphic = chart.renderer.path().add(series.group);
        }
        if (!series.chart.styledMode) {
          graphic.attr(series.pointAttribs(point, point.selected && "select")).shadow(series.options.shadow);
        }
        crispCorr = graphic.strokeWidth() % 2 / 2;
        crispX = Math.round(point.plotX) - crispCorr;
        plotOpen = point.plotOpen;
        plotClose = point.plotClose;
        topBox = Math.min(plotOpen, plotClose);
        bottomBox = Math.max(plotOpen, plotClose);
        halfWidth = Math.round(point.shapeArgs.width / 2);
        hasTopWhisker = reversedYAxis ? bottomBox !== point.yBottom : Math.round(topBox) !== Math.round(point.plotHigh);
        hasBottomWhisker = reversedYAxis ? Math.round(topBox) !== Math.round(point.plotHigh) : bottomBox !== point.yBottom;
        topBox = Math.round(topBox) + crispCorr;
        bottomBox = Math.round(bottomBox) + crispCorr;
        path = [];
        path.push(["M", crispX - halfWidth, bottomBox], ["L", crispX - halfWidth, topBox], ["L", crispX + halfWidth, topBox], ["L", crispX + halfWidth, bottomBox], ["Z"], ["M", crispX, topBox], [
          "L",
          crispX,
          hasTopWhisker ? Math.round(reversedYAxis ? point.yBottom : point.plotHigh) : topBox
        ], ["M", crispX, bottomBox], [
          "L",
          crispX,
          hasBottomWhisker ? Math.round(reversedYAxis ? point.plotHigh : point.yBottom) : bottomBox
        ]);
        graphic[isNew ? "attr" : "animate"]({ d: path }).addClass(point.getClassName(), true);
      }
    });
  };
  CandlestickSeries2.defaultOptions = merge34(OHLCSeries2.defaultOptions, defaultOptions8.plotOptions, {
    states: {
      hover: {
        lineWidth: 2
      }
    },
    tooltip: defaultOptions8.plotOptions.ohlc.tooltip,
    threshold: null,
    lineColor: Palette_default.neutralColor100,
    lineWidth: 1,
    upColor: Palette_default.backgroundColor,
    stickyTracking: true
  });
  return CandlestickSeries2;
}(OHLCSeries2);
SeriesRegistry_default.registerSeriesType("candlestick", CandlestickSeries);

// node_modules/highcharts/es-modules/Series/Flags/FlagsPoint.js
var __extends17 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ColumnSeries5 = SeriesRegistry_default.seriesTypes.column;
var isNumber27 = Utilities_default.isNumber;
var FlagsPoint = function(_super) {
  __extends17(FlagsPoint2, _super);
  function FlagsPoint2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.options = void 0;
    _this.series = void 0;
    return _this;
  }
  FlagsPoint2.prototype.isValid = function() {
    return isNumber27(this.y) || typeof this.y === "undefined";
  };
  FlagsPoint2.prototype.hasNewShapeType = function() {
    var shape = this.options.shape || this.series.options.shape;
    return this.graphic && shape && shape !== this.graphic.symbolKey;
  };
  return FlagsPoint2;
}(ColumnSeries5.prototype.pointClass);
var FlagsPoint_default = FlagsPoint;

// node_modules/highcharts/es-modules/Mixins/OnSeries.js
var columnProto = ColumnSeries_default.prototype;
var seriesProto2 = Series_default.prototype;
var defined26 = Utilities_default.defined;
var stableSort4 = Utilities_default.stableSort;
var onSeriesMixin = {
  getPlotBox: function() {
    return seriesProto2.getPlotBox.call(this.options.onSeries && this.chart.get(this.options.onSeries) || this);
  },
  translate: function() {
    columnProto.translate.apply(this);
    var series = this, options = series.options, chart = series.chart, points = series.points, cursor = points.length - 1, point, lastPoint, optionsOnSeries = options.onSeries, onSeries = optionsOnSeries && chart.get(optionsOnSeries), onKey = options.onKey || "y", step = onSeries && onSeries.options.step, onData = onSeries && onSeries.points, i = onData && onData.length, inverted = chart.inverted, xAxis = series.xAxis, yAxis = series.yAxis, xOffset = 0, leftPoint, lastX, rightPoint, currentDataGrouping, distanceRatio;
    if (onSeries && onSeries.visible && i) {
      xOffset = (onSeries.pointXOffset || 0) + (onSeries.barW || 0) / 2;
      currentDataGrouping = onSeries.currentDataGrouping;
      lastX = onData[i - 1].x + (currentDataGrouping ? currentDataGrouping.totalRange : 0);
      stableSort4(points, function(a, b) {
        return a.x - b.x;
      });
      onKey = "plot" + onKey[0].toUpperCase() + onKey.substr(1);
      while (i-- && points[cursor]) {
        leftPoint = onData[i];
        point = points[cursor];
        point.y = leftPoint.y;
        if (leftPoint.x <= point.x && typeof leftPoint[onKey] !== "undefined") {
          if (point.x <= lastX) {
            point.plotY = leftPoint[onKey];
            if (leftPoint.x < point.x && !step) {
              rightPoint = onData[i + 1];
              if (rightPoint && typeof rightPoint[onKey] !== "undefined") {
                distanceRatio = (point.x - leftPoint.x) / (rightPoint.x - leftPoint.x);
                point.plotY += distanceRatio * (rightPoint[onKey] - leftPoint[onKey]);
                point.y += distanceRatio * (rightPoint.y - leftPoint.y);
              }
            }
          }
          cursor--;
          i++;
          if (cursor < 0) {
            break;
          }
        }
      }
    }
    points.forEach(function(point2, i2) {
      var stackIndex;
      point2.plotX += xOffset;
      if (typeof point2.plotY === "undefined" || inverted) {
        if (point2.plotX >= 0 && point2.plotX <= xAxis.len) {
          if (inverted) {
            point2.plotY = xAxis.translate(point2.x, 0, 1, 0, 1);
            point2.plotX = defined26(point2.y) ? yAxis.translate(point2.y, 0, 0, 0, 1) : 0;
          } else {
            point2.plotY = (xAxis.opposite ? 0 : series.yAxis.len) + xAxis.offset;
          }
        } else {
          point2.shapeArgs = {};
        }
      }
      lastPoint = points[i2 - 1];
      if (lastPoint && lastPoint.plotX === point2.plotX) {
        if (typeof lastPoint.stackIndex === "undefined") {
          lastPoint.stackIndex = 0;
        }
        stackIndex = lastPoint.stackIndex + 1;
      }
      point2.stackIndex = stackIndex;
    });
    this.onSeries = onSeries;
  }
};
var OnSeries_default = onSeriesMixin;

// node_modules/highcharts/es-modules/Series/Flags/FlagsSymbols.js
var symbols = SVGRenderer_default.prototype.symbols;
symbols.flag = function(x, y, w2, h, options) {
  var anchorX = options && options.anchorX || x, anchorY = options && options.anchorY || y;
  var path = symbols.circle(anchorX - 1, anchorY - 1, 2, 2);
  path.push(["M", anchorX, anchorY], ["L", x, y + h], ["L", x, y], ["L", x + w2, y], ["L", x + w2, y + h], ["L", x, y + h], ["Z"]);
  return path;
};
function createPinSymbol(shape) {
  symbols[shape + "pin"] = function(x, y, w2, h, options) {
    var anchorX = options && options.anchorX, anchorY = options && options.anchorY;
    var path;
    if (shape === "circle" && h > w2) {
      x -= Math.round((h - w2) / 2);
      w2 = h;
    }
    path = symbols[shape](x, y, w2, h);
    if (anchorX && anchorY) {
      var labelX = anchorX;
      if (shape === "circle") {
        labelX = x + w2 / 2;
      } else {
        var startSeg = path[0];
        var endSeg = path[1];
        if (startSeg[0] === "M" && endSeg[0] === "L") {
          labelX = (startSeg[1] + endSeg[1]) / 2;
        }
      }
      var labelY = y > anchorY ? y : y + h;
      path.push([
        "M",
        labelX,
        labelY
      ], [
        "L",
        anchorX,
        anchorY
      ]);
      path = path.concat(symbols.circle(anchorX - 1, anchorY - 1, 2, 2));
    }
    return path;
  };
}
createPinSymbol("circle");
createPinSymbol("square");
var Renderer = RendererRegistry_default.getRendererType();
if (Renderer !== SVGRenderer_default) {
  Renderer.prototype.symbols.circlepin = symbols.circlepin;
  Renderer.prototype.symbols.flag = symbols.flag;
  Renderer.prototype.symbols.squarepin = symbols.squarepin;
}

// node_modules/highcharts/es-modules/Series/Flags/FlagsSeries.js
var __extends18 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var noop8 = Globals_default.noop;
var distribute4 = RendererUtilities_default.distribute;
var Series4 = SeriesRegistry_default.series;
var ColumnSeries6 = SeriesRegistry_default.seriesTypes.column;
var addEvent22 = Utilities_default.addEvent;
var defined27 = Utilities_default.defined;
var extend27 = Utilities_default.extend;
var merge35 = Utilities_default.merge;
var objectEach24 = Utilities_default.objectEach;
var wrap3 = Utilities_default.wrap;
var FlagsSeries = function(_super) {
  __extends18(FlagsSeries2, _super);
  function FlagsSeries2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.data = void 0;
    _this.options = void 0;
    _this.points = void 0;
    return _this;
  }
  FlagsSeries2.prototype.animate = function(init) {
    if (init) {
      this.setClip();
    }
  };
  FlagsSeries2.prototype.drawPoints = function() {
    var series = this, points = series.points, chart = series.chart, renderer = chart.renderer, plotX, plotY, inverted = chart.inverted, options = series.options, optionsY = options.y, shape, i, point, graphic, stackIndex, anchorY, attribs, outsideRight, yAxis = series.yAxis, boxesMap = {}, boxes = [], centered;
    i = points.length;
    while (i--) {
      point = points[i];
      outsideRight = (inverted ? point.plotY : point.plotX) > series.xAxis.len;
      plotX = point.plotX;
      stackIndex = point.stackIndex;
      shape = point.options.shape || options.shape;
      plotY = point.plotY;
      if (typeof plotY !== "undefined") {
        plotY = point.plotY + optionsY - (typeof stackIndex !== "undefined" && stackIndex * options.stackDistance);
      }
      point.anchorX = stackIndex ? void 0 : point.plotX;
      anchorY = stackIndex ? void 0 : point.plotY;
      centered = shape !== "flag";
      graphic = point.graphic;
      if (typeof plotY !== "undefined" && plotX >= 0 && !outsideRight) {
        if (graphic && point.hasNewShapeType()) {
          graphic = graphic.destroy();
        }
        if (!graphic) {
          graphic = point.graphic = renderer.label("", null, null, shape, null, null, options.useHTML).addClass("highcharts-point").add(series.markerGroup);
          if (point.graphic.div) {
            point.graphic.div.point = point;
          }
          graphic.isNew = true;
        }
        graphic.attr({
          align: centered ? "center" : "left",
          width: options.width,
          height: options.height,
          "text-align": options.textAlign
        });
        if (!chart.styledMode) {
          graphic.attr(series.pointAttribs(point)).css(merge35(options.style, point.style)).shadow(options.shadow);
        }
        if (plotX > 0) {
          plotX -= graphic.strokeWidth() % 2;
        }
        attribs = {
          y: plotY,
          anchorY
        };
        if (options.allowOverlapX) {
          attribs.x = plotX;
          attribs.anchorX = point.anchorX;
        }
        graphic.attr({
          text: point.options.title || options.title || "A"
        })[graphic.isNew ? "attr" : "animate"](attribs);
        if (!options.allowOverlapX) {
          if (!boxesMap[point.plotX]) {
            boxesMap[point.plotX] = {
              align: centered ? 0.5 : 0,
              size: graphic.width,
              target: plotX,
              anchorX: plotX
            };
          } else {
            boxesMap[point.plotX].size = Math.max(boxesMap[point.plotX].size, graphic.width);
          }
        }
        point.tooltipPos = [
          plotX,
          plotY + yAxis.pos - chart.plotTop
        ];
      } else if (graphic) {
        point.graphic = graphic.destroy();
      }
    }
    if (!options.allowOverlapX) {
      objectEach24(boxesMap, function(box) {
        box.plotX = box.anchorX;
        boxes.push(box);
      });
      distribute4(boxes, inverted ? yAxis.len : this.xAxis.len, 100);
      points.forEach(function(point2) {
        var box = point2.graphic && boxesMap[point2.plotX];
        if (box) {
          point2.graphic[point2.graphic.isNew ? "attr" : "animate"]({
            x: box.pos + box.align * box.size,
            anchorX: point2.anchorX
          });
          if (!defined27(box.pos)) {
            point2.graphic.attr({
              x: -9999,
              anchorX: -9999
            });
            point2.graphic.isNew = true;
          } else {
            point2.graphic.isNew = false;
          }
        }
      });
    }
    if (options.useHTML) {
      wrap3(series.markerGroup, "on", function(proceed) {
        return SVGElement_default.prototype.on.apply(proceed.apply(this, [].slice.call(arguments, 1)), [].slice.call(arguments, 1));
      });
    }
  };
  FlagsSeries2.prototype.drawTracker = function() {
    var series = this, points = series.points;
    _super.prototype.drawTracker.call(this);
    points.forEach(function(point) {
      var graphic = point.graphic;
      if (graphic) {
        if (point.unbindMouseOver) {
          point.unbindMouseOver();
        }
        point.unbindMouseOver = addEvent22(graphic.element, "mouseover", function() {
          if (point.stackIndex > 0 && !point.raised) {
            point._y = graphic.y;
            graphic.attr({
              y: point._y - 8
            });
            point.raised = true;
          }
          points.forEach(function(otherPoint) {
            if (otherPoint !== point && otherPoint.raised && otherPoint.graphic) {
              otherPoint.graphic.attr({
                y: otherPoint._y
              });
              otherPoint.raised = false;
            }
          });
        });
      }
    });
  };
  FlagsSeries2.prototype.pointAttribs = function(point, state) {
    var options = this.options, color18 = point && point.color || this.color, lineColor = options.lineColor, lineWidth = point && point.lineWidth, fill = point && point.fillColor || options.fillColor;
    if (state) {
      fill = options.states[state].fillColor;
      lineColor = options.states[state].lineColor;
      lineWidth = options.states[state].lineWidth;
    }
    return {
      fill: fill || color18,
      stroke: lineColor || color18,
      "stroke-width": lineWidth || options.lineWidth || 0
    };
  };
  FlagsSeries2.prototype.setClip = function() {
    Series4.prototype.setClip.apply(this, arguments);
    if (this.options.clip !== false && this.sharedClipKey && this.markerGroup) {
      this.markerGroup.clip(this.chart.sharedClips[this.sharedClipKey]);
    }
  };
  FlagsSeries2.defaultOptions = merge35(ColumnSeries6.defaultOptions, {
    pointRange: 0,
    allowOverlapX: false,
    shape: "flag",
    stackDistance: 12,
    textAlign: "center",
    tooltip: {
      pointFormat: "{point.text}"
    },
    threshold: null,
    y: -30,
    fillColor: Palette_default.backgroundColor,
    lineWidth: 1,
    states: {
      hover: {
        lineColor: Palette_default.neutralColor100,
        fillColor: Palette_default.highlightColor20
      }
    },
    style: {
      fontSize: "11px",
      fontWeight: "bold"
    }
  });
  return FlagsSeries2;
}(ColumnSeries6);
extend27(FlagsSeries.prototype, {
  allowDG: false,
  buildKDTree: noop8,
  forceCrop: true,
  getPlotBox: OnSeries_default.getPlotBox,
  init: Series4.prototype.init,
  invertGroups: noop8,
  invertible: false,
  noSharedTooltip: true,
  pointClass: FlagsPoint_default,
  sorted: false,
  takeOrdinalPosition: false,
  trackerGroups: ["markerGroup"],
  translate: OnSeries_default.translate
});
SeriesRegistry_default.registerSeriesType("flags", FlagsSeries);

// node_modules/highcharts/es-modules/Core/Axis/ScrollbarAxis.js
var addEvent23 = Utilities_default.addEvent;
var defined28 = Utilities_default.defined;
var pick40 = Utilities_default.pick;
var ScrollbarAxis = function() {
  function ScrollbarAxis2() {
  }
  ScrollbarAxis2.compose = function(AxisClass, ScrollbarClass) {
    if (ScrollbarAxis2.composed.indexOf(AxisClass) === -1) {
      ScrollbarAxis2.composed.push(AxisClass);
    } else {
      return AxisClass;
    }
    var getExtremes = function(axis) {
      var axisMin = pick40(axis.options && axis.options.min, axis.min);
      var axisMax = pick40(axis.options && axis.options.max, axis.max);
      return {
        axisMin,
        axisMax,
        scrollMin: defined28(axis.dataMin) ? Math.min(axisMin, axis.min, axis.dataMin, pick40(axis.threshold, Infinity)) : axisMin,
        scrollMax: defined28(axis.dataMax) ? Math.max(axisMax, axis.max, axis.dataMax, pick40(axis.threshold, -Infinity)) : axisMax
      };
    };
    addEvent23(AxisClass, "afterInit", function() {
      var axis = this;
      if (axis.options && axis.options.scrollbar && axis.options.scrollbar.enabled) {
        axis.options.scrollbar.vertical = !axis.horiz;
        axis.options.startOnTick = axis.options.endOnTick = false;
        axis.scrollbar = new ScrollbarClass(axis.chart.renderer, axis.options.scrollbar, axis.chart);
        addEvent23(axis.scrollbar, "changed", function(e2) {
          var _a15 = getExtremes(axis), axisMin = _a15.axisMin, axisMax = _a15.axisMax, unitedMin = _a15.scrollMin, unitedMax = _a15.scrollMax, range = unitedMax - unitedMin, to, from;
          if (!defined28(axisMin) || !defined28(axisMax)) {
            return;
          }
          if (axis.horiz && !axis.reversed || !axis.horiz && axis.reversed) {
            to = unitedMin + range * this.to;
            from = unitedMin + range * this.from;
          } else {
            to = unitedMin + range * (1 - this.from);
            from = unitedMin + range * (1 - this.to);
          }
          if (this.shouldUpdateExtremes(e2.DOMType)) {
            axis.setExtremes(from, to, true, e2.DOMType !== "mousemove" && e2.DOMType !== "touchmove", e2);
          } else {
            this.setRange(this.from, this.to);
          }
        });
      }
    });
    addEvent23(AxisClass, "afterRender", function() {
      var axis = this, _a15 = getExtremes(axis), scrollMin = _a15.scrollMin, scrollMax = _a15.scrollMax, scrollbar = axis.scrollbar, offset3 = axis.axisTitleMargin + (axis.titleOffset || 0), scrollbarsOffsets = axis.chart.scrollbarsOffsets, axisMargin = axis.options.margin || 0, offsetsIndex, from, to;
      if (scrollbar) {
        if (axis.horiz) {
          if (!axis.opposite) {
            scrollbarsOffsets[1] += offset3;
          }
          scrollbar.position(axis.left, axis.top + axis.height + 2 + scrollbarsOffsets[1] - (axis.opposite ? axisMargin : 0), axis.width, axis.height);
          if (!axis.opposite) {
            scrollbarsOffsets[1] += axisMargin;
          }
          offsetsIndex = 1;
        } else {
          if (axis.opposite) {
            scrollbarsOffsets[0] += offset3;
          }
          scrollbar.position(axis.left + axis.width + 2 + scrollbarsOffsets[0] - (axis.opposite ? 0 : axisMargin), axis.top, axis.width, axis.height);
          if (axis.opposite) {
            scrollbarsOffsets[0] += axisMargin;
          }
          offsetsIndex = 0;
        }
        scrollbarsOffsets[offsetsIndex] += scrollbar.size + scrollbar.options.margin;
        if (isNaN(scrollMin) || isNaN(scrollMax) || !defined28(axis.min) || !defined28(axis.max) || axis.min === axis.max) {
          scrollbar.setRange(0, 1);
        } else {
          from = (axis.min - scrollMin) / (scrollMax - scrollMin);
          to = (axis.max - scrollMin) / (scrollMax - scrollMin);
          if (axis.horiz && !axis.reversed || !axis.horiz && axis.reversed) {
            scrollbar.setRange(from, to);
          } else {
            scrollbar.setRange(1 - to, 1 - from);
          }
        }
      }
    });
    addEvent23(AxisClass, "afterGetOffset", function() {
      var axis = this, index = axis.horiz ? 2 : 1, scrollbar = axis.scrollbar;
      if (scrollbar) {
        axis.chart.scrollbarsOffsets = [0, 0];
        axis.chart.axisOffset[index] += scrollbar.size + scrollbar.options.margin;
      }
    });
    return AxisClass;
  };
  ScrollbarAxis2.composed = [];
  return ScrollbarAxis2;
}();
var ScrollbarAxis_default = ScrollbarAxis;

// node_modules/highcharts/es-modules/Core/ScrollbarDefaults.js
var isTouchDevice2 = Globals_default.isTouchDevice;
var ScrollbarDefaults = {
  height: isTouchDevice2 ? 20 : 14,
  barBorderRadius: 0,
  buttonBorderRadius: 0,
  liveRedraw: void 0,
  margin: 10,
  minWidth: 6,
  step: 0.2,
  zIndex: 3,
  barBackgroundColor: Palette_default.neutralColor20,
  barBorderWidth: 1,
  barBorderColor: Palette_default.neutralColor20,
  buttonArrowColor: Palette_default.neutralColor80,
  buttonBackgroundColor: Palette_default.neutralColor10,
  buttonBorderColor: Palette_default.neutralColor20,
  buttonBorderWidth: 1,
  rifleColor: Palette_default.neutralColor80,
  trackBackgroundColor: Palette_default.neutralColor5,
  trackBorderColor: Palette_default.neutralColor5,
  trackBorderWidth: 1
};
var ScrollbarDefaults_default = ScrollbarDefaults;

// node_modules/highcharts/es-modules/Core/Scrollbar.js
var defaultOptions9 = DefaultOptions_default.defaultOptions;
var addEvent24 = Utilities_default.addEvent;
var correctFloat8 = Utilities_default.correctFloat;
var defined29 = Utilities_default.defined;
var destroyObjectProperties8 = Utilities_default.destroyObjectProperties;
var fireEvent18 = Utilities_default.fireEvent;
var merge36 = Utilities_default.merge;
var pick41 = Utilities_default.pick;
var removeEvent9 = Utilities_default.removeEvent;
var Scrollbar = function() {
  function Scrollbar2(renderer, options, chart) {
    this._events = [];
    this.chart = void 0;
    this.chartX = 0;
    this.chartY = 0;
    this.from = 0;
    this.group = void 0;
    this.options = void 0;
    this.renderer = void 0;
    this.scrollbar = void 0;
    this.scrollbarButtons = [];
    this.scrollbarGroup = void 0;
    this.scrollbarLeft = 0;
    this.scrollbarRifles = void 0;
    this.scrollbarStrokeWidth = 1;
    this.scrollbarTop = 0;
    this.size = 0;
    this.to = 0;
    this.track = void 0;
    this.trackBorderWidth = 1;
    this.userOptions = void 0;
    this.x = 0;
    this.y = 0;
    this.init(renderer, options, chart);
  }
  Scrollbar2.compose = function(AxisClass) {
    ScrollbarAxis_default.compose(AxisClass, Scrollbar2);
  };
  Scrollbar2.swapXY = function(path, vertical) {
    if (vertical) {
      path.forEach(function(seg) {
        var len = seg.length;
        var temp;
        for (var i = 0; i < len; i += 2) {
          temp = seg[i + 1];
          if (typeof temp === "number") {
            seg[i + 1] = seg[i + 2];
            seg[i + 2] = temp;
          }
        }
      });
    }
    return path;
  };
  Scrollbar2.prototype.addEvents = function() {
    var buttonsOrder = this.options.inverted ? [1, 0] : [0, 1], buttons = this.scrollbarButtons, bar = this.scrollbarGroup.element, track = this.track.element, mouseDownHandler = this.mouseDownHandler.bind(this), mouseMoveHandler = this.mouseMoveHandler.bind(this), mouseUpHandler = this.mouseUpHandler.bind(this);
    var _events = [
      [buttons[buttonsOrder[0]].element, "click", this.buttonToMinClick.bind(this)],
      [buttons[buttonsOrder[1]].element, "click", this.buttonToMaxClick.bind(this)],
      [track, "click", this.trackClick.bind(this)],
      [bar, "mousedown", mouseDownHandler],
      [bar.ownerDocument, "mousemove", mouseMoveHandler],
      [bar.ownerDocument, "mouseup", mouseUpHandler]
    ];
    if (Globals_default.hasTouch) {
      _events.push([bar, "touchstart", mouseDownHandler], [bar.ownerDocument, "touchmove", mouseMoveHandler], [bar.ownerDocument, "touchend", mouseUpHandler]);
    }
    _events.forEach(function(args) {
      addEvent24.apply(null, args);
    });
    this._events = _events;
  };
  Scrollbar2.prototype.buttonToMaxClick = function(e2) {
    var scroller = this;
    var range = (scroller.to - scroller.from) * pick41(scroller.options.step, 0.2);
    scroller.updatePosition(scroller.from + range, scroller.to + range);
    fireEvent18(scroller, "changed", {
      from: scroller.from,
      to: scroller.to,
      trigger: "scrollbar",
      DOMEvent: e2
    });
  };
  Scrollbar2.prototype.buttonToMinClick = function(e2) {
    var scroller = this;
    var range = correctFloat8(scroller.to - scroller.from) * pick41(scroller.options.step, 0.2);
    scroller.updatePosition(correctFloat8(scroller.from - range), correctFloat8(scroller.to - range));
    fireEvent18(scroller, "changed", {
      from: scroller.from,
      to: scroller.to,
      trigger: "scrollbar",
      DOMEvent: e2
    });
  };
  Scrollbar2.prototype.cursorToScrollbarPosition = function(normalizedEvent) {
    var scroller = this, options = scroller.options, minWidthDifference = options.minWidth > scroller.calculatedWidth ? options.minWidth : 0;
    return {
      chartX: (normalizedEvent.chartX - scroller.x - scroller.xOffset) / (scroller.barWidth - minWidthDifference),
      chartY: (normalizedEvent.chartY - scroller.y - scroller.yOffset) / (scroller.barWidth - minWidthDifference)
    };
  };
  Scrollbar2.prototype.destroy = function() {
    var scroller = this, navigator = scroller.chart.scroller;
    scroller.removeEvents();
    [
      "track",
      "scrollbarRifles",
      "scrollbar",
      "scrollbarGroup",
      "group"
    ].forEach(function(prop) {
      if (scroller[prop] && scroller[prop].destroy) {
        scroller[prop] = scroller[prop].destroy();
      }
    });
    if (navigator && scroller === navigator.scrollbar) {
      navigator.scrollbar = null;
      destroyObjectProperties8(navigator.scrollbarButtons);
    }
  };
  Scrollbar2.prototype.drawScrollbarButton = function(index) {
    var scroller = this, renderer = scroller.renderer, scrollbarButtons = scroller.scrollbarButtons, options = scroller.options, size = scroller.size, group = renderer.g().add(scroller.group);
    var tempElem;
    scrollbarButtons.push(group);
    tempElem = renderer.rect().addClass("highcharts-scrollbar-button").add(group);
    if (!scroller.chart.styledMode) {
      tempElem.attr({
        stroke: options.buttonBorderColor,
        "stroke-width": options.buttonBorderWidth,
        fill: options.buttonBackgroundColor
      });
    }
    tempElem.attr(tempElem.crisp({
      x: -0.5,
      y: -0.5,
      width: size + 1,
      height: size + 1,
      r: options.buttonBorderRadius
    }, tempElem.strokeWidth()));
    tempElem = renderer.path(Scrollbar2.swapXY([[
      "M",
      size / 2 + (index ? -1 : 1),
      size / 2 - 3
    ], [
      "L",
      size / 2 + (index ? -1 : 1),
      size / 2 + 3
    ], [
      "L",
      size / 2 + (index ? 2 : -2),
      size / 2
    ]], options.vertical)).addClass("highcharts-scrollbar-arrow").add(scrollbarButtons[index]);
    if (!scroller.chart.styledMode) {
      tempElem.attr({
        fill: options.buttonArrowColor
      });
    }
  };
  Scrollbar2.prototype.init = function(renderer, options, chart) {
    var scroller = this;
    scroller.scrollbarButtons = [];
    scroller.renderer = renderer;
    scroller.userOptions = options;
    scroller.options = merge36(ScrollbarDefaults_default, defaultOptions9.scrollbar, options);
    scroller.chart = chart;
    scroller.size = pick41(scroller.options.size, scroller.options.height);
    if (options.enabled) {
      scroller.render();
      scroller.addEvents();
    }
  };
  Scrollbar2.prototype.mouseDownHandler = function(e2) {
    var scroller = this, normalizedEvent = scroller.chart.pointer.normalize(e2), mousePosition = scroller.cursorToScrollbarPosition(normalizedEvent);
    scroller.chartX = mousePosition.chartX;
    scroller.chartY = mousePosition.chartY;
    scroller.initPositions = [scroller.from, scroller.to];
    scroller.grabbedCenter = true;
  };
  Scrollbar2.prototype.mouseMoveHandler = function(e2) {
    var scroller = this, normalizedEvent = scroller.chart.pointer.normalize(e2), options = scroller.options, direction = options.vertical ? "chartY" : "chartX", initPositions = scroller.initPositions || [];
    var scrollPosition, chartPosition, change;
    if (scroller.grabbedCenter && (!e2.touches || e2.touches[0][direction] !== 0)) {
      chartPosition = scroller.cursorToScrollbarPosition(normalizedEvent)[direction];
      scrollPosition = scroller[direction];
      change = chartPosition - scrollPosition;
      scroller.hasDragged = true;
      scroller.updatePosition(initPositions[0] + change, initPositions[1] + change);
      if (scroller.hasDragged) {
        fireEvent18(scroller, "changed", {
          from: scroller.from,
          to: scroller.to,
          trigger: "scrollbar",
          DOMType: e2.type,
          DOMEvent: e2
        });
      }
    }
  };
  Scrollbar2.prototype.mouseUpHandler = function(e2) {
    var scroller = this;
    if (scroller.hasDragged) {
      fireEvent18(scroller, "changed", {
        from: scroller.from,
        to: scroller.to,
        trigger: "scrollbar",
        DOMType: e2.type,
        DOMEvent: e2
      });
    }
    scroller.grabbedCenter = scroller.hasDragged = scroller.chartX = scroller.chartY = null;
  };
  Scrollbar2.prototype.position = function(x, y, width, height) {
    var scroller = this, options = scroller.options, vertical = options.vertical, method = scroller.rendered ? "animate" : "attr";
    var xOffset = height, yOffset = 0;
    scroller.x = x;
    scroller.y = y + this.trackBorderWidth;
    scroller.width = width;
    scroller.height = height;
    scroller.xOffset = xOffset;
    scroller.yOffset = yOffset;
    if (vertical) {
      scroller.width = scroller.yOffset = width = yOffset = scroller.size;
      scroller.xOffset = xOffset = 0;
      scroller.barWidth = height - width * 2;
      scroller.x = x = x + scroller.options.margin;
    } else {
      scroller.height = scroller.xOffset = height = xOffset = scroller.size;
      scroller.barWidth = width - height * 2;
      scroller.y = scroller.y + scroller.options.margin;
    }
    scroller.group[method]({
      translateX: x,
      translateY: scroller.y
    });
    scroller.track[method]({
      width,
      height
    });
    scroller.scrollbarButtons[1][method]({
      translateX: vertical ? 0 : width - xOffset,
      translateY: vertical ? height - yOffset : 0
    });
  };
  Scrollbar2.prototype.removeEvents = function() {
    this._events.forEach(function(args) {
      removeEvent9.apply(null, args);
    });
    this._events.length = 0;
  };
  Scrollbar2.prototype.render = function() {
    var scroller = this, renderer = scroller.renderer, options = scroller.options, size = scroller.size, styledMode = scroller.chart.styledMode, group = renderer.g("scrollbar").attr({
      zIndex: options.zIndex,
      translateY: -99999
    }).add();
    scroller.group = group;
    scroller.track = renderer.rect().addClass("highcharts-scrollbar-track").attr({
      x: 0,
      r: options.trackBorderRadius || 0,
      height: size,
      width: size
    }).add(group);
    if (!styledMode) {
      scroller.track.attr({
        fill: options.trackBackgroundColor,
        stroke: options.trackBorderColor,
        "stroke-width": options.trackBorderWidth
      });
    }
    scroller.trackBorderWidth = scroller.track.strokeWidth();
    scroller.track.attr({
      y: -this.trackBorderWidth % 2 / 2
    });
    scroller.scrollbarGroup = renderer.g().add(group);
    scroller.scrollbar = renderer.rect().addClass("highcharts-scrollbar-thumb").attr({
      height: size,
      width: size,
      r: options.barBorderRadius || 0
    }).add(scroller.scrollbarGroup);
    scroller.scrollbarRifles = renderer.path(Scrollbar2.swapXY([
      ["M", -3, size / 4],
      ["L", -3, 2 * size / 3],
      ["M", 0, size / 4],
      ["L", 0, 2 * size / 3],
      ["M", 3, size / 4],
      ["L", 3, 2 * size / 3]
    ], options.vertical)).addClass("highcharts-scrollbar-rifles").add(scroller.scrollbarGroup);
    if (!styledMode) {
      scroller.scrollbar.attr({
        fill: options.barBackgroundColor,
        stroke: options.barBorderColor,
        "stroke-width": options.barBorderWidth
      });
      scroller.scrollbarRifles.attr({
        stroke: options.rifleColor,
        "stroke-width": 1
      });
    }
    scroller.scrollbarStrokeWidth = scroller.scrollbar.strokeWidth();
    scroller.scrollbarGroup.translate(-scroller.scrollbarStrokeWidth % 2 / 2, -scroller.scrollbarStrokeWidth % 2 / 2);
    scroller.drawScrollbarButton(0);
    scroller.drawScrollbarButton(1);
  };
  Scrollbar2.prototype.setRange = function(from, to) {
    var scroller = this, options = scroller.options, vertical = options.vertical, minWidth = options.minWidth, fullWidth = scroller.barWidth, method = this.rendered && !this.hasDragged && !(this.chart.navigator && this.chart.navigator.hasDragged) ? "animate" : "attr";
    if (!defined29(fullWidth)) {
      return;
    }
    var toPX = fullWidth * Math.min(to, 1);
    var fromPX, newSize;
    from = Math.max(from, 0);
    fromPX = Math.ceil(fullWidth * from);
    scroller.calculatedWidth = newSize = correctFloat8(toPX - fromPX);
    if (newSize < minWidth) {
      fromPX = (fullWidth - minWidth + newSize) * from;
      newSize = minWidth;
    }
    var newPos = Math.floor(fromPX + scroller.xOffset + scroller.yOffset);
    var newRiflesPos = newSize / 2 - 0.5;
    scroller.from = from;
    scroller.to = to;
    if (!vertical) {
      scroller.scrollbarGroup[method]({
        translateX: newPos
      });
      scroller.scrollbar[method]({
        width: newSize
      });
      scroller.scrollbarRifles[method]({
        translateX: newRiflesPos
      });
      scroller.scrollbarLeft = newPos;
      scroller.scrollbarTop = 0;
    } else {
      scroller.scrollbarGroup[method]({
        translateY: newPos
      });
      scroller.scrollbar[method]({
        height: newSize
      });
      scroller.scrollbarRifles[method]({
        translateY: newRiflesPos
      });
      scroller.scrollbarTop = newPos;
      scroller.scrollbarLeft = 0;
    }
    if (newSize <= 12) {
      scroller.scrollbarRifles.hide();
    } else {
      scroller.scrollbarRifles.show(true);
    }
    if (options.showFull === false) {
      if (from <= 0 && to >= 1) {
        scroller.group.hide();
      } else {
        scroller.group.show();
      }
    }
    scroller.rendered = true;
  };
  Scrollbar2.prototype.shouldUpdateExtremes = function(eventType) {
    return pick41(this.options.liveRedraw, Globals_default.svg && !Globals_default.isTouchDevice && !this.chart.isBoosting) || eventType === "mouseup" || eventType === "touchend" || !defined29(eventType);
  };
  Scrollbar2.prototype.trackClick = function(e2) {
    var scroller = this;
    var normalizedEvent = scroller.chart.pointer.normalize(e2), range = scroller.to - scroller.from, top = scroller.y + scroller.scrollbarTop, left = scroller.x + scroller.scrollbarLeft;
    if (scroller.options.vertical && normalizedEvent.chartY > top || !scroller.options.vertical && normalizedEvent.chartX > left) {
      scroller.updatePosition(scroller.from + range, scroller.to + range);
    } else {
      scroller.updatePosition(scroller.from - range, scroller.to - range);
    }
    fireEvent18(scroller, "changed", {
      from: scroller.from,
      to: scroller.to,
      trigger: "scrollbar",
      DOMEvent: e2
    });
  };
  Scrollbar2.prototype.update = function(options) {
    this.destroy();
    this.init(this.chart.renderer, merge36(true, this.options, options), this.chart);
  };
  Scrollbar2.prototype.updatePosition = function(from, to) {
    if (to > 1) {
      from = correctFloat8(1 - correctFloat8(to - from));
      to = 1;
    }
    if (from < 0) {
      to = correctFloat8(to - from);
      from = 0;
    }
    this.from = from;
    this.to = to;
  };
  Scrollbar2.defaultOptions = ScrollbarDefaults_default;
  return Scrollbar2;
}();
defaultOptions9.scrollbar = merge36(true, Scrollbar.defaultOptions, defaultOptions9.scrollbar);
var Scrollbar_default = Scrollbar;

// node_modules/highcharts/es-modules/Core/Axis/NavigatorAxis.js
var isTouchDevice3 = Globals_default.isTouchDevice;
var addEvent25 = Utilities_default.addEvent;
var correctFloat9 = Utilities_default.correctFloat;
var defined30 = Utilities_default.defined;
var isNumber28 = Utilities_default.isNumber;
var pick42 = Utilities_default.pick;
var NavigatorAxisAdditions = function() {
  function NavigatorAxisAdditions2(axis) {
    this.axis = axis;
  }
  NavigatorAxisAdditions2.prototype.destroy = function() {
    this.axis = void 0;
  };
  NavigatorAxisAdditions2.prototype.toFixedRange = function(pxMin, pxMax, fixedMin, fixedMax) {
    var navigator = this;
    var axis = navigator.axis;
    var chart = axis.chart;
    var fixedRange = chart && chart.fixedRange, halfPointRange = (axis.pointRange || 0) / 2, newMin = pick42(fixedMin, axis.translate(pxMin, true, !axis.horiz)), newMax = pick42(fixedMax, axis.translate(pxMax, true, !axis.horiz)), changeRatio = fixedRange && (newMax - newMin) / fixedRange;
    if (!defined30(fixedMin)) {
      newMin = correctFloat9(newMin + halfPointRange);
    }
    if (!defined30(fixedMax)) {
      newMax = correctFloat9(newMax - halfPointRange);
    }
    if (changeRatio > 0.7 && changeRatio < 1.3) {
      if (fixedMax) {
        newMin = newMax - fixedRange;
      } else {
        newMax = newMin + fixedRange;
      }
    }
    if (!isNumber28(newMin) || !isNumber28(newMax)) {
      newMin = newMax = void 0;
    }
    return {
      min: newMin,
      max: newMax
    };
  };
  return NavigatorAxisAdditions2;
}();
var NavigatorAxis = function() {
  function NavigatorAxis2() {
  }
  NavigatorAxis2.compose = function(AxisClass) {
    AxisClass.keepProps.push("navigatorAxis");
    addEvent25(AxisClass, "init", function() {
      var axis = this;
      if (!axis.navigatorAxis) {
        axis.navigatorAxis = new NavigatorAxisAdditions(axis);
      }
    });
    addEvent25(AxisClass, "zoom", function(e2) {
      var axis = this;
      var chart = axis.chart;
      var chartOptions = chart.options;
      var navigator = chartOptions.navigator;
      var navigatorAxis = axis.navigatorAxis;
      var pinchType = chartOptions.chart.pinchType;
      var rangeSelector = chartOptions.rangeSelector;
      var zoomType = chartOptions.chart.zoomType;
      var previousZoom;
      if (axis.isXAxis && (navigator && navigator.enabled || rangeSelector && rangeSelector.enabled)) {
        if (zoomType === "y") {
          e2.zoomed = false;
        } else if ((!isTouchDevice3 && zoomType === "xy" || isTouchDevice3 && pinchType === "xy") && axis.options.range) {
          previousZoom = navigatorAxis.previousZoom;
          if (defined30(e2.newMin)) {
            navigatorAxis.previousZoom = [axis.min, axis.max];
          } else if (previousZoom) {
            e2.newMin = previousZoom[0];
            e2.newMax = previousZoom[1];
            navigatorAxis.previousZoom = void 0;
          }
        }
      }
      if (typeof e2.zoomed !== "undefined") {
        e2.preventDefault();
      }
    });
  };
  NavigatorAxis2.AdditionsClass = NavigatorAxisAdditions;
  return NavigatorAxis2;
}();
var NavigatorAxis_default = NavigatorAxis;

// node_modules/highcharts/es-modules/Core/Navigator.js
var color6 = Color_default.parse;
var hasTouch3 = Globals_default.hasTouch;
var isTouchDevice4 = Globals_default.isTouchDevice;
var defaultOptions10 = DefaultOptions_default.defaultOptions;
var seriesTypes3 = SeriesRegistry_default.seriesTypes;
var addEvent26 = Utilities_default.addEvent;
var clamp10 = Utilities_default.clamp;
var correctFloat10 = Utilities_default.correctFloat;
var defined31 = Utilities_default.defined;
var destroyObjectProperties9 = Utilities_default.destroyObjectProperties;
var erase9 = Utilities_default.erase;
var extend28 = Utilities_default.extend;
var find8 = Utilities_default.find;
var isArray16 = Utilities_default.isArray;
var isNumber29 = Utilities_default.isNumber;
var merge37 = Utilities_default.merge;
var pick43 = Utilities_default.pick;
var removeEvent10 = Utilities_default.removeEvent;
var splat11 = Utilities_default.splat;
var defaultSeriesType;
var numExt = function(extreme) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  var numbers = [].filter.call(args, isNumber29);
  if (numbers.length) {
    return Math[extreme].apply(0, numbers);
  }
};
defaultSeriesType = typeof seriesTypes3.areaspline === "undefined" ? "line" : "areaspline";
extend28(defaultOptions10, {
  navigator: {
    height: 40,
    margin: 25,
    maskInside: true,
    handles: {
      width: 7,
      height: 15,
      symbols: ["navigator-handle", "navigator-handle"],
      enabled: true,
      lineWidth: 1,
      backgroundColor: Palette_default.neutralColor5,
      borderColor: Palette_default.neutralColor40
    },
    maskFill: color6(Palette_default.highlightColor60).setOpacity(0.3).get(),
    outlineColor: Palette_default.neutralColor20,
    outlineWidth: 1,
    series: {
      type: defaultSeriesType,
      fillOpacity: 0.05,
      lineWidth: 1,
      compare: null,
      dataGrouping: {
        approximation: "average",
        enabled: true,
        groupPixelWidth: 2,
        firstAnchor: "firstPoint",
        anchor: "middle",
        lastAnchor: "lastPoint",
        units: [
          ["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]],
          ["second", [1, 2, 5, 10, 15, 30]],
          ["minute", [1, 2, 5, 10, 15, 30]],
          ["hour", [1, 2, 3, 4, 6, 8, 12]],
          ["day", [1, 2, 3, 4]],
          ["week", [1, 2, 3]],
          ["month", [1, 3, 6]],
          ["year", null]
        ]
      },
      dataLabels: {
        enabled: false,
        zIndex: 2
      },
      id: "highcharts-navigator-series",
      className: "highcharts-navigator-series",
      lineColor: null,
      marker: {
        enabled: false
      },
      threshold: null
    },
    xAxis: {
      overscroll: 0,
      className: "highcharts-navigator-xaxis",
      tickLength: 0,
      lineWidth: 0,
      gridLineColor: Palette_default.neutralColor10,
      gridLineWidth: 1,
      tickPixelInterval: 200,
      labels: {
        align: "left",
        style: {
          color: Palette_default.neutralColor40
        },
        x: 3,
        y: -4
      },
      crosshair: false
    },
    yAxis: {
      className: "highcharts-navigator-yaxis",
      gridLineWidth: 0,
      startOnTick: false,
      endOnTick: false,
      minPadding: 0.1,
      maxPadding: 0.1,
      labels: {
        enabled: false
      },
      crosshair: false,
      title: {
        text: null
      },
      tickLength: 0,
      tickWidth: 0
    }
  }
});
RendererRegistry_default.getRendererType().prototype.symbols["navigator-handle"] = function(_x, _y, _w, _h, options) {
  var halfWidth = (options && options.width || 0) / 2, markerPosition = Math.round(halfWidth / 3) + 0.5, height = options && options.height || 0;
  return [
    ["M", -halfWidth - 1, 0.5],
    ["L", halfWidth, 0.5],
    ["L", halfWidth, height + 0.5],
    ["L", -halfWidth - 1, height + 0.5],
    ["L", -halfWidth - 1, 0.5],
    ["M", -markerPosition, 4],
    ["L", -markerPosition, height - 3],
    ["M", markerPosition - 1, 4],
    ["L", markerPosition - 1, height - 3]
  ];
};
var Navigator = function() {
  function Navigator2(chart) {
    this.baseSeries = void 0;
    this.chart = void 0;
    this.handles = void 0;
    this.height = void 0;
    this.left = void 0;
    this.navigatorEnabled = void 0;
    this.navigatorGroup = void 0;
    this.navigatorOptions = void 0;
    this.navigatorSeries = void 0;
    this.navigatorSize = void 0;
    this.opposite = void 0;
    this.outline = void 0;
    this.outlineHeight = void 0;
    this.range = void 0;
    this.rendered = void 0;
    this.shades = void 0;
    this.size = void 0;
    this.top = void 0;
    this.xAxis = void 0;
    this.yAxis = void 0;
    this.zoomedMax = void 0;
    this.zoomedMin = void 0;
    this.init(chart);
  }
  Navigator2.prototype.drawHandle = function(x, index, inverted, verb) {
    var navigator = this, height = navigator.navigatorOptions.handles.height;
    navigator.handles[index][verb](inverted ? {
      translateX: Math.round(navigator.left + navigator.height / 2),
      translateY: Math.round(navigator.top + parseInt(x, 10) + 0.5 - height)
    } : {
      translateX: Math.round(navigator.left + parseInt(x, 10)),
      translateY: Math.round(navigator.top + navigator.height / 2 - height / 2 - 1)
    });
  };
  Navigator2.prototype.drawOutline = function(zoomedMin, zoomedMax, inverted, verb) {
    var navigator = this, maskInside = navigator.navigatorOptions.maskInside, outlineWidth = navigator.outline.strokeWidth(), halfOutline = outlineWidth / 2, outlineCorrection = outlineWidth % 2 / 2, outlineHeight = navigator.outlineHeight, scrollbarHeight = navigator.scrollbarHeight || 0, navigatorSize = navigator.size, left = navigator.left - scrollbarHeight, navigatorTop = navigator.top, verticalMin, path;
    if (inverted) {
      left -= halfOutline;
      verticalMin = navigatorTop + zoomedMax + outlineCorrection;
      zoomedMax = navigatorTop + zoomedMin + outlineCorrection;
      path = [
        ["M", left + outlineHeight, navigatorTop - scrollbarHeight - outlineCorrection],
        ["L", left + outlineHeight, verticalMin],
        ["L", left, verticalMin],
        ["L", left, zoomedMax],
        ["L", left + outlineHeight, zoomedMax],
        ["L", left + outlineHeight, navigatorTop + navigatorSize + scrollbarHeight]
      ];
      if (maskInside) {
        path.push(["M", left + outlineHeight, verticalMin - halfOutline], ["L", left + outlineHeight, zoomedMax + halfOutline]);
      }
    } else {
      zoomedMin += left + scrollbarHeight - outlineCorrection;
      zoomedMax += left + scrollbarHeight - outlineCorrection;
      navigatorTop += halfOutline;
      path = [
        ["M", left, navigatorTop],
        ["L", zoomedMin, navigatorTop],
        ["L", zoomedMin, navigatorTop + outlineHeight],
        ["L", zoomedMax, navigatorTop + outlineHeight],
        ["L", zoomedMax, navigatorTop],
        ["L", left + navigatorSize + scrollbarHeight * 2, navigatorTop]
      ];
      if (maskInside) {
        path.push(["M", zoomedMin - halfOutline, navigatorTop], ["L", zoomedMax + halfOutline, navigatorTop]);
      }
    }
    navigator.outline[verb]({
      d: path
    });
  };
  Navigator2.prototype.drawMasks = function(zoomedMin, zoomedMax, inverted, verb) {
    var navigator = this, left = navigator.left, top = navigator.top, navigatorHeight = navigator.height, height, width, x, y;
    if (inverted) {
      x = [left, left, left];
      y = [top, top + zoomedMin, top + zoomedMax];
      width = [navigatorHeight, navigatorHeight, navigatorHeight];
      height = [
        zoomedMin,
        zoomedMax - zoomedMin,
        navigator.size - zoomedMax
      ];
    } else {
      x = [left, left + zoomedMin, left + zoomedMax];
      y = [top, top, top];
      width = [
        zoomedMin,
        zoomedMax - zoomedMin,
        navigator.size - zoomedMax
      ];
      height = [navigatorHeight, navigatorHeight, navigatorHeight];
    }
    navigator.shades.forEach(function(shade, i) {
      shade[verb]({
        x: x[i],
        y: y[i],
        width: width[i],
        height: height[i]
      });
    });
  };
  Navigator2.prototype.renderElements = function() {
    var navigator = this, navigatorOptions = navigator.navigatorOptions, maskInside = navigatorOptions.maskInside, chart = navigator.chart, inverted = chart.inverted, renderer = chart.renderer, navigatorGroup, mouseCursor = {
      cursor: inverted ? "ns-resize" : "ew-resize"
    };
    navigator.navigatorGroup = navigatorGroup = renderer.g("navigator").attr({
      zIndex: 8,
      visibility: "hidden"
    }).add();
    [
      !maskInside,
      maskInside,
      !maskInside
    ].forEach(function(hasMask, index) {
      navigator.shades[index] = renderer.rect().addClass("highcharts-navigator-mask" + (index === 1 ? "-inside" : "-outside")).add(navigatorGroup);
      if (!chart.styledMode) {
        navigator.shades[index].attr({
          fill: hasMask ? navigatorOptions.maskFill : "rgba(0,0,0,0)"
        }).css(index === 1 && mouseCursor);
      }
    });
    navigator.outline = renderer.path().addClass("highcharts-navigator-outline").add(navigatorGroup);
    if (!chart.styledMode) {
      navigator.outline.attr({
        "stroke-width": navigatorOptions.outlineWidth,
        stroke: navigatorOptions.outlineColor
      });
    }
    if (navigatorOptions.handles.enabled) {
      [0, 1].forEach(function(index) {
        navigatorOptions.handles.inverted = chart.inverted;
        navigator.handles[index] = renderer.symbol(navigatorOptions.handles.symbols[index], -navigatorOptions.handles.width / 2 - 1, 0, navigatorOptions.handles.width, navigatorOptions.handles.height, navigatorOptions.handles);
        navigator.handles[index].attr({ zIndex: 7 - index }).addClass("highcharts-navigator-handle highcharts-navigator-handle-" + ["left", "right"][index]).add(navigatorGroup);
        if (!chart.styledMode) {
          var handlesOptions = navigatorOptions.handles;
          navigator.handles[index].attr({
            fill: handlesOptions.backgroundColor,
            stroke: handlesOptions.borderColor,
            "stroke-width": handlesOptions.lineWidth
          }).css(mouseCursor);
        }
      });
    }
  };
  Navigator2.prototype.update = function(options) {
    (this.series || []).forEach(function(series) {
      if (series.baseSeries) {
        delete series.baseSeries.navigatorSeries;
      }
    });
    this.destroy();
    var chartOptions = this.chart.options;
    merge37(true, chartOptions.navigator, this.options, options);
    this.init(this.chart);
  };
  Navigator2.prototype.render = function(min, max, pxMin, pxMax) {
    var navigator = this, chart = navigator.chart, navigatorWidth, scrollbarLeft, scrollbarTop, scrollbarHeight = navigator.scrollbarHeight, navigatorSize, xAxis = navigator.xAxis, pointRange = xAxis.pointRange || 0, scrollbarXAxis = xAxis.navigatorAxis.fake ? chart.xAxis[0] : xAxis, navigatorEnabled = navigator.navigatorEnabled, zoomedMin, zoomedMax, rendered = navigator.rendered, inverted = chart.inverted, verb, newMin, newMax, currentRange, minRange = chart.xAxis[0].minRange, maxRange = chart.xAxis[0].options.maxRange;
    if (this.hasDragged && !defined31(pxMin)) {
      return;
    }
    min = correctFloat10(min - pointRange / 2);
    max = correctFloat10(max + pointRange / 2);
    if (!isNumber29(min) || !isNumber29(max)) {
      if (rendered) {
        pxMin = 0;
        pxMax = pick43(xAxis.width, scrollbarXAxis.width);
      } else {
        return;
      }
    }
    navigator.left = pick43(xAxis.left, chart.plotLeft + scrollbarHeight + (inverted ? chart.plotWidth : 0));
    navigator.size = zoomedMax = navigatorSize = pick43(xAxis.len, (inverted ? chart.plotHeight : chart.plotWidth) - 2 * scrollbarHeight);
    if (inverted) {
      navigatorWidth = scrollbarHeight;
    } else {
      navigatorWidth = navigatorSize + 2 * scrollbarHeight;
    }
    pxMin = pick43(pxMin, xAxis.toPixels(min, true));
    pxMax = pick43(pxMax, xAxis.toPixels(max, true));
    if (!isNumber29(pxMin) || Math.abs(pxMin) === Infinity) {
      pxMin = 0;
      pxMax = navigatorWidth;
    }
    newMin = xAxis.toValue(pxMin, true);
    newMax = xAxis.toValue(pxMax, true);
    currentRange = Math.abs(correctFloat10(newMax - newMin));
    if (currentRange < minRange) {
      if (this.grabbedLeft) {
        pxMin = xAxis.toPixels(newMax - minRange - pointRange, true);
      } else if (this.grabbedRight) {
        pxMax = xAxis.toPixels(newMin + minRange + pointRange, true);
      }
    } else if (defined31(maxRange) && correctFloat10(currentRange - pointRange) > maxRange) {
      if (this.grabbedLeft) {
        pxMin = xAxis.toPixels(newMax - maxRange - pointRange, true);
      } else if (this.grabbedRight) {
        pxMax = xAxis.toPixels(newMin + maxRange + pointRange, true);
      }
    }
    navigator.zoomedMax = clamp10(Math.max(pxMin, pxMax), 0, zoomedMax);
    navigator.zoomedMin = clamp10(navigator.fixedWidth ? navigator.zoomedMax - navigator.fixedWidth : Math.min(pxMin, pxMax), 0, zoomedMax);
    navigator.range = navigator.zoomedMax - navigator.zoomedMin;
    zoomedMax = Math.round(navigator.zoomedMax);
    zoomedMin = Math.round(navigator.zoomedMin);
    if (navigatorEnabled) {
      navigator.navigatorGroup.attr({
        visibility: "visible"
      });
      verb = rendered && !navigator.hasDragged ? "animate" : "attr";
      navigator.drawMasks(zoomedMin, zoomedMax, inverted, verb);
      navigator.drawOutline(zoomedMin, zoomedMax, inverted, verb);
      if (navigator.navigatorOptions.handles.enabled) {
        navigator.drawHandle(zoomedMin, 0, inverted, verb);
        navigator.drawHandle(zoomedMax, 1, inverted, verb);
      }
    }
    if (navigator.scrollbar) {
      if (inverted) {
        scrollbarTop = navigator.top - scrollbarHeight;
        scrollbarLeft = navigator.left - scrollbarHeight + (navigatorEnabled || !scrollbarXAxis.opposite ? 0 : (scrollbarXAxis.titleOffset || 0) + scrollbarXAxis.axisTitleMargin);
        scrollbarHeight = navigatorSize + 2 * scrollbarHeight;
      } else {
        scrollbarTop = navigator.top + (navigatorEnabled ? navigator.height : -scrollbarHeight);
        scrollbarLeft = navigator.left - scrollbarHeight;
      }
      navigator.scrollbar.position(scrollbarLeft, scrollbarTop, navigatorWidth, scrollbarHeight);
      navigator.scrollbar.setRange(navigator.zoomedMin / (navigatorSize || 1), navigator.zoomedMax / (navigatorSize || 1));
    }
    navigator.rendered = true;
  };
  Navigator2.prototype.addMouseEvents = function() {
    var navigator = this, chart = navigator.chart, container = chart.container, eventsToUnbind = [], mouseMoveHandler, mouseUpHandler;
    navigator.mouseMoveHandler = mouseMoveHandler = function(e2) {
      navigator.onMouseMove(e2);
    };
    navigator.mouseUpHandler = mouseUpHandler = function(e2) {
      navigator.onMouseUp(e2);
    };
    eventsToUnbind = navigator.getPartsEvents("mousedown");
    eventsToUnbind.push(addEvent26(chart.renderTo, "mousemove", mouseMoveHandler), addEvent26(container.ownerDocument, "mouseup", mouseUpHandler));
    if (hasTouch3) {
      eventsToUnbind.push(addEvent26(chart.renderTo, "touchmove", mouseMoveHandler), addEvent26(container.ownerDocument, "touchend", mouseUpHandler));
      eventsToUnbind.concat(navigator.getPartsEvents("touchstart"));
    }
    navigator.eventsToUnbind = eventsToUnbind;
    if (navigator.series && navigator.series[0]) {
      eventsToUnbind.push(addEvent26(navigator.series[0].xAxis, "foundExtremes", function() {
        chart.navigator.modifyNavigatorAxisExtremes();
      }));
    }
  };
  Navigator2.prototype.getPartsEvents = function(eventName) {
    var navigator = this, events = [];
    ["shades", "handles"].forEach(function(name) {
      navigator[name].forEach(function(navigatorItem, index) {
        events.push(addEvent26(navigatorItem.element, eventName, function(e2) {
          navigator[name + "Mousedown"](e2, index);
        }));
      });
    });
    return events;
  };
  Navigator2.prototype.shadesMousedown = function(e2, index) {
    e2 = this.chart.pointer.normalize(e2);
    var navigator = this, chart = navigator.chart, xAxis = navigator.xAxis, zoomedMin = navigator.zoomedMin, navigatorPosition = navigator.left, navigatorSize = navigator.size, range = navigator.range, chartX = e2.chartX, fixedMax, fixedMin, ext, left;
    if (chart.inverted) {
      chartX = e2.chartY;
      navigatorPosition = navigator.top;
    }
    if (index === 1) {
      navigator.grabbedCenter = chartX;
      navigator.fixedWidth = range;
      navigator.dragOffset = chartX - zoomedMin;
    } else {
      left = chartX - navigatorPosition - range / 2;
      if (index === 0) {
        left = Math.max(0, left);
      } else if (index === 2 && left + range >= navigatorSize) {
        left = navigatorSize - range;
        if (navigator.reversedExtremes) {
          left -= range;
          fixedMin = navigator.getUnionExtremes().dataMin;
        } else {
          fixedMax = navigator.getUnionExtremes().dataMax;
        }
      }
      if (left !== zoomedMin) {
        navigator.fixedWidth = range;
        ext = xAxis.navigatorAxis.toFixedRange(left, left + range, fixedMin, fixedMax);
        if (defined31(ext.min)) {
          chart.xAxis[0].setExtremes(Math.min(ext.min, ext.max), Math.max(ext.min, ext.max), true, null, { trigger: "navigator" });
        }
      }
    }
  };
  Navigator2.prototype.handlesMousedown = function(e2, index) {
    e2 = this.chart.pointer.normalize(e2);
    var navigator = this, chart = navigator.chart, baseXAxis = chart.xAxis[0], reverse = navigator.reversedExtremes;
    if (index === 0) {
      navigator.grabbedLeft = true;
      navigator.otherHandlePos = navigator.zoomedMax;
      navigator.fixedExtreme = reverse ? baseXAxis.min : baseXAxis.max;
    } else {
      navigator.grabbedRight = true;
      navigator.otherHandlePos = navigator.zoomedMin;
      navigator.fixedExtreme = reverse ? baseXAxis.max : baseXAxis.min;
    }
    chart.fixedRange = null;
  };
  Navigator2.prototype.onMouseMove = function(e2) {
    var navigator = this, chart = navigator.chart, left = navigator.left, navigatorSize = navigator.navigatorSize, range = navigator.range, dragOffset = navigator.dragOffset, inverted = chart.inverted, chartX;
    if (!e2.touches || e2.touches[0].pageX !== 0) {
      e2 = chart.pointer.normalize(e2);
      chartX = e2.chartX;
      if (inverted) {
        left = navigator.top;
        chartX = e2.chartY;
      }
      if (navigator.grabbedLeft) {
        navigator.hasDragged = true;
        navigator.render(0, 0, chartX - left, navigator.otherHandlePos);
      } else if (navigator.grabbedRight) {
        navigator.hasDragged = true;
        navigator.render(0, 0, navigator.otherHandlePos, chartX - left);
      } else if (navigator.grabbedCenter) {
        navigator.hasDragged = true;
        if (chartX < dragOffset) {
          chartX = dragOffset;
        } else if (chartX > navigatorSize + dragOffset - range) {
          chartX = navigatorSize + dragOffset - range;
        }
        navigator.render(0, 0, chartX - dragOffset, chartX - dragOffset + range);
      }
      if (navigator.hasDragged && navigator.scrollbar && pick43(navigator.scrollbar.options.liveRedraw, Globals_default.svg && !isTouchDevice4 && !this.chart.isBoosting)) {
        e2.DOMType = e2.type;
        setTimeout(function() {
          navigator.onMouseUp(e2);
        }, 0);
      }
    }
  };
  Navigator2.prototype.onMouseUp = function(e2) {
    var navigator = this, chart = navigator.chart, xAxis = navigator.xAxis, scrollbar = navigator.scrollbar, DOMEvent = e2.DOMEvent || e2, inverted = chart.inverted, verb = navigator.rendered && !navigator.hasDragged ? "animate" : "attr", zoomedMax, zoomedMin, unionExtremes, fixedMin, fixedMax, ext;
    if (navigator.hasDragged && (!scrollbar || !scrollbar.hasDragged) || e2.trigger === "scrollbar") {
      unionExtremes = navigator.getUnionExtremes();
      if (navigator.zoomedMin === navigator.otherHandlePos) {
        fixedMin = navigator.fixedExtreme;
      } else if (navigator.zoomedMax === navigator.otherHandlePos) {
        fixedMax = navigator.fixedExtreme;
      }
      if (navigator.zoomedMax === navigator.size) {
        fixedMax = navigator.reversedExtremes ? unionExtremes.dataMin : unionExtremes.dataMax;
      }
      if (navigator.zoomedMin === 0) {
        fixedMin = navigator.reversedExtremes ? unionExtremes.dataMax : unionExtremes.dataMin;
      }
      ext = xAxis.navigatorAxis.toFixedRange(navigator.zoomedMin, navigator.zoomedMax, fixedMin, fixedMax);
      if (defined31(ext.min)) {
        chart.xAxis[0].setExtremes(Math.min(ext.min, ext.max), Math.max(ext.min, ext.max), true, navigator.hasDragged ? false : null, {
          trigger: "navigator",
          triggerOp: "navigator-drag",
          DOMEvent
        });
      }
    }
    if (e2.DOMType !== "mousemove" && e2.DOMType !== "touchmove") {
      navigator.grabbedLeft = navigator.grabbedRight = navigator.grabbedCenter = navigator.fixedWidth = navigator.fixedExtreme = navigator.otherHandlePos = navigator.hasDragged = navigator.dragOffset = null;
    }
    if (navigator.navigatorEnabled && isNumber29(navigator.zoomedMin) && isNumber29(navigator.zoomedMax)) {
      zoomedMin = Math.round(navigator.zoomedMin);
      zoomedMax = Math.round(navigator.zoomedMax);
      if (navigator.shades) {
        navigator.drawMasks(zoomedMin, zoomedMax, inverted, verb);
      }
      if (navigator.outline) {
        navigator.drawOutline(zoomedMin, zoomedMax, inverted, verb);
      }
      if (navigator.navigatorOptions.handles.enabled && Object.keys(navigator.handles).length === navigator.handles.length) {
        navigator.drawHandle(zoomedMin, 0, inverted, verb);
        navigator.drawHandle(zoomedMax, 1, inverted, verb);
      }
    }
  };
  Navigator2.prototype.removeEvents = function() {
    if (this.eventsToUnbind) {
      this.eventsToUnbind.forEach(function(unbind) {
        unbind();
      });
      this.eventsToUnbind = void 0;
    }
    this.removeBaseSeriesEvents();
  };
  Navigator2.prototype.removeBaseSeriesEvents = function() {
    var baseSeries = this.baseSeries || [];
    if (this.navigatorEnabled && baseSeries[0]) {
      if (this.navigatorOptions.adaptToUpdatedData !== false) {
        baseSeries.forEach(function(series) {
          removeEvent10(series, "updatedData", this.updatedDataHandler);
        }, this);
      }
      if (baseSeries[0].xAxis) {
        removeEvent10(baseSeries[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes);
      }
    }
  };
  Navigator2.prototype.init = function(chart) {
    var chartOptions = chart.options, navigatorOptions = chartOptions.navigator, navigatorEnabled = navigatorOptions.enabled, scrollbarOptions = chartOptions.scrollbar, scrollbarEnabled = scrollbarOptions.enabled, height = navigatorEnabled ? navigatorOptions.height : 0, scrollbarHeight = scrollbarEnabled ? scrollbarOptions.height : 0;
    this.handles = [];
    this.shades = [];
    this.chart = chart;
    this.setBaseSeries();
    this.height = height;
    this.scrollbarHeight = scrollbarHeight;
    this.scrollbarEnabled = scrollbarEnabled;
    this.navigatorEnabled = navigatorEnabled;
    this.navigatorOptions = navigatorOptions;
    this.scrollbarOptions = scrollbarOptions;
    this.outlineHeight = height + scrollbarHeight;
    this.opposite = pick43(navigatorOptions.opposite, Boolean(!navigatorEnabled && chart.inverted));
    var navigator = this, baseSeries = navigator.baseSeries, xAxisIndex = chart.xAxis.length, yAxisIndex = chart.yAxis.length, baseXaxis = baseSeries && baseSeries[0] && baseSeries[0].xAxis || chart.xAxis[0] || { options: {} };
    chart.isDirtyBox = true;
    if (navigator.navigatorEnabled) {
      navigator.xAxis = new Axis_default(chart, merge37({
        breaks: baseXaxis.options.breaks,
        ordinal: baseXaxis.options.ordinal
      }, navigatorOptions.xAxis, {
        id: "navigator-x-axis",
        yAxis: "navigator-y-axis",
        isX: true,
        type: "datetime",
        index: xAxisIndex,
        isInternal: true,
        offset: 0,
        keepOrdinalPadding: true,
        startOnTick: false,
        endOnTick: false,
        minPadding: 0,
        maxPadding: 0,
        zoomEnabled: false
      }, chart.inverted ? {
        offsets: [scrollbarHeight, 0, -scrollbarHeight, 0],
        width: height
      } : {
        offsets: [0, -scrollbarHeight, 0, scrollbarHeight],
        height
      }));
      navigator.yAxis = new Axis_default(chart, merge37(navigatorOptions.yAxis, {
        id: "navigator-y-axis",
        alignTicks: false,
        offset: 0,
        index: yAxisIndex,
        isInternal: true,
        reversed: pick43(navigatorOptions.yAxis && navigatorOptions.yAxis.reversed, chart.yAxis[0] && chart.yAxis[0].reversed, false),
        zoomEnabled: false
      }, chart.inverted ? {
        width: height
      } : {
        height
      }));
      if (baseSeries || navigatorOptions.series.data) {
        navigator.updateNavigatorSeries(false);
      } else if (chart.series.length === 0) {
        navigator.unbindRedraw = addEvent26(chart, "beforeRedraw", function() {
          if (chart.series.length > 0 && !navigator.series) {
            navigator.setBaseSeries();
            navigator.unbindRedraw();
          }
        });
      }
      navigator.reversedExtremes = chart.inverted && !navigator.xAxis.reversed || !chart.inverted && navigator.xAxis.reversed;
      navigator.renderElements();
      navigator.addMouseEvents();
    } else {
      navigator.xAxis = {
        chart,
        navigatorAxis: {
          fake: true
        },
        translate: function(value, reverse) {
          var axis = chart.xAxis[0], ext = axis.getExtremes(), scrollTrackWidth = axis.len - 2 * scrollbarHeight, min = numExt("min", axis.options.min, ext.dataMin), valueRange = numExt("max", axis.options.max, ext.dataMax) - min;
          return reverse ? value * valueRange / scrollTrackWidth + min : scrollTrackWidth * (value - min) / valueRange;
        },
        toPixels: function(value) {
          return this.translate(value);
        },
        toValue: function(value) {
          return this.translate(value, true);
        }
      };
      navigator.xAxis.navigatorAxis.axis = navigator.xAxis;
      navigator.xAxis.navigatorAxis.toFixedRange = NavigatorAxis_default.AdditionsClass.prototype.toFixedRange.bind(navigator.xAxis.navigatorAxis);
    }
    if (chart.options.scrollbar.enabled) {
      chart.scrollbar = navigator.scrollbar = new Scrollbar_default(chart.renderer, merge37(chart.options.scrollbar, {
        margin: navigator.navigatorEnabled ? 0 : 10,
        vertical: chart.inverted
      }), chart);
      addEvent26(navigator.scrollbar, "changed", function(e2) {
        var range = navigator.size, to = range * this.to, from = range * this.from;
        navigator.hasDragged = navigator.scrollbar.hasDragged;
        navigator.render(0, 0, from, to);
        if (this.shouldUpdateExtremes(e2.DOMType)) {
          setTimeout(function() {
            navigator.onMouseUp(e2);
          });
        }
      });
    }
    navigator.addBaseSeriesEvents();
    navigator.addChartEvents();
  };
  Navigator2.prototype.getUnionExtremes = function(returnFalseOnNoBaseSeries) {
    var baseAxis = this.chart.xAxis[0], navAxis = this.xAxis, navAxisOptions = navAxis.options, baseAxisOptions = baseAxis.options, ret;
    if (!returnFalseOnNoBaseSeries || baseAxis.dataMin !== null) {
      ret = {
        dataMin: pick43(navAxisOptions && navAxisOptions.min, numExt("min", baseAxisOptions.min, baseAxis.dataMin, navAxis.dataMin, navAxis.min)),
        dataMax: pick43(navAxisOptions && navAxisOptions.max, numExt("max", baseAxisOptions.max, baseAxis.dataMax, navAxis.dataMax, navAxis.max))
      };
    }
    return ret;
  };
  Navigator2.prototype.setBaseSeries = function(baseSeriesOptions, redraw) {
    var chart = this.chart, baseSeries = this.baseSeries = [];
    baseSeriesOptions = baseSeriesOptions || chart.options && chart.options.navigator.baseSeries || (chart.series.length ? find8(chart.series, function(s) {
      return !s.options.isInternal;
    }).index : 0);
    (chart.series || []).forEach(function(series, i) {
      if (!series.options.isInternal && (series.options.showInNavigator || (i === baseSeriesOptions || series.options.id === baseSeriesOptions) && series.options.showInNavigator !== false)) {
        baseSeries.push(series);
      }
    });
    if (this.xAxis && !this.xAxis.navigatorAxis.fake) {
      this.updateNavigatorSeries(true, redraw);
    }
  };
  Navigator2.prototype.updateNavigatorSeries = function(addEvents, redraw) {
    var navigator = this, chart = navigator.chart, baseSeries = navigator.baseSeries, baseOptions, mergedNavSeriesOptions, chartNavigatorSeriesOptions = navigator.navigatorOptions.series, baseNavigatorOptions, navSeriesMixin = {
      enableMouseTracking: false,
      index: null,
      linkedTo: null,
      group: "nav",
      padXAxis: false,
      xAxis: "navigator-x-axis",
      yAxis: "navigator-y-axis",
      showInLegend: false,
      stacking: void 0,
      isInternal: true,
      states: {
        inactive: {
          opacity: 1
        }
      }
    }, navigatorSeries = navigator.series = (navigator.series || []).filter(function(navSeries) {
      var base = navSeries.baseSeries;
      if (baseSeries.indexOf(base) < 0) {
        if (base) {
          removeEvent10(base, "updatedData", navigator.updatedDataHandler);
          delete base.navigatorSeries;
        }
        if (navSeries.chart) {
          navSeries.destroy();
        }
        return false;
      }
      return true;
    });
    if (baseSeries && baseSeries.length) {
      baseSeries.forEach(function eachBaseSeries(base) {
        var linkedNavSeries = base.navigatorSeries, userNavOptions = extend28({
          color: base.color,
          visible: base.visible
        }, !isArray16(chartNavigatorSeriesOptions) ? chartNavigatorSeriesOptions : defaultOptions10.navigator.series);
        if (linkedNavSeries && navigator.navigatorOptions.adaptToUpdatedData === false) {
          return;
        }
        navSeriesMixin.name = "Navigator " + baseSeries.length;
        baseOptions = base.options || {};
        baseNavigatorOptions = baseOptions.navigatorOptions || {};
        userNavOptions.dataLabels = splat11(userNavOptions.dataLabels);
        mergedNavSeriesOptions = merge37(baseOptions, navSeriesMixin, userNavOptions, baseNavigatorOptions);
        mergedNavSeriesOptions.pointRange = pick43(userNavOptions.pointRange, baseNavigatorOptions.pointRange, defaultOptions10.plotOptions[mergedNavSeriesOptions.type || "line"].pointRange);
        var navigatorSeriesData = baseNavigatorOptions.data || userNavOptions.data;
        navigator.hasNavigatorData = navigator.hasNavigatorData || !!navigatorSeriesData;
        mergedNavSeriesOptions.data = navigatorSeriesData || baseOptions.data && baseOptions.data.slice(0);
        if (linkedNavSeries && linkedNavSeries.options) {
          linkedNavSeries.update(mergedNavSeriesOptions, redraw);
        } else {
          base.navigatorSeries = chart.initSeries(mergedNavSeriesOptions);
          base.navigatorSeries.baseSeries = base;
          navigatorSeries.push(base.navigatorSeries);
        }
      });
    }
    if (chartNavigatorSeriesOptions.data && !(baseSeries && baseSeries.length) || isArray16(chartNavigatorSeriesOptions)) {
      navigator.hasNavigatorData = false;
      chartNavigatorSeriesOptions = splat11(chartNavigatorSeriesOptions);
      chartNavigatorSeriesOptions.forEach(function(userSeriesOptions, i) {
        navSeriesMixin.name = "Navigator " + (navigatorSeries.length + 1);
        mergedNavSeriesOptions = merge37(defaultOptions10.navigator.series, {
          color: chart.series[i] && !chart.series[i].options.isInternal && chart.series[i].color || chart.options.colors[i] || chart.options.colors[0]
        }, navSeriesMixin, userSeriesOptions);
        mergedNavSeriesOptions.data = userSeriesOptions.data;
        if (mergedNavSeriesOptions.data) {
          navigator.hasNavigatorData = true;
          navigatorSeries.push(chart.initSeries(mergedNavSeriesOptions));
        }
      });
    }
    if (addEvents) {
      this.addBaseSeriesEvents();
    }
  };
  Navigator2.prototype.addBaseSeriesEvents = function() {
    var navigator = this, baseSeries = navigator.baseSeries || [];
    if (baseSeries[0] && baseSeries[0].xAxis) {
      baseSeries[0].eventsToUnbind.push(addEvent26(baseSeries[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes));
    }
    baseSeries.forEach(function(base) {
      base.eventsToUnbind.push(addEvent26(base, "show", function() {
        if (this.navigatorSeries) {
          this.navigatorSeries.setVisible(true, false);
        }
      }));
      base.eventsToUnbind.push(addEvent26(base, "hide", function() {
        if (this.navigatorSeries) {
          this.navigatorSeries.setVisible(false, false);
        }
      }));
      if (this.navigatorOptions.adaptToUpdatedData !== false) {
        if (base.xAxis) {
          base.eventsToUnbind.push(addEvent26(base, "updatedData", this.updatedDataHandler));
        }
      }
      base.eventsToUnbind.push(addEvent26(base, "remove", function() {
        if (this.navigatorSeries) {
          erase9(navigator.series, this.navigatorSeries);
          if (defined31(this.navigatorSeries.options)) {
            this.navigatorSeries.remove(false);
          }
          delete this.navigatorSeries;
        }
      }));
    }, this);
  };
  Navigator2.prototype.getBaseSeriesMin = function(currentSeriesMin) {
    return this.baseSeries.reduce(function(min, series) {
      return Math.min(min, series.xData ? series.xData[0] : min);
    }, currentSeriesMin);
  };
  Navigator2.prototype.modifyNavigatorAxisExtremes = function() {
    var xAxis = this.xAxis, unionExtremes;
    if (typeof xAxis.getExtremes !== "undefined") {
      unionExtremes = this.getUnionExtremes(true);
      if (unionExtremes && (unionExtremes.dataMin !== xAxis.min || unionExtremes.dataMax !== xAxis.max)) {
        xAxis.min = unionExtremes.dataMin;
        xAxis.max = unionExtremes.dataMax;
      }
    }
  };
  Navigator2.prototype.modifyBaseAxisExtremes = function() {
    var baseXAxis = this, navigator = baseXAxis.chart.navigator, baseExtremes = baseXAxis.getExtremes(), baseMin = baseExtremes.min, baseMax = baseExtremes.max, baseDataMin = baseExtremes.dataMin, baseDataMax = baseExtremes.dataMax, range = baseMax - baseMin, stickToMin = navigator.stickToMin, stickToMax = navigator.stickToMax, overscroll = pick43(baseXAxis.options.overscroll, 0), newMax, newMin, navigatorSeries = navigator.series && navigator.series[0], hasSetExtremes = !!baseXAxis.setExtremes, unmutable = baseXAxis.eventArgs && baseXAxis.eventArgs.trigger === "rangeSelectorButton";
    if (!unmutable) {
      if (stickToMin) {
        newMin = baseDataMin;
        newMax = newMin + range;
      }
      if (stickToMax) {
        newMax = baseDataMax + overscroll;
        if (!stickToMin) {
          newMin = Math.max(baseDataMin, newMax - range, navigator.getBaseSeriesMin(navigatorSeries && navigatorSeries.xData ? navigatorSeries.xData[0] : -Number.MAX_VALUE));
        }
      }
      if (hasSetExtremes && (stickToMin || stickToMax)) {
        if (isNumber29(newMin)) {
          baseXAxis.min = baseXAxis.userMin = newMin;
          baseXAxis.max = baseXAxis.userMax = newMax;
        }
      }
    }
    navigator.stickToMin = navigator.stickToMax = null;
  };
  Navigator2.prototype.updatedDataHandler = function() {
    var navigator = this.chart.navigator, baseSeries = this, navigatorSeries = this.navigatorSeries;
    navigator.stickToMax = navigator.reversedExtremes ? Math.round(navigator.zoomedMin) === 0 : Math.round(navigator.zoomedMax) >= Math.round(navigator.size);
    navigator.stickToMin = navigator.shouldStickToMin(baseSeries, navigator);
    if (navigatorSeries && !navigator.hasNavigatorData) {
      navigatorSeries.options.pointStart = baseSeries.xData[0];
      navigatorSeries.setData(baseSeries.options.data, false, null, false);
    }
  };
  Navigator2.prototype.shouldStickToMin = function(baseSeries, navigator) {
    var xDataMin = navigator.getBaseSeriesMin(baseSeries.xData[0]), xAxis = baseSeries.xAxis, max = xAxis.max, min = xAxis.min, range = xAxis.options.range;
    var stickToMin = true;
    if (isNumber29(max) && isNumber29(min)) {
      if (range && max - xDataMin > 0) {
        stickToMin = max - xDataMin < range && !this.chart.fixedRange;
      } else {
        stickToMin = min <= xDataMin;
      }
    } else {
      stickToMin = false;
    }
    return stickToMin;
  };
  Navigator2.prototype.addChartEvents = function() {
    if (!this.eventsToUnbind) {
      this.eventsToUnbind = [];
    }
    this.eventsToUnbind.push(addEvent26(this.chart, "redraw", function() {
      var navigator = this.navigator, xAxis = navigator && (navigator.baseSeries && navigator.baseSeries[0] && navigator.baseSeries[0].xAxis || this.xAxis[0]);
      if (xAxis) {
        navigator.render(xAxis.min, xAxis.max);
      }
    }), addEvent26(this.chart, "getMargins", function() {
      var chart = this, navigator = chart.navigator, marginName = navigator.opposite ? "plotTop" : "marginBottom";
      if (chart.inverted) {
        marginName = navigator.opposite ? "marginRight" : "plotLeft";
      }
      chart[marginName] = (chart[marginName] || 0) + (navigator.navigatorEnabled || !chart.inverted ? navigator.outlineHeight : 0) + navigator.navigatorOptions.margin;
    }));
  };
  Navigator2.prototype.destroy = function() {
    this.removeEvents();
    if (this.xAxis) {
      erase9(this.chart.xAxis, this.xAxis);
      erase9(this.chart.axes, this.xAxis);
    }
    if (this.yAxis) {
      erase9(this.chart.yAxis, this.yAxis);
      erase9(this.chart.axes, this.yAxis);
    }
    (this.series || []).forEach(function(s) {
      if (s.destroy) {
        s.destroy();
      }
    });
    [
      "series",
      "xAxis",
      "yAxis",
      "shades",
      "outline",
      "scrollbarTrack",
      "scrollbarRifles",
      "scrollbarGroup",
      "scrollbar",
      "navigatorGroup",
      "rendered"
    ].forEach(function(prop) {
      if (this[prop] && this[prop].destroy) {
        this[prop].destroy();
      }
      this[prop] = null;
    }, this);
    [this.handles].forEach(function(coll) {
      destroyObjectProperties9(coll);
    }, this);
  };
  return Navigator2;
}();
if (!Globals_default.Navigator) {
  Globals_default.Navigator = Navigator;
  NavigatorAxis_default.compose(Axis_default);
  addEvent26(Chart_default, "beforeShowResetZoom", function() {
    var chartOptions = this.options, navigator = chartOptions.navigator, rangeSelector = chartOptions.rangeSelector;
    if ((navigator && navigator.enabled || rangeSelector && rangeSelector.enabled) && (!isTouchDevice4 && chartOptions.chart.zoomType === "x" || isTouchDevice4 && chartOptions.chart.pinchType === "x")) {
      return false;
    }
  });
  addEvent26(Chart_default, "beforeRender", function() {
    var options = this.options;
    if (options.navigator.enabled || options.scrollbar.enabled) {
      this.scroller = this.navigator = new Navigator(this);
    }
  });
  addEvent26(Chart_default, "afterSetChartSize", function() {
    var legend = this.legend, navigator = this.navigator, scrollbarHeight, legendOptions, xAxis, yAxis;
    if (navigator) {
      legendOptions = legend && legend.options;
      xAxis = navigator.xAxis;
      yAxis = navigator.yAxis;
      scrollbarHeight = navigator.scrollbarHeight;
      if (this.inverted) {
        navigator.left = navigator.opposite ? this.chartWidth - scrollbarHeight - navigator.height : this.spacing[3] + scrollbarHeight;
        navigator.top = this.plotTop + scrollbarHeight;
      } else {
        navigator.left = pick43(xAxis.left, this.plotLeft + scrollbarHeight);
        navigator.top = navigator.navigatorOptions.top || this.chartHeight - navigator.height - scrollbarHeight - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (legendOptions && legendOptions.verticalAlign === "bottom" && legendOptions.layout !== "proximate" && legendOptions.enabled && !legendOptions.floating ? legend.legendHeight + pick43(legendOptions.margin, 10) : 0) - (this.titleOffset ? this.titleOffset[2] : 0);
      }
      if (xAxis && yAxis) {
        if (this.inverted) {
          xAxis.options.left = yAxis.options.left = navigator.left;
        } else {
          xAxis.options.top = yAxis.options.top = navigator.top;
        }
        xAxis.setAxisSize();
        yAxis.setAxisSize();
      }
    }
  });
  addEvent26(Chart_default, "update", function(e2) {
    var navigatorOptions = e2.options.navigator || {}, scrollbarOptions = e2.options.scrollbar || {};
    if (!this.navigator && !this.scroller && (navigatorOptions.enabled || scrollbarOptions.enabled)) {
      merge37(true, this.options.navigator, navigatorOptions);
      merge37(true, this.options.scrollbar, scrollbarOptions);
      delete e2.options.navigator;
      delete e2.options.scrollbar;
    }
  });
  addEvent26(Chart_default, "afterUpdate", function(event) {
    if (!this.navigator && !this.scroller && (this.options.navigator.enabled || this.options.scrollbar.enabled)) {
      this.scroller = this.navigator = new Navigator(this);
      if (pick43(event.redraw, true)) {
        this.redraw(event.animation);
      }
    }
  });
  addEvent26(Chart_default, "afterAddSeries", function() {
    if (this.navigator) {
      this.navigator.setBaseSeries(null, false);
    }
  });
  addEvent26(Series_default, "afterUpdate", function() {
    if (this.chart.navigator && !this.options.isInternal) {
      this.chart.navigator.setBaseSeries(null, false);
    }
  });
  Chart_default.prototype.callbacks.push(function(chart) {
    var extremes, navigator = chart.navigator;
    if (navigator && chart.xAxis[0]) {
      extremes = chart.xAxis[0].getExtremes();
      navigator.render(extremes.min, extremes.max);
    }
  });
}
Globals_default.Navigator = Navigator;
var Navigator_default = Globals_default.Navigator;

// node_modules/highcharts/es-modules/Extensions/RangeSelector.js
var defaultOptions11 = DefaultOptions_default.defaultOptions;
var addEvent27 = Utilities_default.addEvent;
var createElement9 = Utilities_default.createElement;
var css13 = Utilities_default.css;
var defined32 = Utilities_default.defined;
var destroyObjectProperties10 = Utilities_default.destroyObjectProperties;
var discardElement6 = Utilities_default.discardElement;
var extend29 = Utilities_default.extend;
var find9 = Utilities_default.find;
var fireEvent19 = Utilities_default.fireEvent;
var isNumber30 = Utilities_default.isNumber;
var merge38 = Utilities_default.merge;
var objectEach25 = Utilities_default.objectEach;
var pad3 = Utilities_default.pad;
var pick44 = Utilities_default.pick;
var pInt8 = Utilities_default.pInt;
var splat12 = Utilities_default.splat;
extend29(defaultOptions11, {
  rangeSelector: {
    allButtonsEnabled: false,
    buttons: void 0,
    buttonSpacing: 5,
    dropdown: "responsive",
    enabled: void 0,
    verticalAlign: "top",
    buttonTheme: {
      width: 28,
      height: 18,
      padding: 2,
      zIndex: 7
    },
    floating: false,
    x: 0,
    y: 0,
    height: void 0,
    inputBoxBorderColor: "none",
    inputBoxHeight: 17,
    inputBoxWidth: void 0,
    inputDateFormat: "%b %e, %Y",
    inputDateParser: void 0,
    inputEditDateFormat: "%Y-%m-%d",
    inputEnabled: true,
    inputPosition: {
      align: "right",
      x: 0,
      y: 0
    },
    inputSpacing: 5,
    selected: void 0,
    buttonPosition: {
      align: "left",
      x: 0,
      y: 0
    },
    inputStyle: {
      color: Palette_default.highlightColor80,
      cursor: "pointer"
    },
    labelStyle: {
      color: Palette_default.neutralColor60
    }
  }
});
extend29(defaultOptions11.lang, {
  rangeSelectorZoom: "Zoom",
  rangeSelectorFrom: "",
  rangeSelectorTo: "\u2192"
});
var RangeSelector = function() {
  function RangeSelector2(chart) {
    this.buttons = void 0;
    this.buttonOptions = RangeSelector2.prototype.defaultButtons;
    this.initialButtonGroupWidth = 0;
    this.options = void 0;
    this.chart = chart;
    this.init(chart);
  }
  RangeSelector2.prototype.clickButton = function(i, redraw) {
    var rangeSelector = this, chart = rangeSelector.chart, rangeOptions = rangeSelector.buttonOptions[i], baseAxis = chart.xAxis[0], unionExtremes = chart.scroller && chart.scroller.getUnionExtremes() || baseAxis || {}, dataMin = unionExtremes.dataMin, dataMax = unionExtremes.dataMax, newMin, newMax = baseAxis && Math.round(Math.min(baseAxis.max, pick44(dataMax, baseAxis.max))), type = rangeOptions.type, baseXAxisOptions, range = rangeOptions._range, rangeMin, minSetting, rangeSetting, ctx, ytdExtremes, dataGrouping2 = rangeOptions.dataGrouping;
    if (dataMin === null || dataMax === null) {
      return;
    }
    chart.fixedRange = range;
    rangeSelector.setSelected(i);
    if (dataGrouping2) {
      this.forcedDataGrouping = true;
      Axis_default.prototype.setDataGrouping.call(baseAxis || { chart: this.chart }, dataGrouping2, false);
      this.frozenStates = rangeOptions.preserveDataGrouping;
    }
    if (type === "month" || type === "year") {
      if (!baseAxis) {
        range = rangeOptions;
      } else {
        ctx = {
          range: rangeOptions,
          max: newMax,
          chart,
          dataMin,
          dataMax
        };
        newMin = baseAxis.minFromRange.call(ctx);
        if (isNumber30(ctx.newMax)) {
          newMax = ctx.newMax;
        }
      }
    } else if (range) {
      newMin = Math.max(newMax - range, dataMin);
      newMax = Math.min(newMin + range, dataMax);
    } else if (type === "ytd") {
      if (baseAxis) {
        if (typeof dataMax === "undefined") {
          dataMin = Number.MAX_VALUE;
          dataMax = Number.MIN_VALUE;
          chart.series.forEach(function(series) {
            var xData = series.xData;
            dataMin = Math.min(xData[0], dataMin);
            dataMax = Math.max(xData[xData.length - 1], dataMax);
          });
          redraw = false;
        }
        ytdExtremes = rangeSelector.getYTDExtremes(dataMax, dataMin, chart.time.useUTC);
        newMin = rangeMin = ytdExtremes.min;
        newMax = ytdExtremes.max;
      } else {
        rangeSelector.deferredYTDClick = i;
        return;
      }
    } else if (type === "all" && baseAxis) {
      if (chart.navigator && chart.navigator.baseSeries[0]) {
        chart.navigator.baseSeries[0].xAxis.options.range = void 0;
      }
      newMin = dataMin;
      newMax = dataMax;
    }
    if (defined32(newMin)) {
      newMin += rangeOptions._offsetMin;
    }
    if (defined32(newMax)) {
      newMax += rangeOptions._offsetMax;
    }
    if (this.dropdown) {
      this.dropdown.selectedIndex = i + 1;
    }
    if (!baseAxis) {
      baseXAxisOptions = splat12(chart.options.xAxis)[0];
      rangeSetting = baseXAxisOptions.range;
      baseXAxisOptions.range = range;
      minSetting = baseXAxisOptions.min;
      baseXAxisOptions.min = rangeMin;
      addEvent27(chart, "load", function resetMinAndRange() {
        baseXAxisOptions.range = rangeSetting;
        baseXAxisOptions.min = minSetting;
      });
    } else {
      baseAxis.setExtremes(newMin, newMax, pick44(redraw, true), void 0, {
        trigger: "rangeSelectorButton",
        rangeSelectorButton: rangeOptions
      });
    }
    fireEvent19(this, "afterBtnClick");
  };
  RangeSelector2.prototype.setSelected = function(selected) {
    this.selected = this.options.selected = selected;
  };
  RangeSelector2.prototype.init = function(chart) {
    var rangeSelector = this, options = chart.options.rangeSelector, buttonOptions = options.buttons || rangeSelector.defaultButtons.slice(), selectedOption = options.selected, blurInputs = function() {
      var minInput = rangeSelector.minInput, maxInput = rangeSelector.maxInput;
      if (minInput && minInput.blur) {
        fireEvent19(minInput, "blur");
      }
      if (maxInput && maxInput.blur) {
        fireEvent19(maxInput, "blur");
      }
    };
    rangeSelector.chart = chart;
    rangeSelector.options = options;
    rangeSelector.buttons = [];
    rangeSelector.buttonOptions = buttonOptions;
    this.eventsToUnbind = [];
    this.eventsToUnbind.push(addEvent27(chart.container, "mousedown", blurInputs));
    this.eventsToUnbind.push(addEvent27(chart, "resize", blurInputs));
    buttonOptions.forEach(rangeSelector.computeButtonRange);
    if (typeof selectedOption !== "undefined" && buttonOptions[selectedOption]) {
      this.clickButton(selectedOption, false);
    }
    this.eventsToUnbind.push(addEvent27(chart, "load", function() {
      if (chart.xAxis && chart.xAxis[0]) {
        addEvent27(chart.xAxis[0], "setExtremes", function(e2) {
          if (this.max - this.min !== chart.fixedRange && e2.trigger !== "rangeSelectorButton" && e2.trigger !== "updatedData" && rangeSelector.forcedDataGrouping && !rangeSelector.frozenStates) {
            this.setDataGrouping(false, false);
          }
        });
      }
    }));
  };
  RangeSelector2.prototype.updateButtonStates = function() {
    var rangeSelector = this, chart = this.chart, dropdown = this.dropdown, baseAxis = chart.xAxis[0], actualRange = Math.round(baseAxis.max - baseAxis.min), hasNoData = !baseAxis.hasVisibleSeries, day = 24 * 36e5, unionExtremes = chart.scroller && chart.scroller.getUnionExtremes() || baseAxis, dataMin = unionExtremes.dataMin, dataMax = unionExtremes.dataMax, ytdExtremes = rangeSelector.getYTDExtremes(dataMax, dataMin, chart.time.useUTC), ytdMin = ytdExtremes.min, ytdMax = ytdExtremes.max, selected = rangeSelector.selected, selectedExists = isNumber30(selected), allButtonsEnabled = rangeSelector.options.allButtonsEnabled, buttons = rangeSelector.buttons;
    rangeSelector.buttonOptions.forEach(function(rangeOptions, i) {
      var range = rangeOptions._range, type = rangeOptions.type, count = rangeOptions.count || 1, button = buttons[i], state = 0, disable, select, offsetRange = rangeOptions._offsetMax - rangeOptions._offsetMin, isSelected = i === selected, isTooGreatRange = range > dataMax - dataMin, isTooSmallRange = range < baseAxis.minRange, isYTDButNotSelected = false, isAllButAlreadyShowingAll = false, isSameRange = range === actualRange;
      if ((type === "month" || type === "year") && actualRange + 36e5 >= { month: 28, year: 365 }[type] * day * count - offsetRange && actualRange - 36e5 <= { month: 31, year: 366 }[type] * day * count + offsetRange) {
        isSameRange = true;
      } else if (type === "ytd") {
        isSameRange = ytdMax - ytdMin + offsetRange === actualRange;
        isYTDButNotSelected = !isSelected;
      } else if (type === "all") {
        isSameRange = baseAxis.max - baseAxis.min >= dataMax - dataMin;
        isAllButAlreadyShowingAll = !isSelected && selectedExists && isSameRange;
      }
      disable = !allButtonsEnabled && (isTooGreatRange || isTooSmallRange || isAllButAlreadyShowingAll || hasNoData);
      select = isSelected && isSameRange || isSameRange && !selectedExists && !isYTDButNotSelected || isSelected && rangeSelector.frozenStates;
      if (disable) {
        state = 3;
      } else if (select) {
        selectedExists = true;
        state = 2;
      }
      if (button.state !== state) {
        button.setState(state);
        if (dropdown) {
          dropdown.options[i + 1].disabled = disable;
          if (state === 2) {
            dropdown.selectedIndex = i + 1;
          }
        }
        if (state === 0 && selected === i) {
          rangeSelector.setSelected();
        }
      }
    });
  };
  RangeSelector2.prototype.computeButtonRange = function(rangeOptions) {
    var type = rangeOptions.type, count = rangeOptions.count || 1, fixedTimes = {
      millisecond: 1,
      second: 1e3,
      minute: 60 * 1e3,
      hour: 3600 * 1e3,
      day: 24 * 3600 * 1e3,
      week: 7 * 24 * 3600 * 1e3
    };
    if (fixedTimes[type]) {
      rangeOptions._range = fixedTimes[type] * count;
    } else if (type === "month" || type === "year") {
      rangeOptions._range = {
        month: 30,
        year: 365
      }[type] * 24 * 36e5 * count;
    }
    rangeOptions._offsetMin = pick44(rangeOptions.offsetMin, 0);
    rangeOptions._offsetMax = pick44(rangeOptions.offsetMax, 0);
    rangeOptions._range += rangeOptions._offsetMax - rangeOptions._offsetMin;
  };
  RangeSelector2.prototype.getInputValue = function(name) {
    var input = name === "min" ? this.minInput : this.maxInput;
    var options = this.chart.options.rangeSelector;
    var time = this.chart.time;
    if (input) {
      return (input.type === "text" && options.inputDateParser || this.defaultInputDateParser)(input.value, time.useUTC, time);
    }
    return 0;
  };
  RangeSelector2.prototype.setInputValue = function(name, inputTime) {
    var options = this.options, time = this.chart.time, input = name === "min" ? this.minInput : this.maxInput, dateBox = name === "min" ? this.minDateBox : this.maxDateBox;
    if (input) {
      var hcTimeAttr = input.getAttribute("data-hc-time");
      var updatedTime = defined32(hcTimeAttr) ? Number(hcTimeAttr) : void 0;
      if (defined32(inputTime)) {
        var previousTime = updatedTime;
        if (defined32(previousTime)) {
          input.setAttribute("data-hc-time-previous", previousTime);
        }
        input.setAttribute("data-hc-time", inputTime);
        updatedTime = inputTime;
      }
      input.value = time.dateFormat(this.inputTypeFormats[input.type] || options.inputEditDateFormat, updatedTime);
      if (dateBox) {
        dateBox.attr({
          text: time.dateFormat(options.inputDateFormat, updatedTime)
        });
      }
    }
  };
  RangeSelector2.prototype.setInputExtremes = function(name, min, max) {
    var input = name === "min" ? this.minInput : this.maxInput;
    if (input) {
      var format13 = this.inputTypeFormats[input.type];
      var time = this.chart.time;
      if (format13) {
        var newMin = time.dateFormat(format13, min);
        if (input.min !== newMin) {
          input.min = newMin;
        }
        var newMax = time.dateFormat(format13, max);
        if (input.max !== newMax) {
          input.max = newMax;
        }
      }
    }
  };
  RangeSelector2.prototype.showInput = function(name) {
    var dateBox = name === "min" ? this.minDateBox : this.maxDateBox;
    var input = name === "min" ? this.minInput : this.maxInput;
    if (input && dateBox && this.inputGroup) {
      var isTextInput = input.type === "text";
      var _a15 = this.inputGroup, translateX = _a15.translateX, translateY = _a15.translateY;
      var inputBoxWidth = this.options.inputBoxWidth;
      css13(input, {
        width: isTextInput ? dateBox.width + (inputBoxWidth ? -2 : 20) + "px" : "auto",
        height: isTextInput ? dateBox.height - 2 + "px" : "auto",
        border: "2px solid silver"
      });
      if (isTextInput && inputBoxWidth) {
        css13(input, {
          left: translateX + dateBox.x + "px",
          top: translateY + "px"
        });
      } else {
        css13(input, {
          left: Math.min(Math.round(dateBox.x + translateX - (input.offsetWidth - dateBox.width) / 2), this.chart.chartWidth - input.offsetWidth) + "px",
          top: translateY - (input.offsetHeight - dateBox.height) / 2 + "px"
        });
      }
    }
  };
  RangeSelector2.prototype.hideInput = function(name) {
    var input = name === "min" ? this.minInput : this.maxInput;
    if (input) {
      css13(input, {
        top: "-9999em",
        border: 0,
        width: "1px",
        height: "1px"
      });
    }
  };
  RangeSelector2.prototype.defaultInputDateParser = function(inputDate, useUTC, time) {
    var hasTimezone = function(str) {
      return str.length > 6 && (str.lastIndexOf("-") === str.length - 6 || str.lastIndexOf("+") === str.length - 6);
    };
    var input = inputDate.split("/").join("-").split(" ").join("T");
    if (input.indexOf("T") === -1) {
      input += "T00:00";
    }
    if (useUTC) {
      input += "Z";
    } else if (Globals_default.isSafari && !hasTimezone(input)) {
      var offset3 = new Date(input).getTimezoneOffset() / 60;
      input += offset3 <= 0 ? "+" + pad3(-offset3) + ":00" : "-" + pad3(offset3) + ":00";
    }
    var date = Date.parse(input);
    if (!isNumber30(date)) {
      var parts = inputDate.split("-");
      date = Date.UTC(pInt8(parts[0]), pInt8(parts[1]) - 1, pInt8(parts[2]));
    }
    if (time && useUTC && isNumber30(date)) {
      date += time.getTimezoneOffset(date);
    }
    return date;
  };
  RangeSelector2.prototype.drawInput = function(name) {
    var _a15 = this, chart = _a15.chart, div = _a15.div, inputGroup = _a15.inputGroup;
    var rangeSelector = this, chartStyle = chart.renderer.style || {}, renderer = chart.renderer, options = chart.options.rangeSelector, lang2 = defaultOptions11.lang, isMin = name === "min";
    function updateExtremes() {
      var value = rangeSelector.getInputValue(name), chartAxis = chart.xAxis[0], dataAxis = chart.scroller && chart.scroller.xAxis ? chart.scroller.xAxis : chartAxis, dataMin = dataAxis.dataMin, dataMax = dataAxis.dataMax;
      var maxInput = rangeSelector.maxInput, minInput = rangeSelector.minInput;
      if (value !== Number(input.getAttribute("data-hc-time-previous")) && isNumber30(value)) {
        input.setAttribute("data-hc-time-previous", value);
        if (isMin && maxInput && isNumber30(dataMin)) {
          if (value > Number(maxInput.getAttribute("data-hc-time"))) {
            value = void 0;
          } else if (value < dataMin) {
            value = dataMin;
          }
        } else if (minInput && isNumber30(dataMax)) {
          if (value < Number(minInput.getAttribute("data-hc-time"))) {
            value = void 0;
          } else if (value > dataMax) {
            value = dataMax;
          }
        }
        if (typeof value !== "undefined") {
          chartAxis.setExtremes(isMin ? value : chartAxis.min, isMin ? chartAxis.max : value, void 0, void 0, { trigger: "rangeSelectorInput" });
        }
      }
    }
    var text = lang2[isMin ? "rangeSelectorFrom" : "rangeSelectorTo"] || "";
    var label = renderer.label(text, 0).addClass("highcharts-range-label").attr({
      padding: text ? 2 : 0,
      height: text ? options.inputBoxHeight : 0
    }).add(inputGroup);
    var dateBox = renderer.label("", 0).addClass("highcharts-range-input").attr({
      padding: 2,
      width: options.inputBoxWidth,
      height: options.inputBoxHeight,
      "text-align": "center"
    }).on("click", function() {
      rangeSelector.showInput(name);
      rangeSelector[name + "Input"].focus();
    });
    if (!chart.styledMode) {
      dateBox.attr({
        stroke: options.inputBoxBorderColor,
        "stroke-width": 1
      });
    }
    dateBox.add(inputGroup);
    var input = createElement9("input", {
      name,
      className: "highcharts-range-selector"
    }, void 0, div);
    input.setAttribute("type", preferredInputType(options.inputDateFormat || "%b %e, %Y"));
    if (!chart.styledMode) {
      label.css(merge38(chartStyle, options.labelStyle));
      dateBox.css(merge38({
        color: Palette_default.neutralColor80
      }, chartStyle, options.inputStyle));
      css13(input, extend29({
        position: "absolute",
        border: 0,
        boxShadow: "0 0 15px rgba(0,0,0,0.3)",
        width: "1px",
        height: "1px",
        padding: 0,
        textAlign: "center",
        fontSize: chartStyle.fontSize,
        fontFamily: chartStyle.fontFamily,
        top: "-9999em"
      }, options.inputStyle));
    }
    input.onfocus = function() {
      rangeSelector.showInput(name);
    };
    input.onblur = function() {
      if (input === Globals_default.doc.activeElement) {
        updateExtremes();
      }
      rangeSelector.hideInput(name);
      rangeSelector.setInputValue(name);
      input.blur();
    };
    var keyDown = false;
    input.onchange = function() {
      if (!keyDown) {
        updateExtremes();
        rangeSelector.hideInput(name);
        input.blur();
      }
    };
    input.onkeypress = function(event) {
      if (event.keyCode === 13) {
        updateExtremes();
      }
    };
    input.onkeydown = function(event) {
      keyDown = true;
      if (event.keyCode === 38 || event.keyCode === 40) {
        updateExtremes();
      }
    };
    input.onkeyup = function() {
      keyDown = false;
    };
    return { dateBox, input, label };
  };
  RangeSelector2.prototype.getPosition = function() {
    var chart = this.chart, options = chart.options.rangeSelector, top = options.verticalAlign === "top" ? chart.plotTop - chart.axisOffset[0] : 0;
    return {
      buttonTop: top + options.buttonPosition.y,
      inputTop: top + options.inputPosition.y - 10
    };
  };
  RangeSelector2.prototype.getYTDExtremes = function(dataMax, dataMin, useUTC) {
    var time = this.chart.time, min, now = new time.Date(dataMax), year = time.get("FullYear", now), startOfYear = useUTC ? time.Date.UTC(year, 0, 1) : +new time.Date(year, 0, 1);
    min = Math.max(dataMin, startOfYear);
    var ts = now.getTime();
    return {
      max: Math.min(dataMax || ts, ts),
      min
    };
  };
  RangeSelector2.prototype.render = function(min, max) {
    var chart = this.chart, renderer = chart.renderer, container = chart.container, chartOptions = chart.options, options = chartOptions.rangeSelector, inputsZIndex = pick44(chartOptions.chart.style && chartOptions.chart.style.zIndex, 0) + 1, inputEnabled = options.inputEnabled, rendered = this.rendered;
    if (options.enabled === false) {
      return;
    }
    if (!rendered) {
      this.group = renderer.g("range-selector-group").attr({
        zIndex: 7
      }).add();
      this.div = createElement9("div", void 0, {
        position: "relative",
        height: 0,
        zIndex: inputsZIndex
      });
      if (this.buttonOptions.length) {
        this.renderButtons();
      }
      if (container.parentNode) {
        container.parentNode.insertBefore(this.div, container);
      }
      if (inputEnabled) {
        this.inputGroup = renderer.g("input-group").add(this.group);
        var minElems = this.drawInput("min");
        this.minDateBox = minElems.dateBox;
        this.minLabel = minElems.label;
        this.minInput = minElems.input;
        var maxElems = this.drawInput("max");
        this.maxDateBox = maxElems.dateBox;
        this.maxLabel = maxElems.label;
        this.maxInput = maxElems.input;
      }
    }
    if (inputEnabled) {
      this.setInputValue("min", min);
      this.setInputValue("max", max);
      var unionExtremes = chart.scroller && chart.scroller.getUnionExtremes() || chart.xAxis[0] || {};
      if (defined32(unionExtremes.dataMin) && defined32(unionExtremes.dataMax)) {
        var minRange = chart.xAxis[0].minRange || 0;
        this.setInputExtremes("min", unionExtremes.dataMin, Math.min(unionExtremes.dataMax, this.getInputValue("max")) - minRange);
        this.setInputExtremes("max", Math.max(unionExtremes.dataMin, this.getInputValue("min")) + minRange, unionExtremes.dataMax);
      }
      if (this.inputGroup) {
        var x_1 = 0;
        [
          this.minLabel,
          this.minDateBox,
          this.maxLabel,
          this.maxDateBox
        ].forEach(function(label) {
          if (label) {
            var width = label.getBBox().width;
            if (width) {
              label.attr({ x: x_1 });
              x_1 += width + options.inputSpacing;
            }
          }
        });
      }
    }
    this.alignElements();
    this.rendered = true;
  };
  RangeSelector2.prototype.renderButtons = function() {
    var _this = this;
    var _a15 = this, buttons = _a15.buttons, chart = _a15.chart, options = _a15.options;
    var lang2 = defaultOptions11.lang;
    var renderer = chart.renderer;
    var buttonTheme = merge38(options.buttonTheme);
    var states = buttonTheme && buttonTheme.states;
    var width = buttonTheme.width || 28;
    delete buttonTheme.width;
    delete buttonTheme.states;
    this.buttonGroup = renderer.g("range-selector-buttons").add(this.group);
    var dropdown = this.dropdown = createElement9("select", void 0, {
      position: "absolute",
      width: "1px",
      height: "1px",
      padding: 0,
      border: 0,
      top: "-9999em",
      cursor: "pointer",
      opacity: 1e-4
    }, this.div);
    addEvent27(dropdown, "touchstart", function() {
      dropdown.style.fontSize = "16px";
    });
    [
      [Globals_default.isMS ? "mouseover" : "mouseenter"],
      [Globals_default.isMS ? "mouseout" : "mouseleave"],
      ["change", "click"]
    ].forEach(function(_a16) {
      var from = _a16[0], to = _a16[1];
      addEvent27(dropdown, from, function() {
        var button = buttons[_this.currentButtonIndex()];
        if (button) {
          fireEvent19(button.element, to || from);
        }
      });
    });
    this.zoomText = renderer.label(lang2 && lang2.rangeSelectorZoom || "", 0).attr({
      padding: options.buttonTheme.padding,
      height: options.buttonTheme.height,
      paddingLeft: 0,
      paddingRight: 0
    }).add(this.buttonGroup);
    if (!this.chart.styledMode) {
      this.zoomText.css(options.labelStyle);
      buttonTheme["stroke-width"] = pick44(buttonTheme["stroke-width"], 0);
    }
    createElement9("option", {
      textContent: this.zoomText.textStr,
      disabled: true
    }, void 0, dropdown);
    this.buttonOptions.forEach(function(rangeOptions, i) {
      createElement9("option", {
        textContent: rangeOptions.title || rangeOptions.text
      }, void 0, dropdown);
      buttons[i] = renderer.button(rangeOptions.text, 0, 0, function(e2) {
        var buttonEvents = rangeOptions.events && rangeOptions.events.click, callDefaultEvent;
        if (buttonEvents) {
          callDefaultEvent = buttonEvents.call(rangeOptions, e2);
        }
        if (callDefaultEvent !== false) {
          _this.clickButton(i);
        }
        _this.isActive = true;
      }, buttonTheme, states && states.hover, states && states.select, states && states.disabled).attr({
        "text-align": "center",
        width
      }).add(_this.buttonGroup);
      if (rangeOptions.title) {
        buttons[i].attr("title", rangeOptions.title);
      }
    });
  };
  RangeSelector2.prototype.alignElements = function() {
    var _this = this;
    var _a15 = this, buttonGroup = _a15.buttonGroup, buttons = _a15.buttons, chart = _a15.chart, group = _a15.group, inputGroup = _a15.inputGroup, options = _a15.options, zoomText = _a15.zoomText;
    var chartOptions = chart.options;
    var navButtonOptions = chartOptions.exporting && chartOptions.exporting.enabled !== false && chartOptions.navigation && chartOptions.navigation.buttonOptions;
    var buttonPosition = options.buttonPosition, inputPosition = options.inputPosition, verticalAlign = options.verticalAlign;
    var getXOffsetForExportButton = function(group2, position) {
      if (navButtonOptions && _this.titleCollision(chart) && verticalAlign === "top" && position.align === "right" && position.y - group2.getBBox().height - 12 < (navButtonOptions.y || 0) + (navButtonOptions.height || 0) + chart.spacing[0]) {
        return -40;
      }
      return 0;
    };
    var plotLeft = chart.plotLeft;
    if (group && buttonPosition && inputPosition) {
      var translateX = buttonPosition.x - chart.spacing[3];
      if (buttonGroup) {
        this.positionButtons();
        if (!this.initialButtonGroupWidth) {
          var width_1 = 0;
          if (zoomText) {
            width_1 += zoomText.getBBox().width + 5;
          }
          buttons.forEach(function(button, i) {
            width_1 += button.width;
            if (i !== buttons.length - 1) {
              width_1 += options.buttonSpacing;
            }
          });
          this.initialButtonGroupWidth = width_1;
        }
        plotLeft -= chart.spacing[3];
        this.updateButtonStates();
        var xOffsetForExportButton_1 = getXOffsetForExportButton(buttonGroup, buttonPosition);
        this.alignButtonGroup(xOffsetForExportButton_1);
        group.placed = buttonGroup.placed = chart.hasLoaded;
      }
      var xOffsetForExportButton = 0;
      if (inputGroup) {
        xOffsetForExportButton = getXOffsetForExportButton(inputGroup, inputPosition);
        if (inputPosition.align === "left") {
          translateX = plotLeft;
        } else if (inputPosition.align === "right") {
          translateX = -Math.max(chart.axisOffset[1], -xOffsetForExportButton);
        }
        inputGroup.align({
          y: inputPosition.y,
          width: inputGroup.getBBox().width,
          align: inputPosition.align,
          x: inputPosition.x + translateX - 2
        }, true, chart.spacingBox);
        inputGroup.placed = chart.hasLoaded;
      }
      this.handleCollision(xOffsetForExportButton);
      group.align({
        verticalAlign
      }, true, chart.spacingBox);
      var alignTranslateY = group.alignAttr.translateY;
      var groupHeight = group.getBBox().height + 20;
      var translateY = 0;
      if (verticalAlign === "bottom") {
        var legendOptions = chart.legend && chart.legend.options;
        var legendHeight = legendOptions && legendOptions.verticalAlign === "bottom" && legendOptions.enabled && !legendOptions.floating ? chart.legend.legendHeight + pick44(legendOptions.margin, 10) : 0;
        groupHeight = groupHeight + legendHeight - 20;
        translateY = alignTranslateY - groupHeight - (options.floating ? 0 : options.y) - (chart.titleOffset ? chart.titleOffset[2] : 0) - 10;
      }
      if (verticalAlign === "top") {
        if (options.floating) {
          translateY = 0;
        }
        if (chart.titleOffset && chart.titleOffset[0]) {
          translateY = chart.titleOffset[0];
        }
        translateY += chart.margin[0] - chart.spacing[0] || 0;
      } else if (verticalAlign === "middle") {
        if (inputPosition.y === buttonPosition.y) {
          translateY = alignTranslateY;
        } else if (inputPosition.y || buttonPosition.y) {
          if (inputPosition.y < 0 || buttonPosition.y < 0) {
            translateY -= Math.min(inputPosition.y, buttonPosition.y);
          } else {
            translateY = alignTranslateY - groupHeight;
          }
        }
      }
      group.translate(options.x, options.y + Math.floor(translateY));
      var _b = this, minInput = _b.minInput, maxInput = _b.maxInput, dropdown = _b.dropdown;
      if (options.inputEnabled && minInput && maxInput) {
        minInput.style.marginTop = group.translateY + "px";
        maxInput.style.marginTop = group.translateY + "px";
      }
      if (dropdown) {
        dropdown.style.marginTop = group.translateY + "px";
      }
    }
  };
  RangeSelector2.prototype.alignButtonGroup = function(xOffsetForExportButton, width) {
    var _a15 = this, chart = _a15.chart, options = _a15.options, buttonGroup = _a15.buttonGroup, buttons = _a15.buttons;
    var buttonPosition = options.buttonPosition;
    var plotLeft = chart.plotLeft - chart.spacing[3];
    var translateX = buttonPosition.x - chart.spacing[3];
    if (buttonPosition.align === "right") {
      translateX += xOffsetForExportButton - plotLeft;
    } else if (buttonPosition.align === "center") {
      translateX -= plotLeft / 2;
    }
    if (buttonGroup) {
      buttonGroup.align({
        y: buttonPosition.y,
        width: pick44(width, this.initialButtonGroupWidth),
        align: buttonPosition.align,
        x: translateX
      }, true, chart.spacingBox);
    }
  };
  RangeSelector2.prototype.positionButtons = function() {
    var _a15 = this, buttons = _a15.buttons, chart = _a15.chart, options = _a15.options, zoomText = _a15.zoomText;
    var verb = chart.hasLoaded ? "animate" : "attr";
    var buttonPosition = options.buttonPosition;
    var plotLeft = chart.plotLeft;
    var buttonLeft = plotLeft;
    if (zoomText && zoomText.visibility !== "hidden") {
      zoomText[verb]({
        x: pick44(plotLeft + buttonPosition.x, plotLeft)
      });
      buttonLeft += buttonPosition.x + zoomText.getBBox().width + 5;
    }
    this.buttonOptions.forEach(function(rangeOptions, i) {
      if (buttons[i].visibility !== "hidden") {
        buttons[i][verb]({ x: buttonLeft });
        buttonLeft += buttons[i].width + options.buttonSpacing;
      } else {
        buttons[i][verb]({ x: plotLeft });
      }
    });
  };
  RangeSelector2.prototype.handleCollision = function(xOffsetForExportButton) {
    var _this = this;
    var _a15 = this, chart = _a15.chart, buttonGroup = _a15.buttonGroup, inputGroup = _a15.inputGroup;
    var _b = this.options, buttonPosition = _b.buttonPosition, dropdown = _b.dropdown, inputPosition = _b.inputPosition;
    var maxButtonWidth = function() {
      var buttonWidth = 0;
      _this.buttons.forEach(function(button) {
        var bBox = button.getBBox();
        if (bBox.width > buttonWidth) {
          buttonWidth = bBox.width;
        }
      });
      return buttonWidth;
    };
    var groupsOverlap = function(buttonGroupWidth) {
      if (inputGroup && buttonGroup) {
        var inputGroupX = inputGroup.alignAttr.translateX + inputGroup.alignOptions.x - xOffsetForExportButton + inputGroup.getBBox().x + 2;
        var inputGroupWidth = inputGroup.alignOptions.width;
        var buttonGroupX = buttonGroup.alignAttr.translateX + buttonGroup.getBBox().x;
        return buttonGroupX + buttonGroupWidth > inputGroupX && inputGroupX + inputGroupWidth > buttonGroupX && buttonPosition.y < inputPosition.y + inputGroup.getBBox().height;
      }
      return false;
    };
    var moveInputsDown = function() {
      if (inputGroup && buttonGroup) {
        inputGroup.attr({
          translateX: inputGroup.alignAttr.translateX + (chart.axisOffset[1] >= -xOffsetForExportButton ? 0 : -xOffsetForExportButton),
          translateY: inputGroup.alignAttr.translateY + buttonGroup.getBBox().height + 10
        });
      }
    };
    if (buttonGroup) {
      if (dropdown === "always") {
        this.collapseButtons(xOffsetForExportButton);
        if (groupsOverlap(maxButtonWidth())) {
          moveInputsDown();
        }
        return;
      }
      if (dropdown === "never") {
        this.expandButtons();
      }
    }
    if (inputGroup && buttonGroup) {
      if (inputPosition.align === buttonPosition.align || groupsOverlap(this.initialButtonGroupWidth + 20)) {
        if (dropdown === "responsive") {
          this.collapseButtons(xOffsetForExportButton);
          if (groupsOverlap(maxButtonWidth())) {
            moveInputsDown();
          }
        } else {
          moveInputsDown();
        }
      } else if (dropdown === "responsive") {
        this.expandButtons();
      }
    } else if (buttonGroup && dropdown === "responsive") {
      if (this.initialButtonGroupWidth > chart.plotWidth) {
        this.collapseButtons(xOffsetForExportButton);
      } else {
        this.expandButtons();
      }
    }
  };
  RangeSelector2.prototype.collapseButtons = function(xOffsetForExportButton) {
    var _a15 = this, buttons = _a15.buttons, buttonOptions = _a15.buttonOptions, chart = _a15.chart, dropdown = _a15.dropdown, options = _a15.options, zoomText = _a15.zoomText;
    var userButtonTheme = chart.userOptions.rangeSelector && chart.userOptions.rangeSelector.buttonTheme || {};
    var getAttribs = function(text) {
      return {
        text: text ? text + " \u25BE" : "\u25BE",
        width: "auto",
        paddingLeft: pick44(options.buttonTheme.paddingLeft, userButtonTheme.padding, 8),
        paddingRight: pick44(options.buttonTheme.paddingRight, userButtonTheme.padding, 8)
      };
    };
    if (zoomText) {
      zoomText.hide();
    }
    var hasActiveButton = false;
    buttonOptions.forEach(function(rangeOptions, i) {
      var button = buttons[i];
      if (button.state !== 2) {
        button.hide();
      } else {
        button.show();
        button.attr(getAttribs(rangeOptions.text));
        hasActiveButton = true;
      }
    });
    if (!hasActiveButton) {
      if (dropdown) {
        dropdown.selectedIndex = 0;
      }
      buttons[0].show();
      buttons[0].attr(getAttribs(this.zoomText && this.zoomText.textStr));
    }
    var align = options.buttonPosition.align;
    this.positionButtons();
    if (align === "right" || align === "center") {
      this.alignButtonGroup(xOffsetForExportButton, buttons[this.currentButtonIndex()].getBBox().width);
    }
    this.showDropdown();
  };
  RangeSelector2.prototype.expandButtons = function() {
    var _a15 = this, buttons = _a15.buttons, buttonOptions = _a15.buttonOptions, options = _a15.options, zoomText = _a15.zoomText;
    this.hideDropdown();
    if (zoomText) {
      zoomText.show();
    }
    buttonOptions.forEach(function(rangeOptions, i) {
      var button = buttons[i];
      button.show();
      button.attr({
        text: rangeOptions.text,
        width: options.buttonTheme.width || 28,
        paddingLeft: pick44(options.buttonTheme.paddingLeft, "unset"),
        paddingRight: pick44(options.buttonTheme.paddingRight, "unset")
      });
      if (button.state < 2) {
        button.setState(0);
      }
    });
    this.positionButtons();
  };
  RangeSelector2.prototype.currentButtonIndex = function() {
    var dropdown = this.dropdown;
    if (dropdown && dropdown.selectedIndex > 0) {
      return dropdown.selectedIndex - 1;
    }
    return 0;
  };
  RangeSelector2.prototype.showDropdown = function() {
    var _a15 = this, buttonGroup = _a15.buttonGroup, buttons = _a15.buttons, chart = _a15.chart, dropdown = _a15.dropdown;
    if (buttonGroup && dropdown) {
      var translateX = buttonGroup.translateX, translateY = buttonGroup.translateY;
      var bBox = buttons[this.currentButtonIndex()].getBBox();
      css13(dropdown, {
        left: chart.plotLeft + translateX + "px",
        top: translateY + 0.5 + "px",
        width: bBox.width + "px",
        height: bBox.height + "px"
      });
      this.hasVisibleDropdown = true;
    }
  };
  RangeSelector2.prototype.hideDropdown = function() {
    var dropdown = this.dropdown;
    if (dropdown) {
      css13(dropdown, {
        top: "-9999em",
        width: "1px",
        height: "1px"
      });
      this.hasVisibleDropdown = false;
    }
  };
  RangeSelector2.prototype.getHeight = function() {
    var rangeSelector = this, options = rangeSelector.options, rangeSelectorGroup = rangeSelector.group, inputPosition = options.inputPosition, buttonPosition = options.buttonPosition, yPosition = options.y, buttonPositionY = buttonPosition.y, inputPositionY = inputPosition.y, rangeSelectorHeight = 0, minPosition;
    if (options.height) {
      return options.height;
    }
    this.alignElements();
    rangeSelectorHeight = rangeSelectorGroup ? rangeSelectorGroup.getBBox(true).height + 13 + yPosition : 0;
    minPosition = Math.min(inputPositionY, buttonPositionY);
    if (inputPositionY < 0 && buttonPositionY < 0 || inputPositionY > 0 && buttonPositionY > 0) {
      rangeSelectorHeight += Math.abs(minPosition);
    }
    return rangeSelectorHeight;
  };
  RangeSelector2.prototype.titleCollision = function(chart) {
    return !(chart.options.title.text || chart.options.subtitle.text);
  };
  RangeSelector2.prototype.update = function(options) {
    var chart = this.chart;
    merge38(true, chart.options.rangeSelector, options);
    this.destroy();
    this.init(chart);
    this.render();
  };
  RangeSelector2.prototype.destroy = function() {
    var rSelector = this, minInput = rSelector.minInput, maxInput = rSelector.maxInput;
    if (rSelector.eventsToUnbind) {
      rSelector.eventsToUnbind.forEach(function(unbind) {
        return unbind();
      });
      rSelector.eventsToUnbind = void 0;
    }
    destroyObjectProperties10(rSelector.buttons);
    if (minInput) {
      minInput.onfocus = minInput.onblur = minInput.onchange = null;
    }
    if (maxInput) {
      maxInput.onfocus = maxInput.onblur = maxInput.onchange = null;
    }
    objectEach25(rSelector, function(val, key) {
      if (val && key !== "chart") {
        if (val instanceof SVGElement_default) {
          val.destroy();
        } else if (val instanceof window.HTMLElement) {
          discardElement6(val);
        }
      }
      if (val !== RangeSelector2.prototype[key]) {
        rSelector[key] = null;
      }
    }, this);
  };
  return RangeSelector2;
}();
RangeSelector.prototype.defaultButtons = [{
  type: "month",
  count: 1,
  text: "1m",
  title: "View 1 month"
}, {
  type: "month",
  count: 3,
  text: "3m",
  title: "View 3 months"
}, {
  type: "month",
  count: 6,
  text: "6m",
  title: "View 6 months"
}, {
  type: "ytd",
  text: "YTD",
  title: "View year to date"
}, {
  type: "year",
  count: 1,
  text: "1y",
  title: "View 1 year"
}, {
  type: "all",
  text: "All",
  title: "View all"
}];
RangeSelector.prototype.inputTypeFormats = {
  "datetime-local": "%Y-%m-%dT%H:%M:%S",
  "date": "%Y-%m-%d",
  "time": "%H:%M:%S"
};
function preferredInputType(format13) {
  var ms = format13.indexOf("%L") !== -1;
  if (ms) {
    return "text";
  }
  var date = ["a", "A", "d", "e", "w", "b", "B", "m", "o", "y", "Y"].some(function(char) {
    return format13.indexOf("%" + char) !== -1;
  });
  var time = ["H", "k", "I", "l", "M", "S"].some(function(char) {
    return format13.indexOf("%" + char) !== -1;
  });
  if (date && time) {
    return "datetime-local";
  }
  if (date) {
    return "date";
  }
  if (time) {
    return "time";
  }
  return "text";
}
Axis_default.prototype.minFromRange = function() {
  var rangeOptions = this.range, type = rangeOptions.type, min, max = this.max, dataMin, range, time = this.chart.time, getTrueRange = function(base, count) {
    var timeName = type === "year" ? "FullYear" : "Month";
    var date = new time.Date(base);
    var basePeriod = time.get(timeName, date);
    time.set(timeName, date, basePeriod + count);
    if (basePeriod === time.get(timeName, date)) {
      time.set("Date", date, 0);
    }
    return date.getTime() - base;
  };
  if (isNumber30(rangeOptions)) {
    min = max - rangeOptions;
    range = rangeOptions;
  } else {
    min = max + getTrueRange(max, -rangeOptions.count);
    if (this.chart) {
      this.chart.fixedRange = max - min;
    }
  }
  dataMin = pick44(this.dataMin, Number.MIN_VALUE);
  if (!isNumber30(min)) {
    min = dataMin;
  }
  if (min <= dataMin) {
    min = dataMin;
    if (typeof range === "undefined") {
      range = getTrueRange(min, rangeOptions.count);
    }
    this.newMax = Math.min(min + range, this.dataMax);
  }
  if (!isNumber30(max)) {
    min = void 0;
  }
  return min;
};
if (!Globals_default.RangeSelector) {
  chartDestroyEvents_1 = [];
  initRangeSelector_1 = function(chart) {
    var extremes, rangeSelector = chart.rangeSelector, legend, alignTo, verticalAlign;
    function render() {
      if (rangeSelector) {
        extremes = chart.xAxis[0].getExtremes();
        legend = chart.legend;
        verticalAlign = rangeSelector && rangeSelector.options.verticalAlign;
        if (isNumber30(extremes.min)) {
          rangeSelector.render(extremes.min, extremes.max);
        }
        if (legend.display && verticalAlign === "top" && verticalAlign === legend.options.verticalAlign) {
          alignTo = merge38(chart.spacingBox);
          if (legend.options.layout === "vertical") {
            alignTo.y = chart.plotTop;
          } else {
            alignTo.y += rangeSelector.getHeight();
          }
          legend.group.placed = false;
          legend.align(alignTo);
        }
      }
    }
    if (rangeSelector) {
      var events = find9(chartDestroyEvents_1, function(e2) {
        return e2[0] === chart;
      });
      if (!events) {
        chartDestroyEvents_1.push([chart, [
          addEvent27(chart.xAxis[0], "afterSetExtremes", function(e2) {
            if (rangeSelector) {
              rangeSelector.render(e2.min, e2.max);
            }
          }),
          addEvent27(chart, "redraw", render)
        ]]);
      }
      render();
    }
  };
  addEvent27(Chart_default, "afterGetContainer", function() {
    if (this.options.rangeSelector && this.options.rangeSelector.enabled) {
      this.rangeSelector = new RangeSelector(this);
    }
  });
  addEvent27(Chart_default, "beforeRender", function() {
    var chart = this, axes = chart.axes, rangeSelector = chart.rangeSelector, verticalAlign;
    if (rangeSelector) {
      if (isNumber30(rangeSelector.deferredYTDClick)) {
        rangeSelector.clickButton(rangeSelector.deferredYTDClick);
        delete rangeSelector.deferredYTDClick;
      }
      axes.forEach(function(axis) {
        axis.updateNames();
        axis.setScale();
      });
      chart.getAxisMargins();
      rangeSelector.render();
      verticalAlign = rangeSelector.options.verticalAlign;
      if (!rangeSelector.options.floating) {
        if (verticalAlign === "bottom") {
          this.extraBottomMargin = true;
        } else if (verticalAlign !== "middle") {
          this.extraTopMargin = true;
        }
      }
    }
  });
  addEvent27(Chart_default, "update", function(e2) {
    var chart = this, options = e2.options, optionsRangeSelector = options.rangeSelector, rangeSelector = chart.rangeSelector, verticalAlign, extraBottomMarginWas = this.extraBottomMargin, extraTopMarginWas = this.extraTopMargin;
    if (optionsRangeSelector && optionsRangeSelector.enabled && !defined32(rangeSelector) && this.options.rangeSelector) {
      this.options.rangeSelector.enabled = true;
      this.rangeSelector = rangeSelector = new RangeSelector(this);
    }
    this.extraBottomMargin = false;
    this.extraTopMargin = false;
    if (rangeSelector) {
      initRangeSelector_1(this);
      verticalAlign = optionsRangeSelector && optionsRangeSelector.verticalAlign || rangeSelector.options && rangeSelector.options.verticalAlign;
      if (!rangeSelector.options.floating) {
        if (verticalAlign === "bottom") {
          this.extraBottomMargin = true;
        } else if (verticalAlign !== "middle") {
          this.extraTopMargin = true;
        }
      }
      if (this.extraBottomMargin !== extraBottomMarginWas || this.extraTopMargin !== extraTopMarginWas) {
        this.isDirtyBox = true;
      }
    }
  });
  addEvent27(Chart_default, "render", function() {
    var chart = this, rangeSelector = chart.rangeSelector, verticalAlign;
    if (rangeSelector && !rangeSelector.options.floating) {
      rangeSelector.render();
      verticalAlign = rangeSelector.options.verticalAlign;
      if (verticalAlign === "bottom") {
        this.extraBottomMargin = true;
      } else if (verticalAlign !== "middle") {
        this.extraTopMargin = true;
      }
    }
  });
  addEvent27(Chart_default, "getMargins", function() {
    var rangeSelector = this.rangeSelector, rangeSelectorHeight;
    if (rangeSelector) {
      rangeSelectorHeight = rangeSelector.getHeight();
      if (this.extraTopMargin) {
        this.plotTop += rangeSelectorHeight;
      }
      if (this.extraBottomMargin) {
        this.marginBottom += rangeSelectorHeight;
      }
    }
  });
  Chart_default.prototype.callbacks.push(initRangeSelector_1);
  addEvent27(Chart_default, "destroy", function destroyEvents() {
    for (var i = 0; i < chartDestroyEvents_1.length; i++) {
      var events = chartDestroyEvents_1[i];
      if (events[0] === this) {
        events[1].forEach(function(unbind) {
          return unbind();
        });
        chartDestroyEvents_1.splice(i, 1);
        return;
      }
    }
  });
  Globals_default.RangeSelector = RangeSelector;
}
var chartDestroyEvents_1;
var initRangeSelector_1;
var RangeSelector_default = RangeSelector;

// node_modules/highcharts/es-modules/Core/Chart/StockChart.js
var __extends19 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var animObject9 = AnimationUtilities_default.animObject;
var format8 = FormatUtilities_default.format;
var getOptions2 = DefaultOptions_default.getOptions;
var pointTooltipFormatter = Point_default.prototype.tooltipFormatter;
var _a2 = Series_default.prototype;
var seriesInit = _a2.init;
var seriesProcessData = _a2.processData;
var addEvent28 = Utilities_default.addEvent;
var arrayMax7 = Utilities_default.arrayMax;
var arrayMin6 = Utilities_default.arrayMin;
var clamp11 = Utilities_default.clamp;
var defined33 = Utilities_default.defined;
var extend30 = Utilities_default.extend;
var find10 = Utilities_default.find;
var isNumber31 = Utilities_default.isNumber;
var isString10 = Utilities_default.isString;
var merge39 = Utilities_default.merge;
var pick45 = Utilities_default.pick;
var splat13 = Utilities_default.splat;
var StockChart = function(_super) {
  __extends19(StockChart2, _super);
  function StockChart2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  StockChart2.prototype.init = function(userOptions, callback) {
    var defaultOptions17 = getOptions2(), xAxisOptions = userOptions.xAxis, yAxisOptions = userOptions.yAxis, navigatorEnabled = pick45(userOptions.navigator && userOptions.navigator.enabled, defaultOptions17.navigator.enabled, true);
    userOptions.xAxis = userOptions.yAxis = void 0;
    var options = merge39({
      chart: {
        panning: {
          enabled: true,
          type: "x"
        },
        pinchType: "x"
      },
      navigator: {
        enabled: navigatorEnabled
      },
      scrollbar: {
        enabled: pick45(defaultOptions17.scrollbar && defaultOptions17.scrollbar.enabled, true)
      },
      rangeSelector: {
        enabled: pick45(defaultOptions17.rangeSelector.enabled, true)
      },
      title: {
        text: null
      },
      tooltip: {
        split: pick45(defaultOptions17.tooltip.split, true),
        crosshairs: true
      },
      legend: {
        enabled: false
      }
    }, userOptions, {
      isStock: true
    });
    userOptions.xAxis = xAxisOptions;
    userOptions.yAxis = yAxisOptions;
    options.xAxis = splat13(userOptions.xAxis || {}).map(function(xAxisOptions2, i) {
      return merge39(getDefaultAxisOptions("xAxis", xAxisOptions2), defaultOptions17.xAxis, defaultOptions17.xAxis && defaultOptions17.xAxis[i], xAxisOptions2, getForcedAxisOptions("xAxis", userOptions));
    });
    options.yAxis = splat13(userOptions.yAxis || {}).map(function(yAxisOptions2, i) {
      return merge39(getDefaultAxisOptions("yAxis", yAxisOptions2), defaultOptions17.yAxis, defaultOptions17.yAxis && defaultOptions17.yAxis[i], yAxisOptions2);
    });
    _super.prototype.init.call(this, options, callback);
  };
  StockChart2.prototype.createAxis = function(type, options) {
    options.axis = merge39(getDefaultAxisOptions(type, options.axis), options.axis, getForcedAxisOptions(type, this.userOptions));
    return _super.prototype.createAxis.call(this, type, options);
  };
  return StockChart2;
}(Chart_default);
(function(StockChart2) {
  function stockChart(a, b, c) {
    return new StockChart2(a, b, c);
  }
  StockChart2.stockChart = stockChart;
})(StockChart || (StockChart = {}));
function getDefaultAxisOptions(type, options) {
  if (type === "xAxis") {
    return {
      minPadding: 0,
      maxPadding: 0,
      overscroll: 0,
      ordinal: true,
      title: {
        text: null
      },
      labels: {
        overflow: "justify"
      },
      showLastLabel: true
    };
  }
  if (type === "yAxis") {
    return {
      labels: {
        y: -2
      },
      opposite: pick45(options.opposite, true),
      showLastLabel: !!(options.categories || options.type === "category"),
      title: {
        text: null
      }
    };
  }
  return {};
}
function getForcedAxisOptions(type, chartOptions) {
  if (type === "xAxis") {
    var defaultOptions17 = getOptions2(), navigatorEnabled = pick45(chartOptions.navigator && chartOptions.navigator.enabled, defaultOptions17.navigator.enabled, true);
    var axisOptions = {
      type: "datetime",
      categories: void 0
    };
    if (navigatorEnabled) {
      axisOptions.startOnTick = false;
      axisOptions.endOnTick = false;
    }
    return axisOptions;
  }
  return {};
}
addEvent28(Series_default, "setOptions", function(e2) {
  var overrides;
  if (this.chart.options.isStock) {
    if (this.is("column") || this.is("columnrange")) {
      overrides = {
        borderWidth: 0,
        shadow: false
      };
    } else if (!this.is("scatter") && !this.is("sma")) {
      overrides = {
        marker: {
          enabled: false,
          radius: 2
        }
      };
    }
    if (overrides) {
      e2.plotOptions[this.type] = merge39(e2.plotOptions[this.type], overrides);
    }
  }
});
addEvent28(Axis_default, "autoLabelAlign", function(e2) {
  var chart = this.chart, options = this.options, panes = chart._labelPanes = chart._labelPanes || {}, key, labelOptions = this.options.labels;
  if (this.chart.options.isStock && this.coll === "yAxis") {
    key = options.top + "," + options.height;
    if (!panes[key] && labelOptions.enabled) {
      if (labelOptions.x === 15) {
        labelOptions.x = 0;
      }
      if (typeof labelOptions.align === "undefined") {
        labelOptions.align = "right";
      }
      panes[key] = this;
      e2.align = "right";
      e2.preventDefault();
    }
  }
});
addEvent28(Axis_default, "destroy", function() {
  var chart = this.chart, key = this.options && this.options.top + "," + this.options.height;
  if (key && chart._labelPanes && chart._labelPanes[key] === this) {
    delete chart._labelPanes[key];
  }
});
addEvent28(Axis_default, "getPlotLinePath", function(e2) {
  var axis = this, series = this.isLinked && !this.series ? this.linkedParent.series : this.series, chart = axis.chart, renderer = chart.renderer, axisLeft = axis.left, axisTop = axis.top, x1, y1, x2, y2, result2 = [], axes = [], axes2, uniqueAxes, translatedValue = e2.translatedValue, value = e2.value, force = e2.force, transVal;
  function getAxis(coll) {
    var otherColl = coll === "xAxis" ? "yAxis" : "xAxis", opt = axis.options[otherColl];
    if (isNumber31(opt)) {
      return [chart[otherColl][opt]];
    }
    if (isString10(opt)) {
      return [chart.get(opt)];
    }
    return series.map(function(s) {
      return s[otherColl];
    });
  }
  if (chart.options.isStock && e2.acrossPanes !== false && axis.coll === "xAxis" || axis.coll === "yAxis") {
    e2.preventDefault();
    axes = getAxis(axis.coll);
    axes2 = axis.isXAxis ? chart.yAxis : chart.xAxis;
    axes2.forEach(function(A) {
      if (defined33(A.options.id) ? A.options.id.indexOf("navigator") === -1 : true) {
        var a = A.isXAxis ? "yAxis" : "xAxis", rax = defined33(A.options[a]) ? chart[a][A.options[a]] : chart[a][0];
        if (axis === rax) {
          axes.push(A);
        }
      }
    });
    uniqueAxes = axes.length ? [] : [axis.isXAxis ? chart.yAxis[0] : chart.xAxis[0]];
    axes.forEach(function(axis2) {
      if (uniqueAxes.indexOf(axis2) === -1 && !find10(uniqueAxes, function(unique) {
        return unique.pos === axis2.pos && unique.len === axis2.len;
      })) {
        uniqueAxes.push(axis2);
      }
    });
    transVal = pick45(translatedValue, axis.translate(value, null, null, e2.old));
    if (isNumber31(transVal)) {
      if (axis.horiz) {
        uniqueAxes.forEach(function(axis2) {
          var skip;
          y1 = axis2.pos;
          y2 = y1 + axis2.len;
          x1 = x2 = Math.round(transVal + axis.transB);
          if (force !== "pass" && (x1 < axisLeft || x1 > axisLeft + axis.width)) {
            if (force) {
              x1 = x2 = clamp11(x1, axisLeft, axisLeft + axis.width);
            } else {
              skip = true;
            }
          }
          if (!skip) {
            result2.push(["M", x1, y1], ["L", x2, y2]);
          }
        });
      } else {
        uniqueAxes.forEach(function(axis2) {
          var skip;
          x1 = axis2.pos;
          x2 = x1 + axis2.len;
          y1 = y2 = Math.round(axisTop + axis.height - transVal);
          if (force !== "pass" && (y1 < axisTop || y1 > axisTop + axis.height)) {
            if (force) {
              y1 = y2 = clamp11(y1, axisTop, axisTop + axis.height);
            } else {
              skip = true;
            }
          }
          if (!skip) {
            result2.push(["M", x1, y1], ["L", x2, y2]);
          }
        });
      }
    }
    e2.path = result2.length > 0 ? renderer.crispPolyLine(result2, e2.lineWidth || 1) : null;
  }
});
SVGRenderer_default.prototype.crispPolyLine = function(points, width) {
  for (var i = 0; i < points.length; i = i + 2) {
    var start = points[i], end = points[i + 1];
    if (start[1] === end[1]) {
      start[1] = end[1] = Math.round(start[1]) - width % 2 / 2;
    }
    if (start[2] === end[2]) {
      start[2] = end[2] = Math.round(start[2]) + width % 2 / 2;
    }
  }
  return points;
};
addEvent28(Axis_default, "afterHideCrosshair", function() {
  if (this.crossLabel) {
    this.crossLabel = this.crossLabel.hide();
  }
});
addEvent28(Axis_default, "afterDrawCrosshair", function(event) {
  if (!this.crosshair || !this.crosshair.label || !this.crosshair.label.enabled || !this.cross || !isNumber31(this.min) || !isNumber31(this.max)) {
    return;
  }
  var chart = this.chart, log = this.logarithmic, options = this.crosshair.label, horiz = this.horiz, opposite = this.opposite, left = this.left, top = this.top, crossLabel = this.crossLabel, posx, posy, crossBox, formatOption = options.format, formatFormat = "", limit, align, tickInside = this.options.tickPosition === "inside", snap = this.crosshair.snap !== false, offset3 = 0, e2 = event.e || this.cross && this.cross.e, point = event.point, min = this.min, max = this.max;
  if (log) {
    min = log.lin2log(min);
    max = log.lin2log(max);
  }
  align = horiz ? "center" : opposite ? this.labelAlign === "right" ? "right" : "left" : this.labelAlign === "left" ? "left" : "center";
  if (!crossLabel) {
    crossLabel = this.crossLabel = chart.renderer.label("", 0, void 0, options.shape || "callout").addClass("highcharts-crosshair-label highcharts-color-" + (point ? point.series.colorIndex : this.series[0] && this.series[0].colorIndex)).attr({
      align: options.align || align,
      padding: pick45(options.padding, 8),
      r: pick45(options.borderRadius, 3),
      zIndex: 2
    }).add(this.labelGroup);
    if (!chart.styledMode) {
      crossLabel.attr({
        fill: options.backgroundColor || point && point.series && point.series.color || Palette_default.neutralColor60,
        stroke: options.borderColor || "",
        "stroke-width": options.borderWidth || 0
      }).css(extend30({
        color: Palette_default.backgroundColor,
        fontWeight: "normal",
        fontSize: "11px",
        textAlign: "center"
      }, options.style || {}));
    }
  }
  if (horiz) {
    posx = snap ? (point.plotX || 0) + left : e2.chartX;
    posy = top + (opposite ? 0 : this.height);
  } else {
    posx = opposite ? this.width + left : 0;
    posy = snap ? (point.plotY || 0) + top : e2.chartY;
  }
  if (!formatOption && !options.formatter) {
    if (this.dateTime) {
      formatFormat = "%b %d, %Y";
    }
    formatOption = "{value" + (formatFormat ? ":" + formatFormat : "") + "}";
  }
  var value = snap ? this.isXAxis ? point.x : point.y : this.toValue(horiz ? e2.chartX : e2.chartY);
  var isInside = point ? point.series.isPointInside(point) : isNumber31(value) && value > min && value < max;
  var text = "";
  if (formatOption) {
    text = format8(formatOption, { value }, chart);
  } else if (options.formatter && isNumber31(value)) {
    text = options.formatter.call(this, value);
  }
  crossLabel.attr({
    text,
    x: posx,
    y: posy,
    visibility: isInside ? "visible" : "hidden"
  });
  crossBox = crossLabel.getBBox();
  if (isNumber31(crossLabel.y)) {
    if (horiz) {
      if (tickInside && !opposite || !tickInside && opposite) {
        posy = crossLabel.y - crossBox.height;
      }
    } else {
      posy = crossLabel.y - crossBox.height / 2;
    }
  }
  if (horiz) {
    limit = {
      left: left - crossBox.x,
      right: left + this.width - crossBox.x
    };
  } else {
    limit = {
      left: this.labelAlign === "left" ? left : 0,
      right: this.labelAlign === "right" ? left + this.width : chart.chartWidth
    };
  }
  if (crossLabel.translateX < limit.left) {
    offset3 = limit.left - crossLabel.translateX;
  }
  if (crossLabel.translateX + crossBox.width >= limit.right) {
    offset3 = -(crossLabel.translateX + crossBox.width - limit.right);
  }
  crossLabel.attr({
    x: posx + offset3,
    y: posy,
    anchorX: horiz ? posx : this.opposite ? 0 : chart.chartWidth,
    anchorY: horiz ? this.opposite ? chart.chartHeight : 0 : posy + crossBox.height / 2
  });
});
Series_default.prototype.init = function() {
  seriesInit.apply(this, arguments);
  this.initCompare(this.options.compare);
};
Series_default.prototype.setCompare = function(compare) {
  this.initCompare(compare);
  this.userOptions.compare = compare;
};
Series_default.prototype.initCompare = function(compare) {
  this.modifyValue = compare === "value" || compare === "percent" ? function(value, point) {
    var compareValue = this.compareValue;
    if (typeof value !== "undefined" && typeof compareValue !== "undefined") {
      if (compare === "value") {
        value -= compareValue;
      } else {
        value = 100 * (value / compareValue) - (this.options.compareBase === 100 ? 0 : 100);
      }
      if (point) {
        point.change = value;
      }
      return value;
    }
    return 0;
  } : null;
  if (this.chart.hasRendered) {
    this.isDirty = true;
  }
};
Series_default.prototype.forceCropping = function() {
  var chart = this.chart, options = this.options, dataGroupingOptions = options.dataGrouping, groupingEnabled = this.allowDG !== false && dataGroupingOptions && pick45(dataGroupingOptions.enabled, chart.options.isStock);
  return groupingEnabled;
};
Series_default.prototype.processData = function(force) {
  var series = this, i, keyIndex = -1, processedXData, processedYData, compareStart = series.options.compareStart === true ? 0 : 1, length, compareValue;
  seriesProcessData.apply(this, arguments);
  if (series.xAxis && series.processedYData) {
    processedXData = series.processedXData;
    processedYData = series.processedYData;
    length = processedYData.length;
    if (series.pointArrayMap) {
      keyIndex = series.pointArrayMap.indexOf(series.options.pointValKey || series.pointValKey || "y");
    }
    for (i = 0; i < length - compareStart; i++) {
      compareValue = processedYData[i] && keyIndex > -1 ? processedYData[i][keyIndex] : processedYData[i];
      if (isNumber31(compareValue) && processedXData[i + compareStart] >= series.xAxis.min && compareValue !== 0) {
        series.compareValue = compareValue;
        break;
      }
    }
  }
  return;
};
addEvent28(Series_default, "afterGetExtremes", function(e2) {
  var dataExtremes = e2.dataExtremes;
  if (this.modifyValue && dataExtremes) {
    var extremes = [
      this.modifyValue(dataExtremes.dataMin),
      this.modifyValue(dataExtremes.dataMax)
    ];
    dataExtremes.dataMin = arrayMin6(extremes);
    dataExtremes.dataMax = arrayMax7(extremes);
  }
});
Axis_default.prototype.setCompare = function(compare, redraw) {
  if (!this.isXAxis) {
    this.series.forEach(function(series) {
      series.setCompare(compare);
    });
    if (pick45(redraw, true)) {
      this.chart.redraw();
    }
  }
};
Point_default.prototype.tooltipFormatter = function(pointFormat) {
  var point = this;
  var numberFormatter = point.series.chart.numberFormatter;
  pointFormat = pointFormat.replace("{point.change}", (point.change > 0 ? "+" : "") + numberFormatter(point.change, pick45(point.series.tooltipOptions.changeDecimals, 2)));
  return pointTooltipFormatter.apply(this, [pointFormat]);
};
addEvent28(Series_default, "render", function() {
  var chart = this.chart, clipHeight;
  if (!(chart.is3d && chart.is3d()) && !chart.polar && this.xAxis && !this.xAxis.isRadial && this.options.clip !== false) {
    clipHeight = this.yAxis.len;
    if (this.xAxis.axisLine) {
      var dist = chart.plotTop + chart.plotHeight - this.yAxis.pos - this.yAxis.len, lineHeightCorrection = Math.floor(this.xAxis.axisLine.strokeWidth() / 2);
      if (dist >= 0) {
        clipHeight -= Math.max(lineHeightCorrection - dist, 0);
      }
    }
    if (!chart.hasLoaded || !this.clipBox && this.isDirty && !this.isDirtyData) {
      this.clipBox = this.clipBox || merge39(chart.clipBox);
      this.clipBox.width = this.xAxis.len;
      this.clipBox.height = clipHeight;
    }
    if (chart.hasRendered) {
      var animation = animObject9(this.options.animation);
      var sharedClipKey = this.getSharedClipKey(animation);
      var clipRect = chart.sharedClips[sharedClipKey];
      if (clipRect) {
        clipRect.animate({
          width: this.xAxis.len,
          height: clipHeight
        });
        var markerClipRect = chart.sharedClips[sharedClipKey + "m"];
        if (markerClipRect) {
          markerClipRect.animate({
            width: this.xAxis.len
          });
        }
      }
    }
  }
});
addEvent28(Chart_default, "update", function(e2) {
  var options = e2.options;
  if ("scrollbar" in options && this.navigator) {
    merge39(true, this.options.scrollbar, options.scrollbar);
    this.navigator.update({}, false);
    delete options.scrollbar;
  }
});
var StockChart_default = StockChart;

// node_modules/highcharts/es-modules/masters/modules/stock.src.js
var G3 = Globals_default;
G3.Scrollbar = Scrollbar_default;
G3.StockChart = G3.stockChart = StockChart_default.stockChart;
Scrollbar_default.compose(G3.Axis);
OrdinalAxis_default.compose(G3.Axis, G3.Series, G3.Chart);

// node_modules/highcharts/es-modules/masters/highstock.src.js
highcharts_src_default.product = "Highstock";
var highstock_src_default = highcharts_src_default;

// node_modules/highcharts/es-modules/Accessibility/Utils/HTMLUtilities.js
var doc8 = Globals_default.doc;
var win12 = Globals_default.win;
var merge40 = Utilities_default.merge;
function addClass(el, className) {
  if (el.classList) {
    el.classList.add(className);
  } else if (el.className.indexOf(className) < 0) {
    el.className += className;
  }
}
function escapeStringForHTML(str) {
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/\//g, "&#x2F;");
}
function getElement(id) {
  return doc8.getElementById(id);
}
function getFakeMouseEvent(type) {
  if (typeof win12.MouseEvent === "function") {
    return new win12.MouseEvent(type);
  }
  if (doc8.createEvent) {
    var evt = doc8.createEvent("MouseEvent");
    if (evt.initMouseEvent) {
      evt.initMouseEvent(type, true, true, win12, type === "click" ? 1 : 0, 0, 0, 0, 0, false, false, false, false, 0, null);
      return evt;
    }
  }
  return { type };
}
function getHeadingTagNameForElement(element) {
  var getIncreasedHeadingLevel = function(tagName) {
    var headingLevel = parseInt(tagName.slice(1), 10);
    var newLevel = Math.min(6, headingLevel + 1);
    return "h" + newLevel;
  };
  var isHeading = function(tagName) {
    return /H[1-6]/.test(tagName);
  };
  var getPreviousSiblingsHeading = function(el) {
    var sibling = el;
    while (sibling = sibling.previousSibling) {
      var tagName = sibling.tagName || "";
      if (isHeading(tagName)) {
        return tagName;
      }
    }
    return "";
  };
  var getHeadingRecursive = function(el) {
    var prevSiblingsHeading = getPreviousSiblingsHeading(el);
    if (prevSiblingsHeading) {
      return getIncreasedHeadingLevel(prevSiblingsHeading);
    }
    var parent = el.parentElement;
    if (!parent) {
      return "p";
    }
    var parentTagName = parent.tagName;
    if (isHeading(parentTagName)) {
      return getIncreasedHeadingLevel(parentTagName);
    }
    return getHeadingRecursive(parent);
  };
  return getHeadingRecursive(element);
}
function removeElement(element) {
  if (element && element.parentNode) {
    element.parentNode.removeChild(element);
  }
}
function reverseChildNodes(node) {
  var i = node.childNodes.length;
  while (i--) {
    node.appendChild(node.childNodes[i]);
  }
}
function setElAttrs(el, attrs) {
  Object.keys(attrs).forEach(function(attr10) {
    var val = attrs[attr10];
    if (val === null) {
      el.removeAttribute(attr10);
    } else {
      el.setAttribute(attr10, val);
    }
  });
}
function stripHTMLTagsFromString(str) {
  return typeof str === "string" ? str.replace(/<\/?[^>]+(>|$)/g, "") : str;
}
function visuallyHideElement(element) {
  var hiddenStyle = {
    position: "absolute",
    width: "1px",
    height: "1px",
    overflow: "hidden",
    whiteSpace: "nowrap",
    clip: "rect(1px, 1px, 1px, 1px)",
    marginTop: "-3px",
    "-ms-filter": "progid:DXImageTransform.Microsoft.Alpha(Opacity=1)",
    filter: "alpha(opacity=1)",
    opacity: "0.01"
  };
  merge40(true, element.style, hiddenStyle);
}
var HTMLUtilities = {
  addClass,
  escapeStringForHTML,
  getElement,
  getFakeMouseEvent,
  getHeadingTagNameForElement,
  removeElement,
  reverseChildNodes,
  setElAttrs,
  stripHTMLTagsFromString,
  visuallyHideElement
};
var HTMLUtilities_default = HTMLUtilities;

// node_modules/highcharts/es-modules/Accessibility/Utils/ChartUtilities.js
var stripHTMLTags = HTMLUtilities_default.stripHTMLTagsFromString;
var doc9 = Globals_default.doc;
var defined34 = Utilities_default.defined;
var find11 = Utilities_default.find;
var fireEvent20 = Utilities_default.fireEvent;
function getChartTitle(chart) {
  return stripHTMLTags(chart.options.title.text || chart.langFormat("accessibility.defaultChartTitle", { chart }));
}
function getAxisDescription(axis) {
  return axis && (axis.userOptions && axis.userOptions.accessibility && axis.userOptions.accessibility.description || axis.axisTitle && axis.axisTitle.textStr || axis.options.id || axis.categories && "categories" || axis.dateTime && "Time" || "values");
}
function getAxisRangeDescription(axis) {
  var axisOptions = axis.options || {};
  if (axisOptions.accessibility && typeof axisOptions.accessibility.rangeDescription !== "undefined") {
    return axisOptions.accessibility.rangeDescription;
  }
  if (axis.categories) {
    return getCategoryAxisRangeDesc(axis);
  }
  if (axis.dateTime && (axis.min === 0 || axis.dataMin === 0)) {
    return getAxisTimeLengthDesc(axis);
  }
  return getAxisFromToDescription(axis);
}
function getCategoryAxisRangeDesc(axis) {
  var chart = axis.chart;
  if (axis.dataMax && axis.dataMin) {
    return chart.langFormat("accessibility.axis.rangeCategories", {
      chart,
      axis,
      numCategories: axis.dataMax - axis.dataMin + 1
    });
  }
  return "";
}
function getAxisTimeLengthDesc(axis) {
  var chart = axis.chart;
  var range = {};
  var rangeUnit = "Seconds";
  range.Seconds = ((axis.max || 0) - (axis.min || 0)) / 1e3;
  range.Minutes = range.Seconds / 60;
  range.Hours = range.Minutes / 60;
  range.Days = range.Hours / 24;
  ["Minutes", "Hours", "Days"].forEach(function(unit) {
    if (range[unit] > 2) {
      rangeUnit = unit;
    }
  });
  var rangeValue = range[rangeUnit].toFixed(rangeUnit !== "Seconds" && rangeUnit !== "Minutes" ? 1 : 0);
  return chart.langFormat("accessibility.axis.timeRange" + rangeUnit, {
    chart,
    axis,
    range: rangeValue.replace(".0", "")
  });
}
function getAxisFromToDescription(axis) {
  var chart = axis.chart;
  var dateRangeFormat = chart.options && chart.options.accessibility && chart.options.accessibility.screenReaderSection.axisRangeDateFormat || "";
  var format13 = function(axisKey) {
    return axis.dateTime ? chart.time.dateFormat(dateRangeFormat, axis[axisKey]) : axis[axisKey];
  };
  return chart.langFormat("accessibility.axis.rangeFromTo", {
    chart,
    axis,
    rangeFrom: format13("min"),
    rangeTo: format13("max")
  });
}
function getSeriesFirstPointElement(series) {
  if (series.points && series.points.length) {
    var firstPointWithGraphic = find11(series.points, function(p) {
      return !!p.graphic;
    });
    return firstPointWithGraphic && firstPointWithGraphic.graphic && firstPointWithGraphic.graphic.element;
  }
}
function getSeriesA11yElement(series) {
  var firstPointEl = getSeriesFirstPointElement(series);
  return firstPointEl && firstPointEl.parentNode || series.graph && series.graph.element || series.group && series.group.element;
}
function unhideChartElementFromAT(chart, element) {
  element.setAttribute("aria-hidden", false);
  if (element === chart.renderTo || !element.parentNode || element.parentNode === doc9.body) {
    return;
  }
  Array.prototype.forEach.call(element.parentNode.childNodes, function(node) {
    if (!node.hasAttribute("aria-hidden")) {
      node.setAttribute("aria-hidden", true);
    }
  });
  unhideChartElementFromAT(chart, element.parentNode);
}
function hideSeriesFromAT(series) {
  var seriesEl = getSeriesA11yElement(series);
  if (seriesEl) {
    seriesEl.setAttribute("aria-hidden", true);
  }
}
function getSeriesFromName(chart, name) {
  if (!name) {
    return chart.series;
  }
  return (chart.series || []).filter(function(s) {
    return s.name === name;
  });
}
function getPointFromXY(series, x, y) {
  var i = series.length, res;
  while (i--) {
    res = find11(series[i].points || [], function(p) {
      return p.x === x && p.y === y;
    });
    if (res) {
      return res;
    }
  }
}
function getRelativePointAxisPosition(axis, point) {
  if (!defined34(axis.dataMin) || !defined34(axis.dataMax)) {
    return 0;
  }
  var axisStart = axis.toPixels(axis.dataMin);
  var axisEnd = axis.toPixels(axis.dataMax);
  var positionProp = axis.coll === "xAxis" ? "x" : "y";
  var pointPos = axis.toPixels(point[positionProp] || 0);
  return (pointPos - axisStart) / (axisEnd - axisStart);
}
function scrollToPoint(point) {
  var xAxis = point.series.xAxis;
  var yAxis = point.series.yAxis;
  var axis = xAxis && xAxis.scrollbar ? xAxis : yAxis;
  var scrollbar = axis && axis.scrollbar;
  if (scrollbar && defined34(scrollbar.to) && defined34(scrollbar.from)) {
    var range = scrollbar.to - scrollbar.from;
    var pos = getRelativePointAxisPosition(axis, point);
    scrollbar.updatePosition(pos - range / 2, pos + range / 2);
    fireEvent20(scrollbar, "changed", {
      from: scrollbar.from,
      to: scrollbar.to,
      trigger: "scrollbar",
      DOMEvent: null
    });
  }
}
var ChartUtilities = {
  getChartTitle,
  getAxisDescription,
  getAxisRangeDescription,
  getPointFromXY,
  getSeriesFirstPointElement,
  getSeriesFromName,
  getSeriesA11yElement,
  unhideChartElementFromAT,
  hideSeriesFromAT,
  scrollToPoint
};
var ChartUtilities_default = ChartUtilities;

// node_modules/highcharts/es-modules/Accessibility/KeyboardNavigationHandler.js
var find12 = Utilities_default.find;
function KeyboardNavigationHandler(chart, options) {
  this.chart = chart;
  this.keyCodeMap = options.keyCodeMap || [];
  this.validate = options.validate;
  this.init = options.init;
  this.terminate = options.terminate;
  this.response = {
    success: 1,
    prev: 2,
    next: 3,
    noHandler: 4,
    fail: 5
  };
}
KeyboardNavigationHandler.prototype = {
  run: function(e2) {
    var keyCode = e2.which || e2.keyCode;
    var response = this.response.noHandler;
    var handlerCodeSet = find12(this.keyCodeMap, function(codeSet) {
      return codeSet[0].indexOf(keyCode) > -1;
    });
    if (handlerCodeSet) {
      response = handlerCodeSet[1].call(this, keyCode, e2);
    } else if (keyCode === 9) {
      response = this.response[e2.shiftKey ? "prev" : "next"];
    }
    return response;
  }
};
var KeyboardNavigationHandler_default = KeyboardNavigationHandler;

// node_modules/highcharts/es-modules/Accessibility/Utils/DOMElementProvider.js
var doc10 = Globals_default.doc;
var removeElement2 = HTMLUtilities_default.removeElement;
var extend31 = Utilities_default.extend;
var DOMElementProvider = function() {
  this.elements = [];
};
extend31(DOMElementProvider.prototype, {
  createElement: function() {
    var el = doc10.createElement.apply(doc10, arguments);
    this.elements.push(el);
    return el;
  },
  destroyCreatedElements: function() {
    this.elements.forEach(function(element) {
      removeElement2(element);
    });
    this.elements = [];
  }
});
var DOMElementProvider_default = DOMElementProvider;

// node_modules/highcharts/es-modules/Accessibility/Utils/EventProvider.js
var addEvent29 = Utilities_default.addEvent;
var extend32 = Utilities_default.extend;
var EventProvider = function() {
  this.eventRemovers = [];
};
extend32(EventProvider.prototype, {
  addEvent: function() {
    var remover = addEvent29.apply(Globals_default, arguments);
    this.eventRemovers.push(remover);
    return remover;
  },
  removeAddedEvents: function() {
    this.eventRemovers.forEach(function(remover) {
      remover();
    });
    this.eventRemovers = [];
  }
});
var EventProvider_default = EventProvider;

// node_modules/highcharts/es-modules/Accessibility/AccessibilityComponent.js
var unhideChartElementFromAT2 = ChartUtilities_default.unhideChartElementFromAT;
var doc11 = Globals_default.doc;
var win13 = Globals_default.win;
var removeElement3 = HTMLUtilities_default.removeElement;
var getFakeMouseEvent2 = HTMLUtilities_default.getFakeMouseEvent;
var extend33 = Utilities_default.extend;
var fireEvent21 = Utilities_default.fireEvent;
var merge41 = Utilities_default.merge;
var functionsToOverrideByDerivedClasses = {
  init: function() {
  },
  getKeyboardNavigation: function() {
  },
  onChartUpdate: function() {
  },
  onChartRender: function() {
  },
  destroy: function() {
  }
};
function AccessibilityComponent() {
}
AccessibilityComponent.prototype = {
  initBase: function(chart) {
    this.chart = chart;
    this.eventProvider = new EventProvider_default();
    this.domElementProvider = new DOMElementProvider_default();
    this.keyCodes = {
      left: 37,
      right: 39,
      up: 38,
      down: 40,
      enter: 13,
      space: 32,
      esc: 27,
      tab: 9
    };
  },
  addEvent: function() {
    return this.eventProvider.addEvent.apply(this.eventProvider, arguments);
  },
  createElement: function() {
    return this.domElementProvider.createElement.apply(this.domElementProvider, arguments);
  },
  fireEventOnWrappedOrUnwrappedElement: function(el, eventObject) {
    var type = eventObject.type;
    if (doc11.createEvent && (el.dispatchEvent || el.fireEvent)) {
      if (el.dispatchEvent) {
        el.dispatchEvent(eventObject);
      } else {
        el.fireEvent(type, eventObject);
      }
    } else {
      fireEvent21(el, type, eventObject);
    }
  },
  fakeClickEvent: function(element) {
    if (element) {
      var fakeEventObject = getFakeMouseEvent2("click");
      this.fireEventOnWrappedOrUnwrappedElement(element, fakeEventObject);
    }
  },
  addProxyGroup: function(attrs) {
    this.createOrUpdateProxyContainer();
    var groupDiv = this.createElement("div");
    Object.keys(attrs || {}).forEach(function(prop) {
      if (attrs[prop] !== null) {
        groupDiv.setAttribute(prop, attrs[prop]);
      }
    });
    this.chart.a11yProxyContainer.appendChild(groupDiv);
    return groupDiv;
  },
  createOrUpdateProxyContainer: function() {
    var chart = this.chart, rendererSVGEl = chart.renderer.box;
    chart.a11yProxyContainer = chart.a11yProxyContainer || this.createProxyContainerElement();
    if (rendererSVGEl.nextSibling !== chart.a11yProxyContainer) {
      chart.container.insertBefore(chart.a11yProxyContainer, rendererSVGEl.nextSibling);
    }
  },
  createProxyContainerElement: function() {
    var pc = doc11.createElement("div");
    pc.className = "highcharts-a11y-proxy-container";
    return pc;
  },
  createProxyButton: function(svgElement, parentGroup, attributes, posElement, preClickEvent) {
    var svgEl = svgElement.element, proxy = this.createElement("button"), attrs = merge41({
      "aria-label": svgEl.getAttribute("aria-label")
    }, attributes);
    Object.keys(attrs).forEach(function(prop) {
      if (attrs[prop] !== null) {
        proxy.setAttribute(prop, attrs[prop]);
      }
    });
    proxy.className = "highcharts-a11y-proxy-button";
    if (svgElement.hasClass("highcharts-no-tooltip")) {
      proxy.className += " highcharts-no-tooltip";
    }
    if (preClickEvent) {
      this.addEvent(proxy, "click", preClickEvent);
    }
    this.setProxyButtonStyle(proxy);
    this.updateProxyButtonPosition(proxy, posElement || svgElement);
    this.proxyMouseEventsForButton(svgEl, proxy);
    parentGroup.appendChild(proxy);
    if (!attrs["aria-hidden"]) {
      unhideChartElementFromAT2(this.chart, proxy);
    }
    return proxy;
  },
  getElementPosition: function(element) {
    var el = element.element, div = this.chart.renderTo;
    if (div && el && el.getBoundingClientRect) {
      var rectEl = el.getBoundingClientRect(), rectDiv = div.getBoundingClientRect();
      return {
        x: rectEl.left - rectDiv.left,
        y: rectEl.top - rectDiv.top,
        width: rectEl.right - rectEl.left,
        height: rectEl.bottom - rectEl.top
      };
    }
    return { x: 0, y: 0, width: 1, height: 1 };
  },
  setProxyButtonStyle: function(button) {
    merge41(true, button.style, {
      borderWidth: "0",
      backgroundColor: "transparent",
      cursor: "pointer",
      outline: "none",
      opacity: "0.001",
      filter: "alpha(opacity=1)",
      zIndex: "999",
      overflow: "hidden",
      padding: "0",
      margin: "0",
      display: "block",
      position: "absolute"
    });
    button.style["-ms-filter"] = "progid:DXImageTransform.Microsoft.Alpha(Opacity=1)";
  },
  updateProxyButtonPosition: function(proxy, posElement) {
    var bBox = this.getElementPosition(posElement);
    merge41(true, proxy.style, {
      width: (bBox.width || 1) + "px",
      height: (bBox.height || 1) + "px",
      left: (Math.round(bBox.x) || 0) + "px",
      top: (Math.round(bBox.y) || 0) + "px"
    });
  },
  proxyMouseEventsForButton: function(source, button) {
    var component = this;
    [
      "click",
      "touchstart",
      "touchend",
      "touchcancel",
      "touchmove",
      "mouseover",
      "mouseenter",
      "mouseleave",
      "mouseout"
    ].forEach(function(evtType) {
      var isTouchEvent = evtType.indexOf("touch") === 0;
      component.addEvent(button, evtType, function(e2) {
        var clonedEvent = isTouchEvent ? component.cloneTouchEvent(e2) : component.cloneMouseEvent(e2);
        if (source) {
          component.fireEventOnWrappedOrUnwrappedElement(source, clonedEvent);
        }
        e2.stopPropagation();
        if (evtType !== "touchstart" && evtType !== "touchmove" && evtType !== "touchend") {
          e2.preventDefault();
        }
      }, { passive: false });
    });
  },
  cloneMouseEvent: function(e2) {
    if (typeof win13.MouseEvent === "function") {
      return new win13.MouseEvent(e2.type, e2);
    }
    if (doc11.createEvent) {
      var evt = doc11.createEvent("MouseEvent");
      if (evt.initMouseEvent) {
        evt.initMouseEvent(e2.type, e2.bubbles, e2.cancelable, e2.view || win13, e2.detail, e2.screenX, e2.screenY, e2.clientX, e2.clientY, e2.ctrlKey, e2.altKey, e2.shiftKey, e2.metaKey, e2.button, e2.relatedTarget);
        return evt;
      }
    }
    return getFakeMouseEvent2(e2.type);
  },
  cloneTouchEvent: function(e2) {
    var touchListToTouchArray = function(l) {
      var touchArray = [];
      for (var i = 0; i < l.length; ++i) {
        var item = l.item(i);
        if (item) {
          touchArray.push(item);
        }
      }
      return touchArray;
    };
    if (typeof win13.TouchEvent === "function") {
      var newEvent = new win13.TouchEvent(e2.type, {
        touches: touchListToTouchArray(e2.touches),
        targetTouches: touchListToTouchArray(e2.targetTouches),
        changedTouches: touchListToTouchArray(e2.changedTouches),
        ctrlKey: e2.ctrlKey,
        shiftKey: e2.shiftKey,
        altKey: e2.altKey,
        metaKey: e2.metaKey,
        bubbles: e2.bubbles,
        cancelable: e2.cancelable,
        composed: e2.composed,
        detail: e2.detail,
        view: e2.view
      });
      if (e2.defaultPrevented) {
        newEvent.preventDefault();
      }
      return newEvent;
    }
    var fakeEvt = this.cloneMouseEvent(e2);
    fakeEvt.touches = e2.touches;
    fakeEvt.changedTouches = e2.changedTouches;
    fakeEvt.targetTouches = e2.targetTouches;
    return fakeEvt;
  },
  destroyBase: function() {
    removeElement3(this.chart.a11yProxyContainer);
    this.domElementProvider.destroyCreatedElements();
    this.eventProvider.removeAddedEvents();
  }
};
extend33(AccessibilityComponent.prototype, functionsToOverrideByDerivedClasses);
var AccessibilityComponent_default = AccessibilityComponent;

// node_modules/highcharts/es-modules/Accessibility/KeyboardNavigation.js
var doc12 = Globals_default.doc;
var win14 = Globals_default.win;
var addEvent30 = Utilities_default.addEvent;
var fireEvent22 = Utilities_default.fireEvent;
var getElement2 = HTMLUtilities_default.getElement;
addEvent30(doc12, "keydown", function(e2) {
  var keycode = e2.which || e2.keyCode;
  var esc = 27;
  if (keycode === esc && Globals_default.charts) {
    Globals_default.charts.forEach(function(chart) {
      if (chart && chart.dismissPopupContent) {
        chart.dismissPopupContent();
      }
    });
  }
});
Chart_default.prototype.dismissPopupContent = function() {
  var chart = this;
  fireEvent22(this, "dismissPopupContent", {}, function() {
    if (chart.tooltip) {
      chart.tooltip.hide(0);
    }
    chart.hideExportMenu();
  });
};
function KeyboardNavigation(chart, components) {
  this.init(chart, components);
}
KeyboardNavigation.prototype = {
  init: function(chart, components) {
    var _this = this;
    var ep = this.eventProvider = new EventProvider_default();
    this.chart = chart;
    this.components = components;
    this.modules = [];
    this.currentModuleIx = 0;
    this.update();
    ep.addEvent(this.tabindexContainer, "keydown", function(e2) {
      return _this.onKeydown(e2);
    });
    ep.addEvent(this.tabindexContainer, "focus", function(e2) {
      return _this.onFocus(e2);
    });
    ["mouseup", "touchend"].forEach(function(eventName) {
      return ep.addEvent(doc12, eventName, function() {
        return _this.onMouseUp();
      });
    });
    ["mousedown", "touchstart"].forEach(function(eventName) {
      return ep.addEvent(chart.renderTo, eventName, function() {
        _this.isClickingChart = true;
      });
    });
    ep.addEvent(chart.renderTo, "mouseover", function() {
      _this.pointerIsOverChart = true;
    });
    ep.addEvent(chart.renderTo, "mouseout", function() {
      _this.pointerIsOverChart = false;
    });
    if (this.modules.length) {
      this.modules[0].init(1);
    }
  },
  update: function(order) {
    var a11yOptions = this.chart.options.accessibility, keyboardOptions = a11yOptions && a11yOptions.keyboardNavigation, components = this.components;
    this.updateContainerTabindex();
    if (keyboardOptions && keyboardOptions.enabled && order && order.length) {
      this.modules = order.reduce(function(modules, componentName) {
        var navModules = components[componentName].getKeyboardNavigation();
        return modules.concat(navModules);
      }, []);
      this.updateExitAnchor();
    } else {
      this.modules = [];
      this.currentModuleIx = 0;
      this.removeExitAnchor();
    }
  },
  onFocus: function(e2) {
    var chart = this.chart;
    var focusComesFromChart = e2.relatedTarget && chart.container.contains(e2.relatedTarget);
    if (!this.exiting && !this.tabbingInBackwards && !this.isClickingChart && !focusComesFromChart && this.modules[0]) {
      this.modules[0].init(1);
    }
    this.exiting = false;
  },
  onMouseUp: function() {
    delete this.isClickingChart;
    if (!this.keyboardReset && !this.pointerIsOverChart) {
      var chart = this.chart, curMod = this.modules && this.modules[this.currentModuleIx || 0];
      if (curMod && curMod.terminate) {
        curMod.terminate();
      }
      if (chart.focusElement) {
        chart.focusElement.removeFocusBorder();
      }
      this.currentModuleIx = 0;
      this.keyboardReset = true;
    }
  },
  onKeydown: function(ev) {
    var e2 = ev || win14.event, preventDefault, curNavModule = this.modules && this.modules.length && this.modules[this.currentModuleIx];
    this.keyboardReset = false;
    this.exiting = false;
    if (curNavModule) {
      var response = curNavModule.run(e2);
      if (response === curNavModule.response.success) {
        preventDefault = true;
      } else if (response === curNavModule.response.prev) {
        preventDefault = this.prev();
      } else if (response === curNavModule.response.next) {
        preventDefault = this.next();
      }
      if (preventDefault) {
        e2.preventDefault();
        e2.stopPropagation();
      }
    }
  },
  prev: function() {
    return this.move(-1);
  },
  next: function() {
    return this.move(1);
  },
  move: function(direction) {
    var curModule = this.modules && this.modules[this.currentModuleIx];
    if (curModule && curModule.terminate) {
      curModule.terminate(direction);
    }
    if (this.chart.focusElement) {
      this.chart.focusElement.removeFocusBorder();
    }
    this.currentModuleIx += direction;
    var newModule = this.modules && this.modules[this.currentModuleIx];
    if (newModule) {
      if (newModule.validate && !newModule.validate()) {
        return this.move(direction);
      }
      if (newModule.init) {
        newModule.init(direction);
        return true;
      }
    }
    this.currentModuleIx = 0;
    this.exiting = true;
    if (direction > 0) {
      this.exitAnchor.focus();
    } else {
      this.tabindexContainer.focus();
    }
    return false;
  },
  updateExitAnchor: function() {
    var endMarkerId = "highcharts-end-of-chart-marker-" + this.chart.index, endMarker = getElement2(endMarkerId);
    this.removeExitAnchor();
    if (endMarker) {
      this.makeElementAnExitAnchor(endMarker);
      this.exitAnchor = endMarker;
    } else {
      this.createExitAnchor();
    }
  },
  updateContainerTabindex: function() {
    var a11yOptions = this.chart.options.accessibility, keyboardOptions = a11yOptions && a11yOptions.keyboardNavigation, shouldHaveTabindex = !(keyboardOptions && keyboardOptions.enabled === false), chart = this.chart, container = chart.container;
    var tabindexContainer;
    if (chart.renderTo.hasAttribute("tabindex")) {
      container.removeAttribute("tabindex");
      tabindexContainer = chart.renderTo;
    } else {
      tabindexContainer = container;
    }
    this.tabindexContainer = tabindexContainer;
    var curTabindex = tabindexContainer.getAttribute("tabindex");
    if (shouldHaveTabindex && !curTabindex) {
      tabindexContainer.setAttribute("tabindex", "0");
    } else if (!shouldHaveTabindex) {
      chart.container.removeAttribute("tabindex");
    }
  },
  makeElementAnExitAnchor: function(el) {
    var chartTabindex = this.tabindexContainer.getAttribute("tabindex") || 0;
    el.setAttribute("class", "highcharts-exit-anchor");
    el.setAttribute("tabindex", chartTabindex);
    el.setAttribute("aria-hidden", false);
    this.addExitAnchorEventsToEl(el);
  },
  createExitAnchor: function() {
    var chart = this.chart, exitAnchor = this.exitAnchor = doc12.createElement("div");
    chart.renderTo.appendChild(exitAnchor);
    this.makeElementAnExitAnchor(exitAnchor);
  },
  removeExitAnchor: function() {
    if (this.exitAnchor && this.exitAnchor.parentNode) {
      this.exitAnchor.parentNode.removeChild(this.exitAnchor);
      delete this.exitAnchor;
    }
  },
  addExitAnchorEventsToEl: function(element) {
    var chart = this.chart, keyboardNavigation = this;
    this.eventProvider.addEvent(element, "focus", function(ev) {
      var e2 = ev || win14.event, curModule, focusComesFromChart = e2.relatedTarget && chart.container.contains(e2.relatedTarget), comingInBackwards = !(focusComesFromChart || keyboardNavigation.exiting);
      if (comingInBackwards) {
        keyboardNavigation.tabbingInBackwards = true;
        keyboardNavigation.tabindexContainer.focus();
        delete keyboardNavigation.tabbingInBackwards;
        e2.preventDefault();
        if (keyboardNavigation.modules && keyboardNavigation.modules.length) {
          keyboardNavigation.currentModuleIx = keyboardNavigation.modules.length - 1;
          curModule = keyboardNavigation.modules[keyboardNavigation.currentModuleIx];
          if (curModule && curModule.validate && !curModule.validate()) {
            keyboardNavigation.prev();
          } else if (curModule) {
            curModule.init(-1);
          }
        }
      } else {
        keyboardNavigation.exiting = false;
      }
    });
  },
  destroy: function() {
    this.removeExitAnchor();
    this.eventProvider.removeAddedEvents();
    this.chart.container.removeAttribute("tabindex");
  }
};
var KeyboardNavigation_default = KeyboardNavigation;

// node_modules/highcharts/es-modules/Accessibility/Components/LegendComponent.js
var animObject10 = AnimationUtilities_default.animObject;
var addEvent31 = Utilities_default.addEvent;
var extend34 = Utilities_default.extend;
var find13 = Utilities_default.find;
var fireEvent23 = Utilities_default.fireEvent;
var isNumber32 = Utilities_default.isNumber;
var pick46 = Utilities_default.pick;
var syncTimeout9 = Utilities_default.syncTimeout;
var removeElement4 = HTMLUtilities_default.removeElement;
var stripHTMLTags2 = HTMLUtilities_default.stripHTMLTagsFromString;
var getChartTitle2 = ChartUtilities_default.getChartTitle;
function scrollLegendToItem(legend, itemIx) {
  var itemPage = legend.allItems[itemIx].pageIx, curPage = legend.currentPage;
  if (typeof itemPage !== "undefined" && itemPage + 1 !== curPage) {
    legend.scroll(1 + itemPage - curPage);
  }
}
function shouldDoLegendA11y(chart) {
  var items = chart.legend && chart.legend.allItems, legendA11yOptions = chart.options.legend.accessibility || {};
  return !!(items && items.length && !(chart.colorAxis && chart.colorAxis.length) && legendA11yOptions.enabled !== false);
}
Chart_default.prototype.highlightLegendItem = function(ix) {
  var items = this.legend.allItems, oldIx = this.accessibility && this.accessibility.components.legend.highlightedLegendItemIx;
  if (items[ix]) {
    if (isNumber32(oldIx) && items[oldIx]) {
      fireEvent23(items[oldIx].legendGroup.element, "mouseout");
    }
    scrollLegendToItem(this.legend, ix);
    this.setFocusToElement(items[ix].legendItem, items[ix].a11yProxyElement);
    fireEvent23(items[ix].legendGroup.element, "mouseover");
    return true;
  }
  return false;
};
addEvent31(Legend_default, "afterColorizeItem", function(e2) {
  var chart = this.chart, a11yOptions = chart.options.accessibility, legendItem = e2.item;
  if (a11yOptions.enabled && legendItem && legendItem.a11yProxyElement) {
    legendItem.a11yProxyElement.setAttribute("aria-pressed", e2.visible ? "true" : "false");
  }
});
var LegendComponent = function() {
};
LegendComponent.prototype = new AccessibilityComponent_default();
extend34(LegendComponent.prototype, {
  init: function() {
    var component = this;
    this.proxyElementsList = [];
    this.recreateProxies();
    this.addEvent(Legend_default, "afterScroll", function() {
      if (this.chart === component.chart) {
        component.updateProxiesPositions();
        component.updateLegendItemProxyVisibility();
        this.chart.highlightLegendItem(component.highlightedLegendItemIx);
      }
    });
    this.addEvent(Legend_default, "afterPositionItem", function(e2) {
      if (this.chart === component.chart && this.chart.renderer) {
        component.updateProxyPositionForItem(e2.item);
      }
    });
    this.addEvent(Legend_default, "afterRender", function() {
      if (this.chart === component.chart && this.chart.renderer && component.recreateProxies()) {
        syncTimeout9(function() {
          return component.updateProxiesPositions();
        }, animObject10(pick46(this.chart.renderer.globalAnimation, true)).duration);
      }
    });
  },
  updateLegendItemProxyVisibility: function() {
    var legend = this.chart.legend, items = legend.allItems || [], curPage = legend.currentPage || 1, clipHeight = legend.clipHeight || 0;
    items.forEach(function(item) {
      var itemPage = item.pageIx || 0, y = item._legendItemPos ? item._legendItemPos[1] : 0, h = item.legendItem ? Math.round(item.legendItem.getBBox().height) : 0, hide = y + h - legend.pages[itemPage] > clipHeight || itemPage !== curPage - 1;
      if (item.a11yProxyElement) {
        item.a11yProxyElement.style.visibility = hide ? "hidden" : "visible";
      }
    });
  },
  onChartRender: function() {
    if (!shouldDoLegendA11y(this.chart)) {
      this.removeProxies();
    }
  },
  onChartUpdate: function() {
    this.updateLegendTitle();
  },
  updateProxiesPositions: function() {
    for (var _i = 0, _a15 = this.proxyElementsList; _i < _a15.length; _i++) {
      var _b = _a15[_i], element = _b.element, posElement = _b.posElement;
      this.updateProxyButtonPosition(element, posElement);
    }
  },
  updateProxyPositionForItem: function(item) {
    var proxyRef = find13(this.proxyElementsList, function(ref) {
      return ref.item === item;
    });
    if (proxyRef) {
      this.updateProxyButtonPosition(proxyRef.element, proxyRef.posElement);
    }
  },
  recreateProxies: function() {
    this.removeProxies();
    if (shouldDoLegendA11y(this.chart)) {
      this.addLegendProxyGroup();
      this.addLegendListContainer();
      this.proxyLegendItems();
      this.updateLegendItemProxyVisibility();
      return true;
    }
    return false;
  },
  removeProxies: function() {
    removeElement4(this.legendProxyGroup);
    this.proxyElementsList = [];
  },
  updateLegendTitle: function() {
    var chart = this.chart;
    var legendTitle = stripHTMLTags2((chart.legend && chart.legend.options.title && chart.legend.options.title.text || "").replace(/<br ?\/?>/g, " "));
    var legendLabel = chart.langFormat("accessibility.legend.legendLabel" + (legendTitle ? "" : "NoTitle"), {
      chart,
      legendTitle,
      chartTitle: getChartTitle2(chart)
    });
    if (this.legendProxyGroup) {
      this.legendProxyGroup.setAttribute("aria-label", legendLabel);
    }
  },
  addLegendProxyGroup: function() {
    var a11yOptions = this.chart.options.accessibility, groupRole = a11yOptions.landmarkVerbosity === "all" ? "region" : null;
    this.legendProxyGroup = this.addProxyGroup({
      "aria-label": "_placeholder_",
      role: groupRole
    });
  },
  addLegendListContainer: function() {
    if (this.legendProxyGroup) {
      var container = this.legendListContainer = this.createElement("ul");
      container.style.listStyle = "none";
      this.legendProxyGroup.appendChild(container);
    }
  },
  proxyLegendItems: function() {
    var component = this, items = this.chart.legend && this.chart.legend.allItems || [];
    items.forEach(function(item) {
      if (item.legendItem && item.legendItem.element) {
        component.proxyLegendItem(item);
      }
    });
  },
  proxyLegendItem: function(item) {
    if (!item.legendItem || !item.legendGroup || !this.legendListContainer) {
      return;
    }
    var itemLabel = this.chart.langFormat("accessibility.legend.legendItem", {
      chart: this.chart,
      itemName: stripHTMLTags2(item.name),
      item
    }), attribs = {
      tabindex: -1,
      "aria-pressed": item.visible,
      "aria-label": itemLabel
    }, proxyPositioningElement = item.legendGroup.div ? item.legendItem : item.legendGroup;
    var listItem = this.createElement("li");
    this.legendListContainer.appendChild(listItem);
    item.a11yProxyElement = this.createProxyButton(item.legendItem, listItem, attribs, proxyPositioningElement);
    this.proxyElementsList.push({
      item,
      element: item.a11yProxyElement,
      posElement: proxyPositioningElement
    });
  },
  getKeyboardNavigation: function() {
    var keys2 = this.keyCodes, component = this, chart = this.chart;
    return new KeyboardNavigationHandler_default(chart, {
      keyCodeMap: [
        [
          [keys2.left, keys2.right, keys2.up, keys2.down],
          function(keyCode) {
            return component.onKbdArrowKey(this, keyCode);
          }
        ],
        [
          [keys2.enter, keys2.space],
          function(keyCode) {
            if (Globals_default.isFirefox && keyCode === keys2.space) {
              return this.response.success;
            }
            return component.onKbdClick(this);
          }
        ]
      ],
      validate: function() {
        return component.shouldHaveLegendNavigation();
      },
      init: function(direction) {
        return component.onKbdNavigationInit(direction);
      },
      terminate: function() {
        chart.legend.allItems.forEach(function(item) {
          return item.setState("", true);
        });
      }
    });
  },
  onKbdArrowKey: function(keyboardNavigationHandler, keyCode) {
    var keys2 = this.keyCodes, response = keyboardNavigationHandler.response, chart = this.chart, a11yOptions = chart.options.accessibility, numItems = chart.legend.allItems.length, direction = keyCode === keys2.left || keyCode === keys2.up ? -1 : 1;
    var res = chart.highlightLegendItem(this.highlightedLegendItemIx + direction);
    if (res) {
      this.highlightedLegendItemIx += direction;
      return response.success;
    }
    if (numItems > 1 && a11yOptions.keyboardNavigation.wrapAround) {
      keyboardNavigationHandler.init(direction);
      return response.success;
    }
    return response[direction > 0 ? "next" : "prev"];
  },
  onKbdClick: function(keyboardNavigationHandler) {
    var legendItem = this.chart.legend.allItems[this.highlightedLegendItemIx];
    if (legendItem && legendItem.a11yProxyElement) {
      fireEvent23(legendItem.a11yProxyElement, "click");
    }
    return keyboardNavigationHandler.response.success;
  },
  shouldHaveLegendNavigation: function() {
    var chart = this.chart, legendOptions = chart.options.legend || {}, hasLegend = chart.legend && chart.legend.allItems, hasColorAxis = chart.colorAxis && chart.colorAxis.length, legendA11yOptions = legendOptions.accessibility || {};
    return !!(hasLegend && chart.legend.display && !hasColorAxis && legendA11yOptions.enabled && legendA11yOptions.keyboardNavigation && legendA11yOptions.keyboardNavigation.enabled);
  },
  onKbdNavigationInit: function(direction) {
    var chart = this.chart, lastIx = chart.legend.allItems.length - 1, ixToHighlight = direction > 0 ? 0 : lastIx;
    chart.highlightLegendItem(ixToHighlight);
    this.highlightedLegendItemIx = ixToHighlight;
  }
});
var LegendComponent_default = LegendComponent;

// node_modules/highcharts/es-modules/Accessibility/Components/MenuComponent.js
var extend35 = Utilities_default.extend;
var getChartTitle3 = ChartUtilities_default.getChartTitle;
var unhideChartElementFromAT3 = ChartUtilities_default.unhideChartElementFromAT;
var removeElement5 = HTMLUtilities_default.removeElement;
var getFakeMouseEvent3 = HTMLUtilities_default.getFakeMouseEvent;
function getExportMenuButtonElement(chart) {
  return chart.exportSVGElements && chart.exportSVGElements[0];
}
Chart_default.prototype.showExportMenu = function() {
  var exportButton = getExportMenuButtonElement(this);
  if (exportButton) {
    var el = exportButton.element;
    if (el.onclick) {
      el.onclick(getFakeMouseEvent3("click"));
    }
  }
};
Chart_default.prototype.hideExportMenu = function() {
  var chart = this, exportList = chart.exportDivElements;
  if (exportList && chart.exportContextMenu) {
    exportList.forEach(function(el) {
      if (el && el.className === "highcharts-menu-item" && el.onmouseout) {
        el.onmouseout(getFakeMouseEvent3("mouseout"));
      }
    });
    chart.highlightedExportItemIx = 0;
    chart.exportContextMenu.hideMenu();
    chart.container.focus();
  }
};
Chart_default.prototype.highlightExportItem = function(ix) {
  var listItem = this.exportDivElements && this.exportDivElements[ix], curHighlighted = this.exportDivElements && this.exportDivElements[this.highlightedExportItemIx], hasSVGFocusSupport;
  if (listItem && listItem.tagName === "LI" && !(listItem.children && listItem.children.length)) {
    hasSVGFocusSupport = !!(this.renderTo.getElementsByTagName("g")[0] || {}).focus;
    if (listItem.focus && hasSVGFocusSupport) {
      listItem.focus();
    }
    if (curHighlighted && curHighlighted.onmouseout) {
      curHighlighted.onmouseout(getFakeMouseEvent3("mouseout"));
    }
    if (listItem.onmouseover) {
      listItem.onmouseover(getFakeMouseEvent3("mouseover"));
    }
    this.highlightedExportItemIx = ix;
    return true;
  }
  return false;
};
Chart_default.prototype.highlightLastExportItem = function() {
  var chart = this, i;
  if (chart.exportDivElements) {
    i = chart.exportDivElements.length;
    while (i--) {
      if (chart.highlightExportItem(i)) {
        return true;
      }
    }
  }
  return false;
};
function exportingShouldHaveA11y(chart) {
  var exportingOpts = chart.options.exporting, exportButton = getExportMenuButtonElement(chart);
  return !!(exportingOpts && exportingOpts.enabled !== false && exportingOpts.accessibility && exportingOpts.accessibility.enabled && exportButton && exportButton.element);
}
var MenuComponent = function() {
};
MenuComponent.prototype = new AccessibilityComponent_default();
extend35(MenuComponent.prototype, {
  init: function() {
    var chart = this.chart, component = this;
    this.addEvent(chart, "exportMenuShown", function() {
      component.onMenuShown();
    });
    this.addEvent(chart, "exportMenuHidden", function() {
      component.onMenuHidden();
    });
  },
  onMenuHidden: function() {
    var menu = this.chart.exportContextMenu;
    if (menu) {
      menu.setAttribute("aria-hidden", "true");
    }
    this.isExportMenuShown = false;
    this.setExportButtonExpandedState("false");
  },
  onMenuShown: function() {
    var chart = this.chart, menu = chart.exportContextMenu;
    if (menu) {
      this.addAccessibleContextMenuAttribs();
      unhideChartElementFromAT3(chart, menu);
    }
    this.isExportMenuShown = true;
    this.setExportButtonExpandedState("true");
  },
  setExportButtonExpandedState: function(stateStr) {
    var button = this.exportButtonProxy;
    if (button) {
      button.setAttribute("aria-expanded", stateStr);
    }
  },
  onChartRender: function() {
    var chart = this.chart, a11yOptions = chart.options.accessibility;
    removeElement5(this.exportProxyGroup);
    if (exportingShouldHaveA11y(chart)) {
      this.exportProxyGroup = this.addProxyGroup(a11yOptions.landmarkVerbosity === "all" ? {
        "aria-label": chart.langFormat("accessibility.exporting.exportRegionLabel", { chart, chartTitle: getChartTitle3(chart) }),
        "role": "region"
      } : {});
      var button = getExportMenuButtonElement(this.chart);
      this.exportButtonProxy = this.createProxyButton(button, this.exportProxyGroup, {
        "aria-label": chart.langFormat("accessibility.exporting.menuButtonLabel", { chart }),
        "aria-expanded": false
      });
    }
  },
  addAccessibleContextMenuAttribs: function() {
    var chart = this.chart, exportList = chart.exportDivElements;
    if (exportList && exportList.length) {
      exportList.forEach(function(item) {
        if (item) {
          if (item.tagName === "LI" && !(item.children && item.children.length)) {
            item.setAttribute("tabindex", -1);
          } else {
            item.setAttribute("aria-hidden", "true");
          }
        }
      });
      var parentDiv = exportList[0] && exportList[0].parentNode;
      if (parentDiv) {
        parentDiv.removeAttribute("aria-hidden");
        parentDiv.setAttribute("aria-label", chart.langFormat("accessibility.exporting.chartMenuLabel", { chart }));
      }
    }
  },
  getKeyboardNavigation: function() {
    var keys2 = this.keyCodes, chart = this.chart, component = this;
    return new KeyboardNavigationHandler_default(chart, {
      keyCodeMap: [
        [
          [keys2.left, keys2.up],
          function() {
            return component.onKbdPrevious(this);
          }
        ],
        [
          [keys2.right, keys2.down],
          function() {
            return component.onKbdNext(this);
          }
        ],
        [
          [keys2.enter, keys2.space],
          function() {
            return component.onKbdClick(this);
          }
        ]
      ],
      validate: function() {
        return !!chart.exporting && chart.options.exporting.enabled !== false && chart.options.exporting.accessibility.enabled !== false;
      },
      init: function() {
        var exportBtn = component.exportButtonProxy, exportGroup = chart.exportingGroup;
        if (exportGroup && exportBtn) {
          chart.setFocusToElement(exportGroup, exportBtn);
        }
      },
      terminate: function() {
        chart.hideExportMenu();
      }
    });
  },
  onKbdPrevious: function(keyboardNavigationHandler) {
    var chart = this.chart, a11yOptions = chart.options.accessibility, response = keyboardNavigationHandler.response, i = chart.highlightedExportItemIx || 0;
    while (i--) {
      if (chart.highlightExportItem(i)) {
        return response.success;
      }
    }
    if (a11yOptions.keyboardNavigation.wrapAround) {
      chart.highlightLastExportItem();
      return response.success;
    }
    return response.prev;
  },
  onKbdNext: function(keyboardNavigationHandler) {
    var chart = this.chart, a11yOptions = chart.options.accessibility, response = keyboardNavigationHandler.response, i = (chart.highlightedExportItemIx || 0) + 1;
    for (; i < chart.exportDivElements.length; ++i) {
      if (chart.highlightExportItem(i)) {
        return response.success;
      }
    }
    if (a11yOptions.keyboardNavigation.wrapAround) {
      chart.highlightExportItem(0);
      return response.success;
    }
    return response.next;
  },
  onKbdClick: function(keyboardNavigationHandler) {
    var chart = this.chart, curHighlightedItem = chart.exportDivElements[chart.highlightedExportItemIx], exportButtonElement = getExportMenuButtonElement(chart).element;
    if (this.isExportMenuShown) {
      this.fakeClickEvent(curHighlightedItem);
    } else {
      this.fakeClickEvent(exportButtonElement);
      chart.highlightExportItem(0);
    }
    return keyboardNavigationHandler.response.success;
  }
});
var MenuComponent_default = MenuComponent;

// node_modules/highcharts/es-modules/Accessibility/Components/SeriesComponent/SeriesKeyboardNavigation.js
var seriesTypes4 = SeriesRegistry_default.seriesTypes;
var doc13 = Globals_default.doc;
var defined35 = Utilities_default.defined;
var extend36 = Utilities_default.extend;
var fireEvent24 = Utilities_default.fireEvent;
var getPointFromXY2 = ChartUtilities_default.getPointFromXY;
var getSeriesFromName2 = ChartUtilities_default.getSeriesFromName;
var scrollToPoint2 = ChartUtilities_default.scrollToPoint;
Series_default.prototype.keyboardMoveVertical = true;
["column", "pie"].forEach(function(type) {
  if (seriesTypes4[type]) {
    seriesTypes4[type].prototype.keyboardMoveVertical = false;
  }
});
function getPointIndex(point) {
  var index = point.index, points = point.series.points;
  var i = points.length;
  if (points[index] !== point) {
    while (i--) {
      if (points[i] === point) {
        return i;
      }
    }
  } else {
    return index;
  }
}
function isSkipSeries(series) {
  var a11yOptions = series.chart.options.accessibility, seriesNavOptions = a11yOptions.keyboardNavigation.seriesNavigation, seriesA11yOptions = series.options.accessibility || {}, seriesKbdNavOptions = seriesA11yOptions.keyboardNavigation;
  return seriesKbdNavOptions && seriesKbdNavOptions.enabled === false || seriesA11yOptions.enabled === false || series.options.enableMouseTracking === false || !series.visible || seriesNavOptions.pointNavigationEnabledThreshold && seriesNavOptions.pointNavigationEnabledThreshold <= series.points.length;
}
function isSkipPoint(point) {
  var a11yOptions = point.series.chart.options.accessibility;
  var pointA11yDisabled = point.options.accessibility && point.options.accessibility.enabled === false;
  return point.isNull && a11yOptions.keyboardNavigation.seriesNavigation.skipNullPoints || point.visible === false || point.isInside === false || pointA11yDisabled || isSkipSeries(point.series);
}
function getClosestPoint(point, series, xWeight, yWeight) {
  var minDistance = Infinity, dPoint, minIx, distance, i = series.points.length;
  var hasUndefinedPosition = function(point2) {
    return !(defined35(point2.plotX) && defined35(point2.plotY));
  };
  if (hasUndefinedPosition(point)) {
    return;
  }
  while (i--) {
    dPoint = series.points[i];
    if (hasUndefinedPosition(dPoint)) {
      continue;
    }
    distance = (point.plotX - dPoint.plotX) * (point.plotX - dPoint.plotX) * (xWeight || 1) + (point.plotY - dPoint.plotY) * (point.plotY - dPoint.plotY) * (yWeight || 1);
    if (distance < minDistance) {
      minDistance = distance;
      minIx = i;
    }
  }
  return defined35(minIx) ? series.points[minIx] : void 0;
}
Point_default.prototype.highlight = function() {
  var chart = this.series.chart;
  if (!this.isNull) {
    this.onMouseOver();
  } else {
    if (chart.tooltip) {
      chart.tooltip.hide(0);
    }
  }
  scrollToPoint2(this);
  if (this.graphic) {
    chart.setFocusToElement(this.graphic);
  }
  chart.highlightedPoint = this;
  return this;
};
Chart_default.prototype.highlightAdjacentPoint = function(next) {
  var chart = this, series = chart.series, curPoint = chart.highlightedPoint, curPointIndex = curPoint && getPointIndex(curPoint) || 0, curPoints = curPoint && curPoint.series.points, lastSeries = chart.series && chart.series[chart.series.length - 1], lastPoint = lastSeries && lastSeries.points && lastSeries.points[lastSeries.points.length - 1];
  var newSeries, newPoint;
  if (!series[0] || !series[0].points) {
    return false;
  }
  if (!curPoint) {
    newPoint = next ? series[0].points[0] : lastPoint;
  } else {
    newSeries = series[curPoint.series.index + (next ? 1 : -1)];
    newPoint = curPoints[curPointIndex + (next ? 1 : -1)];
    if (!newPoint && newSeries) {
      newPoint = newSeries.points[next ? 0 : newSeries.points.length - 1];
    }
    if (!newPoint) {
      return false;
    }
  }
  if (isSkipPoint(newPoint)) {
    newSeries = newPoint.series;
    if (isSkipSeries(newSeries)) {
      chart.highlightedPoint = next ? newSeries.points[newSeries.points.length - 1] : newSeries.points[0];
    } else {
      chart.highlightedPoint = newPoint;
    }
    return chart.highlightAdjacentPoint(next);
  }
  return newPoint.highlight();
};
Series_default.prototype.highlightFirstValidPoint = function() {
  var curPoint = this.chart.highlightedPoint, start = (curPoint && curPoint.series) === this ? getPointIndex(curPoint) : 0, points = this.points, len = points.length;
  if (points && len) {
    for (var i = start; i < len; ++i) {
      if (!isSkipPoint(points[i])) {
        return points[i].highlight();
      }
    }
    for (var j = start; j >= 0; --j) {
      if (!isSkipPoint(points[j])) {
        return points[j].highlight();
      }
    }
  }
  return false;
};
Chart_default.prototype.highlightAdjacentSeries = function(down) {
  var chart = this, curPoint = chart.highlightedPoint, lastSeries = chart.series && chart.series[chart.series.length - 1], lastPoint = lastSeries && lastSeries.points && lastSeries.points[lastSeries.points.length - 1];
  var newSeries, newPoint, adjacentNewPoint;
  if (!chart.highlightedPoint) {
    newSeries = down ? chart.series && chart.series[0] : lastSeries;
    newPoint = down ? newSeries && newSeries.points && newSeries.points[0] : lastPoint;
    return newPoint ? newPoint.highlight() : false;
  }
  newSeries = chart.series[curPoint.series.index + (down ? -1 : 1)];
  if (!newSeries) {
    return false;
  }
  newPoint = getClosestPoint(curPoint, newSeries, 4);
  if (!newPoint) {
    return false;
  }
  if (isSkipSeries(newSeries)) {
    newPoint.highlight();
    adjacentNewPoint = chart.highlightAdjacentSeries(down);
    if (!adjacentNewPoint) {
      curPoint.highlight();
      return false;
    }
    return adjacentNewPoint;
  }
  newPoint.highlight();
  return newPoint.series.highlightFirstValidPoint();
};
Chart_default.prototype.highlightAdjacentPointVertical = function(down) {
  var curPoint = this.highlightedPoint;
  var minDistance = Infinity, bestPoint;
  if (!defined35(curPoint.plotX) || !defined35(curPoint.plotY)) {
    return false;
  }
  this.series.forEach(function(series) {
    if (isSkipSeries(series)) {
      return;
    }
    series.points.forEach(function(point) {
      if (!defined35(point.plotY) || !defined35(point.plotX) || point === curPoint) {
        return;
      }
      var yDistance = point.plotY - curPoint.plotY;
      var width = Math.abs(point.plotX - curPoint.plotX), distance = Math.abs(yDistance) * Math.abs(yDistance) + width * width * 4;
      if (series.yAxis && series.yAxis.reversed) {
        yDistance *= -1;
      }
      if (yDistance <= 0 && down || yDistance >= 0 && !down || distance < 5 || isSkipPoint(point)) {
        return;
      }
      if (distance < minDistance) {
        minDistance = distance;
        bestPoint = point;
      }
    });
  });
  return bestPoint ? bestPoint.highlight() : false;
};
function highlightFirstValidPointInChart(chart) {
  var res = false;
  delete chart.highlightedPoint;
  res = chart.series.reduce(function(acc, cur) {
    return acc || cur.highlightFirstValidPoint();
  }, false);
  return res;
}
function highlightLastValidPointInChart(chart) {
  var numSeries = chart.series.length;
  var i = numSeries, res = false;
  while (i--) {
    chart.highlightedPoint = chart.series[i].points[chart.series[i].points.length - 1];
    res = chart.series[i].highlightFirstValidPoint();
    if (res) {
      break;
    }
  }
  return res;
}
function updateChartFocusAfterDrilling(chart) {
  highlightFirstValidPointInChart(chart);
  if (chart.focusElement) {
    chart.focusElement.removeFocusBorder();
  }
}
function SeriesKeyboardNavigation(chart, keyCodes) {
  this.keyCodes = keyCodes;
  this.chart = chart;
}
extend36(SeriesKeyboardNavigation.prototype, {
  init: function() {
    var keyboardNavigation = this, chart = this.chart, e2 = this.eventProvider = new EventProvider_default();
    e2.addEvent(Series_default, "destroy", function() {
      return keyboardNavigation.onSeriesDestroy(this);
    });
    e2.addEvent(chart, "afterDrilldown", function() {
      updateChartFocusAfterDrilling(this);
    });
    e2.addEvent(chart, "drilldown", function(e3) {
      var point = e3.point, series = point.series;
      keyboardNavigation.lastDrilledDownPoint = {
        x: point.x,
        y: point.y,
        seriesName: series ? series.name : ""
      };
    });
    e2.addEvent(chart, "drillupall", function() {
      setTimeout(function() {
        keyboardNavigation.onDrillupAll();
      }, 10);
    });
    e2.addEvent(Point_default, "afterSetState", function() {
      var point = this;
      var pointEl = point.graphic && point.graphic.element;
      if (chart.highlightedPoint === point && doc13.activeElement !== pointEl && pointEl && pointEl.focus) {
        pointEl.focus();
      }
    });
  },
  onDrillupAll: function() {
    var last = this.lastDrilledDownPoint, chart = this.chart, series = last && getSeriesFromName2(chart, last.seriesName);
    var point;
    if (last && series && defined35(last.x) && defined35(last.y)) {
      point = getPointFromXY2(series, last.x, last.y);
    }
    if (chart.container) {
      chart.container.focus();
    }
    if (point && point.highlight) {
      point.highlight();
    }
    if (chart.focusElement) {
      chart.focusElement.removeFocusBorder();
    }
  },
  getKeyboardNavigationHandler: function() {
    var keyboardNavigation = this, keys2 = this.keyCodes, chart = this.chart, inverted = chart.inverted;
    return new KeyboardNavigationHandler_default(chart, {
      keyCodeMap: [
        [inverted ? [keys2.up, keys2.down] : [keys2.left, keys2.right], function(keyCode) {
          return keyboardNavigation.onKbdSideways(this, keyCode);
        }],
        [inverted ? [keys2.left, keys2.right] : [keys2.up, keys2.down], function(keyCode) {
          return keyboardNavigation.onKbdVertical(this, keyCode);
        }],
        [[keys2.enter, keys2.space], function(keyCode, event) {
          var point = chart.highlightedPoint;
          if (point) {
            event.point = point;
            fireEvent24(point.series, "click", event);
            point.firePointEvent("click");
          }
          return this.response.success;
        }]
      ],
      init: function(dir) {
        return keyboardNavigation.onHandlerInit(this, dir);
      },
      terminate: function() {
        return keyboardNavigation.onHandlerTerminate();
      }
    });
  },
  onKbdSideways: function(handler, keyCode) {
    var keys2 = this.keyCodes, isNext = keyCode === keys2.right || keyCode === keys2.down;
    return this.attemptHighlightAdjacentPoint(handler, isNext);
  },
  onKbdVertical: function(handler, keyCode) {
    var chart = this.chart, keys2 = this.keyCodes, isNext = keyCode === keys2.down || keyCode === keys2.right, navOptions = chart.options.accessibility.keyboardNavigation.seriesNavigation;
    if (navOptions.mode && navOptions.mode === "serialize") {
      return this.attemptHighlightAdjacentPoint(handler, isNext);
    }
    var highlightMethod = chart.highlightedPoint && chart.highlightedPoint.series.keyboardMoveVertical ? "highlightAdjacentPointVertical" : "highlightAdjacentSeries";
    chart[highlightMethod](isNext);
    return handler.response.success;
  },
  onHandlerInit: function(handler, initDirection) {
    var chart = this.chart;
    if (initDirection > 0) {
      highlightFirstValidPointInChart(chart);
    } else {
      highlightLastValidPointInChart(chart);
    }
    return handler.response.success;
  },
  onHandlerTerminate: function() {
    var chart = this.chart;
    if (chart.tooltip) {
      chart.tooltip.hide(0);
    }
    var hoverSeries = chart.highlightedPoint && chart.highlightedPoint.series;
    if (hoverSeries && hoverSeries.onMouseOut) {
      hoverSeries.onMouseOut();
    }
    if (chart.highlightedPoint && chart.highlightedPoint.onMouseOut) {
      chart.highlightedPoint.onMouseOut();
    }
    delete chart.highlightedPoint;
  },
  attemptHighlightAdjacentPoint: function(handler, directionIsNext) {
    var chart = this.chart, wrapAround = chart.options.accessibility.keyboardNavigation.wrapAround, highlightSuccessful = chart.highlightAdjacentPoint(directionIsNext);
    if (!highlightSuccessful) {
      if (wrapAround) {
        return handler.init(directionIsNext ? 1 : -1);
      }
      return handler.response[directionIsNext ? "next" : "prev"];
    }
    return handler.response.success;
  },
  onSeriesDestroy: function(series) {
    var chart = this.chart, currentHighlightedPointDestroyed = chart.highlightedPoint && chart.highlightedPoint.series === series;
    if (currentHighlightedPointDestroyed) {
      delete chart.highlightedPoint;
      if (chart.focusElement) {
        chart.focusElement.removeFocusBorder();
      }
    }
  },
  destroy: function() {
    this.eventProvider.removeAddedEvents();
  }
});
var SeriesKeyboardNavigation_default = SeriesKeyboardNavigation;

// node_modules/highcharts/es-modules/Accessibility/Components/AnnotationsA11y.js
var escapeStringForHTML2 = HTMLUtilities_default.escapeStringForHTML;
var stripHTMLTagsFromString2 = HTMLUtilities_default.stripHTMLTagsFromString;
function getChartAnnotationLabels(chart) {
  var annotations = chart.annotations || [];
  return annotations.reduce(function(acc, cur) {
    if (cur.options && cur.options.visible !== false) {
      acc = acc.concat(cur.labels);
    }
    return acc;
  }, []);
}
function getLabelText(label) {
  return label.options && label.options.accessibility && label.options.accessibility.description || label.graphic && label.graphic.text && label.graphic.text.textStr || "";
}
function getAnnotationLabelDescription(label) {
  var a11yDesc = label.options && label.options.accessibility && label.options.accessibility.description;
  if (a11yDesc) {
    return a11yDesc;
  }
  var chart = label.chart;
  var labelText = getLabelText(label);
  var points = label.points;
  var getAriaLabel = function(point) {
    return point.graphic && point.graphic.element && point.graphic.element.getAttribute("aria-label") || "";
  };
  var getValueDesc = function(point) {
    var valDesc = point.accessibility && point.accessibility.valueDescription || getAriaLabel(point);
    var seriesName = point && point.series.name || "";
    return (seriesName ? seriesName + ", " : "") + "data point " + valDesc;
  };
  var pointValueDescriptions = points.filter(function(p) {
    return !!p.graphic;
  }).map(getValueDesc).filter(function(desc) {
    return !!desc;
  });
  var numPoints = pointValueDescriptions.length;
  var pointsSelector = numPoints > 1 ? "MultiplePoints" : numPoints ? "SinglePoint" : "NoPoints";
  var langFormatStr = "accessibility.screenReaderSection.annotations.description" + pointsSelector;
  var context = {
    annotationText: labelText,
    annotation: label,
    numPoints,
    annotationPoint: pointValueDescriptions[0],
    additionalAnnotationPoints: pointValueDescriptions.slice(1)
  };
  return chart.langFormat(langFormatStr, context);
}
function getAnnotationListItems(chart) {
  var labels = getChartAnnotationLabels(chart);
  return labels.map(function(label) {
    var desc = escapeStringForHTML2(stripHTMLTagsFromString2(getAnnotationLabelDescription(label)));
    return desc ? "<li>" + desc + "</li>" : "";
  });
}
function getAnnotationsInfoHTML(chart) {
  var annotations = chart.annotations;
  if (!(annotations && annotations.length)) {
    return "";
  }
  var annotationItems = getAnnotationListItems(chart);
  return '<ul style="list-style-type: none">' + annotationItems.join(" ") + "</ul>";
}
function getPointAnnotationTexts(point) {
  var labels = getChartAnnotationLabels(point.series.chart);
  var pointLabels = labels.filter(function(label) {
    return label.points.indexOf(point) > -1;
  });
  if (!pointLabels.length) {
    return [];
  }
  return pointLabels.map(function(label) {
    return "" + getLabelText(label);
  });
}
var AnnotationsA11y = {
  getAnnotationsInfoHTML,
  getAnnotationLabelDescription,
  getAnnotationListItems,
  getPointAnnotationTexts
};
var AnnotationsA11y_default = AnnotationsA11y;

// node_modules/highcharts/es-modules/Accessibility/Components/SeriesComponent/SeriesDescriber.js
var getPointAnnotationTexts2 = AnnotationsA11y_default.getPointAnnotationTexts;
var getAxisDescription2 = ChartUtilities_default.getAxisDescription;
var getSeriesFirstPointElement2 = ChartUtilities_default.getSeriesFirstPointElement;
var getSeriesA11yElement2 = ChartUtilities_default.getSeriesA11yElement;
var unhideChartElementFromAT4 = ChartUtilities_default.unhideChartElementFromAT;
var format9 = FormatUtilities_default.format;
var numberFormat3 = FormatUtilities_default.numberFormat;
var reverseChildNodes2 = HTMLUtilities_default.reverseChildNodes;
var stripHTMLTags3 = HTMLUtilities_default.stripHTMLTagsFromString;
var find14 = Utilities_default.find;
var isNumber33 = Utilities_default.isNumber;
var pick47 = Utilities_default.pick;
var defined36 = Utilities_default.defined;
function findFirstPointWithGraphic(point) {
  var sourcePointIndex = point.index;
  if (!point.series || !point.series.data || !defined36(sourcePointIndex)) {
    return null;
  }
  return find14(point.series.data, function(p) {
    return !!(p && typeof p.index !== "undefined" && p.index > sourcePointIndex && p.graphic && p.graphic.element);
  }) || null;
}
function shouldAddDummyPoint(point) {
  var isSunburst = point.series && point.series.is("sunburst"), isNull = point.isNull;
  return isNull && !isSunburst;
}
function makeDummyElement(point, pos) {
  var renderer = point.series.chart.renderer, dummy = renderer.rect(pos.x, pos.y, 1, 1);
  dummy.attr({
    "class": "highcharts-a11y-dummy-point",
    fill: "none",
    opacity: 0,
    "fill-opacity": 0,
    "stroke-opacity": 0
  });
  return dummy;
}
function addDummyPointElement(point) {
  var series = point.series, firstPointWithGraphic = findFirstPointWithGraphic(point), firstGraphic = firstPointWithGraphic && firstPointWithGraphic.graphic, parentGroup = firstGraphic ? firstGraphic.parentGroup : series.graph || series.group, dummyPos = firstPointWithGraphic ? {
    x: pick47(point.plotX, firstPointWithGraphic.plotX, 0),
    y: pick47(point.plotY, firstPointWithGraphic.plotY, 0)
  } : {
    x: pick47(point.plotX, 0),
    y: pick47(point.plotY, 0)
  }, dummyElement = makeDummyElement(point, dummyPos);
  if (parentGroup && parentGroup.element) {
    point.graphic = dummyElement;
    point.hasDummyGraphic = true;
    dummyElement.add(parentGroup);
    parentGroup.element.insertBefore(dummyElement.element, firstGraphic ? firstGraphic.element : null);
    return dummyElement.element;
  }
}
function hasMorePointsThanDescriptionThreshold(series) {
  var chartA11yOptions = series.chart.options.accessibility, threshold = chartA11yOptions.series.pointDescriptionEnabledThreshold;
  return !!(threshold !== false && series.points && series.points.length >= threshold);
}
function shouldSetScreenReaderPropsOnPoints(series) {
  var seriesA11yOptions = series.options.accessibility || {};
  return !hasMorePointsThanDescriptionThreshold(series) && !seriesA11yOptions.exposeAsGroupOnly;
}
function shouldSetKeyboardNavPropsOnPoints(series) {
  var chartA11yOptions = series.chart.options.accessibility, seriesNavOptions = chartA11yOptions.keyboardNavigation.seriesNavigation;
  return !!(series.points && (series.points.length < seriesNavOptions.pointNavigationEnabledThreshold || seriesNavOptions.pointNavigationEnabledThreshold === false));
}
function shouldDescribeSeriesElement(series) {
  var chart = series.chart, chartOptions = chart.options.chart, chartHas3d = chartOptions.options3d && chartOptions.options3d.enabled, hasMultipleSeries = chart.series.length > 1, describeSingleSeriesOption = chart.options.accessibility.series.describeSingleSeries, exposeAsGroupOnlyOption = (series.options.accessibility || {}).exposeAsGroupOnly, noDescribe3D = chartHas3d && hasMultipleSeries;
  return !noDescribe3D && (hasMultipleSeries || describeSingleSeriesOption || exposeAsGroupOnlyOption || hasMorePointsThanDescriptionThreshold(series));
}
function pointNumberToString(point, value) {
  var chart = point.series.chart, a11yPointOptions = chart.options.accessibility.point || {}, tooltipOptions = point.series.tooltipOptions || {}, lang2 = chart.options.lang;
  if (isNumber33(value)) {
    return numberFormat3(value, a11yPointOptions.valueDecimals || tooltipOptions.valueDecimals || -1, lang2.decimalPoint, lang2.accessibility.thousandsSep || lang2.thousandsSep);
  }
  return value;
}
function getSeriesDescriptionText(series) {
  var seriesA11yOptions = series.options.accessibility || {}, descOpt = seriesA11yOptions.description;
  return descOpt && series.chart.langFormat("accessibility.series.description", {
    description: descOpt,
    series
  }) || "";
}
function getSeriesAxisDescriptionText(series, axisCollection) {
  var axis = series[axisCollection];
  return series.chart.langFormat("accessibility.series." + axisCollection + "Description", {
    name: getAxisDescription2(axis),
    series
  });
}
function getPointA11yTimeDescription(point) {
  var series = point.series, chart = series.chart, a11yOptions = chart.options.accessibility.point || {}, dateXAxis = series.xAxis && series.xAxis.dateTime;
  if (dateXAxis) {
    var tooltipDateFormat = dateXAxis.getXDateFormat(point.x || 0, chart.options.tooltip.dateTimeLabelFormats), dateFormat2 = a11yOptions.dateFormatter && a11yOptions.dateFormatter(point) || a11yOptions.dateFormat || tooltipDateFormat;
    return chart.time.dateFormat(dateFormat2, point.x || 0, void 0);
  }
}
function getPointXDescription(point) {
  var timeDesc = getPointA11yTimeDescription(point), xAxis = point.series.xAxis || {}, pointCategory = xAxis.categories && defined36(point.category) && ("" + point.category).replace("<br/>", " "), canUseId = point.id && point.id.indexOf("highcharts-") < 0, fallback = "x, " + point.x;
  return point.name || timeDesc || pointCategory || (canUseId ? point.id : fallback);
}
function getPointArrayMapValueDescription(point, prefix, suffix) {
  var pre = prefix || "", suf = suffix || "", keyToValStr = function(key) {
    var num = pointNumberToString(point, pick47(point[key], point.options[key]));
    return key + ": " + pre + num + suf;
  }, pointArrayMap = point.series.pointArrayMap;
  return pointArrayMap.reduce(function(desc, key) {
    return desc + (desc.length ? ", " : "") + keyToValStr(key);
  }, "");
}
function getPointValue(point) {
  var series = point.series, a11yPointOpts = series.chart.options.accessibility.point || {}, tooltipOptions = series.tooltipOptions || {}, valuePrefix = a11yPointOpts.valuePrefix || tooltipOptions.valuePrefix || "", valueSuffix = a11yPointOpts.valueSuffix || tooltipOptions.valueSuffix || "", fallbackKey = typeof point.value !== "undefined" ? "value" : "y", fallbackDesc = pointNumberToString(point, point[fallbackKey]);
  if (point.isNull) {
    return series.chart.langFormat("accessibility.series.nullPointValue", {
      point
    });
  }
  if (series.pointArrayMap) {
    return getPointArrayMapValueDescription(point, valuePrefix, valueSuffix);
  }
  return valuePrefix + fallbackDesc + valueSuffix;
}
function getPointAnnotationDescription(point) {
  var chart = point.series.chart;
  var langKey = "accessibility.series.pointAnnotationsDescription";
  var annotations = getPointAnnotationTexts2(point);
  var context = { point, annotations };
  return annotations.length ? chart.langFormat(langKey, context) : "";
}
function getPointValueDescription(point) {
  var series = point.series, chart = series.chart, pointValueDescriptionFormat = chart.options.accessibility.point.valueDescriptionFormat, showXDescription = pick47(series.xAxis && series.xAxis.options.accessibility && series.xAxis.options.accessibility.enabled, !chart.angular), xDesc = showXDescription ? getPointXDescription(point) : "", context = {
    point,
    index: defined36(point.index) ? point.index + 1 : "",
    xDescription: xDesc,
    value: getPointValue(point),
    separator: showXDescription ? ", " : ""
  };
  return format9(pointValueDescriptionFormat, context, chart);
}
function defaultPointDescriptionFormatter(point) {
  var series = point.series, chart = series.chart, valText = getPointValueDescription(point), description = point.options && point.options.accessibility && point.options.accessibility.description, userDescText = description ? " " + description : "", seriesNameText = chart.series.length > 1 && series.name ? " " + series.name + "." : "", annotationsDesc = getPointAnnotationDescription(point), pointAnnotationsText = annotationsDesc ? " " + annotationsDesc : "";
  point.accessibility = point.accessibility || {};
  point.accessibility.valueDescription = valText;
  return valText + userDescText + seriesNameText + pointAnnotationsText;
}
function setPointScreenReaderAttribs(point, pointElement) {
  var series = point.series, a11yPointOptions = series.chart.options.accessibility.point || {}, seriesA11yOptions = series.options.accessibility || {}, label = stripHTMLTags3(seriesA11yOptions.pointDescriptionFormatter && seriesA11yOptions.pointDescriptionFormatter(point) || a11yPointOptions.descriptionFormatter && a11yPointOptions.descriptionFormatter(point) || defaultPointDescriptionFormatter(point));
  pointElement.setAttribute("role", "img");
  pointElement.setAttribute("aria-label", label);
}
function describePointsInSeries(series) {
  var setScreenReaderProps = shouldSetScreenReaderPropsOnPoints(series), setKeyboardProps = shouldSetKeyboardNavPropsOnPoints(series);
  if (setScreenReaderProps || setKeyboardProps) {
    series.points.forEach(function(point) {
      var pointEl = point.graphic && point.graphic.element || shouldAddDummyPoint(point) && addDummyPointElement(point);
      var pointA11yDisabled = point.options && point.options.accessibility && point.options.accessibility.enabled === false;
      if (pointEl) {
        pointEl.setAttribute("tabindex", "-1");
        pointEl.style.outline = "0";
        if (setScreenReaderProps && !pointA11yDisabled) {
          setPointScreenReaderAttribs(point, pointEl);
        } else {
          pointEl.setAttribute("aria-hidden", true);
        }
      }
    });
  }
}
function defaultSeriesDescriptionFormatter(series) {
  var chart = series.chart, chartTypes = chart.types || [], description = getSeriesDescriptionText(series), shouldDescribeAxis = function(coll) {
    return chart[coll] && chart[coll].length > 1 && series[coll];
  }, xAxisInfo = getSeriesAxisDescriptionText(series, "xAxis"), yAxisInfo = getSeriesAxisDescriptionText(series, "yAxis"), summaryContext = {
    name: series.name || "",
    ix: series.index + 1,
    numSeries: chart.series && chart.series.length,
    numPoints: series.points && series.points.length,
    series
  }, combinationSuffix = chartTypes.length > 1 ? "Combination" : "", summary = chart.langFormat("accessibility.series.summary." + series.type + combinationSuffix, summaryContext) || chart.langFormat("accessibility.series.summary.default" + combinationSuffix, summaryContext);
  return summary + (description ? " " + description : "") + (shouldDescribeAxis("yAxis") ? " " + yAxisInfo : "") + (shouldDescribeAxis("xAxis") ? " " + xAxisInfo : "");
}
function describeSeriesElement(series, seriesElement) {
  var seriesA11yOptions = series.options.accessibility || {}, a11yOptions = series.chart.options.accessibility, landmarkVerbosity = a11yOptions.landmarkVerbosity;
  if (seriesA11yOptions.exposeAsGroupOnly) {
    seriesElement.setAttribute("role", "img");
  } else if (landmarkVerbosity === "all") {
    seriesElement.setAttribute("role", "region");
  }
  seriesElement.setAttribute("tabindex", "-1");
  seriesElement.style.outline = "0";
  seriesElement.setAttribute("aria-label", stripHTMLTags3(a11yOptions.series.descriptionFormatter && a11yOptions.series.descriptionFormatter(series) || defaultSeriesDescriptionFormatter(series)));
}
function describeSeries(series) {
  var chart = series.chart, firstPointEl = getSeriesFirstPointElement2(series), seriesEl = getSeriesA11yElement2(series), is3d = chart.is3d && chart.is3d();
  if (seriesEl) {
    if (seriesEl.lastChild === firstPointEl && !is3d) {
      reverseChildNodes2(seriesEl);
    }
    describePointsInSeries(series);
    unhideChartElementFromAT4(chart, seriesEl);
    if (shouldDescribeSeriesElement(series)) {
      describeSeriesElement(series, seriesEl);
    } else {
      seriesEl.setAttribute("aria-label", "");
    }
  }
}
var SeriesDescriber = {
  describeSeries,
  defaultPointDescriptionFormatter,
  defaultSeriesDescriptionFormatter,
  getPointA11yTimeDescription,
  getPointXDescription,
  getPointValue,
  getPointValueDescription
};
var SeriesDescriber_default = SeriesDescriber;

// node_modules/highcharts/es-modules/Accessibility/Utils/Announcer.js
var doc14 = Globals_default.doc;
var setElAttrs2 = HTMLUtilities_default.setElAttrs;
var visuallyHideElement2 = HTMLUtilities_default.visuallyHideElement;
var Announcer = function() {
  function Announcer2(chart, type) {
    this.chart = chart;
    this.domElementProvider = new DOMElementProvider_default();
    this.announceRegion = this.addAnnounceRegion(type);
  }
  Announcer2.prototype.destroy = function() {
    this.domElementProvider.destroyCreatedElements();
  };
  Announcer2.prototype.announce = function(message) {
    var _this = this;
    AST_default.setElementHTML(this.announceRegion, message);
    if (this.clearAnnouncementRegionTimer) {
      clearTimeout(this.clearAnnouncementRegionTimer);
    }
    this.clearAnnouncementRegionTimer = setTimeout(function() {
      _this.announceRegion.innerHTML = "";
      delete _this.clearAnnouncementRegionTimer;
    }, 1e3);
  };
  Announcer2.prototype.addAnnounceRegion = function(type) {
    var chartContainer = this.chart.announcerContainer || this.createAnnouncerContainer(), div = this.domElementProvider.createElement("div");
    setElAttrs2(div, {
      "aria-hidden": false,
      "aria-live": type
    });
    visuallyHideElement2(div);
    chartContainer.appendChild(div);
    return div;
  };
  Announcer2.prototype.createAnnouncerContainer = function() {
    var chart = this.chart, container = doc14.createElement("div");
    setElAttrs2(container, {
      "aria-hidden": false,
      style: "position:relative",
      "class": "highcharts-announcer-container"
    });
    chart.renderTo.insertBefore(container, chart.renderTo.firstChild);
    chart.announcerContainer = container;
    return container;
  };
  return Announcer2;
}();
var Announcer_default = Announcer;

// node_modules/highcharts/es-modules/Accessibility/Components/SeriesComponent/NewDataAnnouncer.js
var extend37 = Utilities_default.extend;
var defined37 = Utilities_default.defined;
var getChartTitle4 = ChartUtilities_default.getChartTitle;
var defaultPointDescriptionFormatter2 = SeriesDescriber_default.defaultPointDescriptionFormatter;
var defaultSeriesDescriptionFormatter2 = SeriesDescriber_default.defaultSeriesDescriptionFormatter;
function chartHasAnnounceEnabled(chart) {
  return !!chart.options.accessibility.announceNewData.enabled;
}
function findPointInDataArray(point) {
  var candidates = point.series.data.filter(function(candidate) {
    return point.x === candidate.x && point.y === candidate.y;
  });
  return candidates.length === 1 ? candidates[0] : point;
}
function getUniqueSeries(arrayA, arrayB) {
  var uniqueSeries = (arrayA || []).concat(arrayB || []).reduce(function(acc, cur) {
    acc[cur.name + cur.index] = cur;
    return acc;
  }, {});
  return Object.keys(uniqueSeries).map(function(ix) {
    return uniqueSeries[ix];
  });
}
var NewDataAnnouncer = function(chart) {
  this.chart = chart;
};
extend37(NewDataAnnouncer.prototype, {
  init: function() {
    var chart = this.chart;
    var announceOptions = chart.options.accessibility.announceNewData;
    var announceType = announceOptions.interruptUser ? "assertive" : "polite";
    this.lastAnnouncementTime = 0;
    this.dirty = {
      allSeries: {}
    };
    this.eventProvider = new EventProvider_default();
    this.announcer = new Announcer_default(chart, announceType);
    this.addEventListeners();
  },
  destroy: function() {
    this.eventProvider.removeAddedEvents();
    this.announcer.destroy();
  },
  addEventListeners: function() {
    var announcer = this, chart = this.chart, e2 = this.eventProvider;
    e2.addEvent(chart, "afterDrilldown", function() {
      announcer.lastAnnouncementTime = 0;
    });
    e2.addEvent(Series_default, "updatedData", function() {
      announcer.onSeriesUpdatedData(this);
    });
    e2.addEvent(chart, "afterAddSeries", function(e3) {
      announcer.onSeriesAdded(e3.series);
    });
    e2.addEvent(Series_default, "addPoint", function(e3) {
      announcer.onPointAdded(e3.point);
    });
    e2.addEvent(chart, "redraw", function() {
      announcer.announceDirtyData();
    });
  },
  onSeriesUpdatedData: function(series) {
    var chart = this.chart;
    if (series.chart === chart && chartHasAnnounceEnabled(chart)) {
      this.dirty.hasDirty = true;
      this.dirty.allSeries[series.name + series.index] = series;
    }
  },
  onSeriesAdded: function(series) {
    if (chartHasAnnounceEnabled(this.chart)) {
      this.dirty.hasDirty = true;
      this.dirty.allSeries[series.name + series.index] = series;
      this.dirty.newSeries = defined37(this.dirty.newSeries) ? void 0 : series;
    }
  },
  onPointAdded: function(point) {
    var chart = point.series.chart;
    if (this.chart === chart && chartHasAnnounceEnabled(chart)) {
      this.dirty.newPoint = defined37(this.dirty.newPoint) ? void 0 : point;
    }
  },
  announceDirtyData: function() {
    var chart = this.chart, announcer = this;
    if (chart.options.accessibility.announceNewData && this.dirty.hasDirty) {
      var newPoint = this.dirty.newPoint;
      if (newPoint) {
        newPoint = findPointInDataArray(newPoint);
      }
      this.queueAnnouncement(Object.keys(this.dirty.allSeries).map(function(ix) {
        return announcer.dirty.allSeries[ix];
      }), this.dirty.newSeries, newPoint);
      this.dirty = {
        allSeries: {}
      };
    }
  },
  queueAnnouncement: function(dirtySeries, newSeries, newPoint) {
    var _this = this;
    var chart = this.chart;
    var annOptions = chart.options.accessibility.announceNewData;
    if (annOptions.enabled) {
      var now = +new Date();
      var dTime = now - this.lastAnnouncementTime;
      var time = Math.max(0, annOptions.minAnnounceInterval - dTime);
      var allSeries = getUniqueSeries(this.queuedAnnouncement && this.queuedAnnouncement.series, dirtySeries);
      var message = this.buildAnnouncementMessage(allSeries, newSeries, newPoint);
      if (message) {
        if (this.queuedAnnouncement) {
          clearTimeout(this.queuedAnnouncementTimer);
        }
        this.queuedAnnouncement = {
          time: now,
          message,
          series: allSeries
        };
        this.queuedAnnouncementTimer = setTimeout(function() {
          if (_this && _this.announcer) {
            _this.lastAnnouncementTime = +new Date();
            _this.announcer.announce(_this.queuedAnnouncement.message);
            delete _this.queuedAnnouncement;
            delete _this.queuedAnnouncementTimer;
          }
        }, time);
      }
    }
  },
  buildAnnouncementMessage: function(dirtySeries, newSeries, newPoint) {
    var chart = this.chart, annOptions = chart.options.accessibility.announceNewData;
    if (annOptions.announcementFormatter) {
      var formatterRes = annOptions.announcementFormatter(dirtySeries, newSeries, newPoint);
      if (formatterRes !== false) {
        return formatterRes.length ? formatterRes : null;
      }
    }
    var multiple = Globals_default.charts && Globals_default.charts.length > 1 ? "Multiple" : "Single", langKey = newSeries ? "newSeriesAnnounce" + multiple : newPoint ? "newPointAnnounce" + multiple : "newDataAnnounce", chartTitle = getChartTitle4(chart);
    return chart.langFormat("accessibility.announceNewData." + langKey, {
      chartTitle,
      seriesDesc: newSeries ? defaultSeriesDescriptionFormatter2(newSeries) : null,
      pointDesc: newPoint ? defaultPointDescriptionFormatter2(newPoint) : null,
      point: newPoint,
      series: newSeries
    });
  }
});
var NewDataAnnouncer_default = NewDataAnnouncer;

// node_modules/highcharts/es-modules/Accessibility/Components/SeriesComponent/ForcedMarkers.js
var addEvent32 = Utilities_default.addEvent;
var merge42 = Utilities_default.merge;
function isWithinDescriptionThreshold(series) {
  var a11yOptions = series.chart.options.accessibility;
  return series.points.length < a11yOptions.series.pointDescriptionEnabledThreshold || a11yOptions.series.pointDescriptionEnabledThreshold === false;
}
function shouldForceMarkers(series) {
  var chart = series.chart, chartA11yEnabled = chart.options.accessibility.enabled, seriesA11yEnabled = (series.options.accessibility && series.options.accessibility.enabled) !== false;
  return chartA11yEnabled && seriesA11yEnabled && isWithinDescriptionThreshold(series);
}
function hasIndividualPointMarkerOptions(series) {
  return !!(series._hasPointMarkers && series.points && series.points.length);
}
function unforceSeriesMarkerOptions(series) {
  var resetMarkerOptions = series.resetA11yMarkerOptions;
  if (resetMarkerOptions) {
    merge42(true, series.options, {
      marker: {
        enabled: resetMarkerOptions.enabled,
        states: {
          normal: {
            opacity: resetMarkerOptions.states && resetMarkerOptions.states.normal && resetMarkerOptions.states.normal.opacity
          }
        }
      }
    });
  }
}
function forceZeroOpacityMarkerOptions(options) {
  merge42(true, options, {
    marker: {
      enabled: true,
      states: {
        normal: {
          opacity: 0
        }
      }
    }
  });
}
function getPointMarkerOpacity(pointOptions) {
  return pointOptions.marker.states && pointOptions.marker.states.normal && pointOptions.marker.states.normal.opacity || 1;
}
function unforcePointMarkerOptions(pointOptions) {
  merge42(true, pointOptions.marker, {
    states: {
      normal: {
        opacity: getPointMarkerOpacity(pointOptions)
      }
    }
  });
}
function handleForcePointMarkers(series) {
  var i = series.points.length;
  while (i--) {
    var point = series.points[i];
    var pointOptions = point.options;
    delete point.hasForcedA11yMarker;
    if (pointOptions.marker) {
      if (pointOptions.marker.enabled) {
        unforcePointMarkerOptions(pointOptions);
        point.hasForcedA11yMarker = false;
      } else {
        forceZeroOpacityMarkerOptions(pointOptions);
        point.hasForcedA11yMarker = true;
      }
    }
  }
}
function addForceMarkersEvents() {
  addEvent32(Series_default, "render", function() {
    var series = this, options = series.options;
    if (shouldForceMarkers(series)) {
      if (options.marker && options.marker.enabled === false) {
        series.a11yMarkersForced = true;
        forceZeroOpacityMarkerOptions(series.options);
      }
      if (hasIndividualPointMarkerOptions(series)) {
        handleForcePointMarkers(series);
      }
    } else if (series.a11yMarkersForced) {
      delete series.a11yMarkersForced;
      unforceSeriesMarkerOptions(series);
    }
  });
  addEvent32(Series_default, "afterSetOptions", function(e2) {
    this.resetA11yMarkerOptions = merge42(e2.options.marker || {}, this.userOptions.marker || {});
  });
  addEvent32(Series_default, "afterRender", function() {
    var series = this;
    if (series.chart.styledMode) {
      if (series.markerGroup) {
        series.markerGroup[series.a11yMarkersForced ? "addClass" : "removeClass"]("highcharts-a11y-markers-hidden");
      }
      if (hasIndividualPointMarkerOptions(series)) {
        series.points.forEach(function(point) {
          if (point.graphic) {
            point.graphic[point.hasForcedA11yMarker ? "addClass" : "removeClass"]("highcharts-a11y-marker-hidden");
            point.graphic[point.hasForcedA11yMarker === false ? "addClass" : "removeClass"]("highcharts-a11y-marker-visible");
          }
        });
      }
    }
  });
}
var ForcedMarkers_default = addForceMarkersEvents;

// node_modules/highcharts/es-modules/Accessibility/Components/SeriesComponent/SeriesComponent.js
var extend38 = Utilities_default.extend;
var hideSeriesFromAT2 = ChartUtilities_default.hideSeriesFromAT;
var describeSeries2 = SeriesDescriber_default.describeSeries;
Globals_default.SeriesAccessibilityDescriber = SeriesDescriber_default;
ForcedMarkers_default();
var SeriesComponent = function() {
};
SeriesComponent.prototype = new AccessibilityComponent_default();
extend38(SeriesComponent.prototype, {
  init: function() {
    this.newDataAnnouncer = new NewDataAnnouncer_default(this.chart);
    this.newDataAnnouncer.init();
    this.keyboardNavigation = new SeriesKeyboardNavigation_default(this.chart, this.keyCodes);
    this.keyboardNavigation.init();
    this.hideTooltipFromATWhenShown();
    this.hideSeriesLabelsFromATWhenShown();
  },
  hideTooltipFromATWhenShown: function() {
    var component = this;
    this.addEvent(Tooltip_default, "refresh", function() {
      if (this.chart === component.chart && this.label && this.label.element) {
        this.label.element.setAttribute("aria-hidden", true);
      }
    });
  },
  hideSeriesLabelsFromATWhenShown: function() {
    this.addEvent(this.chart, "afterDrawSeriesLabels", function() {
      this.series.forEach(function(series) {
        if (series.labelBySeries) {
          series.labelBySeries.attr("aria-hidden", true);
        }
      });
    });
  },
  onChartRender: function() {
    var chart = this.chart;
    chart.series.forEach(function(series) {
      var shouldDescribeSeries = (series.options.accessibility && series.options.accessibility.enabled) !== false && series.visible;
      if (shouldDescribeSeries) {
        describeSeries2(series);
      } else {
        hideSeriesFromAT2(series);
      }
    });
  },
  getKeyboardNavigation: function() {
    return this.keyboardNavigation.getKeyboardNavigationHandler();
  },
  destroy: function() {
    this.newDataAnnouncer.destroy();
    this.keyboardNavigation.destroy();
  }
});
var SeriesComponent_default = SeriesComponent;

// node_modules/highcharts/es-modules/Accessibility/Components/ZoomComponent.js
var unhideChartElementFromAT5 = ChartUtilities_default.unhideChartElementFromAT;
var noop9 = Globals_default.noop;
var removeElement6 = HTMLUtilities_default.removeElement;
var setElAttrs3 = HTMLUtilities_default.setElAttrs;
var extend39 = Utilities_default.extend;
var pick48 = Utilities_default.pick;
function chartHasMapZoom(chart) {
  return !!(chart.mapZoom && chart.mapNavButtons && chart.mapNavButtons.length);
}
Globals_default.Axis.prototype.panStep = function(direction, granularity) {
  var gran = granularity || 3, extremes = this.getExtremes(), step = (extremes.max - extremes.min) / gran * direction, newMax = extremes.max + step, newMin = extremes.min + step, size = newMax - newMin;
  if (direction < 0 && newMin < extremes.dataMin) {
    newMin = extremes.dataMin;
    newMax = newMin + size;
  } else if (direction > 0 && newMax > extremes.dataMax) {
    newMax = extremes.dataMax;
    newMin = newMax - size;
  }
  this.setExtremes(newMin, newMax);
};
var ZoomComponent = noop9;
ZoomComponent.prototype = new AccessibilityComponent_default();
extend39(ZoomComponent.prototype, {
  init: function() {
    var component = this, chart = this.chart;
    [
      "afterShowResetZoom",
      "afterDrilldown",
      "drillupall"
    ].forEach(function(eventType) {
      component.addEvent(chart, eventType, function() {
        component.updateProxyOverlays();
      });
    });
  },
  onChartUpdate: function() {
    var chart = this.chart, component = this;
    if (chart.mapNavButtons) {
      chart.mapNavButtons.forEach(function(button, i) {
        unhideChartElementFromAT5(chart, button.element);
        component.setMapNavButtonAttrs(button.element, "accessibility.zoom.mapZoom" + (i ? "Out" : "In"));
      });
    }
  },
  setMapNavButtonAttrs: function(button, labelFormatKey) {
    var chart = this.chart, label = chart.langFormat(labelFormatKey, { chart });
    setElAttrs3(button, {
      tabindex: -1,
      role: "button",
      "aria-label": label
    });
  },
  onChartRender: function() {
    this.updateProxyOverlays();
  },
  updateProxyOverlays: function() {
    var chart = this.chart;
    removeElement6(this.drillUpProxyGroup);
    removeElement6(this.resetZoomProxyGroup);
    if (chart.resetZoomButton) {
      this.recreateProxyButtonAndGroup(chart.resetZoomButton, "resetZoomProxyButton", "resetZoomProxyGroup", chart.langFormat("accessibility.zoom.resetZoomButton", { chart }));
    }
    if (chart.drillUpButton) {
      this.recreateProxyButtonAndGroup(chart.drillUpButton, "drillUpProxyButton", "drillUpProxyGroup", chart.langFormat("accessibility.drillUpButton", {
        chart,
        buttonText: chart.getDrilldownBackText()
      }));
    }
  },
  recreateProxyButtonAndGroup: function(buttonEl, buttonProp, groupProp, label) {
    removeElement6(this[groupProp]);
    this[groupProp] = this.addProxyGroup();
    this[buttonProp] = this.createProxyButton(buttonEl, this[groupProp], { "aria-label": label, tabindex: -1 });
  },
  getMapZoomNavigation: function() {
    var keys2 = this.keyCodes, chart = this.chart, component = this;
    return new KeyboardNavigationHandler_default(chart, {
      keyCodeMap: [
        [
          [keys2.up, keys2.down, keys2.left, keys2.right],
          function(keyCode) {
            return component.onMapKbdArrow(this, keyCode);
          }
        ],
        [
          [keys2.tab],
          function(_keyCode, e2) {
            return component.onMapKbdTab(this, e2);
          }
        ],
        [
          [keys2.space, keys2.enter],
          function() {
            return component.onMapKbdClick(this);
          }
        ]
      ],
      validate: function() {
        return chartHasMapZoom(chart);
      },
      init: function(direction) {
        return component.onMapNavInit(direction);
      }
    });
  },
  onMapKbdArrow: function(keyboardNavigationHandler, keyCode) {
    var keys2 = this.keyCodes, panAxis = keyCode === keys2.up || keyCode === keys2.down ? "yAxis" : "xAxis", stepDirection = keyCode === keys2.left || keyCode === keys2.up ? -1 : 1;
    this.chart[panAxis][0].panStep(stepDirection);
    return keyboardNavigationHandler.response.success;
  },
  onMapKbdTab: function(keyboardNavigationHandler, event) {
    var button, chart = this.chart, response = keyboardNavigationHandler.response, isBackwards = event.shiftKey, isMoveOutOfRange = isBackwards && !this.focusedMapNavButtonIx || !isBackwards && this.focusedMapNavButtonIx;
    chart.mapNavButtons[this.focusedMapNavButtonIx].setState(0);
    if (isMoveOutOfRange) {
      chart.mapZoom();
      return response[isBackwards ? "prev" : "next"];
    }
    this.focusedMapNavButtonIx += isBackwards ? -1 : 1;
    button = chart.mapNavButtons[this.focusedMapNavButtonIx];
    chart.setFocusToElement(button.box, button.element);
    button.setState(2);
    return response.success;
  },
  onMapKbdClick: function(keyboardNavigationHandler) {
    this.fakeClickEvent(this.chart.mapNavButtons[this.focusedMapNavButtonIx].element);
    return keyboardNavigationHandler.response.success;
  },
  onMapNavInit: function(direction) {
    var chart = this.chart, zoomIn = chart.mapNavButtons[0], zoomOut = chart.mapNavButtons[1], initialButton = direction > 0 ? zoomIn : zoomOut;
    chart.setFocusToElement(initialButton.box, initialButton.element);
    initialButton.setState(2);
    this.focusedMapNavButtonIx = direction > 0 ? 0 : 1;
  },
  simpleButtonNavigation: function(buttonProp, proxyProp, onClick) {
    var keys2 = this.keyCodes, component = this, chart = this.chart;
    return new KeyboardNavigationHandler_default(chart, {
      keyCodeMap: [
        [
          [keys2.tab, keys2.up, keys2.down, keys2.left, keys2.right],
          function(keyCode, e2) {
            var isBackwards = keyCode === keys2.tab && e2.shiftKey || keyCode === keys2.left || keyCode === keys2.up;
            return this.response[isBackwards ? "prev" : "next"];
          }
        ],
        [
          [keys2.space, keys2.enter],
          function() {
            var res = onClick(this, chart);
            return pick48(res, this.response.success);
          }
        ]
      ],
      validate: function() {
        var hasButton = chart[buttonProp] && chart[buttonProp].box && component[proxyProp];
        return hasButton;
      },
      init: function() {
        chart.setFocusToElement(chart[buttonProp].box, component[proxyProp]);
      }
    });
  },
  getKeyboardNavigation: function() {
    return [
      this.simpleButtonNavigation("resetZoomButton", "resetZoomProxyButton", function(_handler, chart) {
        chart.zoomOut();
      }),
      this.simpleButtonNavigation("drillUpButton", "drillUpProxyButton", function(handler, chart) {
        chart.drillUp();
        return handler.response.prev;
      }),
      this.getMapZoomNavigation()
    ];
  }
});
var ZoomComponent_default = ZoomComponent;

// node_modules/highcharts/es-modules/Accessibility/Components/RangeSelectorComponent.js
var unhideChartElementFromAT6 = ChartUtilities_default.unhideChartElementFromAT;
var getAxisRangeDescription2 = ChartUtilities_default.getAxisRangeDescription;
var setElAttrs4 = HTMLUtilities_default.setElAttrs;
var addEvent33 = Utilities_default.addEvent;
var extend40 = Utilities_default.extend;
function shouldRunInputNavigation(chart) {
  return Boolean(chart.rangeSelector && chart.rangeSelector.inputGroup && chart.rangeSelector.inputGroup.element.getAttribute("visibility") !== "hidden" && chart.options.rangeSelector.inputEnabled !== false && chart.rangeSelector.minInput && chart.rangeSelector.maxInput);
}
Chart_default.prototype.highlightRangeSelectorButton = function(ix) {
  var buttons = this.rangeSelector && this.rangeSelector.buttons || [];
  var curHighlightedIx = this.highlightedRangeSelectorItemIx;
  var curSelectedIx = this.rangeSelector && this.rangeSelector.selected;
  if (typeof curHighlightedIx !== "undefined" && buttons[curHighlightedIx] && curHighlightedIx !== curSelectedIx) {
    buttons[curHighlightedIx].setState(this.oldRangeSelectorItemState || 0);
  }
  this.highlightedRangeSelectorItemIx = ix;
  if (buttons[ix]) {
    this.setFocusToElement(buttons[ix].box, buttons[ix].element);
    if (ix !== curSelectedIx) {
      this.oldRangeSelectorItemState = buttons[ix].state;
      buttons[ix].setState(1);
    }
    return true;
  }
  return false;
};
addEvent33(RangeSelector_default, "afterBtnClick", function() {
  if (this.chart.accessibility && this.chart.accessibility.components.rangeSelector) {
    return this.chart.accessibility.components.rangeSelector.onAfterBtnClick();
  }
});
var RangeSelectorComponent = function() {
};
RangeSelectorComponent.prototype = new AccessibilityComponent_default();
extend40(RangeSelectorComponent.prototype, {
  init: function() {
    var chart = this.chart;
    this.announcer = new Announcer_default(chart, "polite");
  },
  onChartUpdate: function() {
    var chart = this.chart, component = this, rangeSelector = chart.rangeSelector;
    if (!rangeSelector) {
      return;
    }
    this.updateSelectorVisibility();
    this.setDropdownAttrs();
    if (rangeSelector.buttons && rangeSelector.buttons.length) {
      rangeSelector.buttons.forEach(function(button) {
        component.setRangeButtonAttrs(button);
      });
    }
    if (rangeSelector.maxInput && rangeSelector.minInput) {
      ["minInput", "maxInput"].forEach(function(key, i) {
        var input = rangeSelector[key];
        if (input) {
          unhideChartElementFromAT6(chart, input);
          component.setRangeInputAttrs(input, "accessibility.rangeSelector." + (i ? "max" : "min") + "InputLabel");
        }
      });
    }
  },
  updateSelectorVisibility: function() {
    var chart = this.chart;
    var rangeSelector = chart.rangeSelector;
    var dropdown = rangeSelector && rangeSelector.dropdown;
    var buttons = rangeSelector && rangeSelector.buttons || [];
    var hideFromAT = function(el) {
      return el.setAttribute("aria-hidden", true);
    };
    if (rangeSelector && rangeSelector.hasVisibleDropdown && dropdown) {
      unhideChartElementFromAT6(chart, dropdown);
      buttons.forEach(function(btn) {
        return hideFromAT(btn.element);
      });
    } else {
      if (dropdown) {
        hideFromAT(dropdown);
      }
      buttons.forEach(function(btn) {
        return unhideChartElementFromAT6(chart, btn.element);
      });
    }
  },
  setDropdownAttrs: function() {
    var chart = this.chart;
    var dropdown = chart.rangeSelector && chart.rangeSelector.dropdown;
    if (dropdown) {
      var label = chart.langFormat("accessibility.rangeSelector.dropdownLabel", { rangeTitle: chart.options.lang.rangeSelectorZoom });
      dropdown.setAttribute("aria-label", label);
      dropdown.setAttribute("tabindex", -1);
    }
  },
  setRangeButtonAttrs: function(button) {
    setElAttrs4(button.element, {
      tabindex: -1,
      role: "button"
    });
  },
  setRangeInputAttrs: function(input, langKey) {
    var chart = this.chart;
    setElAttrs4(input, {
      tabindex: -1,
      "aria-label": chart.langFormat(langKey, { chart })
    });
  },
  onButtonNavKbdArrowKey: function(keyboardNavigationHandler, keyCode) {
    var response = keyboardNavigationHandler.response, keys2 = this.keyCodes, chart = this.chart, wrapAround = chart.options.accessibility.keyboardNavigation.wrapAround, direction = keyCode === keys2.left || keyCode === keys2.up ? -1 : 1, didHighlight = chart.highlightRangeSelectorButton(chart.highlightedRangeSelectorItemIx + direction);
    if (!didHighlight) {
      if (wrapAround) {
        keyboardNavigationHandler.init(direction);
        return response.success;
      }
      return response[direction > 0 ? "next" : "prev"];
    }
    return response.success;
  },
  onButtonNavKbdClick: function(keyboardNavigationHandler) {
    var response = keyboardNavigationHandler.response, chart = this.chart, wasDisabled = chart.oldRangeSelectorItemState === 3;
    if (!wasDisabled) {
      this.fakeClickEvent(chart.rangeSelector.buttons[chart.highlightedRangeSelectorItemIx].element);
    }
    return response.success;
  },
  onAfterBtnClick: function() {
    var chart = this.chart;
    var axisRangeDescription = getAxisRangeDescription2(chart.xAxis[0]);
    var announcement = chart.langFormat("accessibility.rangeSelector.clickButtonAnnouncement", { chart, axisRangeDescription });
    if (announcement) {
      this.announcer.announce(announcement);
    }
  },
  onInputKbdMove: function(direction) {
    var chart = this.chart;
    var rangeSel = chart.rangeSelector;
    var newIx = chart.highlightedInputRangeIx = (chart.highlightedInputRangeIx || 0) + direction;
    var newIxOutOfRange = newIx > 1 || newIx < 0;
    if (newIxOutOfRange) {
      if (chart.accessibility) {
        chart.accessibility.keyboardNavigation.tabindexContainer.focus();
        chart.accessibility.keyboardNavigation[direction < 0 ? "prev" : "next"]();
      }
    } else if (rangeSel) {
      var svgEl = rangeSel[newIx ? "maxDateBox" : "minDateBox"];
      var inputEl = rangeSel[newIx ? "maxInput" : "minInput"];
      if (svgEl && inputEl) {
        chart.setFocusToElement(svgEl, inputEl);
      }
    }
  },
  onInputNavInit: function(direction) {
    var _this = this;
    var component = this;
    var chart = this.chart;
    var buttonIxToHighlight = direction > 0 ? 0 : 1;
    var rangeSel = chart.rangeSelector;
    var svgEl = rangeSel && rangeSel[buttonIxToHighlight ? "maxDateBox" : "minDateBox"];
    var minInput = rangeSel && rangeSel.minInput;
    var maxInput = rangeSel && rangeSel.maxInput;
    var inputEl = buttonIxToHighlight ? maxInput : minInput;
    chart.highlightedInputRangeIx = buttonIxToHighlight;
    if (svgEl && minInput && maxInput) {
      chart.setFocusToElement(svgEl, inputEl);
      if (this.removeInputKeydownHandler) {
        this.removeInputKeydownHandler();
      }
      var keydownHandler = function(e2) {
        var isTab = (e2.which || e2.keyCode) === _this.keyCodes.tab;
        if (isTab) {
          e2.preventDefault();
          e2.stopPropagation();
          component.onInputKbdMove(e2.shiftKey ? -1 : 1);
        }
      };
      var minRemover_1 = addEvent33(minInput, "keydown", keydownHandler);
      var maxRemover_1 = addEvent33(maxInput, "keydown", keydownHandler);
      this.removeInputKeydownHandler = function() {
        minRemover_1();
        maxRemover_1();
      };
    }
  },
  onInputNavTerminate: function() {
    var rangeSel = this.chart.rangeSelector || {};
    if (rangeSel.maxInput) {
      rangeSel.hideInput("max");
    }
    if (rangeSel.minInput) {
      rangeSel.hideInput("min");
    }
    if (this.removeInputKeydownHandler) {
      this.removeInputKeydownHandler();
      delete this.removeInputKeydownHandler;
    }
  },
  initDropdownNav: function() {
    var _this = this;
    var chart = this.chart;
    var rangeSelector = chart.rangeSelector;
    var dropdown = rangeSelector && rangeSelector.dropdown;
    if (rangeSelector && dropdown) {
      chart.setFocusToElement(rangeSelector.buttonGroup, dropdown);
      if (this.removeDropdownKeydownHandler) {
        this.removeDropdownKeydownHandler();
      }
      this.removeDropdownKeydownHandler = addEvent33(dropdown, "keydown", function(e2) {
        var isTab = (e2.which || e2.keyCode) === _this.keyCodes.tab;
        if (isTab) {
          e2.preventDefault();
          e2.stopPropagation();
          if (chart.accessibility) {
            chart.accessibility.keyboardNavigation.tabindexContainer.focus();
            chart.accessibility.keyboardNavigation[e2.shiftKey ? "prev" : "next"]();
          }
        }
      });
    }
  },
  getRangeSelectorButtonNavigation: function() {
    var chart = this.chart;
    var keys2 = this.keyCodes;
    var component = this;
    return new KeyboardNavigationHandler_default(chart, {
      keyCodeMap: [
        [
          [keys2.left, keys2.right, keys2.up, keys2.down],
          function(keyCode) {
            return component.onButtonNavKbdArrowKey(this, keyCode);
          }
        ],
        [
          [keys2.enter, keys2.space],
          function() {
            return component.onButtonNavKbdClick(this);
          }
        ]
      ],
      validate: function() {
        return !!(chart.rangeSelector && chart.rangeSelector.buttons && chart.rangeSelector.buttons.length);
      },
      init: function(direction) {
        var rangeSelector = chart.rangeSelector;
        if (rangeSelector && rangeSelector.hasVisibleDropdown) {
          component.initDropdownNav();
        } else if (rangeSelector) {
          var lastButtonIx = rangeSelector.buttons.length - 1;
          chart.highlightRangeSelectorButton(direction > 0 ? 0 : lastButtonIx);
        }
      },
      terminate: function() {
        if (component.removeDropdownKeydownHandler) {
          component.removeDropdownKeydownHandler();
          delete component.removeDropdownKeydownHandler;
        }
      }
    });
  },
  getRangeSelectorInputNavigation: function() {
    var chart = this.chart;
    var component = this;
    return new KeyboardNavigationHandler_default(chart, {
      keyCodeMap: [],
      validate: function() {
        return shouldRunInputNavigation(chart);
      },
      init: function(direction) {
        component.onInputNavInit(direction);
      },
      terminate: function() {
        component.onInputNavTerminate();
      }
    });
  },
  getKeyboardNavigation: function() {
    return [
      this.getRangeSelectorButtonNavigation(),
      this.getRangeSelectorInputNavigation()
    ];
  },
  destroy: function() {
    if (this.removeDropdownKeydownHandler) {
      this.removeDropdownKeydownHandler();
    }
    if (this.removeInputKeydownHandler) {
      this.removeInputKeydownHandler();
    }
    if (this.announcer) {
      this.announcer.destroy();
    }
  }
});
var RangeSelectorComponent_default = RangeSelectorComponent;

// node_modules/highcharts/es-modules/Accessibility/Components/InfoRegionsComponent.js
var format10 = FormatUtilities_default.format;
var doc15 = Globals_default.doc;
var extend41 = Utilities_default.extend;
var pick49 = Utilities_default.pick;
var getAnnotationsInfoHTML2 = AnnotationsA11y_default.getAnnotationsInfoHTML;
var getAxisDescription3 = ChartUtilities_default.getAxisDescription;
var getAxisRangeDescription3 = ChartUtilities_default.getAxisRangeDescription;
var getChartTitle5 = ChartUtilities_default.getChartTitle;
var unhideChartElementFromAT7 = ChartUtilities_default.unhideChartElementFromAT;
var addClass2 = HTMLUtilities_default.addClass;
var getElement3 = HTMLUtilities_default.getElement;
var getHeadingTagNameForElement2 = HTMLUtilities_default.getHeadingTagNameForElement;
var setElAttrs5 = HTMLUtilities_default.setElAttrs;
var stripHTMLTagsFromString3 = HTMLUtilities_default.stripHTMLTagsFromString;
var visuallyHideElement3 = HTMLUtilities_default.visuallyHideElement;
function stripEmptyHTMLTags(str) {
  return str.replace(/<(\w+)[^>]*?>\s*<\/\1>/g, "");
}
function getTypeDescForMapChart(chart, formatContext) {
  return formatContext.mapTitle ? chart.langFormat("accessibility.chartTypes.mapTypeDescription", formatContext) : chart.langFormat("accessibility.chartTypes.unknownMap", formatContext);
}
function getTypeDescForCombinationChart(chart, formatContext) {
  return chart.langFormat("accessibility.chartTypes.combinationChart", formatContext);
}
function getTypeDescForEmptyChart(chart, formatContext) {
  return chart.langFormat("accessibility.chartTypes.emptyChart", formatContext);
}
function buildTypeDescriptionFromSeries(chart, types, context) {
  var firstType = types[0], typeExplaination = chart.langFormat("accessibility.seriesTypeDescriptions." + firstType, context), multi = chart.series && chart.series.length < 2 ? "Single" : "Multiple";
  return (chart.langFormat("accessibility.chartTypes." + firstType + multi, context) || chart.langFormat("accessibility.chartTypes.default" + multi, context)) + (typeExplaination ? " " + typeExplaination : "");
}
function getTableSummary(chart) {
  return chart.langFormat("accessibility.table.tableSummary", { chart });
}
Chart_default.prototype.getTypeDescription = function(types) {
  var firstType = types[0], firstSeries = this.series && this.series[0] || {}, formatContext = {
    numSeries: this.series.length,
    numPoints: firstSeries.points && firstSeries.points.length,
    chart: this,
    mapTitle: firstSeries.mapTitle
  };
  if (!firstType) {
    return getTypeDescForEmptyChart(this, formatContext);
  }
  if (firstType === "map") {
    return getTypeDescForMapChart(this, formatContext);
  }
  if (this.types.length > 1) {
    return getTypeDescForCombinationChart(this, formatContext);
  }
  return buildTypeDescriptionFromSeries(this, types, formatContext);
};
var InfoRegionsComponent = function() {
};
InfoRegionsComponent.prototype = new AccessibilityComponent_default();
extend41(InfoRegionsComponent.prototype, {
  init: function() {
    var chart = this.chart;
    var component = this;
    this.initRegionsDefinitions();
    this.addEvent(chart, "aftergetTableAST", function(e2) {
      component.onDataTableCreated(e2);
    });
    this.addEvent(chart, "afterViewData", function(tableDiv) {
      component.dataTableDiv = tableDiv;
      setTimeout(function() {
        component.focusDataTable();
      }, 300);
    });
    this.announcer = new Announcer_default(chart, "assertive");
  },
  initRegionsDefinitions: function() {
    var component = this;
    this.screenReaderSections = {
      before: {
        element: null,
        buildContent: function(chart) {
          var formatter = chart.options.accessibility.screenReaderSection.beforeChartFormatter;
          return formatter ? formatter(chart) : component.defaultBeforeChartFormatter(chart);
        },
        insertIntoDOM: function(el, chart) {
          chart.renderTo.insertBefore(el, chart.renderTo.firstChild);
        },
        afterInserted: function() {
          if (typeof component.sonifyButtonId !== "undefined") {
            component.initSonifyButton(component.sonifyButtonId);
          }
          if (typeof component.dataTableButtonId !== "undefined") {
            component.initDataTableButton(component.dataTableButtonId);
          }
        }
      },
      after: {
        element: null,
        buildContent: function(chart) {
          var formatter = chart.options.accessibility.screenReaderSection.afterChartFormatter;
          return formatter ? formatter(chart) : component.defaultAfterChartFormatter();
        },
        insertIntoDOM: function(el, chart) {
          chart.renderTo.insertBefore(el, chart.container.nextSibling);
        },
        afterInserted: function() {
          if (component.chart.accessibility) {
            component.chart.accessibility.keyboardNavigation.updateExitAnchor();
          }
        }
      }
    };
  },
  onChartRender: function() {
    var component = this;
    this.linkedDescriptionElement = this.getLinkedDescriptionElement();
    this.setLinkedDescriptionAttrs();
    Object.keys(this.screenReaderSections).forEach(function(regionKey) {
      component.updateScreenReaderSection(regionKey);
    });
  },
  getLinkedDescriptionElement: function() {
    var chartOptions = this.chart.options, linkedDescOption = chartOptions.accessibility.linkedDescription;
    if (!linkedDescOption) {
      return;
    }
    if (typeof linkedDescOption !== "string") {
      return linkedDescOption;
    }
    var query = format10(linkedDescOption, this.chart), queryMatch = doc15.querySelectorAll(query);
    if (queryMatch.length === 1) {
      return queryMatch[0];
    }
  },
  setLinkedDescriptionAttrs: function() {
    var el = this.linkedDescriptionElement;
    if (el) {
      el.setAttribute("aria-hidden", "true");
      addClass2(el, "highcharts-linked-description");
    }
  },
  updateScreenReaderSection: function(regionKey) {
    var chart = this.chart, region = this.screenReaderSections[regionKey], content = region.buildContent(chart), sectionDiv = region.element = region.element || this.createElement("div"), hiddenDiv = sectionDiv.firstChild || this.createElement("div");
    this.setScreenReaderSectionAttribs(sectionDiv, regionKey);
    AST_default.setElementHTML(hiddenDiv, content);
    sectionDiv.appendChild(hiddenDiv);
    region.insertIntoDOM(sectionDiv, chart);
    visuallyHideElement3(hiddenDiv);
    unhideChartElementFromAT7(chart, hiddenDiv);
    if (region.afterInserted) {
      region.afterInserted();
    }
  },
  setScreenReaderSectionAttribs: function(sectionDiv, regionKey) {
    var labelLangKey = "accessibility.screenReaderSection." + regionKey + "RegionLabel", chart = this.chart, labelText = chart.langFormat(labelLangKey, { chart, chartTitle: getChartTitle5(chart) }), sectionId = "highcharts-screen-reader-region-" + regionKey + "-" + chart.index;
    setElAttrs5(sectionDiv, {
      id: sectionId,
      "aria-label": labelText
    });
    sectionDiv.style.position = "relative";
    if (chart.options.accessibility.landmarkVerbosity === "all" && labelText) {
      sectionDiv.setAttribute("role", "region");
    }
  },
  defaultBeforeChartFormatter: function() {
    var chart = this.chart, format13 = chart.options.accessibility.screenReaderSection.beforeChartFormat, axesDesc = this.getAxesDescription(), shouldHaveSonifyBtn = chart.sonify && chart.options.sonification && chart.options.sonification.enabled, sonifyButtonId = "highcharts-a11y-sonify-data-btn-" + chart.index, dataTableButtonId = "hc-linkto-highcharts-data-table-" + chart.index, annotationsList = getAnnotationsInfoHTML2(chart), annotationsTitleStr = chart.langFormat("accessibility.screenReaderSection.annotations.heading", { chart }), context = {
      headingTagName: getHeadingTagNameForElement2(chart.renderTo),
      chartTitle: getChartTitle5(chart),
      typeDescription: this.getTypeDescriptionText(),
      chartSubtitle: this.getSubtitleText(),
      chartLongdesc: this.getLongdescText(),
      xAxisDescription: axesDesc.xAxis,
      yAxisDescription: axesDesc.yAxis,
      playAsSoundButton: shouldHaveSonifyBtn ? this.getSonifyButtonText(sonifyButtonId) : "",
      viewTableButton: chart.getCSV ? this.getDataTableButtonText(dataTableButtonId) : "",
      annotationsTitle: annotationsList ? annotationsTitleStr : "",
      annotationsList
    }, formattedString = Globals_default.i18nFormat(format13, context, chart);
    this.dataTableButtonId = dataTableButtonId;
    this.sonifyButtonId = sonifyButtonId;
    return stripEmptyHTMLTags(formattedString);
  },
  defaultAfterChartFormatter: function() {
    var chart = this.chart, format13 = chart.options.accessibility.screenReaderSection.afterChartFormat, context = {
      endOfChartMarker: this.getEndOfChartMarkerText()
    }, formattedString = Globals_default.i18nFormat(format13, context, chart);
    return stripEmptyHTMLTags(formattedString);
  },
  getLinkedDescription: function() {
    var el = this.linkedDescriptionElement, content = el && el.innerHTML || "";
    return stripHTMLTagsFromString3(content);
  },
  getLongdescText: function() {
    var chartOptions = this.chart.options, captionOptions = chartOptions.caption, captionText = captionOptions && captionOptions.text, linkedDescription = this.getLinkedDescription();
    return chartOptions.accessibility.description || linkedDescription || captionText || "";
  },
  getTypeDescriptionText: function() {
    var chart = this.chart;
    return chart.types ? chart.options.accessibility.typeDescription || chart.getTypeDescription(chart.types) : "";
  },
  getDataTableButtonText: function(buttonId) {
    var chart = this.chart, buttonText = chart.langFormat("accessibility.table.viewAsDataTableButtonText", { chart, chartTitle: getChartTitle5(chart) });
    return '<button id="' + buttonId + '">' + buttonText + "</button>";
  },
  getSonifyButtonText: function(buttonId) {
    var chart = this.chart;
    if (chart.options.sonification && chart.options.sonification.enabled === false) {
      return "";
    }
    var buttonText = chart.langFormat("accessibility.sonification.playAsSoundButtonText", { chart, chartTitle: getChartTitle5(chart) });
    return '<button id="' + buttonId + '">' + buttonText + "</button>";
  },
  getSubtitleText: function() {
    var subtitle = this.chart.options.subtitle;
    return stripHTMLTagsFromString3(subtitle && subtitle.text || "");
  },
  getEndOfChartMarkerText: function() {
    var chart = this.chart, markerText = chart.langFormat("accessibility.screenReaderSection.endOfChartMarker", { chart }), id = "highcharts-end-of-chart-marker-" + chart.index;
    return '<div id="' + id + '">' + markerText + "</div>";
  },
  onDataTableCreated: function(e2) {
    var chart = this.chart;
    if (chart.options.accessibility.enabled) {
      if (this.viewDataTableButton) {
        this.viewDataTableButton.setAttribute("aria-expanded", "true");
      }
      var attributes = e2.tree.attributes || {};
      attributes.tabindex = -1;
      attributes.summary = getTableSummary(chart);
      e2.tree.attributes = attributes;
    }
  },
  focusDataTable: function() {
    var tableDiv = this.dataTableDiv, table = tableDiv && tableDiv.getElementsByTagName("table")[0];
    if (table && table.focus) {
      table.focus();
    }
  },
  initSonifyButton: function(sonifyButtonId) {
    var _this = this;
    var el = this.sonifyButton = getElement3(sonifyButtonId);
    var chart = this.chart;
    var defaultHandler = function(e2) {
      if (el) {
        el.setAttribute("aria-hidden", "true");
        el.setAttribute("aria-label", "");
      }
      e2.preventDefault();
      e2.stopPropagation();
      var announceMsg = chart.langFormat("accessibility.sonification.playAsSoundClickAnnouncement", { chart });
      _this.announcer.announce(announceMsg);
      setTimeout(function() {
        if (el) {
          el.removeAttribute("aria-hidden");
          el.removeAttribute("aria-label");
        }
        if (chart.sonify) {
          chart.sonify();
        }
      }, 1e3);
    };
    if (el && chart) {
      setElAttrs5(el, {
        tabindex: -1
      });
      el.onclick = function(e2) {
        var onPlayAsSoundClick = chart.options.accessibility && chart.options.accessibility.screenReaderSection.onPlayAsSoundClick;
        (onPlayAsSoundClick || defaultHandler).call(this, e2, chart);
      };
    }
  },
  initDataTableButton: function(tableButtonId) {
    var el = this.viewDataTableButton = getElement3(tableButtonId), chart = this.chart, tableId = tableButtonId.replace("hc-linkto-", "");
    if (el) {
      setElAttrs5(el, {
        tabindex: -1,
        "aria-expanded": !!getElement3(tableId)
      });
      el.onclick = chart.options.accessibility.screenReaderSection.onViewDataTableClick || function() {
        chart.viewData();
      };
    }
  },
  getAxesDescription: function() {
    var chart = this.chart, shouldDescribeColl = function(collectionKey, defaultCondition) {
      var axes = chart[collectionKey];
      return axes.length > 1 || axes[0] && pick49(axes[0].options.accessibility && axes[0].options.accessibility.enabled, defaultCondition);
    }, hasNoMap = !!chart.types && chart.types.indexOf("map") < 0, hasCartesian = !!chart.hasCartesianSeries, showXAxes = shouldDescribeColl("xAxis", !chart.angular && hasCartesian && hasNoMap), showYAxes = shouldDescribeColl("yAxis", hasCartesian && hasNoMap), desc = {};
    if (showXAxes) {
      desc.xAxis = this.getAxisDescriptionText("xAxis");
    }
    if (showYAxes) {
      desc.yAxis = this.getAxisDescriptionText("yAxis");
    }
    return desc;
  },
  getAxisDescriptionText: function(collectionKey) {
    var chart = this.chart;
    var axes = chart[collectionKey];
    return chart.langFormat("accessibility.axis." + collectionKey + "Description" + (axes.length > 1 ? "Plural" : "Singular"), {
      chart,
      names: axes.map(function(axis) {
        return getAxisDescription3(axis);
      }),
      ranges: axes.map(function(axis) {
        return getAxisRangeDescription3(axis);
      }),
      numAxes: axes.length
    });
  },
  destroy: function() {
    if (this.announcer) {
      this.announcer.destroy();
    }
  }
});
var InfoRegionsComponent_default = InfoRegionsComponent;

// node_modules/highcharts/es-modules/Accessibility/Components/ContainerComponent.js
var unhideChartElementFromAT8 = ChartUtilities_default.unhideChartElementFromAT;
var getChartTitle6 = ChartUtilities_default.getChartTitle;
var doc16 = Globals_default.doc;
var stripHTMLTags4 = HTMLUtilities_default.stripHTMLTagsFromString;
var extend42 = Utilities_default.extend;
var ContainerComponent = function() {
};
ContainerComponent.prototype = new AccessibilityComponent_default();
extend42(ContainerComponent.prototype, {
  onChartUpdate: function() {
    this.handleSVGTitleElement();
    this.setSVGContainerLabel();
    this.setGraphicContainerAttrs();
    this.setRenderToAttrs();
    this.makeCreditsAccessible();
  },
  handleSVGTitleElement: function() {
    var chart = this.chart, titleId = "highcharts-title-" + chart.index, titleContents = stripHTMLTags4(chart.langFormat("accessibility.svgContainerTitle", {
      chartTitle: getChartTitle6(chart)
    }));
    if (titleContents.length) {
      var titleElement = this.svgTitleElement = this.svgTitleElement || doc16.createElementNS("http://www.w3.org/2000/svg", "title");
      titleElement.textContent = titleContents;
      titleElement.id = titleId;
      chart.renderTo.insertBefore(titleElement, chart.renderTo.firstChild);
    }
  },
  setSVGContainerLabel: function() {
    var chart = this.chart, svgContainerLabel = chart.langFormat("accessibility.svgContainerLabel", {
      chartTitle: getChartTitle6(chart)
    });
    if (chart.renderer.box && svgContainerLabel.length) {
      chart.renderer.box.setAttribute("aria-label", svgContainerLabel);
    }
  },
  setGraphicContainerAttrs: function() {
    var chart = this.chart, label = chart.langFormat("accessibility.graphicContainerLabel", {
      chartTitle: getChartTitle6(chart)
    });
    if (label.length) {
      chart.container.setAttribute("aria-label", label);
    }
  },
  setRenderToAttrs: function() {
    var chart = this.chart;
    if (chart.options.accessibility.landmarkVerbosity !== "disabled") {
      chart.renderTo.setAttribute("role", "region");
    } else {
      chart.renderTo.removeAttribute("role");
    }
    chart.renderTo.setAttribute("aria-label", chart.langFormat("accessibility.chartContainerLabel", {
      title: getChartTitle6(chart),
      chart
    }));
  },
  makeCreditsAccessible: function() {
    var chart = this.chart, credits = chart.credits;
    if (credits) {
      if (credits.textStr) {
        credits.element.setAttribute("aria-label", chart.langFormat("accessibility.credits", { creditsStr: stripHTMLTags4(credits.textStr) }));
      }
      unhideChartElementFromAT8(chart, credits.element);
    }
  },
  getKeyboardNavigation: function() {
    var chart = this.chart;
    return new KeyboardNavigationHandler_default(chart, {
      keyCodeMap: [],
      validate: function() {
        return true;
      },
      init: function() {
        var a11y = chart.accessibility;
        if (a11y) {
          a11y.keyboardNavigation.tabindexContainer.focus();
        }
      }
    });
  },
  destroy: function() {
    this.chart.renderTo.setAttribute("aria-hidden", true);
  }
});
var ContainerComponent_default = ContainerComponent;

// node_modules/highcharts/es-modules/Accessibility/HighContrastMode.js
var doc17 = Globals_default.doc;
var isMS3 = Globals_default.isMS;
var win15 = Globals_default.win;
var whcm = {
  isHighContrastModeActive: function() {
    var isEdge = /(Edg)/.test(win15.navigator.userAgent);
    if (win15.matchMedia && isEdge) {
      return win15.matchMedia("(-ms-high-contrast: active)").matches;
    }
    if (isMS3 && win15.getComputedStyle) {
      var testDiv = doc17.createElement("div");
      var imageSrc = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      testDiv.style.backgroundImage = "url(" + imageSrc + ")";
      doc17.body.appendChild(testDiv);
      var bi = (testDiv.currentStyle || win15.getComputedStyle(testDiv)).backgroundImage;
      doc17.body.removeChild(testDiv);
      return bi === "none";
    }
    return false;
  },
  setHighContrastTheme: function(chart) {
    chart.highContrastModeActive = true;
    var theme2 = chart.options.accessibility.highContrastTheme;
    chart.update(theme2, false);
    chart.series.forEach(function(s) {
      var plotOpts = theme2.plotOptions[s.type] || {};
      s.update({
        color: plotOpts.color || "windowText",
        colors: [plotOpts.color || "windowText"],
        borderColor: plotOpts.borderColor || "window"
      });
      s.points.forEach(function(p) {
        if (p.options && p.options.color) {
          p.update({
            color: plotOpts.color || "windowText",
            borderColor: plotOpts.borderColor || "window"
          }, false);
        }
      });
    });
    chart.redraw();
  }
};
var HighContrastMode_default = whcm;

// node_modules/highcharts/es-modules/Accessibility/HighContrastTheme.js
var theme = {
  chart: {
    backgroundColor: "window"
  },
  title: {
    style: {
      color: "windowText"
    }
  },
  subtitle: {
    style: {
      color: "windowText"
    }
  },
  colorAxis: {
    minColor: "windowText",
    maxColor: "windowText",
    stops: []
  },
  colors: ["windowText"],
  xAxis: {
    gridLineColor: "windowText",
    labels: {
      style: {
        color: "windowText"
      }
    },
    lineColor: "windowText",
    minorGridLineColor: "windowText",
    tickColor: "windowText",
    title: {
      style: {
        color: "windowText"
      }
    }
  },
  yAxis: {
    gridLineColor: "windowText",
    labels: {
      style: {
        color: "windowText"
      }
    },
    lineColor: "windowText",
    minorGridLineColor: "windowText",
    tickColor: "windowText",
    title: {
      style: {
        color: "windowText"
      }
    }
  },
  tooltip: {
    backgroundColor: "window",
    borderColor: "windowText",
    style: {
      color: "windowText"
    }
  },
  plotOptions: {
    series: {
      lineColor: "windowText",
      fillColor: "window",
      borderColor: "windowText",
      edgeColor: "windowText",
      borderWidth: 1,
      dataLabels: {
        connectorColor: "windowText",
        color: "windowText",
        style: {
          color: "windowText",
          textOutline: "none"
        }
      },
      marker: {
        lineColor: "windowText",
        fillColor: "windowText"
      }
    },
    pie: {
      color: "window",
      colors: ["window"],
      borderColor: "windowText",
      borderWidth: 1
    },
    boxplot: {
      fillColor: "window"
    },
    candlestick: {
      lineColor: "windowText",
      fillColor: "window"
    },
    errorbar: {
      fillColor: "window"
    }
  },
  legend: {
    backgroundColor: "window",
    itemStyle: {
      color: "windowText"
    },
    itemHoverStyle: {
      color: "windowText"
    },
    itemHiddenStyle: {
      color: "#555"
    },
    title: {
      style: {
        color: "windowText"
      }
    }
  },
  credits: {
    style: {
      color: "windowText"
    }
  },
  labels: {
    style: {
      color: "windowText"
    }
  },
  drilldown: {
    activeAxisLabelStyle: {
      color: "windowText"
    },
    activeDataLabelStyle: {
      color: "windowText"
    }
  },
  navigation: {
    buttonOptions: {
      symbolStroke: "windowText",
      theme: {
        fill: "window"
      }
    }
  },
  rangeSelector: {
    buttonTheme: {
      fill: "window",
      stroke: "windowText",
      style: {
        color: "windowText"
      },
      states: {
        hover: {
          fill: "window",
          stroke: "windowText",
          style: {
            color: "windowText"
          }
        },
        select: {
          fill: "#444",
          stroke: "windowText",
          style: {
            color: "windowText"
          }
        }
      }
    },
    inputBoxBorderColor: "windowText",
    inputStyle: {
      backgroundColor: "window",
      color: "windowText"
    },
    labelStyle: {
      color: "windowText"
    }
  },
  navigator: {
    handles: {
      backgroundColor: "window",
      borderColor: "windowText"
    },
    outlineColor: "windowText",
    maskFill: "transparent",
    series: {
      color: "windowText",
      lineColor: "windowText"
    },
    xAxis: {
      gridLineColor: "windowText"
    }
  },
  scrollbar: {
    barBackgroundColor: "#444",
    barBorderColor: "windowText",
    buttonArrowColor: "windowText",
    buttonBackgroundColor: "window",
    buttonBorderColor: "windowText",
    rifleColor: "windowText",
    trackBackgroundColor: "window",
    trackBorderColor: "windowText"
  }
};
var HighContrastTheme_default = theme;

// node_modules/highcharts/es-modules/Accessibility/Options/Options.js
var Options = {
  accessibility: {
    enabled: true,
    screenReaderSection: {
      beforeChartFormat: "<{headingTagName}>{chartTitle}</{headingTagName}><div>{typeDescription}</div><div>{chartSubtitle}</div><div>{chartLongdesc}</div><div>{playAsSoundButton}</div><div>{viewTableButton}</div><div>{xAxisDescription}</div><div>{yAxisDescription}</div><div>{annotationsTitle}{annotationsList}</div>",
      afterChartFormat: "{endOfChartMarker}",
      axisRangeDateFormat: "%Y-%m-%d %H:%M:%S"
    },
    series: {
      describeSingleSeries: false,
      pointDescriptionEnabledThreshold: 200
    },
    point: {
      valueDescriptionFormat: "{index}. {xDescription}{separator}{value}."
    },
    landmarkVerbosity: "all",
    linkedDescription: '*[data-highcharts-chart="{index}"] + .highcharts-description',
    keyboardNavigation: {
      enabled: true,
      focusBorder: {
        enabled: true,
        hideBrowserFocusOutline: true,
        style: {
          color: Palette_default.highlightColor80,
          lineWidth: 2,
          borderRadius: 3
        },
        margin: 2
      },
      order: ["series", "zoom", "rangeSelector", "legend", "chartMenu"],
      wrapAround: true,
      seriesNavigation: {
        skipNullPoints: true,
        pointNavigationEnabledThreshold: false
      }
    },
    announceNewData: {
      enabled: false,
      minAnnounceInterval: 5e3,
      interruptUser: false
    }
  },
  legend: {
    accessibility: {
      enabled: true,
      keyboardNavigation: {
        enabled: true
      }
    }
  },
  exporting: {
    accessibility: {
      enabled: true
    }
  }
};
var Options_default = Options;

// node_modules/highcharts/es-modules/Accessibility/Options/LangOptions.js
var langOptions = {
  accessibility: {
    defaultChartTitle: "Chart",
    chartContainerLabel: "{title}. Highcharts interactive chart.",
    svgContainerLabel: "Interactive chart",
    drillUpButton: "{buttonText}",
    credits: "Chart credits: {creditsStr}",
    thousandsSep: ",",
    svgContainerTitle: "",
    graphicContainerLabel: "",
    screenReaderSection: {
      beforeRegionLabel: "Chart screen reader information, {chartTitle}.",
      afterRegionLabel: "",
      annotations: {
        heading: "Chart annotations summary",
        descriptionSinglePoint: "{annotationText}. Related to {annotationPoint}",
        descriptionMultiplePoints: "{annotationText}. Related to {annotationPoint}{ Also related to, #each(additionalAnnotationPoints)}",
        descriptionNoPoints: "{annotationText}"
      },
      endOfChartMarker: "End of interactive chart."
    },
    sonification: {
      playAsSoundButtonText: "Play as sound, {chartTitle}",
      playAsSoundClickAnnouncement: "Play"
    },
    legend: {
      legendLabelNoTitle: "Toggle series visibility, {chartTitle}",
      legendLabel: "Chart legend: {legendTitle}",
      legendItem: "Show {itemName}"
    },
    zoom: {
      mapZoomIn: "Zoom chart",
      mapZoomOut: "Zoom out chart",
      resetZoomButton: "Reset zoom"
    },
    rangeSelector: {
      dropdownLabel: "{rangeTitle}",
      minInputLabel: "Select start date.",
      maxInputLabel: "Select end date.",
      clickButtonAnnouncement: "Viewing {axisRangeDescription}"
    },
    table: {
      viewAsDataTableButtonText: "View as data table, {chartTitle}",
      tableSummary: "Table representation of chart."
    },
    announceNewData: {
      newDataAnnounce: "Updated data for chart {chartTitle}",
      newSeriesAnnounceSingle: "New data series: {seriesDesc}",
      newPointAnnounceSingle: "New data point: {pointDesc}",
      newSeriesAnnounceMultiple: "New data series in chart {chartTitle}: {seriesDesc}",
      newPointAnnounceMultiple: "New data point in chart {chartTitle}: {pointDesc}"
    },
    seriesTypeDescriptions: {
      boxplot: "Box plot charts are typically used to display groups of statistical data. Each data point in the chart can have up to 5 values: minimum, lower quartile, median, upper quartile, and maximum.",
      arearange: "Arearange charts are line charts displaying a range between a lower and higher value for each point.",
      areasplinerange: "These charts are line charts displaying a range between a lower and higher value for each point.",
      bubble: "Bubble charts are scatter charts where each data point also has a size value.",
      columnrange: "Columnrange charts are column charts displaying a range between a lower and higher value for each point.",
      errorbar: "Errorbar series are used to display the variability of the data.",
      funnel: "Funnel charts are used to display reduction of data in stages.",
      pyramid: "Pyramid charts consist of a single pyramid with item heights corresponding to each point value.",
      waterfall: "A waterfall chart is a column chart where each column contributes towards a total end value."
    },
    chartTypes: {
      emptyChart: "Empty chart",
      mapTypeDescription: "Map of {mapTitle} with {numSeries} data series.",
      unknownMap: "Map of unspecified region with {numSeries} data series.",
      combinationChart: "Combination chart with {numSeries} data series.",
      defaultSingle: "Chart with {numPoints} data {#plural(numPoints, points, point)}.",
      defaultMultiple: "Chart with {numSeries} data series.",
      splineSingle: "Line chart with {numPoints} data {#plural(numPoints, points, point)}.",
      splineMultiple: "Line chart with {numSeries} lines.",
      lineSingle: "Line chart with {numPoints} data {#plural(numPoints, points, point)}.",
      lineMultiple: "Line chart with {numSeries} lines.",
      columnSingle: "Bar chart with {numPoints} {#plural(numPoints, bars, bar)}.",
      columnMultiple: "Bar chart with {numSeries} data series.",
      barSingle: "Bar chart with {numPoints} {#plural(numPoints, bars, bar)}.",
      barMultiple: "Bar chart with {numSeries} data series.",
      pieSingle: "Pie chart with {numPoints} {#plural(numPoints, slices, slice)}.",
      pieMultiple: "Pie chart with {numSeries} pies.",
      scatterSingle: "Scatter chart with {numPoints} {#plural(numPoints, points, point)}.",
      scatterMultiple: "Scatter chart with {numSeries} data series.",
      boxplotSingle: "Boxplot with {numPoints} {#plural(numPoints, boxes, box)}.",
      boxplotMultiple: "Boxplot with {numSeries} data series.",
      bubbleSingle: "Bubble chart with {numPoints} {#plural(numPoints, bubbles, bubble)}.",
      bubbleMultiple: "Bubble chart with {numSeries} data series."
    },
    axis: {
      xAxisDescriptionSingular: "The chart has 1 X axis displaying {names[0]}. {ranges[0]}",
      xAxisDescriptionPlural: "The chart has {numAxes} X axes displaying {#each(names, -1) }and {names[-1]}.",
      yAxisDescriptionSingular: "The chart has 1 Y axis displaying {names[0]}. {ranges[0]}",
      yAxisDescriptionPlural: "The chart has {numAxes} Y axes displaying {#each(names, -1) }and {names[-1]}.",
      timeRangeDays: "Range: {range} days.",
      timeRangeHours: "Range: {range} hours.",
      timeRangeMinutes: "Range: {range} minutes.",
      timeRangeSeconds: "Range: {range} seconds.",
      rangeFromTo: "Range: {rangeFrom} to {rangeTo}.",
      rangeCategories: "Range: {numCategories} categories."
    },
    exporting: {
      chartMenuLabel: "Chart menu",
      menuButtonLabel: "View chart menu",
      exportRegionLabel: "Chart menu, {chartTitle}"
    },
    series: {
      summary: {
        "default": "{name}, series {ix} of {numSeries} with {numPoints} data {#plural(numPoints, points, point)}.",
        defaultCombination: "{name}, series {ix} of {numSeries} with {numPoints} data {#plural(numPoints, points, point)}.",
        line: "{name}, line {ix} of {numSeries} with {numPoints} data {#plural(numPoints, points, point)}.",
        lineCombination: "{name}, series {ix} of {numSeries}. Line with {numPoints} data {#plural(numPoints, points, point)}.",
        spline: "{name}, line {ix} of {numSeries} with {numPoints} data {#plural(numPoints, points, point)}.",
        splineCombination: "{name}, series {ix} of {numSeries}. Line with {numPoints} data {#plural(numPoints, points, point)}.",
        column: "{name}, bar series {ix} of {numSeries} with {numPoints} {#plural(numPoints, bars, bar)}.",
        columnCombination: "{name}, series {ix} of {numSeries}. Bar series with {numPoints} {#plural(numPoints, bars, bar)}.",
        bar: "{name}, bar series {ix} of {numSeries} with {numPoints} {#plural(numPoints, bars, bar)}.",
        barCombination: "{name}, series {ix} of {numSeries}. Bar series with {numPoints} {#plural(numPoints, bars, bar)}.",
        pie: "{name}, pie {ix} of {numSeries} with {numPoints} {#plural(numPoints, slices, slice)}.",
        pieCombination: "{name}, series {ix} of {numSeries}. Pie with {numPoints} {#plural(numPoints, slices, slice)}.",
        scatter: "{name}, scatter plot {ix} of {numSeries} with {numPoints} {#plural(numPoints, points, point)}.",
        scatterCombination: "{name}, series {ix} of {numSeries}, scatter plot with {numPoints} {#plural(numPoints, points, point)}.",
        boxplot: "{name}, boxplot {ix} of {numSeries} with {numPoints} {#plural(numPoints, boxes, box)}.",
        boxplotCombination: "{name}, series {ix} of {numSeries}. Boxplot with {numPoints} {#plural(numPoints, boxes, box)}.",
        bubble: "{name}, bubble series {ix} of {numSeries} with {numPoints} {#plural(numPoints, bubbles, bubble)}.",
        bubbleCombination: "{name}, series {ix} of {numSeries}. Bubble series with {numPoints} {#plural(numPoints, bubbles, bubble)}.",
        map: "{name}, map {ix} of {numSeries} with {numPoints} {#plural(numPoints, areas, area)}.",
        mapCombination: "{name}, series {ix} of {numSeries}. Map with {numPoints} {#plural(numPoints, areas, area)}.",
        mapline: "{name}, line {ix} of {numSeries} with {numPoints} data {#plural(numPoints, points, point)}.",
        maplineCombination: "{name}, series {ix} of {numSeries}. Line with {numPoints} data {#plural(numPoints, points, point)}.",
        mapbubble: "{name}, bubble series {ix} of {numSeries} with {numPoints} {#plural(numPoints, bubbles, bubble)}.",
        mapbubbleCombination: "{name}, series {ix} of {numSeries}. Bubble series with {numPoints} {#plural(numPoints, bubbles, bubble)}."
      },
      description: "{description}",
      xAxisDescription: "X axis, {name}",
      yAxisDescription: "Y axis, {name}",
      nullPointValue: "No value",
      pointAnnotationsDescription: "{Annotation: #each(annotations). }"
    }
  }
};
var LangOptions_default = langOptions;

// node_modules/highcharts/es-modules/Accessibility/Options/DeprecatedOptions.js
var error10 = Utilities_default.error;
var pick50 = Utilities_default.pick;
function traverseSetOption(root, optionAsArray, val) {
  var opt = root, prop, i = 0;
  for (; i < optionAsArray.length - 1; ++i) {
    prop = optionAsArray[i];
    opt = opt[prop] = pick50(opt[prop], {});
  }
  opt[optionAsArray[optionAsArray.length - 1]] = val;
}
function deprecateFromOptionsMap(chart, rootOldAsArray, rootNewAsArray, mapToNewOptions) {
  function getChildProp(root, propAsArray) {
    return propAsArray.reduce(function(acc, cur) {
      return acc[cur];
    }, root);
  }
  var rootOld = getChildProp(chart.options, rootOldAsArray), rootNew = getChildProp(chart.options, rootNewAsArray);
  Object.keys(mapToNewOptions).forEach(function(oldOptionKey) {
    var _a15;
    var val = rootOld[oldOptionKey];
    if (typeof val !== "undefined") {
      traverseSetOption(rootNew, mapToNewOptions[oldOptionKey], val);
      error10(32, false, chart, (_a15 = {}, _a15[rootOldAsArray.join(".") + "." + oldOptionKey] = rootNewAsArray.join(".") + "." + mapToNewOptions[oldOptionKey].join("."), _a15));
    }
  });
}
function copyDeprecatedChartOptions(chart) {
  var chartOptions = chart.options.chart, a11yOptions = chart.options.accessibility || {};
  ["description", "typeDescription"].forEach(function(prop) {
    var _a15;
    if (chartOptions[prop]) {
      a11yOptions[prop] = chartOptions[prop];
      error10(32, false, chart, (_a15 = {}, _a15["chart." + prop] = "use accessibility." + prop, _a15));
    }
  });
}
function copyDeprecatedAxisOptions(chart) {
  chart.axes.forEach(function(axis) {
    var opts = axis.options;
    if (opts && opts.description) {
      opts.accessibility = opts.accessibility || {};
      opts.accessibility.description = opts.description;
      error10(32, false, chart, { "axis.description": "use axis.accessibility.description" });
    }
  });
}
function copyDeprecatedSeriesOptions(chart) {
  var oldToNewSeriesOptions = {
    description: ["accessibility", "description"],
    exposeElementToA11y: ["accessibility", "exposeAsGroupOnly"],
    pointDescriptionFormatter: [
      "accessibility",
      "pointDescriptionFormatter"
    ],
    skipKeyboardNavigation: [
      "accessibility",
      "keyboardNavigation",
      "enabled"
    ]
  };
  chart.series.forEach(function(series) {
    Object.keys(oldToNewSeriesOptions).forEach(function(oldOption) {
      var _a15;
      var optionVal = series.options[oldOption];
      if (typeof optionVal !== "undefined") {
        traverseSetOption(series.options, oldToNewSeriesOptions[oldOption], oldOption === "skipKeyboardNavigation" ? !optionVal : optionVal);
        error10(32, false, chart, (_a15 = {}, _a15["series." + oldOption] = "series." + oldToNewSeriesOptions[oldOption].join("."), _a15));
      }
    });
  });
}
function copyDeprecatedTopLevelAccessibilityOptions(chart) {
  deprecateFromOptionsMap(chart, ["accessibility"], ["accessibility"], {
    pointDateFormat: ["point", "dateFormat"],
    pointDateFormatter: ["point", "dateFormatter"],
    pointDescriptionFormatter: ["point", "descriptionFormatter"],
    pointDescriptionThreshold: [
      "series",
      "pointDescriptionEnabledThreshold"
    ],
    pointNavigationThreshold: [
      "keyboardNavigation",
      "seriesNavigation",
      "pointNavigationEnabledThreshold"
    ],
    pointValueDecimals: ["point", "valueDecimals"],
    pointValuePrefix: ["point", "valuePrefix"],
    pointValueSuffix: ["point", "valueSuffix"],
    screenReaderSectionFormatter: [
      "screenReaderSection",
      "beforeChartFormatter"
    ],
    describeSingleSeries: ["series", "describeSingleSeries"],
    seriesDescriptionFormatter: ["series", "descriptionFormatter"],
    onTableAnchorClick: ["screenReaderSection", "onViewDataTableClick"],
    axisRangeDateFormat: ["screenReaderSection", "axisRangeDateFormat"]
  });
}
function copyDeprecatedKeyboardNavigationOptions(chart) {
  deprecateFromOptionsMap(chart, ["accessibility", "keyboardNavigation"], ["accessibility", "keyboardNavigation", "seriesNavigation"], {
    skipNullPoints: ["skipNullPoints"],
    mode: ["mode"]
  });
}
function copyDeprecatedLangOptions(chart) {
  deprecateFromOptionsMap(chart, ["lang", "accessibility"], ["lang", "accessibility"], {
    legendItem: ["legend", "legendItem"],
    legendLabel: ["legend", "legendLabel"],
    mapZoomIn: ["zoom", "mapZoomIn"],
    mapZoomOut: ["zoom", "mapZoomOut"],
    resetZoomButton: ["zoom", "resetZoomButton"],
    screenReaderRegionLabel: [
      "screenReaderSection",
      "beforeRegionLabel"
    ],
    rangeSelectorButton: ["rangeSelector", "buttonText"],
    rangeSelectorMaxInput: ["rangeSelector", "maxInputLabel"],
    rangeSelectorMinInput: ["rangeSelector", "minInputLabel"],
    svgContainerEnd: ["screenReaderSection", "endOfChartMarker"],
    viewAsDataTable: ["table", "viewAsDataTableButtonText"],
    tableSummary: ["table", "tableSummary"]
  });
}
function copyDeprecatedOptions(chart) {
  copyDeprecatedChartOptions(chart);
  copyDeprecatedAxisOptions(chart);
  if (chart.series) {
    copyDeprecatedSeriesOptions(chart);
  }
  copyDeprecatedTopLevelAccessibilityOptions(chart);
  copyDeprecatedKeyboardNavigationOptions(chart);
  copyDeprecatedLangOptions(chart);
}
var DeprecatedOptions_default = copyDeprecatedOptions;

// node_modules/highcharts/es-modules/Accessibility/A11yI18n.js
var format11 = FormatUtilities_default.format;
var pick51 = Utilities_default.pick;
function stringTrim(str) {
  return str.trim && str.trim() || str.replace(/^\s+|\s+$/g, "");
}
function formatExtendedStatement(statement, ctx) {
  var eachStart = statement.indexOf("#each("), pluralStart = statement.indexOf("#plural("), indexStart = statement.indexOf("["), indexEnd = statement.indexOf("]"), arr, result2;
  if (eachStart > -1) {
    var eachEnd = statement.slice(eachStart).indexOf(")") + eachStart, preEach = statement.substring(0, eachStart), postEach = statement.substring(eachEnd + 1), eachStatement = statement.substring(eachStart + 6, eachEnd), eachArguments = eachStatement.split(","), lenArg = Number(eachArguments[1]), len = void 0;
    result2 = "";
    arr = ctx[eachArguments[0]];
    if (arr) {
      lenArg = isNaN(lenArg) ? arr.length : lenArg;
      len = lenArg < 0 ? arr.length + lenArg : Math.min(lenArg, arr.length);
      for (var i = 0; i < len; ++i) {
        result2 += preEach + arr[i] + postEach;
      }
    }
    return result2.length ? result2 : "";
  }
  if (pluralStart > -1) {
    var pluralEnd = statement.slice(pluralStart).indexOf(")") + pluralStart, pluralStatement = statement.substring(pluralStart + 8, pluralEnd), pluralArguments = pluralStatement.split(","), num = Number(ctx[pluralArguments[0]]);
    switch (num) {
      case 0:
        result2 = pick51(pluralArguments[4], pluralArguments[1]);
        break;
      case 1:
        result2 = pick51(pluralArguments[2], pluralArguments[1]);
        break;
      case 2:
        result2 = pick51(pluralArguments[3], pluralArguments[1]);
        break;
      default:
        result2 = pluralArguments[1];
    }
    return result2 ? stringTrim(result2) : "";
  }
  if (indexStart > -1) {
    var arrayName = statement.substring(0, indexStart), ix = Number(statement.substring(indexStart + 1, indexEnd)), val = void 0;
    arr = ctx[arrayName];
    if (!isNaN(ix) && arr) {
      if (ix < 0) {
        val = arr[arr.length + ix];
        if (typeof val === "undefined") {
          val = arr[0];
        }
      } else {
        val = arr[ix];
        if (typeof val === "undefined") {
          val = arr[arr.length - 1];
        }
      }
    }
    return typeof val !== "undefined" ? val : "";
  }
  return "{" + statement + "}";
}
Globals_default.i18nFormat = function(formatString, context, chart) {
  var getFirstBracketStatement = function(sourceStr, offset3) {
    var str = sourceStr.slice(offset3 || 0), startBracket = str.indexOf("{"), endBracket = str.indexOf("}");
    if (startBracket > -1 && endBracket > startBracket) {
      return {
        statement: str.substring(startBracket + 1, endBracket),
        begin: offset3 + startBracket + 1,
        end: offset3 + endBracket
      };
    }
  }, tokens = [], bracketRes, constRes, cursor = 0;
  do {
    bracketRes = getFirstBracketStatement(formatString, cursor);
    constRes = formatString.substring(cursor, bracketRes && bracketRes.begin - 1);
    if (constRes.length) {
      tokens.push({
        value: constRes,
        type: "constant"
      });
    }
    if (bracketRes) {
      tokens.push({
        value: bracketRes.statement,
        type: "statement"
      });
    }
    cursor = bracketRes ? bracketRes.end + 1 : cursor + 1;
  } while (bracketRes);
  tokens.forEach(function(token) {
    if (token.type === "statement") {
      token.value = formatExtendedStatement(token.value, context);
    }
  });
  return format11(tokens.reduce(function(acc, cur) {
    return acc + cur.value;
  }, ""), context, chart);
};
Chart_default.prototype.langFormat = function(langKey, context) {
  var keys2 = langKey.split("."), formatString = this.options.lang, i = 0;
  for (; i < keys2.length; ++i) {
    formatString = formatString && formatString[keys2[i]];
  }
  return typeof formatString === "string" ? Globals_default.i18nFormat(formatString, context, this) : "";
};

// node_modules/highcharts/es-modules/Accessibility/FocusBorder.js
var addEvent34 = Utilities_default.addEvent;
var extend43 = Utilities_default.extend;
var pick52 = Utilities_default.pick;
var svgElementBorderUpdateTriggers = [
  "x",
  "y",
  "transform",
  "width",
  "height",
  "r",
  "d",
  "stroke-width"
];
function addDestroyFocusBorderHook(el) {
  if (el.focusBorderDestroyHook) {
    return;
  }
  var origDestroy = el.destroy;
  el.destroy = function() {
    if (el.focusBorder && el.focusBorder.destroy) {
      el.focusBorder.destroy();
    }
    return origDestroy.apply(el, arguments);
  };
  el.focusBorderDestroyHook = origDestroy;
}
function removeDestroyFocusBorderHook(el) {
  if (!el.focusBorderDestroyHook) {
    return;
  }
  el.destroy = el.focusBorderDestroyHook;
  delete el.focusBorderDestroyHook;
}
function addUpdateFocusBorderHooks(el) {
  var updateParams = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    updateParams[_i - 1] = arguments[_i];
  }
  if (el.focusBorderUpdateHooks) {
    return;
  }
  el.focusBorderUpdateHooks = {};
  svgElementBorderUpdateTriggers.forEach(function(trigger) {
    var setterKey = trigger + "Setter";
    var origSetter = el[setterKey] || el._defaultSetter;
    el.focusBorderUpdateHooks[setterKey] = origSetter;
    el[setterKey] = function() {
      var ret = origSetter.apply(el, arguments);
      el.addFocusBorder.apply(el, updateParams);
      return ret;
    };
  });
}
function removeUpdateFocusBorderHooks(el) {
  if (!el.focusBorderUpdateHooks) {
    return;
  }
  Object.keys(el.focusBorderUpdateHooks).forEach(function(setterKey) {
    var origSetter = el.focusBorderUpdateHooks[setterKey];
    if (origSetter === el._defaultSetter) {
      delete el[setterKey];
    } else {
      el[setterKey] = origSetter;
    }
  });
  delete el.focusBorderUpdateHooks;
}
extend43(SVGElement_default.prototype, {
  addFocusBorder: function(margin, attribs) {
    if (this.focusBorder) {
      this.removeFocusBorder();
    }
    var bb = this.getBBox(), pad4 = pick52(margin, 3);
    bb.x += this.translateX ? this.translateX : 0;
    bb.y += this.translateY ? this.translateY : 0;
    var borderPosX = bb.x - pad4, borderPosY = bb.y - pad4, borderWidth = bb.width + 2 * pad4, borderHeight = bb.height + 2 * pad4;
    function getTextAnchorCorrection(text) {
      var posXCorrection = 0, posYCorrection = 0;
      if (text.attr("text-anchor") === "middle") {
        posXCorrection = posYCorrection = 0.5;
      } else if (!text.rotation) {
        posYCorrection = 0.75;
      } else {
        posXCorrection = 0.25;
      }
      return {
        x: posXCorrection,
        y: posYCorrection
      };
    }
    var isLabel = this instanceof SVGLabel_default;
    if (this.element.nodeName === "text" || isLabel) {
      var isRotated = !!this.rotation;
      var correction = !isLabel ? getTextAnchorCorrection(this) : {
        x: isRotated ? 1 : 0,
        y: 0
      };
      var attrX = +this.attr("x");
      var attrY = +this.attr("y");
      if (!isNaN(attrX)) {
        borderPosX = attrX - bb.width * correction.x - pad4;
      }
      if (!isNaN(attrY)) {
        borderPosY = attrY - bb.height * correction.y - pad4;
      }
      if (isLabel && isRotated) {
        var temp = borderWidth;
        borderWidth = borderHeight;
        borderHeight = temp;
        if (!isNaN(attrX)) {
          borderPosX = attrX - bb.height * correction.x - pad4;
        }
        if (!isNaN(attrY)) {
          borderPosY = attrY - bb.width * correction.y - pad4;
        }
      }
    }
    this.focusBorder = this.renderer.rect(borderPosX, borderPosY, borderWidth, borderHeight, parseInt((attribs && attribs.r || 0).toString(), 10)).addClass("highcharts-focus-border").attr({
      zIndex: 99
    }).add(this.parentGroup);
    if (!this.renderer.styledMode) {
      this.focusBorder.attr({
        stroke: attribs && attribs.stroke,
        "stroke-width": attribs && attribs.strokeWidth
      });
    }
    addUpdateFocusBorderHooks(this, margin, attribs);
    addDestroyFocusBorderHook(this);
  },
  removeFocusBorder: function() {
    removeUpdateFocusBorderHooks(this);
    removeDestroyFocusBorderHook(this);
    if (this.focusBorder) {
      this.focusBorder.destroy();
      delete this.focusBorder;
    }
  }
});
Chart_default.prototype.renderFocusBorder = function() {
  var focusElement = this.focusElement, focusBorderOptions = this.options.accessibility.keyboardNavigation.focusBorder;
  if (focusElement) {
    focusElement.removeFocusBorder();
    if (focusBorderOptions.enabled) {
      focusElement.addFocusBorder(focusBorderOptions.margin, {
        stroke: focusBorderOptions.style.color,
        strokeWidth: focusBorderOptions.style.lineWidth,
        r: focusBorderOptions.style.borderRadius
      });
    }
  }
};
Chart_default.prototype.setFocusToElement = function(svgElement, focusElement) {
  var focusBorderOptions = this.options.accessibility.keyboardNavigation.focusBorder, browserFocusElement = focusElement || svgElement.element;
  if (browserFocusElement && browserFocusElement.focus) {
    if (!(browserFocusElement.hcEvents && browserFocusElement.hcEvents.focusin)) {
      addEvent34(browserFocusElement, "focusin", function() {
      });
    }
    browserFocusElement.focus();
    if (focusBorderOptions.hideBrowserFocusOutline) {
      browserFocusElement.style.outline = "none";
    }
  }
  if (this.focusElement) {
    this.focusElement.removeFocusBorder();
  }
  this.focusElement = svgElement;
  this.renderFocusBorder();
};

// node_modules/highcharts/es-modules/Accessibility/Accessibility.js
var doc18 = Globals_default.doc;
var defaultOptions12 = DefaultOptions_default.defaultOptions;
var addEvent35 = Utilities_default.addEvent;
var extend44 = Utilities_default.extend;
var fireEvent25 = Utilities_default.fireEvent;
var merge43 = Utilities_default.merge;
merge43(true, defaultOptions12, Options_default, {
  accessibility: {
    highContrastTheme: HighContrastTheme_default
  },
  lang: LangOptions_default
});
Globals_default.A11yChartUtilities = ChartUtilities_default;
Globals_default.A11yHTMLUtilities = HTMLUtilities_default;
Globals_default.KeyboardNavigationHandler = KeyboardNavigationHandler_default;
Globals_default.AccessibilityComponent = AccessibilityComponent_default;
function Accessibility(chart) {
  this.init(chart);
}
Accessibility.prototype = {
  init: function(chart) {
    this.chart = chart;
    if (!doc18.addEventListener || !chart.renderer.isSVG) {
      chart.renderTo.setAttribute("aria-hidden", true);
      return;
    }
    DeprecatedOptions_default(chart);
    this.initComponents();
    this.keyboardNavigation = new KeyboardNavigation_default(chart, this.components);
    this.update();
  },
  initComponents: function() {
    var chart = this.chart, a11yOptions = chart.options.accessibility;
    this.components = {
      container: new ContainerComponent_default(),
      infoRegions: new InfoRegionsComponent_default(),
      legend: new LegendComponent_default(),
      chartMenu: new MenuComponent_default(),
      rangeSelector: new RangeSelectorComponent_default(),
      series: new SeriesComponent_default(),
      zoom: new ZoomComponent_default()
    };
    if (a11yOptions.customComponents) {
      extend44(this.components, a11yOptions.customComponents);
    }
    var components = this.components;
    this.getComponentOrder().forEach(function(componentName) {
      components[componentName].initBase(chart);
      components[componentName].init();
    });
  },
  getComponentOrder: function() {
    if (!this.components) {
      return [];
    }
    if (!this.components.series) {
      return Object.keys(this.components);
    }
    var componentsExceptSeries = Object.keys(this.components).filter(function(c) {
      return c !== "series";
    });
    return ["series"].concat(componentsExceptSeries);
  },
  update: function() {
    var components = this.components, chart = this.chart, a11yOptions = chart.options.accessibility;
    fireEvent25(chart, "beforeA11yUpdate");
    chart.types = this.getChartTypes();
    this.getComponentOrder().forEach(function(componentName) {
      components[componentName].onChartUpdate();
      fireEvent25(chart, "afterA11yComponentUpdate", {
        name: componentName,
        component: components[componentName]
      });
    });
    this.keyboardNavigation.update(a11yOptions.keyboardNavigation.order);
    if (!chart.highContrastModeActive && HighContrastMode_default.isHighContrastModeActive()) {
      HighContrastMode_default.setHighContrastTheme(chart);
    }
    fireEvent25(chart, "afterA11yUpdate", {
      accessibility: this
    });
  },
  destroy: function() {
    var chart = this.chart || {};
    var components = this.components;
    Object.keys(components).forEach(function(componentName) {
      components[componentName].destroy();
      components[componentName].destroyBase();
    });
    if (this.keyboardNavigation) {
      this.keyboardNavigation.destroy();
    }
    if (chart.renderTo) {
      chart.renderTo.setAttribute("aria-hidden", true);
    }
    if (chart.focusElement) {
      chart.focusElement.removeFocusBorder();
    }
  },
  getChartTypes: function() {
    var types = {};
    this.chart.series.forEach(function(series) {
      types[series.type] = 1;
    });
    return Object.keys(types);
  }
};
Chart_default.prototype.updateA11yEnabled = function() {
  var a11y = this.accessibility, accessibilityOptions = this.options.accessibility;
  if (accessibilityOptions && accessibilityOptions.enabled) {
    if (a11y) {
      a11y.update();
    } else {
      this.accessibility = a11y = new Accessibility(this);
    }
  } else if (a11y) {
    if (a11y.destroy) {
      a11y.destroy();
    }
    delete this.accessibility;
  } else {
    this.renderTo.setAttribute("aria-hidden", true);
  }
};
addEvent35(Chart_default, "render", function(e2) {
  if (this.a11yDirty && this.renderTo) {
    delete this.a11yDirty;
    this.updateA11yEnabled();
  }
  var a11y = this.accessibility;
  if (a11y) {
    a11y.getComponentOrder().forEach(function(componentName) {
      a11y.components[componentName].onChartRender();
    });
  }
});
addEvent35(Chart_default, "update", function(e2) {
  var newOptions = e2.options.accessibility;
  if (newOptions) {
    if (newOptions.customComponents) {
      this.options.accessibility.customComponents = newOptions.customComponents;
      delete newOptions.customComponents;
    }
    merge43(true, this.options.accessibility, newOptions);
    if (this.accessibility && this.accessibility.destroy) {
      this.accessibility.destroy();
      delete this.accessibility;
    }
  }
  this.a11yDirty = true;
});
addEvent35(Point_default, "update", function() {
  if (this.series.chart.accessibility) {
    this.series.chart.a11yDirty = true;
  }
});
["addSeries", "init"].forEach(function(event) {
  addEvent35(Chart_default, event, function() {
    this.a11yDirty = true;
  });
});
["update", "updatedData", "remove"].forEach(function(event) {
  addEvent35(Series_default, event, function() {
    if (this.chart.accessibility) {
      this.chart.a11yDirty = true;
    }
  });
});
[
  "afterDrilldown",
  "drillupall"
].forEach(function(event) {
  addEvent35(Chart_default, event, function() {
    if (this.accessibility) {
      this.accessibility.update();
    }
  });
});
addEvent35(Chart_default, "destroy", function() {
  if (this.accessibility) {
    this.accessibility.destroy();
  }
});

// node_modules/highcharts/es-modules/Extensions/Pane.js
var addEvent36 = Utilities_default.addEvent;
var extend45 = Utilities_default.extend;
var merge44 = Utilities_default.merge;
var pick53 = Utilities_default.pick;
var splat14 = Utilities_default.splat;
Chart_default.prototype.collectionsWithUpdate.push("pane");
var Pane = function() {
  function Pane2(options, chart) {
    this.background = void 0;
    this.center = void 0;
    this.chart = void 0;
    this.options = void 0;
    this.coll = "pane";
    this.defaultOptions = {
      center: ["50%", "50%"],
      size: "85%",
      innerSize: "0%",
      startAngle: 0
    };
    this.defaultBackgroundOptions = {
      shape: "circle",
      borderWidth: 1,
      borderColor: Palette_default.neutralColor20,
      backgroundColor: {
        linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 },
        stops: [
          [0, Palette_default.backgroundColor],
          [1, Palette_default.neutralColor10]
        ]
      },
      from: -Number.MAX_VALUE,
      innerRadius: 0,
      to: Number.MAX_VALUE,
      outerRadius: "105%"
    };
    this.init(options, chart);
  }
  Pane2.prototype.init = function(options, chart) {
    this.chart = chart;
    this.background = [];
    chart.pane.push(this);
    this.setOptions(options);
  };
  Pane2.prototype.setOptions = function(options) {
    this.options = options = merge44(this.defaultOptions, this.chart.angular ? { background: {} } : void 0, options);
  };
  Pane2.prototype.render = function() {
    var options = this.options, backgroundOption = this.options.background, renderer = this.chart.renderer, len, i;
    if (!this.group) {
      this.group = renderer.g("pane-group").attr({ zIndex: options.zIndex || 0 }).add();
    }
    this.updateCenter();
    if (backgroundOption) {
      backgroundOption = splat14(backgroundOption);
      len = Math.max(backgroundOption.length, this.background.length || 0);
      for (i = 0; i < len; i++) {
        if (backgroundOption[i] && this.axis) {
          this.renderBackground(merge44(this.defaultBackgroundOptions, backgroundOption[i]), i);
        } else if (this.background[i]) {
          this.background[i] = this.background[i].destroy();
          this.background.splice(i, 1);
        }
      }
    }
  };
  Pane2.prototype.renderBackground = function(backgroundOptions, i) {
    var method = "animate", attribs = {
      "class": "highcharts-pane " + (backgroundOptions.className || "")
    };
    if (!this.chart.styledMode) {
      extend45(attribs, {
        "fill": backgroundOptions.backgroundColor,
        "stroke": backgroundOptions.borderColor,
        "stroke-width": backgroundOptions.borderWidth
      });
    }
    if (!this.background[i]) {
      this.background[i] = this.chart.renderer.path().add(this.group);
      method = "attr";
    }
    this.background[i][method]({
      "d": this.axis.getPlotBandPath(backgroundOptions.from, backgroundOptions.to, backgroundOptions)
    }).attr(attribs);
  };
  Pane2.prototype.updateCenter = function(axis) {
    this.center = (axis || this.axis || {}).center = CenteredSeries_default.getCenter.call(this);
  };
  Pane2.prototype.update = function(options, redraw) {
    merge44(true, this.options, options);
    this.setOptions(this.options);
    this.render();
    this.chart.axes.forEach(function(axis) {
      if (axis.pane === this) {
        axis.pane = null;
        axis.update({}, redraw);
      }
    }, this);
  };
  return Pane2;
}();
function isInsidePane(x, y, center) {
  return Math.sqrt(Math.pow(x - center[0], 2) + Math.pow(y - center[1], 2)) <= center[2] / 2;
}
Chart_default.prototype.getHoverPane = function(eventArgs) {
  var chart = this;
  var hoverPane;
  if (eventArgs) {
    chart.pane.forEach(function(pane) {
      var plotX = eventArgs.chartX - chart.plotLeft, plotY = eventArgs.chartY - chart.plotTop, x = chart.inverted ? plotY : plotX, y = chart.inverted ? plotX : plotY;
      if (isInsidePane(x, y, pane.center)) {
        hoverPane = pane;
      }
    });
  }
  return hoverPane;
};
addEvent36(Chart_default, "afterIsInsidePlot", function(e2) {
  var chart = this;
  if (chart.polar) {
    e2.isInsidePlot = chart.pane.some(function(pane) {
      return isInsidePane(e2.x, e2.y, pane.center);
    });
  }
});
addEvent36(Pointer_default, "beforeGetHoverData", function(eventArgs) {
  var chart = this.chart;
  if (chart.polar) {
    chart.hoverPane = chart.getHoverPane(eventArgs);
    eventArgs.filter = function(s) {
      return s.visible && !(!eventArgs.shared && s.directTouch) && pick53(s.options.enableMouseTracking, true) && (!chart.hoverPane || s.xAxis.pane === chart.hoverPane);
    };
  } else {
    chart.hoverPane = void 0;
  }
});
addEvent36(Pointer_default, "afterGetHoverData", function(eventArgs) {
  var chart = this.chart;
  if (eventArgs.hoverPoint && eventArgs.hoverPoint.plotX && eventArgs.hoverPoint.plotY && chart.hoverPane && !isInsidePane(eventArgs.hoverPoint.plotX, eventArgs.hoverPoint.plotY, chart.hoverPane.center)) {
    eventArgs.hoverPoint = void 0;
  }
});
Globals_default.Pane = Pane;
var Pane_default = Globals_default.Pane;

// node_modules/highcharts/es-modules/Core/Axis/RadialAxis.js
var defaultOptions13 = DefaultOptions_default.defaultOptions;
var noop10 = Globals_default.noop;
var addEvent37 = Utilities_default.addEvent;
var correctFloat11 = Utilities_default.correctFloat;
var defined38 = Utilities_default.defined;
var extend46 = Utilities_default.extend;
var fireEvent26 = Utilities_default.fireEvent;
var merge45 = Utilities_default.merge;
var pick54 = Utilities_default.pick;
var relativeLength9 = Utilities_default.relativeLength;
var wrap4 = Utilities_default.wrap;
var RadialAxis;
(function(RadialAxis2) {
  var composedClasses2 = [];
  var defaultCircularOptions = {
    gridLineWidth: 1,
    labels: {
      align: void 0,
      distance: 15,
      x: 0,
      y: void 0,
      style: {
        textOverflow: "none"
      }
    },
    maxPadding: 0,
    minPadding: 0,
    showLastLabel: false,
    tickLength: 0
  };
  var defaultRadialGaugeOptions = {
    labels: {
      align: "center",
      x: 0,
      y: void 0
    },
    minorGridLineWidth: 0,
    minorTickInterval: "auto",
    minorTickLength: 10,
    minorTickPosition: "inside",
    minorTickWidth: 1,
    tickLength: 10,
    tickPosition: "inside",
    tickWidth: 2,
    title: {
      rotation: 0
    },
    zIndex: 2
  };
  var defaultRadialOptions = {
    gridLineInterpolation: "circle",
    gridLineWidth: 1,
    labels: {
      align: "right",
      x: -3,
      y: -2
    },
    showLastLabel: false,
    title: {
      x: 4,
      text: null,
      rotation: 90
    }
  };
  function beforeSetTickPositions() {
    this.autoConnect = this.isCircular && typeof pick54(this.userMax, this.options.max) === "undefined" && correctFloat11(this.endAngleRad - this.startAngleRad) === correctFloat11(2 * Math.PI);
    if (!this.isCircular && this.chart.inverted) {
      this.max++;
    }
    if (this.autoConnect) {
      this.max += this.categories && 1 || this.pointRange || this.closestPointRange || 0;
    }
  }
  function compose(AxisClass, TickClass) {
    if (composedClasses2.indexOf(AxisClass) === -1) {
      composedClasses2.push(AxisClass);
      addEvent37(AxisClass, "afterInit", onAxisAfterInit);
      addEvent37(AxisClass, "autoLabelAlign", onAxisAutoLabelAlign);
      addEvent37(AxisClass, "destroy", onAxisDestroy);
      addEvent37(AxisClass, "init", onAxisInit);
      addEvent37(AxisClass, "initialAxisTranslation", onAxisInitialAxisTranslation);
    }
    if (composedClasses2.indexOf(TickClass) === -1) {
      composedClasses2.push(TickClass);
      addEvent37(TickClass, "afterGetLabelPosition", onTickAfterGetLabelPosition);
      addEvent37(TickClass, "afterGetPosition", onTickAfterGetPosition);
      wrap4(TickClass.prototype, "getMarkPath", wrapTickGetMarkPath);
    }
    return AxisClass;
  }
  RadialAxis2.compose = compose;
  function createLabelCollector() {
    var _this = this;
    return function() {
      if (_this.isRadial && _this.tickPositions && _this.options.labels && _this.options.labels.allowOverlap !== true) {
        return _this.tickPositions.map(function(pos) {
          return _this.ticks[pos] && _this.ticks[pos].label;
        }).filter(function(label) {
          return Boolean(label);
        });
      }
    };
  }
  function createLabelCollectorHidden() {
    return noop10;
  }
  function getCrosshairPosition(options, x1, y1) {
    var center = this.pane.center;
    var value = options.value, shapeArgs, end, x2, y2;
    if (this.isCircular) {
      if (!defined38(value)) {
        x2 = options.chartX || 0;
        y2 = options.chartY || 0;
        value = this.translate(Math.atan2(y2 - y1, x2 - x1) - this.startAngleRad, true);
      } else if (options.point) {
        shapeArgs = options.point.shapeArgs || {};
        if (shapeArgs.start) {
          value = this.chart.inverted ? this.translate(options.point.rectPlotY, true) : options.point.x;
        }
      }
      end = this.getPosition(value);
      x2 = end.x;
      y2 = end.y;
    } else {
      if (!defined38(value)) {
        x2 = options.chartX;
        y2 = options.chartY;
      }
      if (defined38(x2) && defined38(y2)) {
        y1 = center[1] + this.chart.plotTop;
        value = this.translate(Math.min(Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)), center[2] / 2) - center[3] / 2, true);
      }
    }
    return [value, x2 || 0, y2 || 0];
  }
  function getLinePath(_lineWidth, radius, innerRadius) {
    var center = this.pane.center, chart = this.chart, left = this.left || 0, top = this.top || 0;
    var end, r = pick54(radius, center[2] / 2 - this.offset), path;
    if (typeof innerRadius === "undefined") {
      innerRadius = this.horiz ? 0 : this.center && -this.center[3] / 2;
    }
    if (innerRadius) {
      r += innerRadius;
    }
    if (this.isCircular || typeof radius !== "undefined") {
      path = this.chart.renderer.symbols.arc(left + center[0], top + center[1], r, r, {
        start: this.startAngleRad,
        end: this.endAngleRad,
        open: true,
        innerR: 0
      });
      path.xBounds = [left + center[0]];
      path.yBounds = [top + center[1] - r];
    } else {
      end = this.postTranslate(this.angleRad, r);
      path = [
        ["M", this.center[0] + chart.plotLeft, this.center[1] + chart.plotTop],
        ["L", end.x, end.y]
      ];
    }
    return path;
  }
  function getOffset() {
    var axisProto = this.constructor.prototype;
    axisProto.getOffset.call(this);
    this.chart.axisOffset[this.side] = 0;
  }
  function getPlotBandPath(from, to, options) {
    var chart = this.chart, radiusToPixels = function(radius) {
      if (typeof radius === "string") {
        var r = parseInt(radius, 10);
        if (percentRegex.test(radius)) {
          r = r * fullRadius / 100;
        }
        return r;
      }
      return radius;
    }, center = this.center, startAngleRad = this.startAngleRad, fullRadius = center[2] / 2, offset3 = Math.min(this.offset, 0), left = this.left || 0, top = this.top || 0, percentRegex = /%$/, isCircular = this.isCircular;
    var start, end, angle, xOnPerimeter, open, path, outerRadius = pick54(radiusToPixels(options.outerRadius), fullRadius), innerRadius = radiusToPixels(options.innerRadius), thickness = pick54(radiusToPixels(options.thickness), 10);
    if (this.options.gridLineInterpolation === "polygon") {
      path = this.getPlotLinePath({ value: from }).concat(this.getPlotLinePath({ value: to, reverse: true }));
    } else {
      from = Math.max(from, this.min);
      to = Math.min(to, this.max);
      var transFrom = this.translate(from), transTo = this.translate(to);
      if (!isCircular) {
        outerRadius = transFrom || 0;
        innerRadius = transTo || 0;
      }
      if (options.shape === "circle" || !isCircular) {
        start = -Math.PI / 2;
        end = Math.PI * 1.5;
        open = true;
      } else {
        start = startAngleRad + (transFrom || 0);
        end = startAngleRad + (transTo || 0);
      }
      outerRadius -= offset3;
      thickness -= offset3;
      path = chart.renderer.symbols.arc(left + center[0], top + center[1], outerRadius, outerRadius, {
        start: Math.min(start, end),
        end: Math.max(start, end),
        innerR: pick54(innerRadius, outerRadius - thickness),
        open
      });
      if (isCircular) {
        angle = (end + start) / 2;
        xOnPerimeter = left + center[0] + center[2] / 2 * Math.cos(angle);
        path.xBounds = angle > -Math.PI / 2 && angle < Math.PI / 2 ? [xOnPerimeter, chart.plotWidth] : [0, xOnPerimeter];
        path.yBounds = [
          top + center[1] + center[2] / 2 * Math.sin(angle)
        ];
        path.yBounds[0] += angle > -Math.PI && angle < 0 || angle > Math.PI ? -10 : 10;
      }
    }
    return path;
  }
  function getPlotLinePath(options) {
    var _this = this;
    var center = this.pane.center, chart = this.chart, inverted = chart.inverted, reverse = options.reverse, background = this.pane.options.background ? this.pane.options.background[0] || this.pane.options.background : {}, innerRadius = background.innerRadius || "0%", outerRadius = background.outerRadius || "100%", x1 = center[0] + chart.plotLeft, y1 = center[1] + chart.plotTop, height = this.height, isCrosshair = options.isCrosshair, paneInnerR = center[3] / 2;
    var value = options.value, innerRatio, distance, a, b, otherAxis, xy, tickPositions, crossPos, path;
    var end = this.getPosition(value);
    var x2 = end.x, y2 = end.y;
    if (isCrosshair) {
      crossPos = this.getCrosshairPosition(options, x1, y1);
      value = crossPos[0];
      x2 = crossPos[1];
      y2 = crossPos[2];
    }
    if (this.isCircular) {
      distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
      a = typeof innerRadius === "string" ? relativeLength9(innerRadius, 1) : innerRadius / distance;
      b = typeof outerRadius === "string" ? relativeLength9(outerRadius, 1) : outerRadius / distance;
      if (center && paneInnerR) {
        innerRatio = paneInnerR / distance;
        if (a < innerRatio) {
          a = innerRatio;
        }
        if (b < innerRatio) {
          b = innerRatio;
        }
      }
      path = [
        ["M", x1 + a * (x2 - x1), y1 - a * (y1 - y2)],
        ["L", x2 - (1 - b) * (x2 - x1), y2 + (1 - b) * (y1 - y2)]
      ];
    } else {
      value = this.translate(value);
      if (value) {
        if (value < 0 || value > height) {
          value = 0;
        }
      }
      if (this.options.gridLineInterpolation === "circle") {
        path = this.getLinePath(0, value, paneInnerR);
      } else {
        path = [];
        chart[inverted ? "yAxis" : "xAxis"].forEach(function(a2) {
          if (a2.pane === _this.pane) {
            otherAxis = a2;
          }
        });
        if (otherAxis) {
          tickPositions = otherAxis.tickPositions;
          if (otherAxis.autoConnect) {
            tickPositions = tickPositions.concat([tickPositions[0]]);
          }
          if (reverse) {
            tickPositions = tickPositions.slice().reverse();
          }
          if (value) {
            value += paneInnerR;
          }
          for (var i = 0; i < tickPositions.length; i++) {
            xy = otherAxis.getPosition(tickPositions[i], value);
            path.push(i ? ["L", xy.x, xy.y] : ["M", xy.x, xy.y]);
          }
        }
      }
    }
    return path;
  }
  function getPosition(value, length) {
    var translatedVal = this.translate(value);
    return this.postTranslate(this.isCircular ? translatedVal : this.angleRad, pick54(this.isCircular ? length : translatedVal < 0 ? 0 : translatedVal, this.center[2] / 2) - this.offset);
  }
  function getTitlePosition() {
    var center = this.center, chart = this.chart, titleOptions = this.options.title;
    return {
      x: chart.plotLeft + center[0] + (titleOptions.x || 0),
      y: chart.plotTop + center[1] - {
        high: 0.5,
        middle: 0.25,
        low: 0
      }[titleOptions.align] * center[2] + (titleOptions.y || 0)
    };
  }
  function modify(axis) {
    axis.beforeSetTickPositions = beforeSetTickPositions;
    axis.createLabelCollector = createLabelCollector;
    axis.getCrosshairPosition = getCrosshairPosition;
    axis.getLinePath = getLinePath;
    axis.getOffset = getOffset;
    axis.getPlotBandPath = getPlotBandPath;
    axis.getPlotLinePath = getPlotLinePath;
    axis.getPosition = getPosition;
    axis.getTitlePosition = getTitlePosition;
    axis.postTranslate = postTranslate;
    axis.setAxisSize = setAxisSize;
    axis.setAxisTranslation = setAxisTranslation;
    axis.setOptions = setOptions3;
  }
  function modifyAsHidden(radialAxis) {
    radialAxis.isHidden = true;
    radialAxis.createLabelCollector = createLabelCollectorHidden;
    radialAxis.getOffset = noop10;
    radialAxis.redraw = renderHidden;
    radialAxis.render = renderHidden;
    radialAxis.setScale = noop10;
    radialAxis.setCategories = noop10;
    radialAxis.setTitle = noop10;
  }
  function onAxisAfterInit() {
    var chart = this.chart, options = this.options, isHidden = chart.angular && this.isXAxis, pane = this.pane, paneOptions = pane && pane.options;
    if (!isHidden && pane && (chart.angular || chart.polar)) {
      this.angleRad = (options.angle || 0) * Math.PI / 180;
      this.startAngleRad = (paneOptions.startAngle - 90) * Math.PI / 180;
      this.endAngleRad = (pick54(paneOptions.endAngle, paneOptions.startAngle + 360) - 90) * Math.PI / 180;
      this.offset = options.offset || 0;
    }
  }
  function onAxisAutoLabelAlign(e2) {
    if (this.isRadial) {
      e2.align = void 0;
      e2.preventDefault();
    }
  }
  function onAxisDestroy() {
    if (this.chart && this.chart.labelCollectors) {
      var index = this.labelCollector ? this.chart.labelCollectors.indexOf(this.labelCollector) : -1;
      if (index >= 0) {
        this.chart.labelCollectors.splice(index, 1);
      }
    }
  }
  function onAxisInit(e2) {
    var chart = this.chart, inverted = chart.inverted, angular = chart.angular, polar = chart.polar, isX = this.isXAxis, coll = this.coll, isHidden = angular && isX, chartOptions = chart.options, paneIndex = e2.userOptions.pane || 0, pane = this.pane = chart.pane && chart.pane[paneIndex];
    var isCircular;
    if (coll === "colorAxis") {
      this.isRadial = false;
      return;
    }
    if (angular) {
      if (isHidden) {
        modifyAsHidden(this);
      } else {
        modify(this);
      }
      isCircular = !isX;
      if (isCircular) {
        this.defaultPolarOptions = defaultRadialGaugeOptions;
      }
    } else if (polar) {
      modify(this);
      isCircular = this.horiz;
      this.defaultPolarOptions = isCircular ? defaultCircularOptions : merge45(coll === "xAxis" ? AxisDefaults_default.defaultXAxisOptions : AxisDefaults_default.defaultYAxisOptions, defaultRadialOptions);
      if (inverted && coll === "yAxis") {
        this.defaultPolarOptions.stackLabels = AxisDefaults_default.defaultYAxisOptions.stackLabels;
        this.defaultPolarOptions.reversedStacks = true;
      }
    }
    if (angular || polar) {
      this.isRadial = true;
      chartOptions.chart.zoomType = null;
      if (!this.labelCollector) {
        this.labelCollector = this.createLabelCollector();
      }
      if (this.labelCollector) {
        chart.labelCollectors.push(this.labelCollector);
      }
    } else {
      this.isRadial = false;
    }
    if (pane && isCircular) {
      pane.axis = this;
    }
    this.isCircular = isCircular;
  }
  function onAxisInitialAxisTranslation() {
    if (this.isRadial) {
      this.beforeSetTickPositions();
    }
  }
  function onTickAfterGetLabelPosition(e2) {
    var label = this.label;
    if (!label) {
      return;
    }
    var axis = this.axis, labelBBox = label.getBBox(), labelOptions = axis.options.labels, angle = (axis.translate(this.pos) + axis.startAngleRad + Math.PI / 2) / Math.PI * 180 % 360, correctAngle = Math.round(angle), labelYPosCorrection = !defined38(labelOptions.y) ? -labelBBox.height * 0.3 : 0;
    var optionsY = labelOptions.y, ret, centerSlot = 20, align = labelOptions.align, labelDir = "end", reducedAngle1 = correctAngle < 0 ? correctAngle + 360 : correctAngle, reducedAngle2 = reducedAngle1, translateY = 0, translateX = 0;
    if (axis.isRadial) {
      ret = axis.getPosition(this.pos, axis.center[2] / 2 + relativeLength9(pick54(labelOptions.distance, -25), axis.center[2] / 2, -axis.center[2] / 2));
      if (labelOptions.rotation === "auto") {
        label.attr({
          rotation: angle
        });
      } else if (!defined38(optionsY)) {
        optionsY = axis.chart.renderer.fontMetrics(label.styles && label.styles.fontSize).b - labelBBox.height / 2;
      }
      if (!defined38(align)) {
        if (axis.isCircular) {
          if (labelBBox.width > axis.len * axis.tickInterval / (axis.max - axis.min)) {
            centerSlot = 0;
          }
          if (angle > centerSlot && angle < 180 - centerSlot) {
            align = "left";
          } else if (angle > 180 + centerSlot && angle < 360 - centerSlot) {
            align = "right";
          } else {
            align = "center";
          }
        } else {
          align = "center";
        }
        label.attr({
          align
        });
      }
      if (align === "auto" && axis.tickPositions.length === 2 && axis.isCircular) {
        if (reducedAngle1 > 90 && reducedAngle1 < 180) {
          reducedAngle1 = 180 - reducedAngle1;
        } else if (reducedAngle1 > 270 && reducedAngle1 <= 360) {
          reducedAngle1 = 540 - reducedAngle1;
        }
        if (reducedAngle2 > 180 && reducedAngle2 <= 360) {
          reducedAngle2 = 360 - reducedAngle2;
        }
        if (axis.pane.options.startAngle === correctAngle || axis.pane.options.startAngle === correctAngle + 360 || axis.pane.options.startAngle === correctAngle - 360) {
          labelDir = "start";
        }
        if (correctAngle >= -90 && correctAngle <= 90 || correctAngle >= -360 && correctAngle <= -270 || correctAngle >= 270 && correctAngle <= 360) {
          align = labelDir === "start" ? "right" : "left";
        } else {
          align = labelDir === "start" ? "left" : "right";
        }
        if (reducedAngle2 > 70 && reducedAngle2 < 110) {
          align = "center";
        }
        if (reducedAngle1 < 15 || reducedAngle1 >= 180 && reducedAngle1 < 195) {
          translateY = labelBBox.height * 0.3;
        } else if (reducedAngle1 >= 15 && reducedAngle1 <= 35) {
          translateY = labelDir === "start" ? 0 : labelBBox.height * 0.75;
        } else if (reducedAngle1 >= 195 && reducedAngle1 <= 215) {
          translateY = labelDir === "start" ? labelBBox.height * 0.75 : 0;
        } else if (reducedAngle1 > 35 && reducedAngle1 <= 90) {
          translateY = labelDir === "start" ? -labelBBox.height * 0.25 : labelBBox.height;
        } else if (reducedAngle1 > 215 && reducedAngle1 <= 270) {
          translateY = labelDir === "start" ? labelBBox.height : -labelBBox.height * 0.25;
        }
        if (reducedAngle2 < 15) {
          translateX = labelDir === "start" ? -labelBBox.height * 0.15 : labelBBox.height * 0.15;
        } else if (reducedAngle2 > 165 && reducedAngle2 <= 180) {
          translateX = labelDir === "start" ? labelBBox.height * 0.15 : -labelBBox.height * 0.15;
        }
        label.attr({ align });
        label.translate(translateX, translateY + labelYPosCorrection);
      }
      e2.pos.x = ret.x + (labelOptions.x || 0);
      e2.pos.y = ret.y + (optionsY || 0);
    }
  }
  function onTickAfterGetPosition(e2) {
    if (this.axis.getPosition) {
      extend46(e2.pos, this.axis.getPosition(this.pos));
    }
  }
  function postTranslate(angle, radius) {
    var chart = this.chart, center = this.center;
    angle = this.startAngleRad + angle;
    return {
      x: chart.plotLeft + center[0] + Math.cos(angle) * radius,
      y: chart.plotTop + center[1] + Math.sin(angle) * radius
    };
  }
  function renderHidden() {
    this.isDirty = false;
  }
  function setAxisSize() {
    var axisProto = this.constructor.prototype;
    var center, start;
    axisProto.setAxisSize.call(this);
    if (this.isRadial) {
      this.pane.updateCenter(this);
      center = this.center = this.pane.center.slice();
      if (this.isCircular) {
        this.sector = this.endAngleRad - this.startAngleRad;
      } else {
        start = this.postTranslate(this.angleRad, center[3] / 2);
        center[0] = start.x - this.chart.plotLeft;
        center[1] = start.y - this.chart.plotTop;
      }
      this.len = this.width = this.height = (center[2] - center[3]) * pick54(this.sector, 1) / 2;
    }
  }
  function setAxisTranslation() {
    var axisProto = this.constructor.prototype;
    axisProto.setAxisTranslation.call(this);
    if (this.center) {
      if (this.isCircular) {
        this.transA = (this.endAngleRad - this.startAngleRad) / (this.max - this.min || 1);
      } else {
        this.transA = (this.center[2] - this.center[3]) / 2 / (this.max - this.min || 1);
      }
      if (this.isXAxis) {
        this.minPixelPadding = this.transA * this.minPointOffset;
      } else {
        this.minPixelPadding = 0;
      }
    }
  }
  function setOptions3(userOptions) {
    var options = this.options = merge45(this.constructor.defaultOptions, this.defaultPolarOptions, defaultOptions13[this.coll], userOptions);
    if (!options.plotBands) {
      options.plotBands = [];
    }
    fireEvent26(this, "afterSetOptions");
  }
  function wrapTickGetMarkPath(proceed, x, y, tickLength, tickWidth, horiz, renderer) {
    var axis = this.axis;
    var endPoint, ret;
    if (axis.isRadial) {
      endPoint = axis.getPosition(this.pos, axis.center[2] / 2 + tickLength);
      ret = [
        "M",
        x,
        y,
        "L",
        endPoint.x,
        endPoint.y
      ];
    } else {
      ret = proceed.call(this, x, y, tickLength, tickWidth, horiz, renderer);
    }
    return ret;
  }
})(RadialAxis || (RadialAxis = {}));
var RadialAxis_default = RadialAxis;

// node_modules/highcharts/es-modules/Series/AreaRange/AreaRangePoint.js
var __extends20 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var pointProto = Point_default.prototype;
var defined39 = Utilities_default.defined;
var isNumber34 = Utilities_default.isNumber;
var AreaRangePoint = function(_super) {
  __extends20(AreaRangePoint3, _super);
  function AreaRangePoint3() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.high = void 0;
    _this.low = void 0;
    _this.options = void 0;
    _this.plotHigh = void 0;
    _this.plotLow = void 0;
    _this.plotHighX = void 0;
    _this.plotLowX = void 0;
    _this.plotX = void 0;
    _this.series = void 0;
    return _this;
  }
  AreaRangePoint3.prototype.setState = function() {
    var prevState = this.state, series = this.series, isPolar = series.chart.polar;
    if (!defined39(this.plotHigh)) {
      this.plotHigh = series.yAxis.toPixels(this.high, true);
    }
    if (!defined39(this.plotLow)) {
      this.plotLow = this.plotY = series.yAxis.toPixels(this.low, true);
    }
    if (series.stateMarkerGraphic) {
      series.lowerStateMarkerGraphic = series.stateMarkerGraphic;
      series.stateMarkerGraphic = series.upperStateMarkerGraphic;
    }
    this.graphic = this.upperGraphic;
    this.plotY = this.plotHigh;
    if (isPolar) {
      this.plotX = this.plotHighX;
    }
    pointProto.setState.apply(this, arguments);
    this.state = prevState;
    this.plotY = this.plotLow;
    this.graphic = this.lowerGraphic;
    if (isPolar) {
      this.plotX = this.plotLowX;
    }
    if (series.stateMarkerGraphic) {
      series.upperStateMarkerGraphic = series.stateMarkerGraphic;
      series.stateMarkerGraphic = series.lowerStateMarkerGraphic;
      series.lowerStateMarkerGraphic = void 0;
    }
    pointProto.setState.apply(this, arguments);
  };
  AreaRangePoint3.prototype.haloPath = function() {
    var isPolar = this.series.chart.polar, path = [];
    this.plotY = this.plotLow;
    if (isPolar) {
      this.plotX = this.plotLowX;
    }
    if (this.isInside) {
      path = pointProto.haloPath.apply(this, arguments);
    }
    this.plotY = this.plotHigh;
    if (isPolar) {
      this.plotX = this.plotHighX;
    }
    if (this.isTopInside) {
      path = path.concat(pointProto.haloPath.apply(this, arguments));
    }
    return path;
  };
  AreaRangePoint3.prototype.isValid = function() {
    return isNumber34(this.low) && isNumber34(this.high);
  };
  return AreaRangePoint3;
}(AreaSeries_default.prototype.pointClass);
var AreaRangePoint_default = AreaRangePoint;

// node_modules/highcharts/es-modules/Series/AreaRange/AreaRangeSeries.js
var __extends21 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var areaProto2 = AreaSeries_default.prototype;
var columnProto2 = ColumnSeries_default.prototype;
var noop11 = Globals_default.noop;
var seriesProto3 = Series_default.prototype;
var defined40 = Utilities_default.defined;
var extend47 = Utilities_default.extend;
var isArray17 = Utilities_default.isArray;
var pick55 = Utilities_default.pick;
var merge46 = Utilities_default.merge;
var AreaRangeSeries = function(_super) {
  __extends21(AreaRangeSeries4, _super);
  function AreaRangeSeries4() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.data = void 0;
    _this.options = void 0;
    _this.points = void 0;
    _this.lowerStateMarkerGraphic = void 0;
    _this.xAxis = void 0;
    return _this;
  }
  AreaRangeSeries4.prototype.toYData = function(point) {
    return [point.low, point.high];
  };
  AreaRangeSeries4.prototype.highToXY = function(point) {
    var chart = this.chart, xy = this.xAxis.postTranslate(point.rectPlotX || 0, this.yAxis.len - point.plotHigh);
    point.plotHighX = xy.x - chart.plotLeft;
    point.plotHigh = xy.y - chart.plotTop;
    point.plotLowX = point.plotX;
  };
  AreaRangeSeries4.prototype.translate = function() {
    var series = this, yAxis = series.yAxis, hasModifyValue = !!series.modifyValue;
    areaProto2.translate.apply(series);
    series.points.forEach(function(point) {
      var high = point.high, plotY = point.plotY;
      if (point.isNull) {
        point.plotY = null;
      } else {
        point.plotLow = plotY;
        point.plotHigh = yAxis.translate(hasModifyValue ? series.modifyValue(high, point) : high, 0, 1, 0, 1);
        if (hasModifyValue) {
          point.yBottom = point.plotHigh;
        }
      }
    });
    if (this.chart.polar) {
      this.points.forEach(function(point) {
        series.highToXY(point);
        point.tooltipPos = [
          (point.plotHighX + point.plotLowX) / 2,
          (point.plotHigh + point.plotLow) / 2
        ];
      });
    }
  };
  AreaRangeSeries4.prototype.getGraphPath = function(points) {
    var highPoints = [], highAreaPoints = [], i, getGraphPath = areaProto2.getGraphPath, point, pointShim, linePath, lowerPath, options = this.options, polar = this.chart.polar, connectEnds = polar && options.connectEnds !== false, connectNulls = options.connectNulls, step = options.step, higherPath, higherAreaPath;
    points = points || this.points;
    i = points.length;
    while (i--) {
      point = points[i];
      var highAreaPoint = polar ? {
        plotX: point.rectPlotX,
        plotY: point.yBottom,
        doCurve: false
      } : {
        plotX: point.plotX,
        plotY: point.plotY,
        doCurve: false
      };
      if (!point.isNull && !connectEnds && !connectNulls && (!points[i + 1] || points[i + 1].isNull)) {
        highAreaPoints.push(highAreaPoint);
      }
      pointShim = {
        polarPlotY: point.polarPlotY,
        rectPlotX: point.rectPlotX,
        yBottom: point.yBottom,
        plotX: pick55(point.plotHighX, point.plotX),
        plotY: point.plotHigh,
        isNull: point.isNull
      };
      highAreaPoints.push(pointShim);
      highPoints.push(pointShim);
      if (!point.isNull && !connectEnds && !connectNulls && (!points[i - 1] || points[i - 1].isNull)) {
        highAreaPoints.push(highAreaPoint);
      }
    }
    lowerPath = getGraphPath.call(this, points);
    if (step) {
      if (step === true) {
        step = "left";
      }
      options.step = {
        left: "right",
        center: "center",
        right: "left"
      }[step];
    }
    higherPath = getGraphPath.call(this, highPoints);
    higherAreaPath = getGraphPath.call(this, highAreaPoints);
    options.step = step;
    linePath = [].concat(lowerPath, higherPath);
    if (!this.chart.polar && higherAreaPath[0] && higherAreaPath[0][0] === "M") {
      higherAreaPath[0] = ["L", higherAreaPath[0][1], higherAreaPath[0][2]];
    }
    this.graphPath = linePath;
    this.areaPath = lowerPath.concat(higherAreaPath);
    linePath.isArea = true;
    linePath.xMap = lowerPath.xMap;
    this.areaPath.xMap = lowerPath.xMap;
    return linePath;
  };
  AreaRangeSeries4.prototype.drawDataLabels = function() {
    var data = this.points, length = data.length, i, originalDataLabels = [], dataLabelOptions = this.options.dataLabels, point, up, inverted = this.chart.inverted, upperDataLabelOptions, lowerDataLabelOptions;
    if (dataLabelOptions) {
      if (isArray17(dataLabelOptions)) {
        upperDataLabelOptions = dataLabelOptions[0] || { enabled: false };
        lowerDataLabelOptions = dataLabelOptions[1] || { enabled: false };
      } else {
        upperDataLabelOptions = extend47({}, dataLabelOptions);
        upperDataLabelOptions.x = dataLabelOptions.xHigh;
        upperDataLabelOptions.y = dataLabelOptions.yHigh;
        lowerDataLabelOptions = extend47({}, dataLabelOptions);
        lowerDataLabelOptions.x = dataLabelOptions.xLow;
        lowerDataLabelOptions.y = dataLabelOptions.yLow;
      }
      if (upperDataLabelOptions.enabled || this._hasPointLabels) {
        i = length;
        while (i--) {
          point = data[i];
          if (point) {
            up = upperDataLabelOptions.inside ? point.plotHigh < point.plotLow : point.plotHigh > point.plotLow;
            point.y = point.high;
            point._plotY = point.plotY;
            point.plotY = point.plotHigh;
            originalDataLabels[i] = point.dataLabel;
            point.dataLabel = point.dataLabelUpper;
            point.below = up;
            if (inverted) {
              if (!upperDataLabelOptions.align) {
                upperDataLabelOptions.align = up ? "right" : "left";
              }
            } else {
              if (!upperDataLabelOptions.verticalAlign) {
                upperDataLabelOptions.verticalAlign = up ? "top" : "bottom";
              }
            }
          }
        }
        this.options.dataLabels = upperDataLabelOptions;
        if (seriesProto3.drawDataLabels) {
          seriesProto3.drawDataLabels.apply(this, arguments);
        }
        i = length;
        while (i--) {
          point = data[i];
          if (point) {
            point.dataLabelUpper = point.dataLabel;
            point.dataLabel = originalDataLabels[i];
            delete point.dataLabels;
            point.y = point.low;
            point.plotY = point._plotY;
          }
        }
      }
      if (lowerDataLabelOptions.enabled || this._hasPointLabels) {
        i = length;
        while (i--) {
          point = data[i];
          if (point) {
            up = lowerDataLabelOptions.inside ? point.plotHigh < point.plotLow : point.plotHigh > point.plotLow;
            point.below = !up;
            if (inverted) {
              if (!lowerDataLabelOptions.align) {
                lowerDataLabelOptions.align = up ? "left" : "right";
              }
            } else {
              if (!lowerDataLabelOptions.verticalAlign) {
                lowerDataLabelOptions.verticalAlign = up ? "bottom" : "top";
              }
            }
          }
        }
        this.options.dataLabels = lowerDataLabelOptions;
        if (seriesProto3.drawDataLabels) {
          seriesProto3.drawDataLabels.apply(this, arguments);
        }
      }
      if (upperDataLabelOptions.enabled) {
        i = length;
        while (i--) {
          point = data[i];
          if (point) {
            point.dataLabels = [
              point.dataLabelUpper,
              point.dataLabel
            ].filter(function(label) {
              return !!label;
            });
          }
        }
      }
      this.options.dataLabels = dataLabelOptions;
    }
  };
  AreaRangeSeries4.prototype.alignDataLabel = function() {
    columnProto2.alignDataLabel.apply(this, arguments);
  };
  AreaRangeSeries4.prototype.drawPoints = function() {
    var series = this, pointLength = series.points.length, point, i;
    seriesProto3.drawPoints.apply(series, arguments);
    i = 0;
    while (i < pointLength) {
      point = series.points[i];
      point.origProps = {
        plotY: point.plotY,
        plotX: point.plotX,
        isInside: point.isInside,
        negative: point.negative,
        zone: point.zone,
        y: point.y
      };
      point.lowerGraphic = point.graphic;
      point.graphic = point.upperGraphic;
      point.plotY = point.plotHigh;
      if (defined40(point.plotHighX)) {
        point.plotX = point.plotHighX;
      }
      point.y = pick55(point.high, point.origProps.y);
      point.negative = point.y < (series.options.threshold || 0);
      if (series.zones.length) {
        point.zone = point.getZone();
      }
      if (!series.chart.polar) {
        point.isInside = point.isTopInside = typeof point.plotY !== "undefined" && point.plotY >= 0 && point.plotY <= series.yAxis.len && point.plotX >= 0 && point.plotX <= series.xAxis.len;
      }
      i++;
    }
    seriesProto3.drawPoints.apply(series, arguments);
    i = 0;
    while (i < pointLength) {
      point = series.points[i];
      point.upperGraphic = point.graphic;
      point.graphic = point.lowerGraphic;
      if (point.origProps) {
        extend47(point, point.origProps);
        delete point.origProps;
      }
      i++;
    }
  };
  AreaRangeSeries4.defaultOptions = merge46(AreaSeries_default.defaultOptions, {
    lineWidth: 1,
    threshold: null,
    tooltip: {
      pointFormat: '<span style="color:{series.color}">\u25CF</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'
    },
    trackByArea: true,
    dataLabels: {
      align: void 0,
      verticalAlign: void 0,
      xLow: 0,
      xHigh: 0,
      yLow: 0,
      yHigh: 0
    }
  });
  return AreaRangeSeries4;
}(AreaSeries_default);
extend47(AreaRangeSeries.prototype, {
  pointArrayMap: ["low", "high"],
  pointValKey: "low",
  deferTranslatePolar: true,
  pointClass: AreaRangePoint_default,
  setStackedPoints: noop11
});
SeriesRegistry_default.registerSeriesType("arearange", AreaRangeSeries);
var AreaRangeSeries_default = AreaRangeSeries;

// node_modules/highcharts/es-modules/Series/AreaSplineRange/AreaSplineRangeSeries.js
var __extends22 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var SplineSeries2 = SeriesRegistry_default.seriesTypes.spline;
var merge47 = Utilities_default.merge;
var extend48 = Utilities_default.extend;
var AreaSplineRangeSeries = function(_super) {
  __extends22(AreaSplineRangeSeries2, _super);
  function AreaSplineRangeSeries2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.options = void 0;
    _this.data = void 0;
    _this.points = void 0;
    return _this;
  }
  AreaSplineRangeSeries2.defaultOptions = merge47(AreaRangeSeries_default.defaultOptions);
  return AreaSplineRangeSeries2;
}(AreaRangeSeries_default);
extend48(AreaSplineRangeSeries.prototype, {
  getPointSpline: SplineSeries2.prototype.getPointSpline
});
SeriesRegistry_default.registerSeriesType("areasplinerange", AreaSplineRangeSeries);

// node_modules/highcharts/es-modules/Series/BoxPlot/BoxPlotSeries.js
var __extends23 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var noop12 = Globals_default.noop;
var extend49 = Utilities_default.extend;
var merge48 = Utilities_default.merge;
var pick56 = Utilities_default.pick;
var BoxPlotSeries = function(_super) {
  __extends23(BoxPlotSeries2, _super);
  function BoxPlotSeries2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.data = void 0;
    _this.options = void 0;
    _this.points = void 0;
    return _this;
  }
  BoxPlotSeries2.prototype.pointAttribs = function() {
    return {};
  };
  BoxPlotSeries2.prototype.translate = function() {
    var series = this, yAxis = series.yAxis, pointArrayMap = series.pointArrayMap;
    _super.prototype.translate.apply(series);
    series.points.forEach(function(point) {
      pointArrayMap.forEach(function(key) {
        if (point[key] !== null) {
          point[key + "Plot"] = yAxis.translate(point[key], 0, 1, 0, 1);
        }
      });
      point.plotHigh = point.highPlot;
    });
  };
  BoxPlotSeries2.prototype.drawPoints = function() {
    var series = this, points = series.points, options = series.options, chart = series.chart, renderer = chart.renderer, q1Plot, q3Plot, highPlot, lowPlot, medianPlot, medianPath, crispCorr, crispX = 0, boxPath, width, left, right, halfWidth, doQuartiles = series.doQuartiles !== false, pointWiskerLength, whiskerLength = series.options.whiskerLength;
    points.forEach(function(point) {
      var graphic = point.graphic, verb = graphic ? "animate" : "attr", shapeArgs = point.shapeArgs, boxAttr = {}, stemAttr = {}, whiskersAttr = {}, medianAttr = {}, color18 = point.color || series.color;
      if (typeof point.plotY !== "undefined") {
        width = Math.round(shapeArgs.width);
        left = Math.floor(shapeArgs.x);
        right = left + width;
        halfWidth = Math.round(width / 2);
        q1Plot = Math.floor(doQuartiles ? point.q1Plot : point.lowPlot);
        q3Plot = Math.floor(doQuartiles ? point.q3Plot : point.lowPlot);
        highPlot = Math.floor(point.highPlot);
        lowPlot = Math.floor(point.lowPlot);
        if (!graphic) {
          point.graphic = graphic = renderer.g("point").add(series.group);
          point.stem = renderer.path().addClass("highcharts-boxplot-stem").add(graphic);
          if (whiskerLength) {
            point.whiskers = renderer.path().addClass("highcharts-boxplot-whisker").add(graphic);
          }
          if (doQuartiles) {
            point.box = renderer.path(boxPath).addClass("highcharts-boxplot-box").add(graphic);
          }
          point.medianShape = renderer.path(medianPath).addClass("highcharts-boxplot-median").add(graphic);
        }
        if (!chart.styledMode) {
          stemAttr.stroke = point.stemColor || options.stemColor || color18;
          stemAttr["stroke-width"] = pick56(point.stemWidth, options.stemWidth, options.lineWidth);
          stemAttr.dashstyle = point.stemDashStyle || options.stemDashStyle || options.dashStyle;
          point.stem.attr(stemAttr);
          if (whiskerLength) {
            whiskersAttr.stroke = point.whiskerColor || options.whiskerColor || color18;
            whiskersAttr["stroke-width"] = pick56(point.whiskerWidth, options.whiskerWidth, options.lineWidth);
            whiskersAttr.dashstyle = point.whiskerDashStyle || options.whiskerDashStyle || options.dashStyle;
            point.whiskers.attr(whiskersAttr);
          }
          if (doQuartiles) {
            boxAttr.fill = point.fillColor || options.fillColor || color18;
            boxAttr.stroke = options.lineColor || color18;
            boxAttr["stroke-width"] = options.lineWidth || 0;
            boxAttr.dashstyle = point.boxDashStyle || options.boxDashStyle || options.dashStyle;
            point.box.attr(boxAttr);
          }
          medianAttr.stroke = point.medianColor || options.medianColor || color18;
          medianAttr["stroke-width"] = pick56(point.medianWidth, options.medianWidth, options.lineWidth);
          medianAttr.dashstyle = point.medianDashStyle || options.medianDashStyle || options.dashStyle;
          point.medianShape.attr(medianAttr);
        }
        var d = void 0;
        crispCorr = point.stem.strokeWidth() % 2 / 2;
        crispX = left + halfWidth + crispCorr;
        d = [
          ["M", crispX, q3Plot],
          ["L", crispX, highPlot],
          ["M", crispX, q1Plot],
          ["L", crispX, lowPlot]
        ];
        point.stem[verb]({ d });
        if (doQuartiles) {
          crispCorr = point.box.strokeWidth() % 2 / 2;
          q1Plot = Math.floor(q1Plot) + crispCorr;
          q3Plot = Math.floor(q3Plot) + crispCorr;
          left += crispCorr;
          right += crispCorr;
          d = [
            ["M", left, q3Plot],
            ["L", left, q1Plot],
            ["L", right, q1Plot],
            ["L", right, q3Plot],
            ["L", left, q3Plot],
            ["Z"]
          ];
          point.box[verb]({ d });
        }
        if (whiskerLength) {
          crispCorr = point.whiskers.strokeWidth() % 2 / 2;
          highPlot = highPlot + crispCorr;
          lowPlot = lowPlot + crispCorr;
          pointWiskerLength = /%$/.test(whiskerLength) ? halfWidth * parseFloat(whiskerLength) / 100 : whiskerLength / 2;
          d = [
            ["M", crispX - pointWiskerLength, highPlot],
            ["L", crispX + pointWiskerLength, highPlot],
            ["M", crispX - pointWiskerLength, lowPlot],
            ["L", crispX + pointWiskerLength, lowPlot]
          ];
          point.whiskers[verb]({ d });
        }
        medianPlot = Math.round(point.medianPlot);
        crispCorr = point.medianShape.strokeWidth() % 2 / 2;
        medianPlot = medianPlot + crispCorr;
        d = [
          ["M", left, medianPlot],
          ["L", right, medianPlot]
        ];
        point.medianShape[verb]({ d });
      }
    });
  };
  BoxPlotSeries2.prototype.toYData = function(point) {
    return [point.low, point.q1, point.median, point.q3, point.high];
  };
  BoxPlotSeries2.defaultOptions = merge48(ColumnSeries_default.defaultOptions, {
    threshold: null,
    tooltip: {
      pointFormat: '<span style="color:{point.color}">\u25CF</span> <b> {series.name}</b><br/>Maximum: {point.high}<br/>Upper quartile: {point.q3}<br/>Median: {point.median}<br/>Lower quartile: {point.q1}<br/>Minimum: {point.low}<br/>'
    },
    whiskerLength: "50%",
    fillColor: Palette_default.backgroundColor,
    lineWidth: 1,
    medianWidth: 2,
    whiskerWidth: 2
  });
  return BoxPlotSeries2;
}(ColumnSeries_default);
extend49(BoxPlotSeries.prototype, {
  pointArrayMap: ["low", "q1", "median", "q3", "high"],
  pointValKey: "high",
  drawDataLabels: noop12,
  setStackedPoints: noop12
});
SeriesRegistry_default.registerSeriesType("boxplot", BoxPlotSeries);
var BoxPlotSeries_default = BoxPlotSeries;

// node_modules/highcharts/es-modules/Series/Bubble/BubbleLegendDefaults.js
var BubbleLegendDefaults = {
  borderColor: void 0,
  borderWidth: 2,
  className: void 0,
  color: void 0,
  connectorClassName: void 0,
  connectorColor: void 0,
  connectorDistance: 60,
  connectorWidth: 1,
  enabled: false,
  labels: {
    className: void 0,
    allowOverlap: false,
    format: "",
    formatter: void 0,
    align: "right",
    style: {
      fontSize: "10px",
      color: Palette_default.neutralColor100
    },
    x: 0,
    y: 0
  },
  maxSize: 60,
  minSize: 10,
  legendIndex: 0,
  ranges: {
    value: void 0,
    borderColor: void 0,
    color: void 0,
    connectorColor: void 0
  },
  sizeBy: "area",
  sizeByAbsoluteValue: false,
  zIndex: 1,
  zThreshold: 0
};
var BubbleLegendDefaults_default = BubbleLegendDefaults;

// node_modules/highcharts/es-modules/Series/Bubble/BubbleLegendItem.js
var color7 = Color_default.parse;
var noop13 = Globals_default.noop;
var arrayMax8 = Utilities_default.arrayMax;
var arrayMin7 = Utilities_default.arrayMin;
var isNumber35 = Utilities_default.isNumber;
var merge49 = Utilities_default.merge;
var pick57 = Utilities_default.pick;
var stableSort5 = Utilities_default.stableSort;
var BubbleLegendItem = function() {
  function BubbleLegendItem2(options, legend) {
    this.chart = void 0;
    this.fontMetrics = void 0;
    this.legend = void 0;
    this.legendGroup = void 0;
    this.legendItem = void 0;
    this.legendItemHeight = void 0;
    this.legendItemWidth = void 0;
    this.legendSymbol = void 0;
    this.maxLabel = void 0;
    this.movementX = void 0;
    this.ranges = void 0;
    this.selected = void 0;
    this.visible = void 0;
    this.symbols = void 0;
    this.options = void 0;
    this.setState = noop13;
    this.init(options, legend);
  }
  BubbleLegendItem2.prototype.init = function(options, legend) {
    this.options = options;
    this.visible = true;
    this.chart = legend.chart;
    this.legend = legend;
  };
  BubbleLegendItem2.prototype.addToLegend = function(items) {
    items.splice(this.options.legendIndex, 0, this);
  };
  BubbleLegendItem2.prototype.drawLegendSymbol = function(legend) {
    var chart = this.chart, options = this.options, itemDistance = pick57(legend.options.itemDistance, 20), ranges = options.ranges, connectorDistance = options.connectorDistance;
    var connectorSpace;
    this.fontMetrics = chart.renderer.fontMetrics(options.labels.style.fontSize);
    if (!ranges || !ranges.length || !isNumber35(ranges[0].value)) {
      legend.options.bubbleLegend.autoRanges = true;
      return;
    }
    stableSort5(ranges, function(a, b) {
      return b.value - a.value;
    });
    this.ranges = ranges;
    this.setOptions();
    this.render();
    var maxLabel = this.getMaxLabelSize(), radius = this.ranges[0].radius, size = radius * 2;
    connectorSpace = connectorDistance - radius + maxLabel.width;
    connectorSpace = connectorSpace > 0 ? connectorSpace : 0;
    this.maxLabel = maxLabel;
    this.movementX = options.labels.align === "left" ? connectorSpace : 0;
    this.legendItemWidth = size + connectorSpace + itemDistance;
    this.legendItemHeight = size + this.fontMetrics.h / 2;
  };
  BubbleLegendItem2.prototype.setOptions = function() {
    var ranges = this.ranges, options = this.options, series = this.chart.series[options.seriesIndex], baseline = this.legend.baseline, bubbleAttribs = {
      zIndex: options.zIndex,
      "stroke-width": options.borderWidth
    }, connectorAttribs = {
      zIndex: options.zIndex,
      "stroke-width": options.connectorWidth
    }, labelAttribs = {
      align: this.legend.options.rtl || options.labels.align === "left" ? "right" : "left",
      zIndex: options.zIndex
    }, fillOpacity = series.options.marker.fillOpacity, styledMode = this.chart.styledMode;
    ranges.forEach(function(range, i) {
      if (!styledMode) {
        bubbleAttribs.stroke = pick57(range.borderColor, options.borderColor, series.color);
        bubbleAttribs.fill = pick57(range.color, options.color, fillOpacity !== 1 ? color7(series.color).setOpacity(fillOpacity).get("rgba") : series.color);
        connectorAttribs.stroke = pick57(range.connectorColor, options.connectorColor, series.color);
      }
      ranges[i].radius = this.getRangeRadius(range.value);
      ranges[i] = merge49(ranges[i], {
        center: ranges[0].radius - ranges[i].radius + baseline
      });
      if (!styledMode) {
        merge49(true, ranges[i], {
          bubbleAttribs: merge49(bubbleAttribs),
          connectorAttribs: merge49(connectorAttribs),
          labelAttribs
        });
      }
    }, this);
  };
  BubbleLegendItem2.prototype.getRangeRadius = function(value) {
    var options = this.options, seriesIndex = this.options.seriesIndex, bubbleSeries = this.chart.series[seriesIndex], zMax = options.ranges[0].value, zMin = options.ranges[options.ranges.length - 1].value, minSize = options.minSize, maxSize = options.maxSize;
    return bubbleSeries.getRadius.call(this, zMin, zMax, minSize, maxSize, value);
  };
  BubbleLegendItem2.prototype.render = function() {
    var renderer = this.chart.renderer, zThreshold = this.options.zThreshold;
    if (!this.symbols) {
      this.symbols = {
        connectors: [],
        bubbleItems: [],
        labels: []
      };
    }
    this.legendSymbol = renderer.g("bubble-legend");
    this.legendItem = renderer.g("bubble-legend-item");
    this.legendSymbol.translateX = 0;
    this.legendSymbol.translateY = 0;
    this.ranges.forEach(function(range) {
      if (range.value >= zThreshold) {
        this.renderRange(range);
      }
    }, this);
    this.legendSymbol.add(this.legendItem);
    this.legendItem.add(this.legendGroup);
    this.hideOverlappingLabels();
  };
  BubbleLegendItem2.prototype.renderRange = function(range) {
    var mainRange = this.ranges[0], legend = this.legend, options = this.options, labelsOptions = options.labels, chart = this.chart, bubbleSeries = chart.series[options.seriesIndex], renderer = chart.renderer, symbols4 = this.symbols, labels = symbols4.labels, elementCenter = range.center, absoluteRadius = Math.abs(range.radius), connectorDistance = options.connectorDistance || 0, labelsAlign = labelsOptions.align, rtl = legend.options.rtl, borderWidth = options.borderWidth, connectorWidth = options.connectorWidth, posX = mainRange.radius || 0, posY = elementCenter - absoluteRadius - borderWidth / 2 + connectorWidth / 2, fontMetrics = this.fontMetrics, labelMovement = fontMetrics.f / 2 - (fontMetrics.h - fontMetrics.f) / 2, crispMovement = (posY % 1 ? 1 : 0.5) - (connectorWidth % 2 ? 0 : 0.5), styledMode = renderer.styledMode;
    var connectorLength = rtl || labelsAlign === "left" ? -connectorDistance : connectorDistance;
    if (labelsAlign === "center") {
      connectorLength = 0;
      options.connectorDistance = 0;
      range.labelAttribs.align = "center";
    }
    var labelY = posY + options.labels.y, labelX = posX + connectorLength + options.labels.x;
    symbols4.bubbleItems.push(renderer.circle(posX, elementCenter + crispMovement, absoluteRadius).attr(styledMode ? {} : range.bubbleAttribs).addClass((styledMode ? "highcharts-color-" + bubbleSeries.colorIndex + " " : "") + "highcharts-bubble-legend-symbol " + (options.className || "")).add(this.legendSymbol));
    symbols4.connectors.push(renderer.path(renderer.crispLine([
      ["M", posX, posY],
      ["L", posX + connectorLength, posY]
    ], options.connectorWidth)).attr(styledMode ? {} : range.connectorAttribs).addClass((styledMode ? "highcharts-color-" + this.options.seriesIndex + " " : "") + "highcharts-bubble-legend-connectors " + (options.connectorClassName || "")).add(this.legendSymbol));
    var label = renderer.text(this.formatLabel(range), labelX, labelY + labelMovement).attr(styledMode ? {} : range.labelAttribs).css(styledMode ? {} : labelsOptions.style).addClass("highcharts-bubble-legend-labels " + (options.labels.className || "")).add(this.legendSymbol);
    labels.push(label);
    label.placed = true;
    label.alignAttr = {
      x: labelX,
      y: labelY + labelMovement
    };
  };
  BubbleLegendItem2.prototype.getMaxLabelSize = function() {
    var labels = this.symbols.labels;
    var maxLabel, labelSize;
    labels.forEach(function(label) {
      labelSize = label.getBBox(true);
      if (maxLabel) {
        maxLabel = labelSize.width > maxLabel.width ? labelSize : maxLabel;
      } else {
        maxLabel = labelSize;
      }
    });
    return maxLabel || {};
  };
  BubbleLegendItem2.prototype.formatLabel = function(range) {
    var options = this.options, formatter = options.labels.formatter, format13 = options.labels.format;
    var numberFormatter = this.chart.numberFormatter;
    return format13 ? FormatUtilities_default.format(format13, range) : formatter ? formatter.call(range) : numberFormatter(range.value, 1);
  };
  BubbleLegendItem2.prototype.hideOverlappingLabels = function() {
    var chart = this.chart, allowOverlap = this.options.labels.allowOverlap, symbols4 = this.symbols;
    if (!allowOverlap && symbols4) {
      chart.hideOverlappingLabels(symbols4.labels);
      symbols4.labels.forEach(function(label, index) {
        if (!label.newOpacity) {
          symbols4.connectors[index].hide();
        } else if (label.newOpacity !== label.oldOpacity) {
          symbols4.connectors[index].show();
        }
      });
    }
  };
  BubbleLegendItem2.prototype.getRanges = function() {
    var bubbleLegend = this.legend.bubbleLegend, series = bubbleLegend.chart.series, rangesOptions = bubbleLegend.options.ranges;
    var ranges, zData, minZ = Number.MAX_VALUE, maxZ = -Number.MAX_VALUE;
    series.forEach(function(s) {
      if (s.isBubble && !s.ignoreSeries) {
        zData = s.zData.filter(isNumber35);
        if (zData.length) {
          minZ = pick57(s.options.zMin, Math.min(minZ, Math.max(arrayMin7(zData), s.options.displayNegative === false ? s.options.zThreshold : -Number.MAX_VALUE)));
          maxZ = pick57(s.options.zMax, Math.max(maxZ, arrayMax8(zData)));
        }
      }
    });
    if (minZ === maxZ) {
      ranges = [{ value: maxZ }];
    } else {
      ranges = [
        { value: minZ },
        { value: (minZ + maxZ) / 2 },
        { value: maxZ, autoRanges: true }
      ];
    }
    if (rangesOptions.length && rangesOptions[0].radius) {
      ranges.reverse();
    }
    ranges.forEach(function(range, i) {
      if (rangesOptions && rangesOptions[i]) {
        ranges[i] = merge49(rangesOptions[i], range);
      }
    });
    return ranges;
  };
  BubbleLegendItem2.prototype.predictBubbleSizes = function() {
    var chart = this.chart, fontMetrics = this.fontMetrics, legendOptions = chart.legend.options, floating = legendOptions.floating, horizontal = legendOptions.layout === "horizontal", lastLineHeight = horizontal ? chart.legend.lastLineHeight : 0, plotSizeX = chart.plotSizeX, plotSizeY = chart.plotSizeY, bubbleSeries = chart.series[this.options.seriesIndex], minSize = Math.ceil(bubbleSeries.minPxSize), maxPxSize = Math.ceil(bubbleSeries.maxPxSize), plotSize = Math.min(plotSizeY, plotSizeX);
    var calculatedSize, maxSize = bubbleSeries.options.maxSize;
    if (floating || !/%$/.test(maxSize)) {
      calculatedSize = maxPxSize;
    } else {
      maxSize = parseFloat(maxSize);
      calculatedSize = (plotSize + lastLineHeight - fontMetrics.h / 2) * maxSize / 100 / (maxSize / 100 + 1);
      if (horizontal && plotSizeY - calculatedSize >= plotSizeX || !horizontal && plotSizeX - calculatedSize >= plotSizeY) {
        calculatedSize = maxPxSize;
      }
    }
    return [minSize, Math.ceil(calculatedSize)];
  };
  BubbleLegendItem2.prototype.updateRanges = function(min, max) {
    var bubbleLegendOptions = this.legend.options.bubbleLegend;
    bubbleLegendOptions.minSize = min;
    bubbleLegendOptions.maxSize = max;
    bubbleLegendOptions.ranges = this.getRanges();
  };
  BubbleLegendItem2.prototype.correctSizes = function() {
    var legend = this.legend, chart = this.chart, bubbleSeries = chart.series[this.options.seriesIndex], bubbleSeriesSize = bubbleSeries.maxPxSize, bubbleLegendSize = this.options.maxSize;
    if (Math.abs(Math.ceil(bubbleSeriesSize) - bubbleLegendSize) > 1) {
      this.updateRanges(this.options.minSize, bubbleSeries.maxPxSize);
      legend.render();
    }
  };
  return BubbleLegendItem2;
}();
var BubbleLegendItem_default = BubbleLegendItem;

// node_modules/highcharts/es-modules/Series/Bubble/BubbleLegendComposition.js
var setOptions2 = DefaultOptions_default.setOptions;
var addEvent38 = Utilities_default.addEvent;
var objectEach26 = Utilities_default.objectEach;
var wrap5 = Utilities_default.wrap;
var BubbleLegendComposition;
(function(BubbleLegendComposition2) {
  var composedClasses2 = [];
  function chartDrawChartBox(proceed, options, callback) {
    var chart = this, legend = chart.legend, bubbleSeries = getVisibleBubbleSeriesIndex(chart) >= 0;
    var bubbleLegendOptions, bubbleSizes;
    if (legend && legend.options.enabled && legend.bubbleLegend && legend.options.bubbleLegend.autoRanges && bubbleSeries) {
      bubbleLegendOptions = legend.bubbleLegend.options;
      bubbleSizes = legend.bubbleLegend.predictBubbleSizes();
      legend.bubbleLegend.updateRanges(bubbleSizes[0], bubbleSizes[1]);
      if (!bubbleLegendOptions.placed) {
        legend.group.placed = false;
        legend.allItems.forEach(function(item) {
          item.legendGroup.translateY = null;
        });
      }
      legend.render();
      chart.getMargins();
      chart.axes.forEach(function(axis) {
        if (axis.visible) {
          axis.render();
        }
        if (!bubbleLegendOptions.placed) {
          axis.setScale();
          axis.updateNames();
          objectEach26(axis.ticks, function(tick) {
            tick.isNew = true;
            tick.isNewLabel = true;
          });
        }
      });
      bubbleLegendOptions.placed = true;
      chart.getMargins();
      proceed.call(chart, options, callback);
      legend.bubbleLegend.correctSizes();
      retranslateItems(legend, getLinesHeights(legend));
    } else {
      proceed.call(chart, options, callback);
      if (legend && legend.options.enabled && legend.bubbleLegend) {
        legend.render();
        retranslateItems(legend, getLinesHeights(legend));
      }
    }
  }
  function compose(ChartClass, LegendClass, SeriesClass) {
    if (composedClasses2.indexOf(ChartClass) === -1) {
      composedClasses2.push(ChartClass);
      setOptions2({
        legend: {
          bubbleLegend: BubbleLegendDefaults_default
        }
      });
      wrap5(ChartClass.prototype, "drawChartBox", chartDrawChartBox);
    }
    if (composedClasses2.indexOf(LegendClass) === -1) {
      composedClasses2.push(LegendClass);
      addEvent38(LegendClass, "afterGetAllItems", onLegendAfterGetAllItems);
    }
    if (composedClasses2.indexOf(SeriesClass) === -1) {
      composedClasses2.push(SeriesClass);
      addEvent38(SeriesClass, "legendItemClick", onSeriesLegendItemClick);
    }
  }
  BubbleLegendComposition2.compose = compose;
  function getVisibleBubbleSeriesIndex(chart) {
    var series = chart.series;
    var i = 0;
    while (i < series.length) {
      if (series[i] && series[i].isBubble && series[i].visible && series[i].zData.length) {
        return i;
      }
      i++;
    }
    return -1;
  }
  function getLinesHeights(legend) {
    var items = legend.allItems, lines = [], length = items.length;
    var lastLine, i = 0, j = 0;
    for (i = 0; i < length; i++) {
      if (items[i].legendItemHeight) {
        items[i].itemHeight = items[i].legendItemHeight;
      }
      if (items[i] === items[length - 1] || items[i + 1] && items[i]._legendItemPos[1] !== items[i + 1]._legendItemPos[1]) {
        lines.push({ height: 0 });
        lastLine = lines[lines.length - 1];
        for (j; j <= i; j++) {
          if (items[j].itemHeight > lastLine.height) {
            lastLine.height = items[j].itemHeight;
          }
        }
        lastLine.step = i;
      }
    }
    return lines;
  }
  function onLegendAfterGetAllItems(e2) {
    var legend = this, bubbleLegend = legend.bubbleLegend, legendOptions = legend.options, options = legendOptions.bubbleLegend, bubbleSeriesIndex = getVisibleBubbleSeriesIndex(legend.chart);
    if (bubbleLegend && bubbleLegend.ranges && bubbleLegend.ranges.length) {
      if (options.ranges.length) {
        options.autoRanges = !!options.ranges[0].autoRanges;
      }
      legend.destroyItem(bubbleLegend);
    }
    if (bubbleSeriesIndex >= 0 && legendOptions.enabled && options.enabled) {
      options.seriesIndex = bubbleSeriesIndex;
      legend.bubbleLegend = new BubbleLegendItem_default(options, legend);
      legend.bubbleLegend.addToLegend(e2.allItems);
    }
  }
  function onSeriesLegendItemClick() {
    var series = this, chart = series.chart, visible = series.visible, legend = series.chart.legend;
    var status;
    if (legend && legend.bubbleLegend) {
      series.visible = !visible;
      series.ignoreSeries = visible;
      status = getVisibleBubbleSeriesIndex(chart) >= 0;
      if (legend.bubbleLegend.visible !== status) {
        legend.update({
          bubbleLegend: { enabled: status }
        });
        legend.bubbleLegend.visible = status;
      }
      series.visible = visible;
    }
  }
  function retranslateItems(legend, lines) {
    var items = legend.allItems, rtl = legend.options.rtl;
    var orgTranslateX, orgTranslateY, movementX, actualLine = 0;
    items.forEach(function(item, index) {
      orgTranslateX = item.legendGroup.translateX;
      orgTranslateY = item._legendItemPos[1];
      movementX = item.movementX;
      if (movementX || rtl && item.ranges) {
        movementX = rtl ? orgTranslateX - item.options.maxSize / 2 : orgTranslateX + movementX;
        item.legendGroup.attr({ translateX: movementX });
      }
      if (index > lines[actualLine].step) {
        actualLine++;
      }
      item.legendGroup.attr({
        translateY: Math.round(orgTranslateY + lines[actualLine].height / 2)
      });
      item._legendItemPos[1] = orgTranslateY + lines[actualLine].height / 2;
    });
  }
})(BubbleLegendComposition || (BubbleLegendComposition = {}));
var BubbleLegendComposition_default = BubbleLegendComposition;

// node_modules/highcharts/es-modules/Series/Bubble/BubblePoint.js
var __extends24 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ScatterPoint = SeriesRegistry_default.seriesTypes.scatter.prototype.pointClass;
var extend50 = Utilities_default.extend;
var BubblePoint = function(_super) {
  __extends24(BubblePoint2, _super);
  function BubblePoint2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.options = void 0;
    _this.series = void 0;
    return _this;
  }
  BubblePoint2.prototype.haloPath = function(size) {
    return Point_default.prototype.haloPath.call(this, size === 0 ? 0 : (this.marker ? this.marker.radius || 0 : 0) + size);
  };
  return BubblePoint2;
}(ScatterPoint);
extend50(BubblePoint.prototype, {
  ttBelow: false
});
var BubblePoint_default = BubblePoint;

// node_modules/highcharts/es-modules/Series/Bubble/BubbleSeries.js
var __extends25 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var color8 = Color_default.parse;
var noop14 = Globals_default.noop;
var _a3 = SeriesRegistry_default.seriesTypes;
var ColumnSeries7 = _a3.column;
var ScatterSeries2 = _a3.scatter;
var arrayMax9 = Utilities_default.arrayMax;
var arrayMin8 = Utilities_default.arrayMin;
var clamp12 = Utilities_default.clamp;
var extend51 = Utilities_default.extend;
var isNumber36 = Utilities_default.isNumber;
var merge50 = Utilities_default.merge;
var pick58 = Utilities_default.pick;
var pInt9 = Utilities_default.pInt;
var BubbleSeries = function(_super) {
  __extends25(BubbleSeries4, _super);
  function BubbleSeries4() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.data = void 0;
    _this.maxPxSize = void 0;
    _this.minPxSize = void 0;
    _this.options = void 0;
    _this.points = void 0;
    _this.radii = void 0;
    _this.yData = void 0;
    _this.zData = void 0;
    return _this;
  }
  BubbleSeries4.prototype.animate = function(init) {
    if (!init && this.points.length < this.options.animationLimit) {
      this.points.forEach(function(point) {
        var graphic = point.graphic;
        if (graphic && graphic.width) {
          if (!this.hasRendered) {
            graphic.attr({
              x: point.plotX,
              y: point.plotY,
              width: 1,
              height: 1
            });
          }
          graphic.animate(this.markerAttribs(point), this.options.animation);
        }
      }, this);
    }
  };
  BubbleSeries4.prototype.getRadii = function(zMin, zMax, series) {
    var len, i, zData = this.zData, yData = this.yData, minSize = series.minPxSize, maxSize = series.maxPxSize, radii = [], value;
    for (i = 0, len = zData.length; i < len; i++) {
      value = zData[i];
      radii.push(this.getRadius(zMin, zMax, minSize, maxSize, value, yData[i]));
    }
    this.radii = radii;
  };
  BubbleSeries4.prototype.getRadius = function(zMin, zMax, minSize, maxSize, value, yValue) {
    var options = this.options, sizeByArea = options.sizeBy !== "width", zThreshold = options.zThreshold, zRange = zMax - zMin, pos = 0.5;
    if (yValue === null || value === null) {
      return null;
    }
    if (isNumber36(value)) {
      if (options.sizeByAbsoluteValue) {
        value = Math.abs(value - zThreshold);
        zMax = zRange = Math.max(zMax - zThreshold, Math.abs(zMin - zThreshold));
        zMin = 0;
      }
      if (value < zMin) {
        return minSize / 2 - 1;
      }
      if (zRange > 0) {
        pos = (value - zMin) / zRange;
      }
    }
    if (sizeByArea && pos >= 0) {
      pos = Math.sqrt(pos);
    }
    return Math.ceil(minSize + pos * (maxSize - minSize)) / 2;
  };
  BubbleSeries4.prototype.hasData = function() {
    return !!this.processedXData.length;
  };
  BubbleSeries4.prototype.pointAttribs = function(point, state) {
    var markerOptions = this.options.marker, fillOpacity = markerOptions.fillOpacity, attr10 = Series_default.prototype.pointAttribs.call(this, point, state);
    if (fillOpacity !== 1) {
      attr10.fill = color8(attr10.fill).setOpacity(fillOpacity).get("rgba");
    }
    return attr10;
  };
  BubbleSeries4.prototype.translate = function() {
    var i, data = this.data, point, radius, radii = this.radii;
    _super.prototype.translate.call(this);
    i = data.length;
    while (i--) {
      point = data[i];
      radius = radii ? radii[i] : 0;
      if (isNumber36(radius) && radius >= this.minPxSize / 2) {
        point.marker = extend51(point.marker, {
          radius,
          width: 2 * radius,
          height: 2 * radius
        });
        point.dlBox = {
          x: point.plotX - radius,
          y: point.plotY - radius,
          width: 2 * radius,
          height: 2 * radius
        };
      } else {
        point.shapeArgs = point.plotY = point.dlBox = void 0;
      }
    }
  };
  BubbleSeries4.compose = BubbleLegendComposition_default.compose;
  BubbleSeries4.defaultOptions = merge50(ScatterSeries2.defaultOptions, {
    dataLabels: {
      formatter: function() {
        var numberFormatter = this.series.chart.numberFormatter;
        var z = this.point.z;
        return isNumber36(z) ? numberFormatter(z, -1) : "";
      },
      inside: true,
      verticalAlign: "middle"
    },
    animationLimit: 250,
    marker: {
      lineColor: null,
      lineWidth: 1,
      fillOpacity: 0.5,
      radius: null,
      states: {
        hover: {
          radiusPlus: 0
        }
      },
      symbol: "circle"
    },
    minSize: 8,
    maxSize: "20%",
    softThreshold: false,
    states: {
      hover: {
        halo: {
          size: 5
        }
      }
    },
    tooltip: {
      pointFormat: "({point.x}, {point.y}), Size: {point.z}"
    },
    turboThreshold: 0,
    zThreshold: 0,
    zoneAxis: "z"
  });
  return BubbleSeries4;
}(ScatterSeries2);
extend51(BubbleSeries.prototype, {
  alignDataLabel: ColumnSeries7.prototype.alignDataLabel,
  applyZones: noop14,
  bubblePadding: true,
  buildKDTree: noop14,
  directTouch: true,
  isBubble: true,
  pointArrayMap: ["y", "z"],
  pointClass: BubblePoint_default,
  parallelArrays: ["x", "y", "z"],
  trackerGroups: ["group", "dataLabelsGroup"],
  specialGroup: "group",
  zoneAxis: "z"
});
Axis_default.prototype.beforePadding = function() {
  var axis = this, axisLength = this.len, chart = this.chart, pxMin = 0, pxMax = axisLength, isXAxis = this.isXAxis, dataKey = isXAxis ? "xData" : "yData", min = this.min, extremes = {}, smallestSize = Math.min(chart.plotWidth, chart.plotHeight), zMin = Number.MAX_VALUE, zMax = -Number.MAX_VALUE, range = this.max - min, transA = axisLength / range, activeSeries = [];
  this.series.forEach(function(series) {
    var seriesOptions = series.options, zData;
    if (series.bubblePadding && (series.visible || !chart.options.chart.ignoreHiddenSeries)) {
      axis.allowZoomOutside = true;
      activeSeries.push(series);
      if (isXAxis) {
        ["minSize", "maxSize"].forEach(function(prop) {
          var length = seriesOptions[prop], isPercent = /%$/.test(length);
          length = pInt9(length);
          extremes[prop] = isPercent ? smallestSize * length / 100 : length;
        });
        series.minPxSize = extremes.minSize;
        series.maxPxSize = Math.max(extremes.maxSize, extremes.minSize);
        zData = series.zData.filter(isNumber36);
        if (zData.length) {
          zMin = pick58(seriesOptions.zMin, clamp12(arrayMin8(zData), seriesOptions.displayNegative === false ? seriesOptions.zThreshold : -Number.MAX_VALUE, zMin));
          zMax = pick58(seriesOptions.zMax, Math.max(zMax, arrayMax9(zData)));
        }
      }
    }
  });
  activeSeries.forEach(function(series) {
    var data = series[dataKey], i = data.length, radius;
    if (isXAxis) {
      series.getRadii(zMin, zMax, series);
    }
    if (range > 0) {
      while (i--) {
        if (isNumber36(data[i]) && axis.dataMin <= data[i] && data[i] <= axis.max) {
          radius = series.radii ? series.radii[i] : 0;
          pxMin = Math.min((data[i] - min) * transA - radius, pxMin);
          pxMax = Math.max((data[i] - min) * transA + radius, pxMax);
        }
      }
    }
  });
  if (activeSeries.length && range > 0 && !this.logarithmic) {
    pxMax -= axisLength;
    transA *= (axisLength + Math.max(0, pxMin) - Math.min(pxMax, axisLength)) / axisLength;
    [
      ["min", "userMin", pxMin],
      ["max", "userMax", pxMax]
    ].forEach(function(keys2) {
      if (typeof pick58(axis.options[keys2[0]], axis[keys2[1]]) === "undefined") {
        axis[keys2[0]] += keys2[2] / transA;
      }
    });
  }
};
SeriesRegistry_default.registerSeriesType("bubble", BubbleSeries);
var BubbleSeries_default = BubbleSeries;

// node_modules/highcharts/es-modules/Series/ColumnRange/ColumnRangePoint.js
var __extends26 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var _a4 = SeriesRegistry_default.seriesTypes;
var ColumnPoint = _a4.column.prototype.pointClass;
var AreaRangePoint2 = _a4.arearange.prototype.pointClass;
var extend52 = Utilities_default.extend;
var isNumber37 = Utilities_default.isNumber;
var ColumnRangePoint = function(_super) {
  __extends26(ColumnRangePoint2, _super);
  function ColumnRangePoint2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.series = void 0;
    _this.options = void 0;
    _this.barX = void 0;
    _this.pointWidth = void 0;
    _this.shapeType = void 0;
    return _this;
  }
  ColumnRangePoint2.prototype.isValid = function() {
    return isNumber37(this.low);
  };
  return ColumnRangePoint2;
}(AreaRangePoint2);
extend52(ColumnRangePoint.prototype, {
  setState: ColumnPoint.prototype.setState
});
var ColumnRangePoint_default = ColumnRangePoint;

// node_modules/highcharts/es-modules/Series/ColumnRange/ColumnRangeSeries.js
var __extends27 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var noop15 = Globals_default.noop;
var _a5 = SeriesRegistry_default.seriesTypes;
var AreaRangeSeries2 = _a5.arearange;
var ColumnSeries8 = _a5.column;
var columnProto3 = ColumnSeries8.prototype;
var arearangeProto = AreaRangeSeries2.prototype;
var clamp13 = Utilities_default.clamp;
var merge51 = Utilities_default.merge;
var pick59 = Utilities_default.pick;
var extend53 = Utilities_default.extend;
var columnRangeOptions = {
  pointRange: null,
  marker: null,
  states: {
    hover: {
      halo: false
    }
  }
};
var ColumnRangeSeries = function(_super) {
  __extends27(ColumnRangeSeries2, _super);
  function ColumnRangeSeries2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.data = void 0;
    _this.points = void 0;
    _this.options = void 0;
    return _this;
  }
  ColumnRangeSeries2.prototype.setOptions = function() {
    merge51(true, arguments[0], { stacking: void 0 });
    return arearangeProto.setOptions.apply(this, arguments);
  };
  ColumnRangeSeries2.prototype.translate = function() {
    var series = this, yAxis = series.yAxis, xAxis = series.xAxis, startAngleRad = xAxis.startAngleRad, start, chart = series.chart, isRadial = series.xAxis.isRadial, safeDistance = Math.max(chart.chartWidth, chart.chartHeight) + 999, plotHigh;
    function safeBounds(pixelPos) {
      return clamp13(pixelPos, -safeDistance, safeDistance);
    }
    columnProto3.translate.apply(series);
    series.points.forEach(function(point) {
      var shapeArgs = point.shapeArgs || {}, minPointLength = series.options.minPointLength, heightDifference, height, y;
      point.plotHigh = plotHigh = safeBounds(yAxis.translate(point.high, 0, 1, 0, 1));
      point.plotLow = safeBounds(point.plotY);
      y = plotHigh;
      height = pick59(point.rectPlotY, point.plotY) - plotHigh;
      if (Math.abs(height) < minPointLength) {
        heightDifference = minPointLength - height;
        height += heightDifference;
        y -= heightDifference / 2;
      } else if (height < 0) {
        height *= -1;
        y -= height;
      }
      if (isRadial) {
        start = point.barX + startAngleRad;
        point.shapeType = "arc";
        point.shapeArgs = series.polarArc(y + height, y, start, start + point.pointWidth);
      } else {
        shapeArgs.height = height;
        shapeArgs.y = y;
        var _a15 = shapeArgs.x, x = _a15 === void 0 ? 0 : _a15, _b = shapeArgs.width, width = _b === void 0 ? 0 : _b;
        point.tooltipPos = chart.inverted ? [
          yAxis.len + yAxis.pos - chart.plotLeft - y - height / 2,
          xAxis.len + xAxis.pos - chart.plotTop - x - width / 2,
          height
        ] : [
          xAxis.left - chart.plotLeft + x + width / 2,
          yAxis.pos - chart.plotTop + y + height / 2,
          height
        ];
      }
    });
  };
  ColumnRangeSeries2.prototype.crispCol = function() {
    return columnProto3.crispCol.apply(this, arguments);
  };
  ColumnRangeSeries2.prototype.drawPoints = function() {
    return columnProto3.drawPoints.apply(this, arguments);
  };
  ColumnRangeSeries2.prototype.drawTracker = function() {
    return columnProto3.drawTracker.apply(this, arguments);
  };
  ColumnRangeSeries2.prototype.getColumnMetrics = function() {
    return columnProto3.getColumnMetrics.apply(this, arguments);
  };
  ColumnRangeSeries2.prototype.pointAttribs = function() {
    return columnProto3.pointAttribs.apply(this, arguments);
  };
  ColumnRangeSeries2.prototype.adjustForMissingColumns = function() {
    return columnProto3.adjustForMissingColumns.apply(this, arguments);
  };
  ColumnRangeSeries2.prototype.animate = function() {
    return columnProto3.animate.apply(this, arguments);
  };
  ColumnRangeSeries2.prototype.translate3dPoints = function() {
    return columnProto3.translate3dPoints.apply(this, arguments);
  };
  ColumnRangeSeries2.prototype.translate3dShapes = function() {
    return columnProto3.translate3dShapes.apply(this, arguments);
  };
  ColumnRangeSeries2.defaultOptions = merge51(ColumnSeries8.defaultOptions, AreaRangeSeries2.defaultOptions, columnRangeOptions);
  return ColumnRangeSeries2;
}(AreaRangeSeries2);
extend53(ColumnRangeSeries.prototype, {
  directTouch: true,
  trackerGroups: ["group", "dataLabelsGroup"],
  drawGraph: noop15,
  getSymbol: noop15,
  polarArc: function() {
    return columnProto3.polarArc.apply(this, arguments);
  },
  pointClass: ColumnRangePoint_default
});
SeriesRegistry_default.registerSeriesType("columnrange", ColumnRangeSeries);

// node_modules/highcharts/es-modules/Series/ColumnPyramid/ColumnPyramidSeries.js
var __extends28 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var colProto = ColumnSeries_default.prototype;
var clamp14 = Utilities_default.clamp;
var extend54 = Utilities_default.extend;
var merge52 = Utilities_default.merge;
var pick60 = Utilities_default.pick;
var ColumnPyramidSeries = function(_super) {
  __extends28(ColumnPyramidSeries2, _super);
  function ColumnPyramidSeries2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.data = void 0;
    _this.options = void 0;
    _this.points = void 0;
    return _this;
  }
  ColumnPyramidSeries2.prototype.translate = function() {
    var series = this, chart = series.chart, options = series.options, dense = series.dense = series.closestPointRange * series.xAxis.transA < 2, borderWidth = series.borderWidth = pick60(options.borderWidth, dense ? 0 : 1), yAxis = series.yAxis, threshold = options.threshold, translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold), minPointLength = pick60(options.minPointLength, 5), metrics = series.getColumnMetrics(), pointWidth = metrics.width, seriesBarW = series.barW = Math.max(pointWidth, 1 + 2 * borderWidth), pointXOffset = series.pointXOffset = metrics.offset;
    if (chart.inverted) {
      translatedThreshold -= 0.5;
    }
    if (options.pointPadding) {
      seriesBarW = Math.ceil(seriesBarW);
    }
    colProto.translate.apply(series);
    series.points.forEach(function(point) {
      var yBottom = pick60(point.yBottom, translatedThreshold), safeDistance = 999 + Math.abs(yBottom), plotY = clamp14(point.plotY, -safeDistance, yAxis.len + safeDistance), barX = point.plotX + pointXOffset, barW = seriesBarW / 2, barY = Math.min(plotY, yBottom), barH = Math.max(plotY, yBottom) - barY, stackTotal, stackHeight, topPointY, topXwidth, bottomXwidth, invBarPos, x1, x2, x3, x4, y1, y2;
      point.barX = barX;
      point.pointWidth = pointWidth;
      point.tooltipPos = chart.inverted ? [
        yAxis.len + yAxis.pos - chart.plotLeft - plotY,
        series.xAxis.len - barX - barW,
        barH
      ] : [
        barX + barW,
        plotY + yAxis.pos - chart.plotTop,
        barH
      ];
      stackTotal = threshold + (point.total || point.y);
      if (options.stacking === "percent") {
        stackTotal = threshold + (point.y < 0) ? -100 : 100;
      }
      topPointY = yAxis.toPixels(stackTotal, true);
      stackHeight = chart.plotHeight - topPointY - (chart.plotHeight - translatedThreshold);
      topXwidth = stackHeight ? barW * (barY - topPointY) / stackHeight : 0;
      bottomXwidth = stackHeight ? barW * (barY + barH - topPointY) / stackHeight : 0;
      x1 = barX - topXwidth + barW;
      x2 = barX + topXwidth + barW;
      x3 = barX + bottomXwidth + barW;
      x4 = barX - bottomXwidth + barW;
      y1 = barY - minPointLength;
      y2 = barY + barH;
      if (point.y < 0) {
        y1 = barY;
        y2 = barY + barH + minPointLength;
      }
      if (chart.inverted) {
        invBarPos = chart.plotWidth - barY;
        stackHeight = topPointY - (chart.plotWidth - translatedThreshold);
        topXwidth = barW * (topPointY - invBarPos) / stackHeight;
        bottomXwidth = barW * (topPointY - (invBarPos - barH)) / stackHeight;
        x1 = barX + barW + topXwidth;
        x2 = x1 - 2 * topXwidth;
        x3 = barX - bottomXwidth + barW;
        x4 = barX + bottomXwidth + barW;
        y1 = barY;
        y2 = barY + barH - minPointLength;
        if (point.y < 0) {
          y2 = barY + barH + minPointLength;
        }
      }
      point.shapeType = "path";
      point.shapeArgs = {
        x: x1,
        y: y1,
        width: x2 - x1,
        height: barH,
        d: [
          ["M", x1, y1],
          ["L", x2, y1],
          ["L", x3, y2],
          ["L", x4, y2],
          ["Z"]
        ]
      };
    });
  };
  ColumnPyramidSeries2.defaultOptions = merge52(ColumnSeries_default.defaultOptions, {});
  return ColumnPyramidSeries2;
}(ColumnSeries_default);
SeriesRegistry_default.registerSeriesType("columnpyramid", ColumnPyramidSeries);

// node_modules/highcharts/es-modules/Series/ErrorBar/ErrorBarSeries.js
var __extends29 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var AreaRangeSeries3 = SeriesRegistry_default.seriesTypes.arearange;
var merge53 = Utilities_default.merge;
var extend55 = Utilities_default.extend;
var ErrorBarSeries = function(_super) {
  __extends29(ErrorBarSeries2, _super);
  function ErrorBarSeries2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.data = void 0;
    _this.options = void 0;
    _this.points = void 0;
    return _this;
  }
  ErrorBarSeries2.prototype.getColumnMetrics = function() {
    return this.linkedParent && this.linkedParent.columnMetrics || ColumnSeries_default.prototype.getColumnMetrics.call(this);
  };
  ErrorBarSeries2.prototype.drawDataLabels = function() {
    var valKey = this.pointValKey;
    if (AreaRangeSeries3) {
      AreaRangeSeries3.prototype.drawDataLabels.call(this);
      this.data.forEach(function(point) {
        point.y = point[valKey];
      });
    }
  };
  ErrorBarSeries2.prototype.toYData = function(point) {
    return [point.low, point.high];
  };
  ErrorBarSeries2.defaultOptions = merge53(BoxPlotSeries_default.defaultOptions, {
    color: Palette_default.neutralColor100,
    grouping: false,
    linkedTo: ":previous",
    tooltip: {
      pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'
    },
    whiskerWidth: null
  });
  return ErrorBarSeries2;
}(BoxPlotSeries_default);
extend55(ErrorBarSeries.prototype, {
  pointArrayMap: ["low", "high"],
  pointValKey: "high",
  doQuartiles: false
});
SeriesRegistry_default.registerSeriesType("errorbar", ErrorBarSeries);

// node_modules/highcharts/es-modules/Series/Gauge/GaugePoint.js
var __extends30 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Point2 = SeriesRegistry_default.series.prototype.pointClass;
var GaugePoint = function(_super) {
  __extends30(GaugePoint2, _super);
  function GaugePoint2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.options = void 0;
    _this.series = void 0;
    _this.shapeArgs = void 0;
    return _this;
  }
  GaugePoint2.prototype.setState = function(state) {
    this.state = state;
  };
  return GaugePoint2;
}(Point2);
var GaugePoint_default = GaugePoint;

// node_modules/highcharts/es-modules/Series/Gauge/GaugeSeries.js
var __extends31 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var noop16 = Globals_default.noop;
var Series5 = SeriesRegistry_default.series;
var ColumnSeries9 = SeriesRegistry_default.seriesTypes.column;
var clamp15 = Utilities_default.clamp;
var isNumber38 = Utilities_default.isNumber;
var extend56 = Utilities_default.extend;
var merge54 = Utilities_default.merge;
var pick61 = Utilities_default.pick;
var pInt10 = Utilities_default.pInt;
var GaugeSeries = function(_super) {
  __extends31(GaugeSeries3, _super);
  function GaugeSeries3() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.data = void 0;
    _this.points = void 0;
    _this.options = void 0;
    _this.yAxis = void 0;
    return _this;
  }
  GaugeSeries3.prototype.translate = function() {
    var series = this, yAxis = series.yAxis, options = series.options, center = yAxis.center;
    series.generatePoints();
    series.points.forEach(function(point) {
      var dialOptions = merge54(options.dial, point.dial), radius = pInt10(pick61(dialOptions.radius, "80%")) * center[2] / 200, baseLength = pInt10(pick61(dialOptions.baseLength, "70%")) * radius / 100, rearLength = pInt10(pick61(dialOptions.rearLength, "10%")) * radius / 100, baseWidth = dialOptions.baseWidth || 3, topWidth = dialOptions.topWidth || 1, overshoot = options.overshoot, rotation = yAxis.startAngleRad + yAxis.translate(point.y, null, null, null, true);
      if (isNumber38(overshoot) || options.wrap === false) {
        overshoot = isNumber38(overshoot) ? overshoot / 180 * Math.PI : 0;
        rotation = clamp15(rotation, yAxis.startAngleRad - overshoot, yAxis.endAngleRad + overshoot);
      }
      rotation = rotation * 180 / Math.PI;
      point.shapeType = "path";
      var d = dialOptions.path || [
        ["M", -rearLength, -baseWidth / 2],
        ["L", baseLength, -baseWidth / 2],
        ["L", radius, -topWidth / 2],
        ["L", radius, topWidth / 2],
        ["L", baseLength, baseWidth / 2],
        ["L", -rearLength, baseWidth / 2],
        ["Z"]
      ];
      point.shapeArgs = {
        d,
        translateX: center[0],
        translateY: center[1],
        rotation
      };
      point.plotX = center[0];
      point.plotY = center[1];
    });
  };
  GaugeSeries3.prototype.drawPoints = function() {
    var series = this, chart = series.chart, center = series.yAxis.center, pivot = series.pivot, options = series.options, pivotOptions = options.pivot, renderer = chart.renderer;
    series.points.forEach(function(point) {
      var graphic = point.graphic, shapeArgs = point.shapeArgs, d = shapeArgs.d, dialOptions = merge54(options.dial, point.dial);
      if (graphic) {
        graphic.animate(shapeArgs);
        shapeArgs.d = d;
      } else {
        point.graphic = renderer[point.shapeType](shapeArgs).attr({
          rotation: shapeArgs.rotation,
          zIndex: 1
        }).addClass("highcharts-dial").add(series.group);
      }
      if (!chart.styledMode) {
        point.graphic[graphic ? "animate" : "attr"]({
          stroke: dialOptions.borderColor || "none",
          "stroke-width": dialOptions.borderWidth || 0,
          fill: dialOptions.backgroundColor || Palette_default.neutralColor100
        });
      }
    });
    if (pivot) {
      pivot.animate({
        translateX: center[0],
        translateY: center[1]
      });
    } else {
      series.pivot = renderer.circle(0, 0, pick61(pivotOptions.radius, 5)).attr({
        zIndex: 2
      }).addClass("highcharts-pivot").translate(center[0], center[1]).add(series.group);
      if (!chart.styledMode) {
        series.pivot.attr({
          "stroke-width": pivotOptions.borderWidth || 0,
          stroke: pivotOptions.borderColor || Palette_default.neutralColor20,
          fill: pivotOptions.backgroundColor || Palette_default.neutralColor100
        });
      }
    }
  };
  GaugeSeries3.prototype.animate = function(init) {
    var series = this;
    if (!init) {
      series.points.forEach(function(point) {
        var graphic = point.graphic;
        if (graphic) {
          graphic.attr({
            rotation: series.yAxis.startAngleRad * 180 / Math.PI
          });
          graphic.animate({
            rotation: point.shapeArgs.rotation
          }, series.options.animation);
        }
      });
    }
  };
  GaugeSeries3.prototype.render = function() {
    this.group = this.plotGroup("group", "series", this.visible ? "visible" : "hidden", this.options.zIndex, this.chart.seriesGroup);
    Series5.prototype.render.call(this);
    this.group.clip(this.chart.clipRect);
  };
  GaugeSeries3.prototype.setData = function(data, redraw) {
    Series5.prototype.setData.call(this, data, false);
    this.processData();
    this.generatePoints();
    if (pick61(redraw, true)) {
      this.chart.redraw();
    }
  };
  GaugeSeries3.prototype.hasData = function() {
    return !!this.points.length;
  };
  GaugeSeries3.defaultOptions = merge54(Series5.defaultOptions, {
    dataLabels: {
      borderColor: Palette_default.neutralColor20,
      borderRadius: 3,
      borderWidth: 1,
      crop: false,
      defer: false,
      enabled: true,
      verticalAlign: "top",
      y: 15,
      zIndex: 2
    },
    dial: {},
    pivot: {},
    tooltip: {
      headerFormat: ""
    },
    showInLegend: false
  });
  return GaugeSeries3;
}(Series5);
extend56(GaugeSeries.prototype, {
  angular: true,
  directTouch: true,
  drawGraph: noop16,
  drawTracker: ColumnSeries9.prototype.drawTracker,
  fixedBox: true,
  forceDL: true,
  noSharedTooltip: true,
  pointClass: GaugePoint_default,
  trackerGroups: ["group", "dataLabelsGroup"]
});
SeriesRegistry_default.registerSeriesType("gauge", GaugeSeries);

// node_modules/highcharts/es-modules/Series/PackedBubble/PackedBubblePoint.js
var __extends32 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var BubbleSeries2 = SeriesRegistry_default.seriesTypes.bubble;
var PackedBubblePoint = function(_super) {
  __extends32(PackedBubblePoint2, _super);
  function PackedBubblePoint2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.degree = NaN;
    _this.mass = NaN;
    _this.radius = NaN;
    _this.options = void 0;
    _this.series = void 0;
    _this.value = null;
    return _this;
  }
  PackedBubblePoint2.prototype.destroy = function() {
    if (this.series.layout) {
      this.series.layout.removeElementFromCollection(this, this.series.layout.nodes);
    }
    return Point_default.prototype.destroy.apply(this, arguments);
  };
  PackedBubblePoint2.prototype.firePointEvent = function() {
    var point = this, series = this.series, seriesOptions = series.options;
    if (this.isParentNode && seriesOptions.parentNode) {
      var temp = seriesOptions.allowPointSelect;
      seriesOptions.allowPointSelect = seriesOptions.parentNode.allowPointSelect;
      Point_default.prototype.firePointEvent.apply(this, arguments);
      seriesOptions.allowPointSelect = temp;
    } else {
      Point_default.prototype.firePointEvent.apply(this, arguments);
    }
  };
  PackedBubblePoint2.prototype.select = function() {
    var point = this, series = this.series, chart = series.chart;
    if (point.isParentNode) {
      chart.getSelectedPoints = chart.getSelectedParentNodes;
      Point_default.prototype.select.apply(this, arguments);
      chart.getSelectedPoints = Chart_default.prototype.getSelectedPoints;
    } else {
      Point_default.prototype.select.apply(this, arguments);
    }
  };
  return PackedBubblePoint2;
}(BubbleSeries2.prototype.pointClass);
var PackedBubblePoint_default = PackedBubblePoint;

// node_modules/highcharts/es-modules/Series/Networkgraph/DraggableNodes.js
var addEvent39 = Utilities_default.addEvent;
Globals_default.dragNodesMixin = {
  onMouseDown: function(point, event) {
    var normalizedEvent = this.chart.pointer.normalize(event);
    point.fixedPosition = {
      chartX: normalizedEvent.chartX,
      chartY: normalizedEvent.chartY,
      plotX: point.plotX,
      plotY: point.plotY
    };
    point.inDragMode = true;
  },
  onMouseMove: function(point, event) {
    if (point.fixedPosition && point.inDragMode) {
      var series = this, chart = series.chart, normalizedEvent = chart.pointer.normalize(event), diffX = point.fixedPosition.chartX - normalizedEvent.chartX, diffY = point.fixedPosition.chartY - normalizedEvent.chartY, newPlotX = void 0, newPlotY = void 0, graphLayoutsLookup = chart.graphLayoutsLookup;
      if (Math.abs(diffX) > 5 || Math.abs(diffY) > 5) {
        newPlotX = point.fixedPosition.plotX - diffX;
        newPlotY = point.fixedPosition.plotY - diffY;
        if (chart.isInsidePlot(newPlotX, newPlotY)) {
          point.plotX = newPlotX;
          point.plotY = newPlotY;
          point.hasDragged = true;
          this.redrawHalo(point);
          graphLayoutsLookup.forEach(function(layout) {
            layout.restartSimulation();
          });
        }
      }
    }
  },
  onMouseUp: function(point, event) {
    if (point.fixedPosition) {
      if (point.hasDragged) {
        if (this.layout.enableSimulation) {
          this.layout.start();
        } else {
          this.chart.redraw();
        }
      }
      point.inDragMode = point.hasDragged = false;
      if (!this.options.fixedDraggable) {
        delete point.fixedPosition;
      }
    }
  },
  redrawHalo: function(point) {
    if (point && this.halo) {
      this.halo.attr({
        d: point.haloPath(this.options.states.hover.halo.size)
      });
    }
  }
};
addEvent39(Chart_default, "load", function() {
  var chart = this, mousedownUnbinder, mousemoveUnbinder, mouseupUnbinder;
  if (chart.container) {
    mousedownUnbinder = addEvent39(chart.container, "mousedown", function(event) {
      var point = chart.hoverPoint;
      if (point && point.series && point.series.hasDraggableNodes && point.series.options.draggable) {
        point.series.onMouseDown(point, event);
        mousemoveUnbinder = addEvent39(chart.container, "mousemove", function(e2) {
          return point && point.series && point.series.onMouseMove(point, e2);
        });
        mouseupUnbinder = addEvent39(chart.container.ownerDocument, "mouseup", function(e2) {
          mousemoveUnbinder();
          mouseupUnbinder();
          return point && point.series && point.series.onMouseUp(point, e2);
        });
      }
    });
  }
  addEvent39(chart, "destroy", function() {
    mousedownUnbinder();
  });
});

// node_modules/highcharts/es-modules/Series/Networkgraph/Integrations.js
Globals_default.networkgraphIntegrations = {
  verlet: {
    attractiveForceFunction: function(d, k) {
      return (k - d) / d;
    },
    repulsiveForceFunction: function(d, k) {
      return (k - d) / d * (k > d ? 1 : 0);
    },
    barycenter: function() {
      var gravitationalConstant = this.options.gravitationalConstant, xFactor = this.barycenter.xFactor, yFactor = this.barycenter.yFactor;
      xFactor = (xFactor - (this.box.left + this.box.width) / 2) * gravitationalConstant;
      yFactor = (yFactor - (this.box.top + this.box.height) / 2) * gravitationalConstant;
      this.nodes.forEach(function(node) {
        if (!node.fixedPosition) {
          node.plotX -= xFactor / node.mass / node.degree;
          node.plotY -= yFactor / node.mass / node.degree;
        }
      });
    },
    repulsive: function(node, force, distanceXY) {
      var factor = force * this.diffTemperature / node.mass / node.degree;
      if (!node.fixedPosition) {
        node.plotX += distanceXY.x * factor;
        node.plotY += distanceXY.y * factor;
      }
    },
    attractive: function(link, force, distanceXY) {
      var massFactor = link.getMass(), translatedX = -distanceXY.x * force * this.diffTemperature, translatedY = -distanceXY.y * force * this.diffTemperature;
      if (!link.fromNode.fixedPosition) {
        link.fromNode.plotX -= translatedX * massFactor.fromNode / link.fromNode.degree;
        link.fromNode.plotY -= translatedY * massFactor.fromNode / link.fromNode.degree;
      }
      if (!link.toNode.fixedPosition) {
        link.toNode.plotX += translatedX * massFactor.toNode / link.toNode.degree;
        link.toNode.plotY += translatedY * massFactor.toNode / link.toNode.degree;
      }
    },
    integrate: function(layout, node) {
      var friction = -layout.options.friction, maxSpeed = layout.options.maxSpeed, prevX = node.prevX, prevY = node.prevY, diffX = (node.plotX + node.dispX - prevX) * friction, diffY = (node.plotY + node.dispY - prevY) * friction, abs = Math.abs, signX = abs(diffX) / (diffX || 1), signY = abs(diffY) / (diffY || 1);
      diffX = signX * Math.min(maxSpeed, Math.abs(diffX));
      diffY = signY * Math.min(maxSpeed, Math.abs(diffY));
      node.prevX = node.plotX + node.dispX;
      node.prevY = node.plotY + node.dispY;
      node.plotX += diffX;
      node.plotY += diffY;
      node.temperature = layout.vectorLength({
        x: diffX,
        y: diffY
      });
    },
    getK: function(layout) {
      return Math.pow(layout.box.width * layout.box.height / layout.nodes.length, 0.5);
    }
  },
  euler: {
    attractiveForceFunction: function(d, k) {
      return d * d / k;
    },
    repulsiveForceFunction: function(d, k) {
      return k * k / d;
    },
    barycenter: function() {
      var gravitationalConstant = this.options.gravitationalConstant, xFactor = this.barycenter.xFactor, yFactor = this.barycenter.yFactor;
      this.nodes.forEach(function(node) {
        if (!node.fixedPosition) {
          var degree = node.getDegree(), phi = degree * (1 + degree / 2);
          node.dispX += (xFactor - node.plotX) * gravitationalConstant * phi / node.degree;
          node.dispY += (yFactor - node.plotY) * gravitationalConstant * phi / node.degree;
        }
      });
    },
    repulsive: function(node, force, distanceXY, distanceR) {
      node.dispX += distanceXY.x / distanceR * force / node.degree;
      node.dispY += distanceXY.y / distanceR * force / node.degree;
    },
    attractive: function(link, force, distanceXY, distanceR) {
      var massFactor = link.getMass(), translatedX = distanceXY.x / distanceR * force, translatedY = distanceXY.y / distanceR * force;
      if (!link.fromNode.fixedPosition) {
        link.fromNode.dispX -= translatedX * massFactor.fromNode / link.fromNode.degree;
        link.fromNode.dispY -= translatedY * massFactor.fromNode / link.fromNode.degree;
      }
      if (!link.toNode.fixedPosition) {
        link.toNode.dispX += translatedX * massFactor.toNode / link.toNode.degree;
        link.toNode.dispY += translatedY * massFactor.toNode / link.toNode.degree;
      }
    },
    integrate: function(layout, node) {
      var distanceR;
      node.dispX += node.dispX * layout.options.friction;
      node.dispY += node.dispY * layout.options.friction;
      distanceR = node.temperature = layout.vectorLength({
        x: node.dispX,
        y: node.dispY
      });
      if (distanceR !== 0) {
        node.plotX += node.dispX / distanceR * Math.min(Math.abs(node.dispX), layout.temperature);
        node.plotY += node.dispY / distanceR * Math.min(Math.abs(node.dispY), layout.temperature);
      }
    },
    getK: function(layout) {
      return Math.pow(layout.box.width * layout.box.height / layout.nodes.length, 0.3);
    }
  }
};

// node_modules/highcharts/es-modules/Series/Networkgraph/QuadTree.js
var extend57 = Utilities_default.extend;
var QuadTreeNode = Globals_default.QuadTreeNode = function(box) {
  this.box = box;
  this.boxSize = Math.min(box.width, box.height);
  this.nodes = [];
  this.isInternal = false;
  this.body = false;
  this.isEmpty = true;
};
extend57(QuadTreeNode.prototype, {
  insert: function(point, depth) {
    var newQuadTreeNode;
    if (this.isInternal) {
      this.nodes[this.getBoxPosition(point)].insert(point, depth - 1);
    } else {
      this.isEmpty = false;
      if (!this.body) {
        this.isInternal = false;
        this.body = point;
      } else {
        if (depth) {
          this.isInternal = true;
          this.divideBox();
          if (this.body !== true) {
            this.nodes[this.getBoxPosition(this.body)].insert(this.body, depth - 1);
            this.body = true;
          }
          this.nodes[this.getBoxPosition(point)].insert(point, depth - 1);
        } else {
          newQuadTreeNode = new QuadTreeNode({
            top: point.plotX,
            left: point.plotY,
            width: 0.1,
            height: 0.1
          });
          newQuadTreeNode.body = point;
          newQuadTreeNode.isInternal = false;
          this.nodes.push(newQuadTreeNode);
        }
      }
    }
  },
  updateMassAndCenter: function() {
    var mass = 0, plotX = 0, plotY = 0;
    if (this.isInternal) {
      this.nodes.forEach(function(pointMass) {
        if (!pointMass.isEmpty) {
          mass += pointMass.mass;
          plotX += pointMass.plotX * pointMass.mass;
          plotY += pointMass.plotY * pointMass.mass;
        }
      });
      plotX /= mass;
      plotY /= mass;
    } else if (this.body) {
      mass = this.body.mass;
      plotX = this.body.plotX;
      plotY = this.body.plotY;
    }
    this.mass = mass;
    this.plotX = plotX;
    this.plotY = plotY;
  },
  divideBox: function() {
    var halfWidth = this.box.width / 2, halfHeight = this.box.height / 2;
    this.nodes[0] = new QuadTreeNode({
      left: this.box.left,
      top: this.box.top,
      width: halfWidth,
      height: halfHeight
    });
    this.nodes[1] = new QuadTreeNode({
      left: this.box.left + halfWidth,
      top: this.box.top,
      width: halfWidth,
      height: halfHeight
    });
    this.nodes[2] = new QuadTreeNode({
      left: this.box.left + halfWidth,
      top: this.box.top + halfHeight,
      width: halfWidth,
      height: halfHeight
    });
    this.nodes[3] = new QuadTreeNode({
      left: this.box.left,
      top: this.box.top + halfHeight,
      width: halfWidth,
      height: halfHeight
    });
  },
  getBoxPosition: function(point) {
    var left = point.plotX < this.box.left + this.box.width / 2, top = point.plotY < this.box.top + this.box.height / 2, index;
    if (left) {
      if (top) {
        index = 0;
      } else {
        index = 3;
      }
    } else {
      if (top) {
        index = 1;
      } else {
        index = 2;
      }
    }
    return index;
  }
});
var QuadTree = Globals_default.QuadTree = function(x, y, width, height) {
  this.box = {
    left: x,
    top: y,
    width,
    height
  };
  this.maxDepth = 25;
  this.root = new QuadTreeNode(this.box, "0");
  this.root.isInternal = true;
  this.root.isRoot = true;
  this.root.divideBox();
};
extend57(QuadTree.prototype, {
  insertNodes: function(points) {
    points.forEach(function(point) {
      this.root.insert(point, this.maxDepth);
    }, this);
  },
  visitNodeRecursive: function(node, beforeCallback, afterCallback) {
    var goFurther;
    if (!node) {
      node = this.root;
    }
    if (node === this.root && beforeCallback) {
      goFurther = beforeCallback(node);
    }
    if (goFurther === false) {
      return;
    }
    node.nodes.forEach(function(qtNode) {
      if (qtNode.isInternal) {
        if (beforeCallback) {
          goFurther = beforeCallback(qtNode);
        }
        if (goFurther === false) {
          return;
        }
        this.visitNodeRecursive(qtNode, beforeCallback, afterCallback);
      } else if (qtNode.body) {
        if (beforeCallback) {
          beforeCallback(qtNode.body);
        }
      }
      if (afterCallback) {
        afterCallback(qtNode);
      }
    }, this);
    if (node === this.root && afterCallback) {
      afterCallback(node);
    }
  },
  calculateMassAndCenter: function() {
    this.visitNodeRecursive(null, null, function(node) {
      node.updateMassAndCenter();
    });
  }
});

// node_modules/highcharts/es-modules/Series/Networkgraph/Layouts.js
var setAnimation6 = AnimationUtilities_default.setAnimation;
var addEvent40 = Utilities_default.addEvent;
var clamp16 = Utilities_default.clamp;
var defined41 = Utilities_default.defined;
var extend58 = Utilities_default.extend;
var isFunction6 = Utilities_default.isFunction;
var pick62 = Utilities_default.pick;
Globals_default.layouts = {
  "reingold-fruchterman": function() {
  }
};
extend58(Globals_default.layouts["reingold-fruchterman"].prototype, {
  init: function(options) {
    this.options = options;
    this.nodes = [];
    this.links = [];
    this.series = [];
    this.box = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    this.setInitialRendering(true);
    this.integration = Globals_default.networkgraphIntegrations[options.integration];
    this.enableSimulation = options.enableSimulation;
    this.attractiveForce = pick62(options.attractiveForce, this.integration.attractiveForceFunction);
    this.repulsiveForce = pick62(options.repulsiveForce, this.integration.repulsiveForceFunction);
    this.approximation = options.approximation;
  },
  updateSimulation: function(enable) {
    this.enableSimulation = pick62(enable, this.options.enableSimulation);
  },
  start: function() {
    var layout = this, series = this.series, options = this.options;
    layout.currentStep = 0;
    layout.forces = series[0] && series[0].forces || [];
    layout.chart = series[0] && series[0].chart;
    if (layout.initialRendering) {
      layout.initPositions();
      series.forEach(function(s) {
        s.finishedAnimating = true;
        s.render();
      });
    }
    layout.setK();
    layout.resetSimulation(options);
    if (layout.enableSimulation) {
      layout.step();
    }
  },
  step: function() {
    var layout = this, series = this.series, options = this.options;
    layout.currentStep++;
    if (layout.approximation === "barnes-hut") {
      layout.createQuadTree();
      layout.quadTree.calculateMassAndCenter();
    }
    layout.forces.forEach(function(forceName) {
      layout[forceName + "Forces"](layout.temperature);
    });
    layout.applyLimits(layout.temperature);
    layout.temperature = layout.coolDown(layout.startTemperature, layout.diffTemperature, layout.currentStep);
    layout.prevSystemTemperature = layout.systemTemperature;
    layout.systemTemperature = layout.getSystemTemperature();
    if (layout.enableSimulation) {
      series.forEach(function(s) {
        if (s.chart) {
          s.render();
        }
      });
      if (layout.maxIterations-- && isFinite(layout.temperature) && !layout.isStable()) {
        if (layout.simulation) {
          Globals_default.win.cancelAnimationFrame(layout.simulation);
        }
        layout.simulation = Globals_default.win.requestAnimationFrame(function() {
          layout.step();
        });
      } else {
        layout.simulation = false;
      }
    }
  },
  stop: function() {
    if (this.simulation) {
      Globals_default.win.cancelAnimationFrame(this.simulation);
    }
  },
  setArea: function(x, y, w2, h) {
    this.box = {
      left: x,
      top: y,
      width: w2,
      height: h
    };
  },
  setK: function() {
    this.k = this.options.linkLength || this.integration.getK(this);
  },
  addElementsToCollection: function(elements, collection) {
    elements.forEach(function(elem) {
      if (collection.indexOf(elem) === -1) {
        collection.push(elem);
      }
    });
  },
  removeElementFromCollection: function(element, collection) {
    var index = collection.indexOf(element);
    if (index !== -1) {
      collection.splice(index, 1);
    }
  },
  clear: function() {
    this.nodes.length = 0;
    this.links.length = 0;
    this.series.length = 0;
    this.resetSimulation();
  },
  resetSimulation: function() {
    this.forcedStop = false;
    this.systemTemperature = 0;
    this.setMaxIterations();
    this.setTemperature();
    this.setDiffTemperature();
  },
  restartSimulation: function() {
    if (!this.simulation) {
      this.setInitialRendering(false);
      if (!this.enableSimulation) {
        this.setMaxIterations(1);
      } else {
        this.start();
      }
      if (this.chart) {
        this.chart.redraw();
      }
      this.setInitialRendering(true);
    } else {
      this.resetSimulation();
    }
  },
  setMaxIterations: function(maxIterations) {
    this.maxIterations = pick62(maxIterations, this.options.maxIterations);
  },
  setTemperature: function() {
    this.temperature = this.startTemperature = Math.sqrt(this.nodes.length);
  },
  setDiffTemperature: function() {
    this.diffTemperature = this.startTemperature / (this.options.maxIterations + 1);
  },
  setInitialRendering: function(enable) {
    this.initialRendering = enable;
  },
  createQuadTree: function() {
    this.quadTree = new Globals_default.QuadTree(this.box.left, this.box.top, this.box.width, this.box.height);
    this.quadTree.insertNodes(this.nodes);
  },
  initPositions: function() {
    var initialPositions = this.options.initialPositions;
    if (isFunction6(initialPositions)) {
      initialPositions.call(this);
      this.nodes.forEach(function(node) {
        if (!defined41(node.prevX)) {
          node.prevX = node.plotX;
        }
        if (!defined41(node.prevY)) {
          node.prevY = node.plotY;
        }
        node.dispX = 0;
        node.dispY = 0;
      });
    } else if (initialPositions === "circle") {
      this.setCircularPositions();
    } else {
      this.setRandomPositions();
    }
  },
  setCircularPositions: function() {
    var box = this.box, nodes = this.nodes, nodesLength = nodes.length + 1, angle = 2 * Math.PI / nodesLength, rootNodes = nodes.filter(function(node) {
      return node.linksTo.length === 0;
    }), sortedNodes = [], visitedNodes = {}, radius = this.options.initialPositionRadius;
    function addToNodes(node) {
      node.linksFrom.forEach(function(link) {
        if (!visitedNodes[link.toNode.id]) {
          visitedNodes[link.toNode.id] = true;
          sortedNodes.push(link.toNode);
          addToNodes(link.toNode);
        }
      });
    }
    rootNodes.forEach(function(rootNode) {
      sortedNodes.push(rootNode);
      addToNodes(rootNode);
    });
    if (!sortedNodes.length) {
      sortedNodes = nodes;
    } else {
      nodes.forEach(function(node) {
        if (sortedNodes.indexOf(node) === -1) {
          sortedNodes.push(node);
        }
      });
    }
    sortedNodes.forEach(function(node, index) {
      node.plotX = node.prevX = pick62(node.plotX, box.width / 2 + radius * Math.cos(index * angle));
      node.plotY = node.prevY = pick62(node.plotY, box.height / 2 + radius * Math.sin(index * angle));
      node.dispX = 0;
      node.dispY = 0;
    });
  },
  setRandomPositions: function() {
    var box = this.box, nodes = this.nodes, nodesLength = nodes.length + 1;
    function unrandom(n) {
      var rand = n * n / Math.PI;
      rand = rand - Math.floor(rand);
      return rand;
    }
    nodes.forEach(function(node, index) {
      node.plotX = node.prevX = pick62(node.plotX, box.width * unrandom(index));
      node.plotY = node.prevY = pick62(node.plotY, box.height * unrandom(nodesLength + index));
      node.dispX = 0;
      node.dispY = 0;
    });
  },
  force: function(name) {
    this.integration[name].apply(this, Array.prototype.slice.call(arguments, 1));
  },
  barycenterForces: function() {
    this.getBarycenter();
    this.force("barycenter");
  },
  getBarycenter: function() {
    var systemMass = 0, cx = 0, cy = 0;
    this.nodes.forEach(function(node) {
      cx += node.plotX * node.mass;
      cy += node.plotY * node.mass;
      systemMass += node.mass;
    });
    this.barycenter = {
      x: cx,
      y: cy,
      xFactor: cx / systemMass,
      yFactor: cy / systemMass
    };
    return this.barycenter;
  },
  barnesHutApproximation: function(node, quadNode) {
    var layout = this, distanceXY = layout.getDistXY(node, quadNode), distanceR = layout.vectorLength(distanceXY), goDeeper, force;
    if (node !== quadNode && distanceR !== 0) {
      if (quadNode.isInternal) {
        if (quadNode.boxSize / distanceR < layout.options.theta && distanceR !== 0) {
          force = layout.repulsiveForce(distanceR, layout.k);
          layout.force("repulsive", node, force * quadNode.mass, distanceXY, distanceR);
          goDeeper = false;
        } else {
          goDeeper = true;
        }
      } else {
        force = layout.repulsiveForce(distanceR, layout.k);
        layout.force("repulsive", node, force * quadNode.mass, distanceXY, distanceR);
      }
    }
    return goDeeper;
  },
  repulsiveForces: function() {
    var layout = this;
    if (layout.approximation === "barnes-hut") {
      layout.nodes.forEach(function(node) {
        layout.quadTree.visitNodeRecursive(null, function(quadNode) {
          return layout.barnesHutApproximation(node, quadNode);
        });
      });
    } else {
      layout.nodes.forEach(function(node) {
        layout.nodes.forEach(function(repNode) {
          var force, distanceR, distanceXY;
          if (node !== repNode && !node.fixedPosition) {
            distanceXY = layout.getDistXY(node, repNode);
            distanceR = layout.vectorLength(distanceXY);
            if (distanceR !== 0) {
              force = layout.repulsiveForce(distanceR, layout.k);
              layout.force("repulsive", node, force * repNode.mass, distanceXY, distanceR);
            }
          }
        });
      });
    }
  },
  attractiveForces: function() {
    var layout = this, distanceXY, distanceR, force;
    layout.links.forEach(function(link) {
      if (link.fromNode && link.toNode) {
        distanceXY = layout.getDistXY(link.fromNode, link.toNode);
        distanceR = layout.vectorLength(distanceXY);
        if (distanceR !== 0) {
          force = layout.attractiveForce(distanceR, layout.k);
          layout.force("attractive", link, force, distanceXY, distanceR);
        }
      }
    });
  },
  applyLimits: function() {
    var layout = this, nodes = layout.nodes;
    nodes.forEach(function(node) {
      if (node.fixedPosition) {
        return;
      }
      layout.integration.integrate(layout, node);
      layout.applyLimitBox(node, layout.box);
      node.dispX = 0;
      node.dispY = 0;
    });
  },
  applyLimitBox: function(node, box) {
    var radius = node.radius;
    node.plotX = clamp16(node.plotX, box.left + radius, box.width - radius);
    node.plotY = clamp16(node.plotY, box.top + radius, box.height - radius);
  },
  coolDown: function(temperature, temperatureStep, currentStep) {
    return temperature - temperatureStep * currentStep;
  },
  isStable: function() {
    return Math.abs(this.systemTemperature - this.prevSystemTemperature) < 1e-5 || this.temperature <= 0;
  },
  getSystemTemperature: function() {
    return this.nodes.reduce(function(value, node) {
      return value + node.temperature;
    }, 0);
  },
  vectorLength: function(vector) {
    return Math.sqrt(vector.x * vector.x + vector.y * vector.y);
  },
  getDistR: function(nodeA, nodeB) {
    var distance = this.getDistXY(nodeA, nodeB);
    return this.vectorLength(distance);
  },
  getDistXY: function(nodeA, nodeB) {
    var xDist = nodeA.plotX - nodeB.plotX, yDist = nodeA.plotY - nodeB.plotY;
    return {
      x: xDist,
      y: yDist,
      absX: Math.abs(xDist),
      absY: Math.abs(yDist)
    };
  }
});
addEvent40(Chart_default, "predraw", function() {
  if (this.graphLayoutsLookup) {
    this.graphLayoutsLookup.forEach(function(layout) {
      layout.stop();
    });
  }
});
addEvent40(Chart_default, "render", function() {
  var systemsStable, afterRender = false;
  function layoutStep(layout) {
    if (layout.maxIterations-- && isFinite(layout.temperature) && !layout.isStable() && !layout.enableSimulation) {
      if (layout.beforeStep) {
        layout.beforeStep();
      }
      layout.step();
      systemsStable = false;
      afterRender = true;
    }
  }
  if (this.graphLayoutsLookup) {
    setAnimation6(false, this);
    this.graphLayoutsLookup.forEach(function(layout) {
      layout.start();
    });
    while (!systemsStable) {
      systemsStable = true;
      this.graphLayoutsLookup.forEach(layoutStep);
    }
    if (afterRender) {
      this.series.forEach(function(s) {
        if (s && s.layout) {
          s.render();
        }
      });
    }
  }
});
addEvent40(Chart_default, "beforePrint", function() {
  if (this.graphLayoutsLookup) {
    this.graphLayoutsLookup.forEach(function(layout) {
      layout.updateSimulation(false);
    });
    this.redraw();
  }
});
addEvent40(Chart_default, "afterPrint", function() {
  if (this.graphLayoutsLookup) {
    this.graphLayoutsLookup.forEach(function(layout) {
      layout.updateSimulation();
    });
  }
  this.redraw();
});

// node_modules/highcharts/es-modules/Series/PackedBubble/PackedBubbleComposition.js
var Reingold = Globals_default.layouts["reingold-fruchterman"];
var addEvent41 = Utilities_default.addEvent;
var extendClass3 = Utilities_default.extendClass;
var pick63 = Utilities_default.pick;
Chart_default.prototype.getSelectedParentNodes = function() {
  var chart = this, series = chart.series, selectedParentsNodes = [];
  series.forEach(function(series2) {
    if (series2.parentNode && series2.parentNode.selected) {
      selectedParentsNodes.push(series2.parentNode);
    }
  });
  return selectedParentsNodes;
};
Globals_default.networkgraphIntegrations.packedbubble = {
  repulsiveForceFunction: function(d, k, node, repNode) {
    return Math.min(d, (node.marker.radius + repNode.marker.radius) / 2);
  },
  barycenter: function() {
    var layout = this, gravitationalConstant = layout.options.gravitationalConstant, box = layout.box, nodes = layout.nodes, centerX, centerY;
    nodes.forEach(function(node) {
      if (layout.options.splitSeries && !node.isParentNode) {
        centerX = node.series.parentNode.plotX;
        centerY = node.series.parentNode.plotY;
      } else {
        centerX = box.width / 2;
        centerY = box.height / 2;
      }
      if (!node.fixedPosition) {
        node.plotX -= (node.plotX - centerX) * gravitationalConstant / (node.mass * Math.sqrt(nodes.length));
        node.plotY -= (node.plotY - centerY) * gravitationalConstant / (node.mass * Math.sqrt(nodes.length));
      }
    });
  },
  repulsive: function(node, force, distanceXY, repNode) {
    var factor = force * this.diffTemperature / node.mass / node.degree, x = distanceXY.x * factor, y = distanceXY.y * factor;
    if (!node.fixedPosition) {
      node.plotX += x;
      node.plotY += y;
    }
    if (!repNode.fixedPosition) {
      repNode.plotX -= x;
      repNode.plotY -= y;
    }
  },
  integrate: Globals_default.networkgraphIntegrations.verlet.integrate,
  getK: Globals_default.noop
};
Globals_default.layouts.packedbubble = extendClass3(Reingold, {
  beforeStep: function() {
    if (this.options.marker) {
      this.series.forEach(function(series) {
        if (series) {
          series.calculateParentRadius();
        }
      });
    }
  },
  isStable: function() {
    var tempDiff = Math.abs(this.prevSystemTemperature - this.systemTemperature);
    var upScaledTemperature = 10 * this.systemTemperature / Math.sqrt(this.nodes.length);
    return Math.abs(upScaledTemperature) < 1 && tempDiff < 1e-5 || this.temperature <= 0;
  },
  setCircularPositions: function() {
    var layout = this, box = layout.box, nodes = layout.nodes, nodesLength = nodes.length + 1, angle = 2 * Math.PI / nodesLength, centerX, centerY, radius = layout.options.initialPositionRadius;
    nodes.forEach(function(node, index) {
      if (layout.options.splitSeries && !node.isParentNode) {
        centerX = node.series.parentNode.plotX;
        centerY = node.series.parentNode.plotY;
      } else {
        centerX = box.width / 2;
        centerY = box.height / 2;
      }
      node.plotX = node.prevX = pick63(node.plotX, centerX + radius * Math.cos(node.index || index * angle));
      node.plotY = node.prevY = pick63(node.plotY, centerY + radius * Math.sin(node.index || index * angle));
      node.dispX = 0;
      node.dispY = 0;
    });
  },
  repulsiveForces: function() {
    var layout = this, force, distanceR, distanceXY, bubblePadding = layout.options.bubblePadding;
    layout.nodes.forEach(function(node) {
      node.degree = node.mass;
      node.neighbours = 0;
      layout.nodes.forEach(function(repNode) {
        force = 0;
        if (node !== repNode && !node.fixedPosition && (layout.options.seriesInteraction || node.series === repNode.series)) {
          distanceXY = layout.getDistXY(node, repNode);
          distanceR = layout.vectorLength(distanceXY) - (node.marker.radius + repNode.marker.radius + bubblePadding);
          if (distanceR < 0) {
            node.degree += 0.01;
            node.neighbours++;
            force = layout.repulsiveForce(-distanceR / Math.sqrt(node.neighbours), layout.k, node, repNode);
          }
          layout.force("repulsive", node, force * repNode.mass, distanceXY, repNode, distanceR);
        }
      });
    });
  },
  applyLimitBox: function(node) {
    var layout = this, distanceXY, distanceR, factor = 0.01;
    if (layout.options.splitSeries && !node.isParentNode && layout.options.parentNodeLimit) {
      distanceXY = layout.getDistXY(node, node.series.parentNode);
      distanceR = node.series.parentNodeRadius - node.marker.radius - layout.vectorLength(distanceXY);
      if (distanceR < 0 && distanceR > -2 * node.marker.radius) {
        node.plotX -= distanceXY.x * factor;
        node.plotY -= distanceXY.y * factor;
      }
    }
    Reingold.prototype.applyLimitBox.apply(this, arguments);
  }
});
addEvent41(Chart_default, "beforeRedraw", function() {
  if (this.allDataPoints) {
    delete this.allDataPoints;
  }
});

// node_modules/highcharts/es-modules/Series/PackedBubble/PackedBubbleSeries.js
var __extends33 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var color9 = Color_default.parse;
var Series6 = SeriesRegistry_default.series;
var BubbleSeries3 = SeriesRegistry_default.seriesTypes.bubble;
var addEvent42 = Utilities_default.addEvent;
var clamp17 = Utilities_default.clamp;
var defined42 = Utilities_default.defined;
var extend59 = Utilities_default.extend;
var fireEvent27 = Utilities_default.fireEvent;
var isArray18 = Utilities_default.isArray;
var isNumber39 = Utilities_default.isNumber;
var merge55 = Utilities_default.merge;
var pick64 = Utilities_default.pick;
var dragNodesMixin = Globals_default.dragNodesMixin;
var PackedBubbleSeries = function(_super) {
  __extends33(PackedBubbleSeries2, _super);
  function PackedBubbleSeries2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.chart = void 0;
    _this.data = void 0;
    _this.layout = void 0;
    _this.options = void 0;
    _this.points = void 0;
    _this.xData = void 0;
    return _this;
  }
  PackedBubbleSeries2.prototype.accumulateAllPoints = function(series) {
    var chart = series.chart, allDataPoints = [], i, j;
    for (i = 0; i < chart.series.length; i++) {
      series = chart.series[i];
      if (series.is("packedbubble") && series.visible || !chart.options.chart.ignoreHiddenSeries) {
        for (j = 0; j < series.yData.length; j++) {
          allDataPoints.push([
            null,
            null,
            series.yData[j],
            series.index,
            j,
            {
              id: j,
              marker: {
                radius: 0
              }
            }
          ]);
        }
      }
    }
    return allDataPoints;
  };
  PackedBubbleSeries2.prototype.addLayout = function() {
    var series = this, layoutOptions = series.options.layoutAlgorithm, graphLayoutsStorage = series.chart.graphLayoutsStorage, graphLayoutsLookup = series.chart.graphLayoutsLookup, chartOptions = series.chart.options.chart, layout;
    if (!graphLayoutsStorage) {
      series.chart.graphLayoutsStorage = graphLayoutsStorage = {};
      series.chart.graphLayoutsLookup = graphLayoutsLookup = [];
    }
    layout = graphLayoutsStorage[layoutOptions.type];
    if (!layout) {
      layoutOptions.enableSimulation = !defined42(chartOptions.forExport) ? layoutOptions.enableSimulation : !chartOptions.forExport;
      graphLayoutsStorage[layoutOptions.type] = layout = new Globals_default.layouts[layoutOptions.type]();
      layout.init(layoutOptions);
      graphLayoutsLookup.splice(layout.index, 0, layout);
    }
    series.layout = layout;
    series.points.forEach(function(node) {
      node.mass = 2;
      node.degree = 1;
      node.collisionNmb = 1;
    });
    layout.setArea(0, 0, series.chart.plotWidth, series.chart.plotHeight);
    layout.addElementsToCollection([series], layout.series);
    layout.addElementsToCollection(series.points, layout.nodes);
  };
  PackedBubbleSeries2.prototype.addSeriesLayout = function() {
    var series = this, layoutOptions = series.options.layoutAlgorithm, graphLayoutsStorage = series.chart.graphLayoutsStorage, graphLayoutsLookup = series.chart.graphLayoutsLookup, parentNodeOptions = merge55(layoutOptions, layoutOptions.parentNodeOptions, {
      enableSimulation: series.layout.options.enableSimulation
    }), parentNodeLayout;
    parentNodeLayout = graphLayoutsStorage[layoutOptions.type + "-series"];
    if (!parentNodeLayout) {
      graphLayoutsStorage[layoutOptions.type + "-series"] = parentNodeLayout = new Globals_default.layouts[layoutOptions.type]();
      parentNodeLayout.init(parentNodeOptions);
      graphLayoutsLookup.splice(parentNodeLayout.index, 0, parentNodeLayout);
    }
    series.parentNodeLayout = parentNodeLayout;
    this.createParentNodes();
  };
  PackedBubbleSeries2.prototype.calculateParentRadius = function() {
    var series = this, bBox, parentPadding = 20, minParentRadius = 20;
    bBox = series.seriesBox();
    series.parentNodeRadius = clamp17(Math.sqrt(2 * series.parentNodeMass / Math.PI) + parentPadding, minParentRadius, bBox ? Math.max(Math.sqrt(Math.pow(bBox.width, 2) + Math.pow(bBox.height, 2)) / 2 + parentPadding, minParentRadius) : Math.sqrt(2 * series.parentNodeMass / Math.PI) + parentPadding);
    if (series.parentNode) {
      series.parentNode.marker.radius = series.parentNode.radius = series.parentNodeRadius;
    }
  };
  PackedBubbleSeries2.prototype.calculateZExtremes = function() {
    var chart = this.chart, zMin = this.options.zMin, zMax = this.options.zMax, valMin = Infinity, valMax = -Infinity;
    if (zMin && zMax) {
      return [zMin, zMax];
    }
    chart.series.forEach(function(s) {
      s.yData.forEach(function(p) {
        if (defined42(p)) {
          if (p > valMax) {
            valMax = p;
          }
          if (p < valMin) {
            valMin = p;
          }
        }
      });
    });
    zMin = pick64(zMin, valMin);
    zMax = pick64(zMax, valMax);
    return [zMin, zMax];
  };
  PackedBubbleSeries2.prototype.checkOverlap = function(bubble1, bubble2) {
    var diffX = bubble1[0] - bubble2[0], diffY = bubble1[1] - bubble2[1], sumRad = bubble1[2] + bubble2[2];
    return Math.sqrt(diffX * diffX + diffY * diffY) - Math.abs(sumRad) < -1e-3;
  };
  PackedBubbleSeries2.prototype.createParentNodes = function() {
    var series = this, chart = series.chart, parentNodeLayout = series.parentNodeLayout, nodeAdded, parentNode = series.parentNode, PackedBubblePoint2 = series.pointClass;
    series.parentNodeMass = 0;
    series.points.forEach(function(p) {
      series.parentNodeMass += Math.PI * Math.pow(p.marker.radius, 2);
    });
    series.calculateParentRadius();
    parentNodeLayout.nodes.forEach(function(node) {
      if (node.seriesIndex === series.index) {
        nodeAdded = true;
      }
    });
    parentNodeLayout.setArea(0, 0, chart.plotWidth, chart.plotHeight);
    if (!nodeAdded) {
      if (!parentNode) {
        parentNode = new PackedBubblePoint2().init(this, {
          mass: series.parentNodeRadius / 2,
          marker: {
            radius: series.parentNodeRadius
          },
          dataLabels: {
            inside: false
          },
          dataLabelOnNull: true,
          degree: series.parentNodeRadius,
          isParentNode: true,
          seriesIndex: series.index
        });
      }
      if (series.parentNode) {
        parentNode.plotX = series.parentNode.plotX;
        parentNode.plotY = series.parentNode.plotY;
      }
      series.parentNode = parentNode;
      parentNodeLayout.addElementsToCollection([series], parentNodeLayout.series);
      parentNodeLayout.addElementsToCollection([parentNode], parentNodeLayout.nodes);
    }
  };
  PackedBubbleSeries2.prototype.deferLayout = function() {
    var series = this, layoutOptions = series.options.layoutAlgorithm;
    if (!series.visible) {
      return;
    }
    series.addLayout();
    if (layoutOptions.splitSeries) {
      series.addSeriesLayout();
    }
  };
  PackedBubbleSeries2.prototype.destroy = function() {
    if (this.chart.graphLayoutsLookup) {
      this.chart.graphLayoutsLookup.forEach(function(layout) {
        layout.removeElementFromCollection(this, layout.series);
      }, this);
    }
    if (this.parentNode && this.parentNodeLayout) {
      this.parentNodeLayout.removeElementFromCollection(this.parentNode, this.parentNodeLayout.nodes);
      if (this.parentNode.dataLabel) {
        this.parentNode.dataLabel = this.parentNode.dataLabel.destroy();
      }
    }
    Series6.prototype.destroy.apply(this, arguments);
  };
  PackedBubbleSeries2.prototype.drawDataLabels = function() {
    var textPath = this.options.dataLabels.textPath, points = this.points;
    Series6.prototype.drawDataLabels.apply(this, arguments);
    if (this.parentNode) {
      this.parentNode.formatPrefix = "parentNode";
      this.points = [this.parentNode];
      this.options.dataLabels.textPath = this.options.dataLabels.parentNodeTextPath;
      Series6.prototype.drawDataLabels.apply(this, arguments);
      this.points = points;
      this.options.dataLabels.textPath = textPath;
    }
  };
  PackedBubbleSeries2.prototype.drawGraph = function() {
    if (!this.layout || !this.layout.options.splitSeries) {
      return;
    }
    var series = this, chart = series.chart, parentAttribs = {}, nodeMarker = this.layout.options.parentNodeOptions.marker, parentOptions = {
      fill: nodeMarker.fillColor || color9(series.color).brighten(0.4).get(),
      opacity: nodeMarker.fillOpacity,
      stroke: nodeMarker.lineColor || series.color,
      "stroke-width": nodeMarker.lineWidth
    };
    if (!this.parentNodesGroup) {
      series.parentNodesGroup = series.plotGroup("parentNodesGroup", "parentNode", series.visible ? "inherit" : "hidden", 0.1, chart.seriesGroup);
      series.group.attr({
        zIndex: 2
      });
    }
    this.calculateParentRadius();
    parentAttribs = merge55({
      x: series.parentNode.plotX - series.parentNodeRadius,
      y: series.parentNode.plotY - series.parentNodeRadius,
      width: series.parentNodeRadius * 2,
      height: series.parentNodeRadius * 2
    }, parentOptions);
    if (!series.parentNode.graphic) {
      series.graph = series.parentNode.graphic = chart.renderer.symbol(parentOptions.symbol).add(series.parentNodesGroup);
    }
    series.parentNode.graphic.attr(parentAttribs);
  };
  PackedBubbleSeries2.prototype.drawTracker = function() {
    var series = this, parentNode = series.parentNode;
    var dataLabels;
    _super.prototype.drawTracker.call(this);
    if (parentNode) {
      dataLabels = isArray18(parentNode.dataLabels) ? parentNode.dataLabels : parentNode.dataLabel ? [parentNode.dataLabel] : [];
      if (parentNode.graphic) {
        parentNode.graphic.element.point = parentNode;
      }
      dataLabels.forEach(function(dataLabel) {
        if (dataLabel.div) {
          dataLabel.div.point = parentNode;
        } else {
          dataLabel.element.point = parentNode;
        }
      });
    }
  };
  PackedBubbleSeries2.prototype.getPointRadius = function() {
    var series = this, chart = series.chart, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, seriesOptions = series.options, useSimulation = seriesOptions.useSimulation, smallestSize = Math.min(plotWidth, plotHeight), extremes = {}, radii = [], allDataPoints = chart.allDataPoints, minSize, maxSize, value, radius, zExtremes;
    ["minSize", "maxSize"].forEach(function(prop) {
      var length = parseInt(seriesOptions[prop], 10), isPercent = /%$/.test(seriesOptions[prop]);
      extremes[prop] = isPercent ? smallestSize * length / 100 : length * Math.sqrt(allDataPoints.length);
    });
    chart.minRadius = minSize = extremes.minSize / Math.sqrt(allDataPoints.length);
    chart.maxRadius = maxSize = extremes.maxSize / Math.sqrt(allDataPoints.length);
    zExtremes = useSimulation ? series.calculateZExtremes() : [minSize, maxSize];
    (allDataPoints || []).forEach(function(point, i) {
      value = useSimulation ? clamp17(point[2], zExtremes[0], zExtremes[1]) : point[2];
      radius = series.getRadius(zExtremes[0], zExtremes[1], minSize, maxSize, value);
      if (radius === 0) {
        radius = null;
      }
      allDataPoints[i][2] = radius;
      radii.push(radius);
    });
    series.radii = radii;
  };
  PackedBubbleSeries2.prototype.init = function() {
    Series6.prototype.init.apply(this, arguments);
    this.eventsToUnbind.push(addEvent42(this, "updatedData", function() {
      this.chart.series.forEach(function(s) {
        if (s.type === this.type) {
          s.isDirty = true;
        }
      }, this);
    }));
    return this;
  };
  PackedBubbleSeries2.prototype.onMouseUp = function(point) {
    if (point.fixedPosition && !point.removed) {
      var distanceXY_1, distanceR_1, layout_1 = this.layout, parentNodeLayout = this.parentNodeLayout;
      if (parentNodeLayout && layout_1.options.dragBetweenSeries) {
        parentNodeLayout.nodes.forEach(function(node) {
          if (point && point.marker && node !== point.series.parentNode) {
            distanceXY_1 = layout_1.getDistXY(point, node);
            distanceR_1 = layout_1.vectorLength(distanceXY_1) - node.marker.radius - point.marker.radius;
            if (distanceR_1 < 0) {
              node.series.addPoint(merge55(point.options, {
                plotX: point.plotX,
                plotY: point.plotY
              }), false);
              layout_1.removeElementFromCollection(point, layout_1.nodes);
              point.remove();
            }
          }
        });
      }
      dragNodesMixin.onMouseUp.apply(this, arguments);
    }
  };
  PackedBubbleSeries2.prototype.placeBubbles = function(allDataPoints) {
    var series = this, checkOverlap = series.checkOverlap, positionBubble = series.positionBubble, bubblePos = [], stage = 1, j = 0, k = 0, calculatedBubble, sortedArr, arr = [], i;
    sortedArr = allDataPoints.sort(function(a, b) {
      return b[2] - a[2];
    });
    if (sortedArr.length) {
      bubblePos.push([
        [
          0,
          0,
          sortedArr[0][2],
          sortedArr[0][3],
          sortedArr[0][4]
        ]
      ]);
      if (sortedArr.length > 1) {
        bubblePos.push([
          [
            0,
            0 - sortedArr[1][2] - sortedArr[0][2],
            sortedArr[1][2],
            sortedArr[1][3],
            sortedArr[1][4]
          ]
        ]);
        for (i = 2; i < sortedArr.length; i++) {
          sortedArr[i][2] = sortedArr[i][2] || 1;
          calculatedBubble = positionBubble(bubblePos[stage][j], bubblePos[stage - 1][k], sortedArr[i]);
          if (checkOverlap(calculatedBubble, bubblePos[stage][0])) {
            bubblePos.push([]);
            k = 0;
            bubblePos[stage + 1].push(positionBubble(bubblePos[stage][j], bubblePos[stage][0], sortedArr[i]));
            stage++;
            j = 0;
          } else if (stage > 1 && bubblePos[stage - 1][k + 1] && checkOverlap(calculatedBubble, bubblePos[stage - 1][k + 1])) {
            k++;
            bubblePos[stage].push(positionBubble(bubblePos[stage][j], bubblePos[stage - 1][k], sortedArr[i]));
            j++;
          } else {
            j++;
            bubblePos[stage].push(calculatedBubble);
          }
        }
      }
      series.chart.stages = bubblePos;
      series.chart.rawPositions = [].concat.apply([], bubblePos);
      series.resizeRadius();
      arr = series.chart.rawPositions;
    }
    return arr;
  };
  PackedBubbleSeries2.prototype.positionBubble = function(lastBubble, newOrigin, nextBubble) {
    var sqrt = Math.sqrt, asin = Math.asin, acos = Math.acos, pow = Math.pow, abs = Math.abs, distance = sqrt(pow(lastBubble[0] - newOrigin[0], 2) + pow(lastBubble[1] - newOrigin[1], 2)), alfa = acos((pow(distance, 2) + pow(nextBubble[2] + newOrigin[2], 2) - pow(nextBubble[2] + lastBubble[2], 2)) / (2 * (nextBubble[2] + newOrigin[2]) * distance)), beta = asin(abs(lastBubble[0] - newOrigin[0]) / distance), gamma = lastBubble[1] - newOrigin[1] < 0 ? 0 : Math.PI, delta = (lastBubble[0] - newOrigin[0]) * (lastBubble[1] - newOrigin[1]) < 0 ? 1 : -1, finalAngle = gamma + alfa + beta * delta, cosA = Math.cos(finalAngle), sinA = Math.sin(finalAngle), posX = newOrigin[0] + (newOrigin[2] + nextBubble[2]) * sinA, posY = newOrigin[1] - (newOrigin[2] + nextBubble[2]) * cosA;
    return [
      posX,
      posY,
      nextBubble[2],
      nextBubble[3],
      nextBubble[4]
    ];
  };
  PackedBubbleSeries2.prototype.render = function() {
    var series = this, dataLabels = [];
    Series6.prototype.render.apply(this, arguments);
    if (!series.options.dataLabels.allowOverlap) {
      series.data.forEach(function(point) {
        if (isArray18(point.dataLabels)) {
          point.dataLabels.forEach(function(dataLabel) {
            dataLabels.push(dataLabel);
          });
        }
      });
      if (series.options.useSimulation) {
        series.chart.hideOverlappingLabels(dataLabels);
      }
    }
  };
  PackedBubbleSeries2.prototype.resizeRadius = function() {
    var chart = this.chart, positions = chart.rawPositions, min = Math.min, max = Math.max, plotLeft = chart.plotLeft, plotTop = chart.plotTop, chartHeight = chart.plotHeight, chartWidth = chart.plotWidth, minX, maxX, minY, maxY, radius, bBox, spaceRatio, smallerDimension, i;
    minX = minY = Number.POSITIVE_INFINITY;
    maxX = maxY = Number.NEGATIVE_INFINITY;
    for (i = 0; i < positions.length; i++) {
      radius = positions[i][2];
      minX = min(minX, positions[i][0] - radius);
      maxX = max(maxX, positions[i][0] + radius);
      minY = min(minY, positions[i][1] - radius);
      maxY = max(maxY, positions[i][1] + radius);
    }
    bBox = [maxX - minX, maxY - minY];
    spaceRatio = [
      (chartWidth - plotLeft) / bBox[0],
      (chartHeight - plotTop) / bBox[1]
    ];
    smallerDimension = min.apply([], spaceRatio);
    if (Math.abs(smallerDimension - 1) > 1e-10) {
      for (i = 0; i < positions.length; i++) {
        positions[i][2] *= smallerDimension;
      }
      this.placeBubbles(positions);
    } else {
      chart.diffY = chartHeight / 2 + plotTop - minY - (maxY - minY) / 2;
      chart.diffX = chartWidth / 2 + plotLeft - minX - (maxX - minX) / 2;
    }
  };
  PackedBubbleSeries2.prototype.seriesBox = function() {
    var series = this, chart = series.chart, data = series.data, max = Math.max, min = Math.min, radius, bBox = [
      chart.plotLeft,
      chart.plotLeft + chart.plotWidth,
      chart.plotTop,
      chart.plotTop + chart.plotHeight
    ];
    data.forEach(function(p) {
      if (defined42(p.plotX) && defined42(p.plotY) && p.marker.radius) {
        radius = p.marker.radius;
        bBox[0] = min(bBox[0], p.plotX - radius);
        bBox[1] = max(bBox[1], p.plotX + radius);
        bBox[2] = min(bBox[2], p.plotY - radius);
        bBox[3] = max(bBox[3], p.plotY + radius);
      }
    });
    return isNumber39(bBox.width / bBox.height) ? bBox : null;
  };
  PackedBubbleSeries2.prototype.setVisible = function() {
    var series = this;
    Series6.prototype.setVisible.apply(series, arguments);
    if (series.parentNodeLayout && series.graph) {
      if (series.visible) {
        series.graph.show();
        if (series.parentNode.dataLabel) {
          series.parentNode.dataLabel.show();
        }
      } else {
        series.graph.hide();
        series.parentNodeLayout.removeElementFromCollection(series.parentNode, series.parentNodeLayout.nodes);
        if (series.parentNode.dataLabel) {
          series.parentNode.dataLabel.hide();
        }
      }
    } else if (series.layout) {
      if (series.visible) {
        series.layout.addElementsToCollection(series.points, series.layout.nodes);
      } else {
        series.points.forEach(function(node) {
          series.layout.removeElementFromCollection(node, series.layout.nodes);
        });
      }
    }
  };
  PackedBubbleSeries2.prototype.translate = function() {
    var series = this, chart = series.chart, data = series.data, index = series.index, point, radius, positions, i, useSimulation = series.options.useSimulation;
    series.processedXData = series.xData;
    series.generatePoints();
    if (!defined42(chart.allDataPoints)) {
      chart.allDataPoints = series.accumulateAllPoints(series);
      series.getPointRadius();
    }
    if (useSimulation) {
      positions = chart.allDataPoints;
    } else {
      positions = series.placeBubbles(chart.allDataPoints);
      series.options.draggable = false;
    }
    for (i = 0; i < positions.length; i++) {
      if (positions[i][3] === index) {
        point = data[positions[i][4]];
        radius = pick64(positions[i][2], void 0);
        if (!useSimulation) {
          point.plotX = positions[i][0] - chart.plotLeft + chart.diffX;
          point.plotY = positions[i][1] - chart.plotTop + chart.diffY;
        }
        if (isNumber39(radius)) {
          point.marker = extend59(point.marker, {
            radius,
            width: 2 * radius,
            height: 2 * radius
          });
          point.radius = radius;
        }
      }
    }
    if (useSimulation) {
      series.deferLayout();
    }
    fireEvent27(series, "afterTranslate");
  };
  PackedBubbleSeries2.defaultOptions = merge55(BubbleSeries3.defaultOptions, {
    minSize: "10%",
    maxSize: "50%",
    sizeBy: "area",
    zoneAxis: "y",
    crisp: false,
    tooltip: {
      pointFormat: "Value: {point.value}"
    },
    draggable: true,
    useSimulation: true,
    parentNode: {
      allowPointSelect: false
    },
    dataLabels: {
      formatter: function() {
        var numberFormatter = this.series.chart.numberFormatter;
        var value = this.point.value;
        return isNumber39(value) ? numberFormatter(value, -1) : "";
      },
      parentNodeFormatter: function() {
        return this.name;
      },
      parentNodeTextPath: {
        enabled: true
      },
      padding: 0,
      style: {
        transition: "opacity 2000ms"
      }
    },
    layoutAlgorithm: {
      initialPositions: "circle",
      initialPositionRadius: 20,
      bubblePadding: 5,
      parentNodeLimit: false,
      seriesInteraction: true,
      dragBetweenSeries: false,
      parentNodeOptions: {
        maxIterations: 400,
        gravitationalConstant: 0.03,
        maxSpeed: 50,
        initialPositionRadius: 100,
        seriesInteraction: true,
        marker: {
          fillColor: null,
          fillOpacity: 1,
          lineWidth: 1,
          lineColor: null,
          symbol: "circle"
        }
      },
      enableSimulation: true,
      type: "packedbubble",
      integration: "packedbubble",
      maxIterations: 1e3,
      splitSeries: false,
      maxSpeed: 5,
      gravitationalConstant: 0.01,
      friction: -0.981
    }
  });
  return PackedBubbleSeries2;
}(BubbleSeries3);
extend59(PackedBubbleSeries.prototype, {
  alignDataLabel: Series6.prototype.alignDataLabel,
  axisTypes: [],
  directTouch: true,
  forces: ["barycenter", "repulsive"],
  hasDraggableNodes: true,
  isCartesian: false,
  noSharedTooltip: true,
  onMouseDown: dragNodesMixin.onMouseDown,
  onMouseMove: dragNodesMixin.onMouseMove,
  pointArrayMap: ["value"],
  pointClass: PackedBubblePoint_default,
  pointValKey: "value",
  redrawHalo: dragNodesMixin.redrawHalo,
  requireSorting: false,
  searchPoint: Globals_default.noop,
  trackerGroups: ["group", "dataLabelsGroup", "parentNodesGroup"]
});
SeriesRegistry_default.registerSeriesType("packedbubble", PackedBubbleSeries);

// node_modules/highcharts/es-modules/Series/Polygon/PolygonSeries.js
var __extends34 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var noop17 = Globals_default.noop;
var Series7 = SeriesRegistry_default.series;
var _a6 = SeriesRegistry_default.seriesTypes;
var AreaSeries2 = _a6.area;
var LineSeries4 = _a6.line;
var ScatterSeries3 = _a6.scatter;
var extend60 = Utilities_default.extend;
var merge56 = Utilities_default.merge;
var PolygonSeries = function(_super) {
  __extends34(PolygonSeries2, _super);
  function PolygonSeries2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.data = void 0;
    _this.options = void 0;
    _this.points = void 0;
    return _this;
  }
  PolygonSeries2.prototype.getGraphPath = function() {
    var graphPath = LineSeries4.prototype.getGraphPath.call(this), i = graphPath.length + 1;
    while (i--) {
      if ((i === graphPath.length || graphPath[i][0] === "M") && i > 0) {
        graphPath.splice(i, 0, ["Z"]);
      }
    }
    this.areaPath = graphPath;
    return graphPath;
  };
  PolygonSeries2.prototype.drawGraph = function() {
    this.options.fillColor = this.color;
    AreaSeries2.prototype.drawGraph.call(this);
  };
  PolygonSeries2.defaultOptions = merge56(ScatterSeries3.defaultOptions, {
    marker: {
      enabled: false,
      states: {
        hover: {
          enabled: false
        }
      }
    },
    stickyTracking: false,
    tooltip: {
      followPointer: true,
      pointFormat: ""
    },
    trackByArea: true
  });
  return PolygonSeries2;
}(ScatterSeries3);
extend60(PolygonSeries.prototype, {
  type: "polygon",
  drawLegendSymbol: LegendSymbol_default.drawRectangle,
  drawTracker: Series7.prototype.drawTracker,
  setStackedPoints: noop17
});
SeriesRegistry_default.registerSeriesType("polygon", PolygonSeries);

// node_modules/highcharts/es-modules/Core/Axis/WaterfallAxis.js
var addEvent43 = Utilities_default.addEvent;
var objectEach27 = Utilities_default.objectEach;
var WaterfallAxis;
(function(WaterfallAxis2) {
  var Composition = function() {
    function Composition2(axis) {
      this.axis = axis;
      this.stacks = {
        changed: false
      };
    }
    Composition2.prototype.renderStackTotals = function() {
      var yAxis = this.axis, waterfallStacks = yAxis.waterfall.stacks, stackTotalGroup = yAxis.stacking && yAxis.stacking.stackTotalGroup, dummyStackItem = new Stacking_default(yAxis, yAxis.options.stackLabels, false, 0, void 0);
      this.dummyStackItem = dummyStackItem;
      objectEach27(waterfallStacks, function(type) {
        objectEach27(type, function(stackItem) {
          dummyStackItem.total = stackItem.stackTotal;
          if (stackItem.label) {
            dummyStackItem.label = stackItem.label;
          }
          Stacking_default.prototype.render.call(dummyStackItem, stackTotalGroup);
          stackItem.label = dummyStackItem.label;
          delete dummyStackItem.label;
        });
      });
      dummyStackItem.total = null;
    };
    return Composition2;
  }();
  WaterfallAxis2.Composition = Composition;
  function compose(AxisClass, ChartClass) {
    addEvent43(AxisClass, "init", onInit);
    addEvent43(AxisClass, "afterBuildStacks", onAfterBuildStacks);
    addEvent43(AxisClass, "afterRender", onAfterRender);
    addEvent43(ChartClass, "beforeRedraw", onBeforeRedraw);
  }
  WaterfallAxis2.compose = compose;
  function onAfterBuildStacks() {
    var axis = this;
    var stacks = axis.waterfall.stacks;
    if (stacks) {
      stacks.changed = false;
      delete stacks.alreadyChanged;
    }
  }
  function onAfterRender() {
    var axis = this;
    var stackLabelOptions = axis.options.stackLabels;
    if (stackLabelOptions && stackLabelOptions.enabled && axis.waterfall.stacks) {
      axis.waterfall.renderStackTotals();
    }
  }
  function onBeforeRedraw() {
    var axes = this.axes, series = this.series, i = series.length;
    while (i--) {
      if (series[i].options.stacking) {
        axes.forEach(function(axis) {
          if (!axis.isXAxis) {
            axis.waterfall.stacks.changed = true;
          }
        });
        i = 0;
      }
    }
  }
  function onInit() {
    var axis = this;
    if (!axis.waterfall) {
      axis.waterfall = new Composition(axis);
    }
  }
})(WaterfallAxis || (WaterfallAxis = {}));
var WaterfallAxis_default = WaterfallAxis;

// node_modules/highcharts/es-modules/Series/Waterfall/WaterfallPoint.js
var __extends35 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var isNumber40 = Utilities_default.isNumber;
var WaterfallPoint = function(_super) {
  __extends35(WaterfallPoint2, _super);
  function WaterfallPoint2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.options = void 0;
    _this.series = void 0;
    return _this;
  }
  WaterfallPoint2.prototype.getClassName = function() {
    var className = Point_default.prototype.getClassName.call(this);
    if (this.isSum) {
      className += " highcharts-sum";
    } else if (this.isIntermediateSum) {
      className += " highcharts-intermediate-sum";
    }
    return className;
  };
  WaterfallPoint2.prototype.isValid = function() {
    return isNumber40(this.y) || this.isSum || Boolean(this.isIntermediateSum);
  };
  return WaterfallPoint2;
}(ColumnSeries_default.prototype.pointClass);
var WaterfallPoint_default = WaterfallPoint;

// node_modules/highcharts/es-modules/Series/Waterfall/WaterfallSeries.js
var __extends36 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var _a7 = SeriesRegistry_default.seriesTypes;
var ColumnSeries10 = _a7.column;
var LineSeries5 = _a7.line;
var arrayMax10 = Utilities_default.arrayMax;
var arrayMin9 = Utilities_default.arrayMin;
var correctFloat12 = Utilities_default.correctFloat;
var extend61 = Utilities_default.extend;
var isNumber41 = Utilities_default.isNumber;
var merge57 = Utilities_default.merge;
var objectEach28 = Utilities_default.objectEach;
var pick65 = Utilities_default.pick;
function ownProp(obj, key) {
  return Object.hasOwnProperty.call(obj, key);
}
var WaterfallSeries = function(_super) {
  __extends36(WaterfallSeries2, _super);
  function WaterfallSeries2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.chart = void 0;
    _this.data = void 0;
    _this.options = void 0;
    _this.points = void 0;
    _this.stackedYNeg = void 0;
    _this.stackedYPos = void 0;
    _this.stackKey = void 0;
    _this.xData = void 0;
    _this.yAxis = void 0;
    _this.yData = void 0;
    return _this;
  }
  WaterfallSeries2.prototype.generatePoints = function() {
    var point, len, i, y;
    ColumnSeries10.prototype.generatePoints.apply(this);
    for (i = 0, len = this.points.length; i < len; i++) {
      point = this.points[i];
      y = this.processedYData[i];
      if (point.isIntermediateSum || point.isSum) {
        point.y = correctFloat12(y);
      }
    }
  };
  WaterfallSeries2.prototype.translate = function() {
    var series = this, options = series.options, yAxis = series.yAxis, y, minPointLength = pick65(options.minPointLength, 5), halfMinPointLength = minPointLength / 2, threshold = options.threshold || 0, previousY = threshold, previousIntermediate = threshold, stacking = options.stacking, actualStack = yAxis.waterfall.stacks[series.stackKey], total, yPos, hPos;
    ColumnSeries10.prototype.translate.apply(series);
    var points = series.points;
    for (var i = 0; i < points.length; i++) {
      var point = points[i];
      var yValue = series.processedYData[i];
      var shapeArgs = point.shapeArgs;
      if (!shapeArgs || !isNumber41(yValue)) {
        continue;
      }
      var range = [0, yValue];
      var pointY = point.y;
      if (stacking) {
        if (actualStack) {
          var actualStackX = actualStack[i];
          if (stacking === "overlap") {
            total = actualStackX.stackState[actualStackX.stateIndex--];
            y = pointY >= 0 ? total : total - pointY;
            if (ownProp(actualStackX, "absolutePos")) {
              delete actualStackX.absolutePos;
            }
            if (ownProp(actualStackX, "absoluteNeg")) {
              delete actualStackX.absoluteNeg;
            }
          } else {
            if (pointY >= 0) {
              total = actualStackX.threshold + actualStackX.posTotal;
              actualStackX.posTotal -= pointY;
              y = total;
            } else {
              total = actualStackX.threshold + actualStackX.negTotal;
              actualStackX.negTotal -= pointY;
              y = total - pointY;
            }
            if (!actualStackX.posTotal) {
              if (ownProp(actualStackX, "absolutePos")) {
                actualStackX.posTotal = actualStackX.absolutePos;
                delete actualStackX.absolutePos;
              }
            }
            if (!actualStackX.negTotal) {
              if (ownProp(actualStackX, "absoluteNeg")) {
                actualStackX.negTotal = actualStackX.absoluteNeg;
                delete actualStackX.absoluteNeg;
              }
            }
          }
          if (!point.isSum) {
            actualStackX.connectorThreshold = actualStackX.threshold + actualStackX.stackTotal;
          }
          if (yAxis.reversed) {
            yPos = pointY >= 0 ? y - pointY : y + pointY;
            hPos = y;
          } else {
            yPos = y;
            hPos = y - pointY;
          }
          point.below = yPos <= threshold;
          shapeArgs.y = yAxis.translate(yPos, false, true, false, true) || 0;
          shapeArgs.height = Math.abs(shapeArgs.y - (yAxis.translate(hPos, false, true, false, true) || 0));
          var dummyStackItem = yAxis.waterfall.dummyStackItem;
          if (dummyStackItem) {
            dummyStackItem.x = i;
            dummyStackItem.label = actualStack[i].label;
            dummyStackItem.setOffset(series.pointXOffset || 0, series.barW || 0, series.stackedYNeg[i], series.stackedYPos[i]);
          }
        }
      } else {
        y = Math.max(previousY, previousY + pointY) + range[0];
        shapeArgs.y = yAxis.translate(y, false, true, false, true) || 0;
        if (point.isSum) {
          shapeArgs.y = yAxis.translate(range[1], false, true, false, true) || 0;
          shapeArgs.height = Math.min(yAxis.translate(range[0], false, true, false, true) || 0, yAxis.len) - shapeArgs.y;
          point.below = range[1] <= threshold;
        } else if (point.isIntermediateSum) {
          if (pointY >= 0) {
            yPos = range[1] + previousIntermediate;
            hPos = previousIntermediate;
          } else {
            yPos = previousIntermediate;
            hPos = range[1] + previousIntermediate;
          }
          if (yAxis.reversed) {
            yPos ^= hPos;
            hPos ^= yPos;
            yPos ^= hPos;
          }
          shapeArgs.y = yAxis.translate(yPos, false, true, false, true) || 0;
          shapeArgs.height = Math.abs(shapeArgs.y - Math.min(yAxis.translate(hPos, false, true, false, true) || 0, yAxis.len));
          previousIntermediate += range[1];
          point.below = yPos <= threshold;
        } else {
          shapeArgs.height = yValue > 0 ? (yAxis.translate(previousY, false, true, false, true) || 0) - shapeArgs.y : (yAxis.translate(previousY, false, true, false, true) || 0) - (yAxis.translate(previousY - yValue, false, true, false, true) || 0);
          previousY += yValue;
          point.below = previousY < threshold;
        }
        if (shapeArgs.height < 0) {
          shapeArgs.y += shapeArgs.height;
          shapeArgs.height *= -1;
        }
      }
      point.plotY = shapeArgs.y = Math.round(shapeArgs.y || 0) - series.borderWidth % 2 / 2;
      shapeArgs.height = Math.max(Math.round(shapeArgs.height || 0), 1e-3);
      point.yBottom = shapeArgs.y + shapeArgs.height;
      if (shapeArgs.height <= minPointLength && !point.isNull) {
        shapeArgs.height = minPointLength;
        shapeArgs.y -= halfMinPointLength;
        point.plotY = shapeArgs.y;
        if (point.y < 0) {
          point.minPointLengthOffset = -halfMinPointLength;
        } else {
          point.minPointLengthOffset = halfMinPointLength;
        }
      } else {
        if (point.isNull) {
          shapeArgs.width = 0;
        }
        point.minPointLengthOffset = 0;
      }
      var tooltipY = point.plotY + (point.negative ? shapeArgs.height : 0);
      if (point.below) {
        point.plotY += shapeArgs.height;
      }
      if (point.tooltipPos) {
        if (series.chart.inverted) {
          point.tooltipPos[0] = yAxis.len - tooltipY;
        } else {
          point.tooltipPos[1] = tooltipY;
        }
      }
    }
  };
  WaterfallSeries2.prototype.processData = function(force) {
    var series = this, options = series.options, yData = series.yData, points = options.data, point, dataLength = yData.length, threshold = options.threshold || 0, subSum, sum, dataMin, dataMax, y, i;
    sum = subSum = dataMin = dataMax = 0;
    for (i = 0; i < dataLength; i++) {
      y = yData[i];
      point = points && points[i] ? points[i] : {};
      if (y === "sum" || point.isSum) {
        yData[i] = correctFloat12(sum);
      } else if (y === "intermediateSum" || point.isIntermediateSum) {
        yData[i] = correctFloat12(subSum);
        subSum = 0;
      } else {
        sum += y;
        subSum += y;
      }
      dataMin = Math.min(sum, dataMin);
      dataMax = Math.max(sum, dataMax);
    }
    _super.prototype.processData.call(this, force);
    if (!options.stacking) {
      series.dataMin = dataMin + threshold;
      series.dataMax = dataMax;
    }
    return;
  };
  WaterfallSeries2.prototype.toYData = function(pt) {
    if (pt.isSum) {
      return "sum";
    }
    if (pt.isIntermediateSum) {
      return "intermediateSum";
    }
    return pt.y;
  };
  WaterfallSeries2.prototype.updateParallelArrays = function(point, i) {
    _super.prototype.updateParallelArrays.call(this, point, i);
    if (this.yData[0] === "sum" || this.yData[0] === "intermediateSum") {
      this.yData[0] = null;
    }
  };
  WaterfallSeries2.prototype.pointAttribs = function(point, state) {
    var upColor = this.options.upColor, attr10;
    if (upColor && !point.options.color) {
      point.color = point.y > 0 ? upColor : null;
    }
    attr10 = ColumnSeries10.prototype.pointAttribs.call(this, point, state);
    delete attr10.dashstyle;
    return attr10;
  };
  WaterfallSeries2.prototype.getGraphPath = function() {
    return [["M", 0, 0]];
  };
  WaterfallSeries2.prototype.getCrispPath = function() {
    var data = this.data, yAxis = this.yAxis, length = data.length, graphNormalizer = Math.round(this.graph.strokeWidth()) % 2 / 2, borderNormalizer = Math.round(this.borderWidth) % 2 / 2, reversedXAxis = this.xAxis.reversed, reversedYAxis = this.yAxis.reversed, stacking = this.options.stacking, path = [], connectorThreshold, prevStack, prevStackX, prevPoint, yPos, isPos, prevArgs, pointArgs, i;
    for (i = 1; i < length; i++) {
      pointArgs = data[i].shapeArgs;
      prevPoint = data[i - 1];
      prevArgs = data[i - 1].shapeArgs;
      prevStack = yAxis.waterfall.stacks[this.stackKey];
      isPos = prevPoint.y > 0 ? -prevArgs.height : 0;
      if (prevStack && prevArgs && pointArgs) {
        prevStackX = prevStack[i - 1];
        if (stacking) {
          connectorThreshold = prevStackX.connectorThreshold;
          yPos = Math.round(yAxis.translate(connectorThreshold, 0, 1, 0, 1) + (reversedYAxis ? isPos : 0)) - graphNormalizer;
        } else {
          yPos = prevArgs.y + prevPoint.minPointLengthOffset + borderNormalizer - graphNormalizer;
        }
        path.push([
          "M",
          (prevArgs.x || 0) + (reversedXAxis ? 0 : prevArgs.width || 0),
          yPos
        ], [
          "L",
          (pointArgs.x || 0) + (reversedXAxis ? pointArgs.width || 0 : 0),
          yPos
        ]);
      }
      if (prevArgs && path.length && (!stacking && prevPoint.y < 0 && !reversedYAxis || prevPoint.y > 0 && reversedYAxis)) {
        var nextLast = path[path.length - 2];
        if (nextLast && typeof nextLast[2] === "number") {
          nextLast[2] += prevArgs.height || 0;
        }
        var last = path[path.length - 1];
        if (last && typeof last[2] === "number") {
          last[2] += prevArgs.height || 0;
        }
      }
    }
    return path;
  };
  WaterfallSeries2.prototype.drawGraph = function() {
    LineSeries5.prototype.drawGraph.call(this);
    this.graph.attr({
      d: this.getCrispPath()
    });
  };
  WaterfallSeries2.prototype.setStackedPoints = function() {
    var series = this, options = series.options, waterfallStacks = series.yAxis.waterfall.stacks, seriesThreshold = options.threshold, stackThreshold = seriesThreshold || 0, interSum = stackThreshold, stackKey = series.stackKey, xData = series.xData, xLength = xData.length, actualStack, actualStackX, totalYVal, actualSum, prevSum, statesLen, posTotal, negTotal, xPoint, yVal, x, alreadyChanged, changed;
    function calculateStackState(firstS, nextS, sInx, sOff) {
      if (!statesLen) {
        actualStackX.stackState[0] = firstS;
        statesLen = actualStackX.stackState.length;
      } else {
        for (sInx; sInx < statesLen; sInx++) {
          actualStackX.stackState[sInx] += sOff;
        }
      }
      actualStackX.stackState.push(actualStackX.stackState[statesLen - 1] + nextS);
    }
    series.yAxis.stacking.usePercentage = false;
    totalYVal = actualSum = prevSum = stackThreshold;
    if (series.visible || !series.chart.options.chart.ignoreHiddenSeries) {
      changed = waterfallStacks.changed;
      alreadyChanged = waterfallStacks.alreadyChanged;
      if (alreadyChanged && alreadyChanged.indexOf(stackKey) < 0) {
        changed = true;
      }
      if (!waterfallStacks[stackKey]) {
        waterfallStacks[stackKey] = {};
      }
      actualStack = waterfallStacks[stackKey];
      for (var i = 0; i < xLength; i++) {
        x = xData[i];
        if (!actualStack[x] || changed) {
          actualStack[x] = {
            negTotal: 0,
            posTotal: 0,
            stackTotal: 0,
            threshold: 0,
            stateIndex: 0,
            stackState: [],
            label: changed && actualStack[x] ? actualStack[x].label : void 0
          };
        }
        actualStackX = actualStack[x];
        yVal = series.yData[i];
        if (yVal >= 0) {
          actualStackX.posTotal += yVal;
        } else {
          actualStackX.negTotal += yVal;
        }
        xPoint = options.data[i];
        posTotal = actualStackX.absolutePos = actualStackX.posTotal;
        negTotal = actualStackX.absoluteNeg = actualStackX.negTotal;
        actualStackX.stackTotal = posTotal + negTotal;
        statesLen = actualStackX.stackState.length;
        if (xPoint && xPoint.isIntermediateSum) {
          calculateStackState(prevSum, actualSum, 0, prevSum);
          prevSum = actualSum;
          actualSum = seriesThreshold;
          stackThreshold ^= interSum;
          interSum ^= stackThreshold;
          stackThreshold ^= interSum;
        } else if (xPoint && xPoint.isSum) {
          calculateStackState(seriesThreshold, totalYVal, statesLen);
          stackThreshold = seriesThreshold;
        } else {
          calculateStackState(stackThreshold, yVal, 0, totalYVal);
          if (xPoint) {
            totalYVal += yVal;
            actualSum += yVal;
          }
        }
        actualStackX.stateIndex++;
        actualStackX.threshold = stackThreshold;
        stackThreshold += actualStackX.stackTotal;
      }
      waterfallStacks.changed = false;
      if (!waterfallStacks.alreadyChanged) {
        waterfallStacks.alreadyChanged = [];
      }
      waterfallStacks.alreadyChanged.push(stackKey);
    }
  };
  WaterfallSeries2.prototype.getExtremes = function() {
    var stacking = this.options.stacking, yAxis, waterfallStacks, stackedYNeg, stackedYPos;
    if (stacking) {
      yAxis = this.yAxis;
      waterfallStacks = yAxis.waterfall.stacks;
      stackedYNeg = this.stackedYNeg = [];
      stackedYPos = this.stackedYPos = [];
      if (stacking === "overlap") {
        objectEach28(waterfallStacks[this.stackKey], function(stackX) {
          stackedYNeg.push(arrayMin9(stackX.stackState));
          stackedYPos.push(arrayMax10(stackX.stackState));
        });
      } else {
        objectEach28(waterfallStacks[this.stackKey], function(stackX) {
          stackedYNeg.push(stackX.negTotal + stackX.threshold);
          stackedYPos.push(stackX.posTotal + stackX.threshold);
        });
      }
      return {
        dataMin: arrayMin9(stackedYNeg),
        dataMax: arrayMax10(stackedYPos)
      };
    }
    return {
      dataMin: this.dataMin,
      dataMax: this.dataMax
    };
  };
  WaterfallSeries2.defaultOptions = merge57(ColumnSeries10.defaultOptions, {
    dataLabels: {
      inside: true
    },
    lineWidth: 1,
    lineColor: Palette_default.neutralColor80,
    dashStyle: "Dot",
    borderColor: Palette_default.neutralColor80,
    states: {
      hover: {
        lineWidthPlus: 0
      }
    }
  });
  return WaterfallSeries2;
}(ColumnSeries10);
extend61(WaterfallSeries.prototype, {
  getZonesGraphs: LineSeries5.prototype.getZonesGraphs,
  pointValKey: "y",
  showLine: true,
  pointClass: WaterfallPoint_default
});
SeriesRegistry_default.registerSeriesType("waterfall", WaterfallSeries);
WaterfallAxis_default.compose(Axis_default, Chart_default);

// node_modules/highcharts/es-modules/Extensions/Polar.js
var animObject11 = AnimationUtilities_default.animObject;
var seriesTypes5 = SeriesRegistry_default.seriesTypes;
var addEvent44 = Utilities_default.addEvent;
var defined43 = Utilities_default.defined;
var find15 = Utilities_default.find;
var isNumber42 = Utilities_default.isNumber;
var pick66 = Utilities_default.pick;
var splat15 = Utilities_default.splat;
var uniqueKey7 = Utilities_default.uniqueKey;
var wrap6 = Utilities_default.wrap;
var seriesProto4 = Series_default.prototype;
var pointerProto = Pointer_default.prototype;
var columnProto4;
var arearangeProto2;
seriesProto4.searchPointByAngle = function(e2) {
  var series = this, chart = series.chart, xAxis = series.xAxis, center = xAxis.pane.center, plotX = e2.chartX - center[0] - chart.plotLeft, plotY = e2.chartY - center[1] - chart.plotTop;
  return this.searchKDTree({
    clientX: 180 + Math.atan2(plotX, plotY) * (-180 / Math.PI)
  });
};
seriesProto4.getConnectors = function(segment, index, calculateNeighbours, connectEnds) {
  var i, prevPointInd, nextPointInd, previousPoint, nextPoint, previousX, previousY, nextX, nextY, plotX, plotY, ret, smoothing = 1.5, denom = smoothing + 1, leftContX, leftContY, rightContX, rightContY, dLControlPoint, dRControlPoint, leftContAngle, rightContAngle, jointAngle, addedNumber = connectEnds ? 1 : 0;
  if (index >= 0 && index <= segment.length - 1) {
    i = index;
  } else if (index < 0) {
    i = segment.length - 1 + index;
  } else {
    i = 0;
  }
  prevPointInd = i - 1 < 0 ? segment.length - (1 + addedNumber) : i - 1;
  nextPointInd = i + 1 > segment.length - 1 ? addedNumber : i + 1;
  previousPoint = segment[prevPointInd];
  nextPoint = segment[nextPointInd];
  previousX = previousPoint.plotX;
  previousY = previousPoint.plotY;
  nextX = nextPoint.plotX;
  nextY = nextPoint.plotY;
  plotX = segment[i].plotX;
  plotY = segment[i].plotY;
  leftContX = (smoothing * plotX + previousX) / denom;
  leftContY = (smoothing * plotY + previousY) / denom;
  rightContX = (smoothing * plotX + nextX) / denom;
  rightContY = (smoothing * plotY + nextY) / denom;
  dLControlPoint = Math.sqrt(Math.pow(leftContX - plotX, 2) + Math.pow(leftContY - plotY, 2));
  dRControlPoint = Math.sqrt(Math.pow(rightContX - plotX, 2) + Math.pow(rightContY - plotY, 2));
  leftContAngle = Math.atan2(leftContY - plotY, leftContX - plotX);
  rightContAngle = Math.atan2(rightContY - plotY, rightContX - plotX);
  jointAngle = Math.PI / 2 + (leftContAngle + rightContAngle) / 2;
  if (Math.abs(leftContAngle - jointAngle) > Math.PI / 2) {
    jointAngle -= Math.PI;
  }
  leftContX = plotX + Math.cos(jointAngle) * dLControlPoint;
  leftContY = plotY + Math.sin(jointAngle) * dLControlPoint;
  rightContX = plotX + Math.cos(Math.PI + jointAngle) * dRControlPoint;
  rightContY = plotY + Math.sin(Math.PI + jointAngle) * dRControlPoint;
  ret = {
    rightContX,
    rightContY,
    leftContX,
    leftContY,
    plotX,
    plotY
  };
  if (calculateNeighbours) {
    ret.prevPointCont = this.getConnectors(segment, prevPointInd, false, connectEnds);
  }
  return ret;
};
seriesProto4.toXY = function(point) {
  var chart = this.chart, xAxis = this.xAxis, yAxis = this.yAxis, plotX = point.plotX, plotY = point.plotY, series = point.series, inverted = chart.inverted, pointY = point.y, radius = inverted ? plotX : yAxis.len - plotY, clientX;
  if (inverted && series && !series.isRadialBar) {
    point.plotY = plotY = typeof pointY === "number" ? yAxis.translate(pointY) || 0 : 0;
  }
  point.rectPlotX = plotX;
  point.rectPlotY = plotY;
  if (yAxis.center) {
    radius += yAxis.center[3] / 2;
  }
  if (isNumber42(plotY)) {
    var xy = inverted ? yAxis.postTranslate(plotY, radius) : xAxis.postTranslate(plotX, radius);
    point.plotX = point.polarPlotX = xy.x - chart.plotLeft;
    point.plotY = point.polarPlotY = xy.y - chart.plotTop;
  }
  if (this.kdByAngle) {
    clientX = (plotX / Math.PI * 180 + xAxis.pane.options.startAngle) % 360;
    if (clientX < 0) {
      clientX += 360;
    }
    point.clientX = clientX;
  } else {
    point.clientX = point.plotX;
  }
};
if (seriesTypes5.spline) {
  wrap6(seriesTypes5.spline.prototype, "getPointSpline", function(proceed, segment, point, i) {
    var ret, connectors;
    if (this.chart.polar) {
      if (!i) {
        ret = ["M", point.plotX, point.plotY];
      } else {
        connectors = this.getConnectors(segment, i, true, this.connectEnds);
        var rightContX = connectors.prevPointCont && connectors.prevPointCont.rightContX;
        var rightContY = connectors.prevPointCont && connectors.prevPointCont.rightContY;
        ret = [
          "C",
          isNumber42(rightContX) ? rightContX : connectors.plotX,
          isNumber42(rightContY) ? rightContY : connectors.plotY,
          isNumber42(connectors.leftContX) ? connectors.leftContX : connectors.plotX,
          isNumber42(connectors.leftContY) ? connectors.leftContY : connectors.plotY,
          connectors.plotX,
          connectors.plotY
        ];
      }
    } else {
      ret = proceed.call(this, segment, point, i);
    }
    return ret;
  });
  if (seriesTypes5.areasplinerange) {
    seriesTypes5.areasplinerange.prototype.getPointSpline = seriesTypes5.spline.prototype.getPointSpline;
  }
}
addEvent44(Series_default, "afterTranslate", function() {
  var series = this;
  var chart = series.chart;
  if (chart.polar && series.xAxis) {
    series.kdByAngle = chart.tooltip && chart.tooltip.shared;
    if (series.kdByAngle) {
      series.searchPoint = series.searchPointByAngle;
    } else {
      series.options.findNearestPointBy = "xy";
    }
    if (!series.preventPostTranslate) {
      var points = series.points;
      var i = points.length;
      while (i--) {
        series.toXY(points[i]);
        if (!chart.hasParallelCoordinates && !series.yAxis.reversed && points[i].y < series.yAxis.min) {
          points[i].isNull = true;
        }
      }
    }
    if (!this.hasClipCircleSetter) {
      this.hasClipCircleSetter = !!series.eventsToUnbind.push(addEvent44(series, "afterRender", function() {
        var circ;
        if (chart.polar) {
          circ = this.yAxis.pane.center;
          if (!this.clipCircle) {
            this.clipCircle = chart.renderer.clipCircle(circ[0], circ[1], circ[2] / 2, circ[3] / 2);
          } else {
            this.clipCircle.animate({
              x: circ[0],
              y: circ[1],
              r: circ[2] / 2,
              innerR: circ[3] / 2
            });
          }
          this.group.clip(this.clipCircle);
          this.setClip = Globals_default.noop;
        }
      }));
    }
  }
}, { order: 2 });
wrap6(seriesTypes5.line.prototype, "getGraphPath", function(proceed, points) {
  var series = this, i, firstValid, popLastPoint;
  if (this.chart.polar) {
    points = points || this.points;
    for (i = 0; i < points.length; i++) {
      if (!points[i].isNull) {
        firstValid = i;
        break;
      }
    }
    if (this.options.connectEnds !== false && typeof firstValid !== "undefined") {
      this.connectEnds = true;
      points.splice(points.length, 0, points[firstValid]);
      popLastPoint = true;
    }
    points.forEach(function(point) {
      if (typeof point.polarPlotY === "undefined") {
        series.toXY(point);
      }
    });
  }
  var ret = proceed.apply(this, [].slice.call(arguments, 1));
  if (popLastPoint) {
    points.pop();
  }
  return ret;
});
var polarAnimate = function(proceed, init) {
  var series = this, chart = this.chart, animation = this.options.animation, group = this.group, markerGroup = this.markerGroup, center = this.xAxis.center, plotLeft = chart.plotLeft, plotTop = chart.plotTop, attribs, paneInnerR, graphic, shapeArgs, r, innerR;
  if (chart.polar) {
    if (series.isRadialBar) {
      if (!init) {
        series.startAngleRad = pick66(series.translatedThreshold, series.xAxis.startAngleRad);
        Globals_default.seriesTypes.pie.prototype.animate.call(series, init);
      }
    } else {
      if (chart.renderer.isSVG) {
        animation = animObject11(animation);
        if (series.is("column")) {
          if (!init) {
            paneInnerR = center[3] / 2;
            series.points.forEach(function(point) {
              graphic = point.graphic;
              shapeArgs = point.shapeArgs;
              r = shapeArgs && shapeArgs.r;
              innerR = shapeArgs && shapeArgs.innerR;
              if (graphic && shapeArgs) {
                graphic.attr({
                  r: paneInnerR,
                  innerR: paneInnerR
                });
                graphic.animate({
                  r,
                  innerR
                }, series.options.animation);
              }
            });
          }
        } else {
          if (init) {
            attribs = {
              translateX: center[0] + plotLeft,
              translateY: center[1] + plotTop,
              scaleX: 1e-3,
              scaleY: 1e-3
            };
            group.attr(attribs);
            if (markerGroup) {
              markerGroup.attr(attribs);
            }
          } else {
            attribs = {
              translateX: plotLeft,
              translateY: plotTop,
              scaleX: 1,
              scaleY: 1
            };
            group.animate(attribs, animation);
            if (markerGroup) {
              markerGroup.animate(attribs, animation);
            }
          }
        }
      }
    }
  } else {
    proceed.call(this, init);
  }
};
wrap6(seriesProto4, "animate", polarAnimate);
if (seriesTypes5.column) {
  arearangeProto2 = seriesTypes5.arearange.prototype;
  columnProto4 = seriesTypes5.column.prototype;
  columnProto4.polarArc = function(low, high, start, end) {
    var center = this.xAxis.center, len = this.yAxis.len, paneInnerR = center[3] / 2, r = len - high + paneInnerR, innerR = len - pick66(low, len) + paneInnerR;
    if (this.yAxis.reversed) {
      if (r < 0) {
        r = paneInnerR;
      }
      if (innerR < 0) {
        innerR = paneInnerR;
      }
    }
    return {
      x: center[0],
      y: center[1],
      r,
      innerR,
      start,
      end
    };
  };
  wrap6(columnProto4, "animate", polarAnimate);
  wrap6(columnProto4, "translate", function(proceed) {
    var series = this, options = series.options, threshold = options.threshold, stacking = options.stacking, chart = series.chart, xAxis = series.xAxis, yAxis = series.yAxis, reversed = yAxis.reversed, center = yAxis.center, startAngleRad = xAxis.startAngleRad, endAngleRad = xAxis.endAngleRad, visibleRange = endAngleRad - startAngleRad, thresholdAngleRad, points, point, i, yMin, yMax, start, end, tooltipPos, pointX, pointY, stackValues, stack, barX, innerR, r;
    series.preventPostTranslate = true;
    proceed.call(series);
    if (xAxis.isRadial) {
      points = series.points;
      i = points.length;
      yMin = yAxis.translate(yAxis.min);
      yMax = yAxis.translate(yAxis.max);
      threshold = options.threshold || 0;
      if (chart.inverted) {
        if (isNumber42(threshold)) {
          thresholdAngleRad = yAxis.translate(threshold);
          if (defined43(thresholdAngleRad)) {
            if (thresholdAngleRad < 0) {
              thresholdAngleRad = 0;
            } else if (thresholdAngleRad > visibleRange) {
              thresholdAngleRad = visibleRange;
            }
            series.translatedThreshold = thresholdAngleRad + startAngleRad;
          }
        }
      }
      while (i--) {
        point = points[i];
        barX = point.barX;
        pointX = point.x;
        pointY = point.y;
        point.shapeType = "arc";
        if (chart.inverted) {
          point.plotY = yAxis.translate(pointY);
          if (stacking && yAxis.stacking) {
            stack = yAxis.stacking.stacks[(pointY < 0 ? "-" : "") + series.stackKey];
            if (series.visible && stack && stack[pointX]) {
              if (!point.isNull) {
                stackValues = stack[pointX].points[series.getStackIndicator(void 0, pointX, series.index).key];
                start = yAxis.translate(stackValues[0]);
                end = yAxis.translate(stackValues[1]);
                if (defined43(start)) {
                  start = Utilities_default.clamp(start, 0, visibleRange);
                }
              }
            }
          } else {
            start = thresholdAngleRad;
            end = point.plotY;
          }
          if (start > end) {
            end = [start, start = end][0];
          }
          if (!reversed) {
            if (start < yMin) {
              start = yMin;
            } else if (end > yMax) {
              end = yMax;
            } else if (end < yMin || start > yMax) {
              start = end = 0;
            }
          } else {
            if (end > yMin) {
              end = yMin;
            } else if (start < yMax) {
              start = yMax;
            } else if (start > yMin || end < yMax) {
              start = end = visibleRange;
            }
          }
          if (yAxis.min > yAxis.max) {
            start = end = reversed ? visibleRange : 0;
          }
          start += startAngleRad;
          end += startAngleRad;
          if (center) {
            point.barX = barX += center[3] / 2;
          }
          innerR = Math.max(barX, 0);
          r = Math.max(barX + point.pointWidth, 0);
          point.shapeArgs = {
            x: center && center[0],
            y: center && center[1],
            r,
            innerR,
            start,
            end
          };
          point.opacity = start === end ? 0 : void 0;
          point.plotY = (defined43(series.translatedThreshold) && (start < series.translatedThreshold ? start : end)) - startAngleRad;
        } else {
          start = barX + startAngleRad;
          point.shapeArgs = series.polarArc(point.yBottom, point.plotY, start, start + point.pointWidth);
        }
        series.toXY(point);
        if (chart.inverted) {
          tooltipPos = yAxis.postTranslate(point.rectPlotY, barX + point.pointWidth / 2);
          point.tooltipPos = [
            tooltipPos.x - chart.plotLeft,
            tooltipPos.y - chart.plotTop
          ];
        } else {
          point.tooltipPos = [point.plotX, point.plotY];
        }
        if (center) {
          point.ttBelow = point.plotY > center[1];
        }
      }
    }
  });
  columnProto4.findAlignments = function(angle, options) {
    var align, verticalAlign;
    if (options.align === null) {
      if (angle > 20 && angle < 160) {
        align = "left";
      } else if (angle > 200 && angle < 340) {
        align = "right";
      } else {
        align = "center";
      }
      options.align = align;
    }
    if (options.verticalAlign === null) {
      if (angle < 45 || angle > 315) {
        verticalAlign = "bottom";
      } else if (angle > 135 && angle < 225) {
        verticalAlign = "top";
      } else {
        verticalAlign = "middle";
      }
      options.verticalAlign = verticalAlign;
    }
    return options;
  };
  if (arearangeProto2) {
    arearangeProto2.findAlignments = columnProto4.findAlignments;
  }
  wrap6(columnProto4, "alignDataLabel", function(proceed, point, dataLabel, options, alignTo, isNew) {
    var chart = this.chart, inside = pick66(options.inside, !!this.options.stacking), angle, shapeArgs, labelPos;
    if (chart.polar) {
      angle = point.rectPlotX / Math.PI * 180;
      if (!chart.inverted) {
        if (this.findAlignments) {
          options = this.findAlignments(angle, options);
        }
      } else {
        this.forceDL = chart.isInsidePlot(point.plotX, Math.round(point.plotY));
        if (inside && point.shapeArgs) {
          shapeArgs = point.shapeArgs;
          labelPos = this.yAxis.postTranslate(((shapeArgs.start || 0) + (shapeArgs.end || 0)) / 2 - this.xAxis.startAngleRad, point.barX + point.pointWidth / 2);
          alignTo = {
            x: labelPos.x - chart.plotLeft,
            y: labelPos.y - chart.plotTop
          };
        } else if (point.tooltipPos) {
          alignTo = {
            x: point.tooltipPos[0],
            y: point.tooltipPos[1]
          };
        }
        options.align = pick66(options.align, "center");
        options.verticalAlign = pick66(options.verticalAlign, "middle");
      }
      seriesProto4.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);
      if (this.isRadialBar && point.shapeArgs && point.shapeArgs.start === point.shapeArgs.end) {
        dataLabel.hide(true);
      }
    } else {
      proceed.call(this, point, dataLabel, options, alignTo, isNew);
    }
  });
}
wrap6(pointerProto, "getCoordinates", function(proceed, e2) {
  var chart = this.chart, ret = {
    xAxis: [],
    yAxis: []
  };
  if (chart.polar) {
    chart.axes.forEach(function(axis) {
      var isXAxis = axis.isXAxis, center = axis.center, x, y;
      if (axis.coll === "colorAxis") {
        return;
      }
      x = e2.chartX - center[0] - chart.plotLeft;
      y = e2.chartY - center[1] - chart.plotTop;
      ret[isXAxis ? "xAxis" : "yAxis"].push({
        axis,
        value: axis.translate(isXAxis ? Math.PI - Math.atan2(x, y) : Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)), true)
      });
    });
  } else {
    ret = proceed.call(this, e2);
  }
  return ret;
});
SVGRenderer_default.prototype.clipCircle = function(x, y, r, innerR) {
  var wrapper, id = uniqueKey7(), clipPath = this.createElement("clipPath").attr({
    id
  }).add(this.defs);
  wrapper = innerR ? this.arc(x, y, r, innerR, 0, 2 * Math.PI).add(clipPath) : this.circle(x, y, r).add(clipPath);
  wrapper.id = id;
  wrapper.clipPath = clipPath;
  return wrapper;
};
addEvent44(Chart_default, "getAxes", function() {
  if (!this.pane) {
    this.pane = [];
  }
  this.options.pane = splat15(this.options.pane);
  this.options.pane.forEach(function(paneOptions) {
    new Pane_default(paneOptions, this);
  }, this);
});
addEvent44(Chart_default, "afterDrawChartBox", function() {
  this.pane.forEach(function(pane) {
    pane.render();
  });
});
addEvent44(Series_default, "afterInit", function() {
  var chart = this.chart;
  if (chart.inverted && chart.polar) {
    this.isRadialSeries = true;
    if (this.is("column")) {
      this.isRadialBar = true;
    }
  }
});
wrap6(Chart_default.prototype, "get", function(proceed, id) {
  return find15(this.pane || [], function(pane) {
    return pane.options.id === id;
  }) || proceed.call(this, id);
});

// node_modules/highcharts/es-modules/masters/highcharts-more.src.js
var G4 = Globals_default;
RadialAxis_default.compose(G4.Axis, G4.Tick);
BubbleSeries_default.compose(G4.Chart, G4.Legend, G4.Series);

// node_modules/highcharts/es-modules/Extensions/Math3D.js
var pick67 = Utilities_default.pick;
var deg2rad6 = Globals_default.deg2rad;
function rotate3D(x, y, z, angles) {
  return {
    x: angles.cosB * x - angles.sinB * z,
    y: -angles.sinA * angles.sinB * x + angles.cosA * y - angles.cosB * angles.sinA * z,
    z: angles.cosA * angles.sinB * x + angles.sinA * y + angles.cosA * angles.cosB * z
  };
}
function perspective3D(coordinate, origin, distance) {
  var projection = distance > 0 && distance < Number.POSITIVE_INFINITY ? distance / (coordinate.z + origin.z + distance) : 1;
  return {
    x: coordinate.x * projection,
    y: coordinate.y * projection
  };
}
Globals_default.perspective3D = perspective3D;
function perspective(points, chart, insidePlotArea, useInvertedPersp) {
  var options3d = chart.options.chart.options3d, inverted = pick67(useInvertedPersp, insidePlotArea ? chart.inverted : false), origin = {
    x: chart.plotWidth / 2,
    y: chart.plotHeight / 2,
    z: options3d.depth / 2,
    vd: pick67(options3d.depth, 1) * pick67(options3d.viewDistance, 0)
  }, scale = chart.scale3d || 1, beta = deg2rad6 * options3d.beta * (inverted ? -1 : 1), alpha = deg2rad6 * options3d.alpha * (inverted ? -1 : 1), angles = {
    cosA: Math.cos(alpha),
    cosB: Math.cos(-beta),
    sinA: Math.sin(alpha),
    sinB: Math.sin(-beta)
  };
  if (!insidePlotArea) {
    origin.x += chart.plotLeft;
    origin.y += chart.plotTop;
  }
  return points.map(function(point) {
    var rotated = rotate3D((inverted ? point.y : point.x) - origin.x, (inverted ? point.x : point.y) - origin.y, (point.z || 0) - origin.z, angles), coordinate = perspective3D(rotated, origin, origin.vd);
    coordinate.x = coordinate.x * scale + origin.x;
    coordinate.y = coordinate.y * scale + origin.y;
    coordinate.z = rotated.z * scale + origin.z;
    return {
      x: inverted ? coordinate.y : coordinate.x,
      y: inverted ? coordinate.x : coordinate.y,
      z: coordinate.z
    };
  });
}
Globals_default.perspective = perspective;
function pointCameraDistance(coordinates, chart) {
  var options3d = chart.options.chart.options3d, cameraPosition = {
    x: chart.plotWidth / 2,
    y: chart.plotHeight / 2,
    z: pick67(options3d.depth, 1) * pick67(options3d.viewDistance, 0) + options3d.depth
  }, distance = Math.sqrt(Math.pow(cameraPosition.x - pick67(coordinates.plotX, coordinates.x), 2) + Math.pow(cameraPosition.y - pick67(coordinates.plotY, coordinates.y), 2) + Math.pow(cameraPosition.z - pick67(coordinates.plotZ, coordinates.z), 2));
  return distance;
}
Globals_default.pointCameraDistance = pointCameraDistance;
function shapeArea(vertexes) {
  var area = 0, i, j;
  for (i = 0; i < vertexes.length; i++) {
    j = (i + 1) % vertexes.length;
    area += vertexes[i].x * vertexes[j].y - vertexes[j].x * vertexes[i].y;
  }
  return area / 2;
}
Globals_default.shapeArea = shapeArea;
function shapeArea3D(vertexes, chart, insidePlotArea) {
  return shapeArea(perspective(vertexes, chart, insidePlotArea));
}
Globals_default.shapeArea3d = shapeArea3D;
var mathModule = {
  perspective,
  perspective3D,
  pointCameraDistance,
  shapeArea,
  shapeArea3D
};
var Math3D_default = mathModule;

// node_modules/highcharts/es-modules/Core/Renderer/SVG/SVGElement3D.js
var color10 = Color_default.parse;
var defined44 = Utilities_default.defined;
var merge58 = Utilities_default.merge;
var objectEach29 = Utilities_default.objectEach;
var pick68 = Utilities_default.pick;
var SVGElement3D = {};
SVGElement3D.base = {
  initArgs: function(args) {
    var elem3d = this, renderer = elem3d.renderer, paths = renderer[elem3d.pathType + "Path"](args), zIndexes = paths.zIndexes;
    elem3d.parts.forEach(function(part) {
      elem3d[part] = renderer.path(paths[part]).attr({
        "class": "highcharts-3d-" + part,
        zIndex: zIndexes[part] || 0
      }).add(elem3d);
    });
    elem3d.attr({
      "stroke-linejoin": "round",
      zIndex: zIndexes.group
    });
    elem3d.originalDestroy = elem3d.destroy;
    elem3d.destroy = elem3d.destroyParts;
    elem3d.forcedSides = paths.forcedSides;
  },
  singleSetterForParts: function(prop, val, values, verb, duration, complete) {
    var elem3d = this, newAttr = {}, optionsToApply = [null, null, verb || "attr", duration, complete], hasZIndexes = values && values.zIndexes;
    if (!values) {
      newAttr[prop] = val;
      optionsToApply[0] = newAttr;
    } else {
      if (hasZIndexes && hasZIndexes.group) {
        this.attr({
          zIndex: hasZIndexes.group
        });
      }
      objectEach29(values, function(partVal, part) {
        newAttr[part] = {};
        newAttr[part][prop] = partVal;
        if (hasZIndexes) {
          newAttr[part].zIndex = values.zIndexes[part] || 0;
        }
      });
      optionsToApply[1] = newAttr;
    }
    return elem3d.processParts.apply(elem3d, optionsToApply);
  },
  processParts: function(props, partsProps, verb, duration, complete) {
    var elem3d = this;
    elem3d.parts.forEach(function(part) {
      if (partsProps) {
        props = pick68(partsProps[part], false);
      }
      if (props !== false) {
        elem3d[part][verb](props, duration, complete);
      }
    });
    return elem3d;
  },
  destroyParts: function() {
    this.processParts(null, null, "destroy");
    return this.originalDestroy();
  }
};
SVGElement3D.cuboid = merge58(SVGElement3D.base, {
  parts: ["front", "top", "side"],
  pathType: "cuboid",
  attr: function(args, val, complete, continueAnimation) {
    if (typeof args === "string" && typeof val !== "undefined") {
      var key = args;
      args = {};
      args[key] = val;
    }
    if (args.shapeArgs || defined44(args.x)) {
      return this.singleSetterForParts("d", null, this.renderer[this.pathType + "Path"](args.shapeArgs || args));
    }
    return SVGElement_default.prototype.attr.call(this, args, void 0, complete, continueAnimation);
  },
  animate: function(args, duration, complete) {
    if (defined44(args.x) && defined44(args.y)) {
      var paths = this.renderer[this.pathType + "Path"](args), forcedSides = paths.forcedSides;
      this.singleSetterForParts("d", null, paths, "animate", duration, complete);
      this.attr({
        zIndex: paths.zIndexes.group
      });
      if (forcedSides !== this.forcedSides) {
        this.forcedSides = forcedSides;
        SVGElement3D.cuboid.fillSetter.call(this, this.fill);
      }
    } else {
      SVGElement_default.prototype.animate.call(this, args, duration, complete);
    }
    return this;
  },
  fillSetter: function(fill) {
    var elem3d = this;
    elem3d.forcedSides = elem3d.forcedSides || [];
    elem3d.singleSetterForParts("fill", null, {
      front: fill,
      top: color10(fill).brighten(elem3d.forcedSides.indexOf("top") >= 0 ? 0 : 0.1).get(),
      side: color10(fill).brighten(elem3d.forcedSides.indexOf("side") >= 0 ? 0 : -0.1).get()
    });
    elem3d.color = elem3d.fill = fill;
    return elem3d;
  }
});
var SVGElement3D_default = SVGElement3D;

// node_modules/highcharts/es-modules/Core/Renderer/SVG/SVGRenderer3D.js
var __extends37 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var animObject12 = AnimationUtilities_default.animObject;
var color11 = Color_default.parse;
var charts6 = Globals_default.charts;
var deg2rad7 = Globals_default.deg2rad;
var perspective2 = Math3D_default.perspective;
var shapeArea2 = Math3D_default.shapeArea;
var defined45 = Utilities_default.defined;
var extend62 = Utilities_default.extend;
var merge59 = Utilities_default.merge;
var pick69 = Utilities_default.pick;
var cos = Math.cos;
var sin = Math.sin;
var PI = Math.PI;
var dFactor = 4 * (Math.sqrt(2) - 1) / 3 / (PI / 2);
var SVGRenderer3D = function(_super) {
  __extends37(SVGRenderer3D2, _super);
  function SVGRenderer3D2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SVGRenderer3D2.compose = function(SVGRendererClass) {
    var svgRendererProto = SVGRendererClass.prototype, svgRenderer3dProto = SVGRenderer3D2.prototype;
    svgRendererProto.elements3d = SVGElement3D_default;
    svgRendererProto.arc3d = svgRenderer3dProto.arc3d;
    svgRendererProto.arc3dPath = svgRenderer3dProto.arc3dPath;
    svgRendererProto.cuboid = svgRenderer3dProto.cuboid;
    svgRendererProto.cuboidPath = svgRenderer3dProto.cuboidPath;
    svgRendererProto.element3d = svgRenderer3dProto.element3d;
    svgRendererProto.face3d = svgRenderer3dProto.face3d;
    svgRendererProto.polyhedron = svgRenderer3dProto.polyhedron;
    svgRendererProto.toLinePath = svgRenderer3dProto.toLinePath;
    svgRendererProto.toLineSegments = svgRenderer3dProto.toLineSegments;
  };
  SVGRenderer3D2.curveTo = function(cx, cy, rx, ry, start, end, dx, dy) {
    var result2 = [], arcAngle = end - start;
    if (end > start && end - start > Math.PI / 2 + 1e-4) {
      result2 = result2.concat(this.curveTo(cx, cy, rx, ry, start, start + Math.PI / 2, dx, dy));
      result2 = result2.concat(this.curveTo(cx, cy, rx, ry, start + Math.PI / 2, end, dx, dy));
      return result2;
    }
    if (end < start && start - end > Math.PI / 2 + 1e-4) {
      result2 = result2.concat(this.curveTo(cx, cy, rx, ry, start, start - Math.PI / 2, dx, dy));
      result2 = result2.concat(this.curveTo(cx, cy, rx, ry, start - Math.PI / 2, end, dx, dy));
      return result2;
    }
    return [[
      "C",
      cx + rx * Math.cos(start) - rx * dFactor * arcAngle * Math.sin(start) + dx,
      cy + ry * Math.sin(start) + ry * dFactor * arcAngle * Math.cos(start) + dy,
      cx + rx * Math.cos(end) + rx * dFactor * arcAngle * Math.sin(end) + dx,
      cy + ry * Math.sin(end) - ry * dFactor * arcAngle * Math.cos(end) + dy,
      cx + rx * Math.cos(end) + dx,
      cy + ry * Math.sin(end) + dy
    ]];
  };
  SVGRenderer3D2.prototype.toLinePath = function(points, closed) {
    var result2 = [];
    points.forEach(function(point) {
      result2.push(["L", point.x, point.y]);
    });
    if (points.length) {
      result2[0][0] = "M";
      if (closed) {
        result2.push(["Z"]);
      }
    }
    return result2;
  };
  SVGRenderer3D2.prototype.toLineSegments = function(points) {
    var result2 = [], m = true;
    points.forEach(function(point) {
      result2.push(m ? ["M", point.x, point.y] : ["L", point.x, point.y]);
      m = !m;
    });
    return result2;
  };
  SVGRenderer3D2.prototype.face3d = function(args) {
    var renderer = this, ret = this.createElement("path");
    ret.vertexes = [];
    ret.insidePlotArea = false;
    ret.enabled = true;
    ret.attr = function(hash) {
      if (typeof hash === "object" && (defined45(hash.enabled) || defined45(hash.vertexes) || defined45(hash.insidePlotArea))) {
        this.enabled = pick69(hash.enabled, this.enabled);
        this.vertexes = pick69(hash.vertexes, this.vertexes);
        this.insidePlotArea = pick69(hash.insidePlotArea, this.insidePlotArea);
        delete hash.enabled;
        delete hash.vertexes;
        delete hash.insidePlotArea;
        var chart = charts6[renderer.chartIndex], vertexes2d = perspective2(this.vertexes, chart, this.insidePlotArea), path = renderer.toLinePath(vertexes2d, true), area = shapeArea2(vertexes2d);
        hash.d = path;
        hash.visibility = this.enabled && area > 0 ? "visible" : "hidden";
      }
      return SVGElement_default.prototype.attr.apply(this, arguments);
    };
    ret.animate = function(params) {
      if (typeof params === "object" && (defined45(params.enabled) || defined45(params.vertexes) || defined45(params.insidePlotArea))) {
        this.enabled = pick69(params.enabled, this.enabled);
        this.vertexes = pick69(params.vertexes, this.vertexes);
        this.insidePlotArea = pick69(params.insidePlotArea, this.insidePlotArea);
        delete params.enabled;
        delete params.vertexes;
        delete params.insidePlotArea;
        var chart = charts6[renderer.chartIndex], vertexes2d = perspective2(this.vertexes, chart, this.insidePlotArea), path = renderer.toLinePath(vertexes2d, true), area = shapeArea2(vertexes2d), visibility = this.enabled && area > 0 ? "visible" : "hidden";
        params.d = path;
        this.attr("visibility", visibility);
      }
      return SVGElement_default.prototype.animate.apply(this, arguments);
    };
    return ret.attr(args);
  };
  SVGRenderer3D2.prototype.polyhedron = function(args) {
    var renderer = this, result2 = this.g(), destroy = result2.destroy;
    if (!this.styledMode) {
      result2.attr({
        "stroke-linejoin": "round"
      });
    }
    result2.faces = [];
    result2.destroy = function() {
      for (var i = 0; i < result2.faces.length; i++) {
        result2.faces[i].destroy();
      }
      return destroy.call(this);
    };
    result2.attr = function(hash, val, complete, continueAnimation) {
      if (typeof hash === "object" && defined45(hash.faces)) {
        while (result2.faces.length > hash.faces.length) {
          result2.faces.pop().destroy();
        }
        while (result2.faces.length < hash.faces.length) {
          result2.faces.push(renderer.face3d().add(result2));
        }
        for (var i = 0; i < hash.faces.length; i++) {
          if (renderer.styledMode) {
            delete hash.faces[i].fill;
          }
          result2.faces[i].attr(hash.faces[i], null, complete, continueAnimation);
        }
        delete hash.faces;
      }
      return SVGElement_default.prototype.attr.apply(this, arguments);
    };
    result2.animate = function(params, duration, complete) {
      if (params && params.faces) {
        while (result2.faces.length > params.faces.length) {
          result2.faces.pop().destroy();
        }
        while (result2.faces.length < params.faces.length) {
          result2.faces.push(renderer.face3d().add(result2));
        }
        for (var i = 0; i < params.faces.length; i++) {
          result2.faces[i].animate(params.faces[i], duration, complete);
        }
        delete params.faces;
      }
      return SVGElement_default.prototype.animate.apply(this, arguments);
    };
    return result2.attr(args);
  };
  SVGRenderer3D2.prototype.element3d = function(type, shapeArgs) {
    var ret = this.g();
    extend62(ret, this.elements3d[type]);
    ret.initArgs(shapeArgs);
    return ret;
  };
  SVGRenderer3D2.prototype.cuboid = function(shapeArgs) {
    return this.element3d("cuboid", shapeArgs);
  };
  SVGRenderer3D2.prototype.cuboidPath = function(shapeArgs) {
    var x = shapeArgs.x || 0, y = shapeArgs.y || 0, z = shapeArgs.z || 0, h = shapeArgs.height || 0, w2 = shapeArgs.width || 0, d = shapeArgs.depth || 0, chart = charts6[this.chartIndex], front, back, top, bottom, left, right, shape, path1, path2, path3, isFront, isTop, isRight, options3d = chart.options.chart.options3d, alpha = options3d.alpha, incrementX = 1e6, incrementY = 10, incrementZ = 100, zIndex = 0, pArr = [{
      x,
      y,
      z
    }, {
      x: x + w2,
      y,
      z
    }, {
      x: x + w2,
      y: y + h,
      z
    }, {
      x,
      y: y + h,
      z
    }, {
      x,
      y: y + h,
      z: z + d
    }, {
      x: x + w2,
      y: y + h,
      z: z + d
    }, {
      x: x + w2,
      y,
      z: z + d
    }, {
      x,
      y,
      z: z + d
    }], forcedSides = [], pickShape;
    pArr = perspective2(pArr, chart, shapeArgs.insidePlotArea);
    function mapSidePath(i) {
      if (h === 0 && i > 1 && i < 6) {
        return {
          x: pArr[i].x,
          y: pArr[i].y + 10,
          z: pArr[i].z
        };
      }
      if (pArr[0].x === pArr[7].x && i >= 4) {
        return {
          x: pArr[i].x + 10,
          y: pArr[i].y,
          z: pArr[i].z
        };
      }
      if (d === 0 && i < 2 || i > 5) {
        return {
          x: pArr[i].x,
          y: pArr[i].y,
          z: pArr[i].z + 10
        };
      }
      return pArr[i];
    }
    function mapPath(i) {
      return pArr[i];
    }
    pickShape = function(verticesIndex1, verticesIndex2, side) {
      var ret = [[], -1], face1 = verticesIndex1.map(mapPath), face2 = verticesIndex2.map(mapPath), dummyFace1 = verticesIndex1.map(mapSidePath), dummyFace2 = verticesIndex2.map(mapSidePath);
      if (shapeArea2(face1) < 0) {
        ret = [face1, 0];
      } else if (shapeArea2(face2) < 0) {
        ret = [face2, 1];
      } else if (side) {
        forcedSides.push(side);
        if (shapeArea2(dummyFace1) < 0) {
          ret = [face1, 0];
        } else if (shapeArea2(dummyFace2) < 0) {
          ret = [face2, 1];
        } else {
          ret = [face1, 0];
        }
      }
      return ret;
    };
    front = [3, 2, 1, 0];
    back = [7, 6, 5, 4];
    shape = pickShape(front, back, "front");
    path1 = shape[0];
    isFront = shape[1];
    top = [1, 6, 7, 0];
    bottom = [4, 5, 2, 3];
    shape = pickShape(top, bottom, "top");
    path2 = shape[0];
    isTop = shape[1];
    right = [1, 2, 5, 6];
    left = [0, 7, 4, 3];
    shape = pickShape(right, left, "side");
    path3 = shape[0];
    isRight = shape[1];
    if (isRight === 1) {
      zIndex += incrementX * (chart.plotWidth - x);
    } else if (!isRight) {
      zIndex += incrementX * x;
    }
    zIndex += incrementY * (!isTop || (alpha >= 0 && alpha <= 180 || alpha < 360 && alpha > 357.5) ? chart.plotHeight - y : 10 + y);
    if (isFront === 1) {
      zIndex += incrementZ * z;
    } else if (!isFront) {
      zIndex += incrementZ * (1e3 - z);
    }
    return {
      front: this.toLinePath(path1, true),
      top: this.toLinePath(path2, true),
      side: this.toLinePath(path3, true),
      zIndexes: {
        group: Math.round(zIndex)
      },
      forcedSides,
      isFront,
      isTop
    };
  };
  SVGRenderer3D2.prototype.arc3d = function(attribs) {
    var wrapper = this.g(), renderer = wrapper.renderer, customAttribs = ["x", "y", "r", "innerR", "start", "end", "depth"];
    function suckOutCustom(params) {
      var hasCA = false, ca = {}, key;
      params = merge59(params);
      for (key in params) {
        if (customAttribs.indexOf(key) !== -1) {
          ca[key] = params[key];
          delete params[key];
          hasCA = true;
        }
      }
      return hasCA ? [ca, params] : false;
    }
    attribs = merge59(attribs);
    attribs.alpha = (attribs.alpha || 0) * deg2rad7;
    attribs.beta = (attribs.beta || 0) * deg2rad7;
    wrapper.top = renderer.path();
    wrapper.side1 = renderer.path();
    wrapper.side2 = renderer.path();
    wrapper.inn = renderer.path();
    wrapper.out = renderer.path();
    wrapper.onAdd = function() {
      var parent = wrapper.parentGroup, className = wrapper.attr("class");
      wrapper.top.add(wrapper);
      ["out", "inn", "side1", "side2"].forEach(function(face) {
        wrapper[face].attr({
          "class": className + " highcharts-3d-side"
        }).add(parent);
      });
    };
    ["addClass", "removeClass"].forEach(function(fn) {
      wrapper[fn] = function() {
        var args = arguments;
        ["top", "out", "inn", "side1", "side2"].forEach(function(face) {
          wrapper[face][fn].apply(wrapper[face], args);
        });
      };
    });
    wrapper.setPaths = function(attribs2) {
      var paths = wrapper.renderer.arc3dPath(attribs2), zIndex = paths.zTop * 100;
      wrapper.attribs = attribs2;
      wrapper.top.attr({ d: paths.top, zIndex: paths.zTop });
      wrapper.inn.attr({ d: paths.inn, zIndex: paths.zInn });
      wrapper.out.attr({ d: paths.out, zIndex: paths.zOut });
      wrapper.side1.attr({ d: paths.side1, zIndex: paths.zSide1 });
      wrapper.side2.attr({ d: paths.side2, zIndex: paths.zSide2 });
      wrapper.zIndex = zIndex;
      wrapper.attr({ zIndex });
      if (attribs2.center) {
        wrapper.top.setRadialReference(attribs2.center);
        delete attribs2.center;
      }
    };
    wrapper.setPaths(attribs);
    wrapper.fillSetter = function(value) {
      var darker = color11(value).brighten(-0.1).get();
      this.fill = value;
      this.side1.attr({ fill: darker });
      this.side2.attr({ fill: darker });
      this.inn.attr({ fill: darker });
      this.out.attr({ fill: darker });
      this.top.attr({ fill: value });
      return this;
    };
    ["opacity", "translateX", "translateY", "visibility"].forEach(function(setter) {
      wrapper[setter + "Setter"] = function(value, key) {
        wrapper[key] = value;
        ["out", "inn", "side1", "side2", "top"].forEach(function(el) {
          wrapper[el].attr(key, value);
        });
      };
    });
    wrapper.attr = function(params) {
      var ca, paramArr;
      if (typeof params === "object") {
        paramArr = suckOutCustom(params);
        if (paramArr) {
          ca = paramArr[0];
          arguments[0] = paramArr[1];
          extend62(wrapper.attribs, ca);
          wrapper.setPaths(wrapper.attribs);
        }
      }
      return SVGElement_default.prototype.attr.apply(wrapper, arguments);
    };
    wrapper.animate = function(params, animation, complete) {
      var paramArr, from = this.attribs, to, anim, randomProp = "data-" + Math.random().toString(26).substring(2, 9);
      delete params.center;
      delete params.z;
      delete params.alpha;
      delete params.beta;
      anim = animObject12(pick69(animation, this.renderer.globalAnimation));
      if (anim.duration) {
        paramArr = suckOutCustom(params);
        wrapper[randomProp] = 0;
        params[randomProp] = 1;
        wrapper[randomProp + "Setter"] = Globals_default.noop;
        if (paramArr) {
          to = paramArr[0];
          anim.step = function(a, fx) {
            function interpolate(key) {
              return from[key] + (pick69(to[key], from[key]) - from[key]) * fx.pos;
            }
            if (fx.prop === randomProp) {
              fx.elem.setPaths(merge59(from, {
                x: interpolate("x"),
                y: interpolate("y"),
                r: interpolate("r"),
                innerR: interpolate("innerR"),
                start: interpolate("start"),
                end: interpolate("end"),
                depth: interpolate("depth")
              }));
            }
          };
        }
        animation = anim;
      }
      return SVGElement_default.prototype.animate.call(this, params, animation, complete);
    };
    wrapper.destroy = function() {
      this.top.destroy();
      this.out.destroy();
      this.inn.destroy();
      this.side1.destroy();
      this.side2.destroy();
      return SVGElement_default.prototype.destroy.call(this);
    };
    wrapper.hide = function() {
      this.top.hide();
      this.out.hide();
      this.inn.hide();
      this.side1.hide();
      this.side2.hide();
    };
    wrapper.show = function(inherit) {
      this.top.show(inherit);
      this.out.show(inherit);
      this.inn.show(inherit);
      this.side1.show(inherit);
      this.side2.show(inherit);
    };
    return wrapper;
  };
  SVGRenderer3D2.prototype.arc3dPath = function(shapeArgs) {
    var cx = shapeArgs.x || 0, cy = shapeArgs.y || 0, start = shapeArgs.start || 0, end = (shapeArgs.end || 0) - 1e-5, r = shapeArgs.r || 0, ir = shapeArgs.innerR || 0, d = shapeArgs.depth || 0, alpha = shapeArgs.alpha || 0, beta = shapeArgs.beta || 0;
    var cs = Math.cos(start), ss = Math.sin(start), ce = Math.cos(end), se = Math.sin(end), rx = r * Math.cos(beta), ry = r * Math.cos(alpha), irx = ir * Math.cos(beta), iry = ir * Math.cos(alpha), dx = d * Math.sin(beta), dy = d * Math.sin(alpha);
    var top = [
      ["M", cx + rx * cs, cy + ry * ss]
    ];
    top = top.concat(SVGRenderer3D2.curveTo(cx, cy, rx, ry, start, end, 0, 0));
    top.push([
      "L",
      cx + irx * ce,
      cy + iry * se
    ]);
    top = top.concat(SVGRenderer3D2.curveTo(cx, cy, irx, iry, end, start, 0, 0));
    top.push(["Z"]);
    var b = beta > 0 ? Math.PI / 2 : 0, a = alpha > 0 ? 0 : Math.PI / 2;
    var start2 = start > -b ? start : end > -b ? -b : start, end2 = end < PI - a ? end : start < PI - a ? PI - a : end, midEnd = 2 * PI - a;
    var out = [
      ["M", cx + rx * cos(start2), cy + ry * sin(start2)]
    ];
    out = out.concat(SVGRenderer3D2.curveTo(cx, cy, rx, ry, start2, end2, 0, 0));
    if (end > midEnd && start < midEnd) {
      out.push([
        "L",
        cx + rx * cos(end2) + dx,
        cy + ry * sin(end2) + dy
      ]);
      out = out.concat(SVGRenderer3D2.curveTo(cx, cy, rx, ry, end2, midEnd, dx, dy));
      out.push([
        "L",
        cx + rx * cos(midEnd),
        cy + ry * sin(midEnd)
      ]);
      out = out.concat(SVGRenderer3D2.curveTo(cx, cy, rx, ry, midEnd, end, 0, 0));
      out.push([
        "L",
        cx + rx * cos(end) + dx,
        cy + ry * sin(end) + dy
      ]);
      out = out.concat(SVGRenderer3D2.curveTo(cx, cy, rx, ry, end, midEnd, dx, dy));
      out.push([
        "L",
        cx + rx * cos(midEnd),
        cy + ry * sin(midEnd)
      ]);
      out = out.concat(SVGRenderer3D2.curveTo(cx, cy, rx, ry, midEnd, end2, 0, 0));
    } else if (end > PI - a && start < PI - a) {
      out.push([
        "L",
        cx + rx * Math.cos(end2) + dx,
        cy + ry * Math.sin(end2) + dy
      ]);
      out = out.concat(SVGRenderer3D2.curveTo(cx, cy, rx, ry, end2, end, dx, dy));
      out.push([
        "L",
        cx + rx * Math.cos(end),
        cy + ry * Math.sin(end)
      ]);
      out = out.concat(SVGRenderer3D2.curveTo(cx, cy, rx, ry, end, end2, 0, 0));
    }
    out.push([
      "L",
      cx + rx * Math.cos(end2) + dx,
      cy + ry * Math.sin(end2) + dy
    ]);
    out = out.concat(SVGRenderer3D2.curveTo(cx, cy, rx, ry, end2, start2, dx, dy));
    out.push(["Z"]);
    var inn = [
      ["M", cx + irx * cs, cy + iry * ss]
    ];
    inn = inn.concat(SVGRenderer3D2.curveTo(cx, cy, irx, iry, start, end, 0, 0));
    inn.push([
      "L",
      cx + irx * Math.cos(end) + dx,
      cy + iry * Math.sin(end) + dy
    ]);
    inn = inn.concat(SVGRenderer3D2.curveTo(cx, cy, irx, iry, end, start, dx, dy));
    inn.push(["Z"]);
    var side1 = [
      ["M", cx + rx * cs, cy + ry * ss],
      ["L", cx + rx * cs + dx, cy + ry * ss + dy],
      ["L", cx + irx * cs + dx, cy + iry * ss + dy],
      ["L", cx + irx * cs, cy + iry * ss],
      ["Z"]
    ];
    var side2 = [
      ["M", cx + rx * ce, cy + ry * se],
      ["L", cx + rx * ce + dx, cy + ry * se + dy],
      ["L", cx + irx * ce + dx, cy + iry * se + dy],
      ["L", cx + irx * ce, cy + iry * se],
      ["Z"]
    ];
    var angleCorr = Math.atan2(dy, -dx), angleEnd = Math.abs(end + angleCorr), angleStart = Math.abs(start + angleCorr), angleMid = Math.abs((start + end) / 2 + angleCorr);
    function toZeroPIRange(angle) {
      angle = angle % (2 * Math.PI);
      if (angle > Math.PI) {
        angle = 2 * Math.PI - angle;
      }
      return angle;
    }
    angleEnd = toZeroPIRange(angleEnd);
    angleStart = toZeroPIRange(angleStart);
    angleMid = toZeroPIRange(angleMid);
    var incPrecision = 1e5, a1 = angleMid * incPrecision, a2 = angleStart * incPrecision, a3 = angleEnd * incPrecision;
    return {
      top,
      zTop: Math.PI * incPrecision + 1,
      out,
      zOut: Math.max(a1, a2, a3),
      inn,
      zInn: Math.max(a1, a2, a3),
      side1,
      zSide1: a3 * 0.99,
      side2,
      zSide2: a2 * 0.99
    };
  };
  return SVGRenderer3D2;
}(SVGRenderer_default);
var SVGRenderer3D_default = SVGRenderer3D;

// node_modules/highcharts/es-modules/Core/Chart/Chart3D.js
var color12 = Color_default.parse;
var perspective3 = Math3D_default.perspective;
var shapeArea3D2 = Math3D_default.shapeArea3D;
var genericDefaultOptions = DefaultOptions_default.defaultOptions;
var addEvent45 = Utilities_default.addEvent;
var isArray19 = Utilities_default.isArray;
var merge60 = Utilities_default.merge;
var pick70 = Utilities_default.pick;
var wrap7 = Utilities_default.wrap;
var Chart3D;
(function(Chart3D2) {
  var Composition = function() {
    function Composition2(chart) {
      this.frame3d = void 0;
      this.chart = chart;
    }
    Composition2.prototype.get3dFrame = function() {
      var chart = this.chart, options3d = chart.options.chart.options3d, frameOptions = options3d.frame, xm = chart.plotLeft, xp = chart.plotLeft + chart.plotWidth, ym = chart.plotTop, yp = chart.plotTop + chart.plotHeight, zm = 0, zp = options3d.depth, faceOrientation = function(vertexes) {
        var area = shapeArea3D2(vertexes, chart);
        if (area > 0.5) {
          return 1;
        }
        if (area < -0.5) {
          return -1;
        }
        return 0;
      }, bottomOrientation = faceOrientation([
        { x: xm, y: yp, z: zp },
        { x: xp, y: yp, z: zp },
        { x: xp, y: yp, z: zm },
        { x: xm, y: yp, z: zm }
      ]), topOrientation = faceOrientation([
        { x: xm, y: ym, z: zm },
        { x: xp, y: ym, z: zm },
        { x: xp, y: ym, z: zp },
        { x: xm, y: ym, z: zp }
      ]), leftOrientation = faceOrientation([
        { x: xm, y: ym, z: zm },
        { x: xm, y: ym, z: zp },
        { x: xm, y: yp, z: zp },
        { x: xm, y: yp, z: zm }
      ]), rightOrientation = faceOrientation([
        { x: xp, y: ym, z: zp },
        { x: xp, y: ym, z: zm },
        { x: xp, y: yp, z: zm },
        { x: xp, y: yp, z: zp }
      ]), frontOrientation = faceOrientation([
        { x: xm, y: yp, z: zm },
        { x: xp, y: yp, z: zm },
        { x: xp, y: ym, z: zm },
        { x: xm, y: ym, z: zm }
      ]), backOrientation = faceOrientation([
        { x: xm, y: ym, z: zp },
        { x: xp, y: ym, z: zp },
        { x: xp, y: yp, z: zp },
        { x: xm, y: yp, z: zp }
      ]), defaultShowFront = false, defaultShowBack = true;
      var defaultShowBottom = false, defaultShowTop = false, defaultShowLeft = false, defaultShowRight = false;
      [].concat(chart.xAxis, chart.yAxis, chart.zAxis).forEach(function(axis) {
        if (axis) {
          if (axis.horiz) {
            if (axis.opposite) {
              defaultShowTop = true;
            } else {
              defaultShowBottom = true;
            }
          } else {
            if (axis.opposite) {
              defaultShowRight = true;
            } else {
              defaultShowLeft = true;
            }
          }
        }
      });
      var getFaceOptions = function(sources, faceOrientation2, defaultVisible) {
        var faceAttrs = ["size", "color", "visible"], options = {};
        for (var i = 0; i < faceAttrs.length; i++) {
          var attr10 = faceAttrs[i];
          for (var j = 0; j < sources.length; j++) {
            if (typeof sources[j] === "object") {
              var val = sources[j][attr10];
              if (typeof val !== "undefined" && val !== null) {
                options[attr10] = val;
                break;
              }
            }
          }
        }
        var isVisible = defaultVisible;
        if (options.visible === true || options.visible === false) {
          isVisible = options.visible;
        } else if (options.visible === "auto") {
          isVisible = faceOrientation2 > 0;
        }
        return {
          size: pick70(options.size, 1),
          color: pick70(options.color, "none"),
          frontFacing: faceOrientation2 > 0,
          visible: isVisible
        };
      };
      var ret = {
        axes: {},
        bottom: getFaceOptions([frameOptions.bottom, frameOptions.top, frameOptions], bottomOrientation, defaultShowBottom),
        top: getFaceOptions([frameOptions.top, frameOptions.bottom, frameOptions], topOrientation, defaultShowTop),
        left: getFaceOptions([
          frameOptions.left,
          frameOptions.right,
          frameOptions.side,
          frameOptions
        ], leftOrientation, defaultShowLeft),
        right: getFaceOptions([
          frameOptions.right,
          frameOptions.left,
          frameOptions.side,
          frameOptions
        ], rightOrientation, defaultShowRight),
        back: getFaceOptions([frameOptions.back, frameOptions.front, frameOptions], backOrientation, defaultShowBack),
        front: getFaceOptions([frameOptions.front, frameOptions.back, frameOptions], frontOrientation, defaultShowFront)
      };
      if (options3d.axisLabelPosition === "auto") {
        var isValidEdge = function(face1, face2) {
          return face1.visible !== face2.visible || face1.visible && face2.visible && face1.frontFacing !== face2.frontFacing;
        };
        var yEdges = [];
        if (isValidEdge(ret.left, ret.front)) {
          yEdges.push({
            y: (ym + yp) / 2,
            x: xm,
            z: zm,
            xDir: { x: 1, y: 0, z: 0 }
          });
        }
        if (isValidEdge(ret.left, ret.back)) {
          yEdges.push({
            y: (ym + yp) / 2,
            x: xm,
            z: zp,
            xDir: { x: 0, y: 0, z: -1 }
          });
        }
        if (isValidEdge(ret.right, ret.front)) {
          yEdges.push({
            y: (ym + yp) / 2,
            x: xp,
            z: zm,
            xDir: { x: 0, y: 0, z: 1 }
          });
        }
        if (isValidEdge(ret.right, ret.back)) {
          yEdges.push({
            y: (ym + yp) / 2,
            x: xp,
            z: zp,
            xDir: { x: -1, y: 0, z: 0 }
          });
        }
        var xBottomEdges = [];
        if (isValidEdge(ret.bottom, ret.front)) {
          xBottomEdges.push({
            x: (xm + xp) / 2,
            y: yp,
            z: zm,
            xDir: { x: 1, y: 0, z: 0 }
          });
        }
        if (isValidEdge(ret.bottom, ret.back)) {
          xBottomEdges.push({
            x: (xm + xp) / 2,
            y: yp,
            z: zp,
            xDir: { x: -1, y: 0, z: 0 }
          });
        }
        var xTopEdges = [];
        if (isValidEdge(ret.top, ret.front)) {
          xTopEdges.push({
            x: (xm + xp) / 2,
            y: ym,
            z: zm,
            xDir: { x: 1, y: 0, z: 0 }
          });
        }
        if (isValidEdge(ret.top, ret.back)) {
          xTopEdges.push({
            x: (xm + xp) / 2,
            y: ym,
            z: zp,
            xDir: { x: -1, y: 0, z: 0 }
          });
        }
        var zBottomEdges = [];
        if (isValidEdge(ret.bottom, ret.left)) {
          zBottomEdges.push({
            z: (zm + zp) / 2,
            y: yp,
            x: xm,
            xDir: { x: 0, y: 0, z: -1 }
          });
        }
        if (isValidEdge(ret.bottom, ret.right)) {
          zBottomEdges.push({
            z: (zm + zp) / 2,
            y: yp,
            x: xp,
            xDir: { x: 0, y: 0, z: 1 }
          });
        }
        var zTopEdges = [];
        if (isValidEdge(ret.top, ret.left)) {
          zTopEdges.push({
            z: (zm + zp) / 2,
            y: ym,
            x: xm,
            xDir: { x: 0, y: 0, z: -1 }
          });
        }
        if (isValidEdge(ret.top, ret.right)) {
          zTopEdges.push({
            z: (zm + zp) / 2,
            y: ym,
            x: xp,
            xDir: { x: 0, y: 0, z: 1 }
          });
        }
        var pickEdge = function(edges, axis, mult) {
          if (edges.length === 0) {
            return null;
          }
          if (edges.length === 1) {
            return edges[0];
          }
          var projections = perspective3(edges, chart, false);
          var best = 0;
          for (var i = 1; i < projections.length; i++) {
            if (mult * projections[i][axis] > mult * projections[best][axis]) {
              best = i;
            } else if (mult * projections[i][axis] === mult * projections[best][axis] && projections[i].z < projections[best].z) {
              best = i;
            }
          }
          return edges[best];
        };
        ret.axes = {
          y: {
            "left": pickEdge(yEdges, "x", -1),
            "right": pickEdge(yEdges, "x", 1)
          },
          x: {
            "top": pickEdge(xTopEdges, "y", -1),
            "bottom": pickEdge(xBottomEdges, "y", 1)
          },
          z: {
            "top": pickEdge(zTopEdges, "y", -1),
            "bottom": pickEdge(zBottomEdges, "y", 1)
          }
        };
      } else {
        ret.axes = {
          y: {
            "left": { x: xm, z: zm, xDir: { x: 1, y: 0, z: 0 } },
            "right": { x: xp, z: zm, xDir: { x: 0, y: 0, z: 1 } }
          },
          x: {
            "top": { y: ym, z: zm, xDir: { x: 1, y: 0, z: 0 } },
            "bottom": { y: yp, z: zm, xDir: { x: 1, y: 0, z: 0 } }
          },
          z: {
            "top": {
              x: defaultShowLeft ? xp : xm,
              y: ym,
              xDir: defaultShowLeft ? { x: 0, y: 0, z: 1 } : { x: 0, y: 0, z: -1 }
            },
            "bottom": {
              x: defaultShowLeft ? xp : xm,
              y: yp,
              xDir: defaultShowLeft ? { x: 0, y: 0, z: 1 } : { x: 0, y: 0, z: -1 }
            }
          }
        };
      }
      return ret;
    };
    Composition2.prototype.getScale = function(depth) {
      var chart = this.chart, plotLeft = chart.plotLeft, plotRight = chart.plotWidth + plotLeft, plotTop = chart.plotTop, plotBottom = chart.plotHeight + plotTop, originX = plotLeft + chart.plotWidth / 2, originY = plotTop + chart.plotHeight / 2, bbox3d = {
        minX: Number.MAX_VALUE,
        maxX: -Number.MAX_VALUE,
        minY: Number.MAX_VALUE,
        maxY: -Number.MAX_VALUE
      };
      var corners, scale = 1;
      corners = [{
        x: plotLeft,
        y: plotTop,
        z: 0
      }, {
        x: plotLeft,
        y: plotTop,
        z: depth
      }];
      [0, 1].forEach(function(i) {
        corners.push({
          x: plotRight,
          y: corners[i].y,
          z: corners[i].z
        });
      });
      [0, 1, 2, 3].forEach(function(i) {
        corners.push({
          x: corners[i].x,
          y: plotBottom,
          z: corners[i].z
        });
      });
      corners = perspective3(corners, chart, false);
      corners.forEach(function(corner) {
        bbox3d.minX = Math.min(bbox3d.minX, corner.x);
        bbox3d.maxX = Math.max(bbox3d.maxX, corner.x);
        bbox3d.minY = Math.min(bbox3d.minY, corner.y);
        bbox3d.maxY = Math.max(bbox3d.maxY, corner.y);
      });
      if (plotLeft > bbox3d.minX) {
        scale = Math.min(scale, 1 - Math.abs((plotLeft + originX) / (bbox3d.minX + originX)) % 1);
      }
      if (plotRight < bbox3d.maxX) {
        scale = Math.min(scale, (plotRight - originX) / (bbox3d.maxX - originX));
      }
      if (plotTop > bbox3d.minY) {
        if (bbox3d.minY < 0) {
          scale = Math.min(scale, (plotTop + originY) / (-bbox3d.minY + plotTop + originY));
        } else {
          scale = Math.min(scale, 1 - (plotTop + originY) / (bbox3d.minY + originY) % 1);
        }
      }
      if (plotBottom < bbox3d.maxY) {
        scale = Math.min(scale, Math.abs((plotBottom - originY) / (bbox3d.maxY - originY)));
      }
      return scale;
    };
    return Composition2;
  }();
  Chart3D2.Composition = Composition;
  Chart3D2.defaultOptions = {
    chart: {
      options3d: {
        enabled: false,
        alpha: 0,
        beta: 0,
        depth: 100,
        fitToPlot: true,
        viewDistance: 25,
        axisLabelPosition: null,
        frame: {
          visible: "default",
          size: 1,
          bottom: {},
          top: {},
          left: {},
          right: {},
          back: {},
          front: {}
        }
      }
    }
  };
  function compose(ChartClass, FxClass) {
    var chartProto = ChartClass.prototype;
    var fxProto = FxClass.prototype;
    chartProto.is3d = function() {
      return Boolean(this.options.chart.options3d && this.options.chart.options3d.enabled);
    };
    chartProto.propsRequireDirtyBox.push("chart.options3d");
    chartProto.propsRequireUpdateSeries.push("chart.options3d");
    fxProto.matrixSetter = function() {
      var interpolated;
      if (this.pos < 1 && (isArray19(this.start) || isArray19(this.end))) {
        var start = this.start || [1, 0, 0, 1, 0, 0], end = this.end || [1, 0, 0, 1, 0, 0];
        interpolated = [];
        for (var i = 0; i < 6; i++) {
          interpolated.push(this.pos * end[i] + (1 - this.pos) * start[i]);
        }
      } else {
        interpolated = this.end;
      }
      this.elem.attr(this.prop, interpolated, null, true);
    };
    merge60(true, genericDefaultOptions, Chart3D2.defaultOptions);
    addEvent45(ChartClass, "init", onInit);
    addEvent45(ChartClass, "addSeries", onAddSeries);
    addEvent45(ChartClass, "afterDrawChartBox", onAfterDrawChartBox);
    addEvent45(ChartClass, "afterGetContainer", onAfterGetContainer);
    addEvent45(ChartClass, "afterInit", onAfterInit);
    addEvent45(ChartClass, "afterSetChartSize", onAfterSetChartSize);
    addEvent45(ChartClass, "beforeRedraw", onBeforeRedraw);
    addEvent45(ChartClass, "beforeRender", onBeforeRender);
    wrap7(chartProto, "isInsidePlot", wrapIsInsidePlot);
    wrap7(ChartClass, "renderSeries", wrapRenderSeries);
    wrap7(ChartClass, "setClassName", wrapSetClassName);
  }
  Chart3D2.compose = compose;
  function onAddSeries(e2) {
    if (this.is3d()) {
      if (e2.options.type === "scatter") {
        e2.options.type = "scatter3d";
      }
    }
  }
  function onAfterDrawChartBox() {
    if (this.chart3d && this.is3d()) {
      var chart = this, renderer = chart.renderer, options3d = chart.options.chart.options3d, frame = chart.chart3d.get3dFrame(), xm = chart.plotLeft, xp = chart.plotLeft + chart.plotWidth, ym = chart.plotTop, yp = chart.plotTop + chart.plotHeight, zm = 0, zp = options3d.depth, xmm = xm - (frame.left.visible ? frame.left.size : 0), xpp = xp + (frame.right.visible ? frame.right.size : 0), ymm = ym - (frame.top.visible ? frame.top.size : 0), ypp = yp + (frame.bottom.visible ? frame.bottom.size : 0), zmm = zm - (frame.front.visible ? frame.front.size : 0), zpp = zp + (frame.back.visible ? frame.back.size : 0), verb = chart.hasRendered ? "animate" : "attr";
      chart.chart3d.frame3d = frame;
      if (!chart.frameShapes) {
        chart.frameShapes = {
          bottom: renderer.polyhedron().add(),
          top: renderer.polyhedron().add(),
          left: renderer.polyhedron().add(),
          right: renderer.polyhedron().add(),
          back: renderer.polyhedron().add(),
          front: renderer.polyhedron().add()
        };
      }
      chart.frameShapes.bottom[verb]({
        "class": "highcharts-3d-frame highcharts-3d-frame-bottom",
        zIndex: frame.bottom.frontFacing ? -1e3 : 1e3,
        faces: [
          {
            fill: color12(frame.bottom.color).brighten(0.1).get(),
            vertexes: [{
              x: xmm,
              y: ypp,
              z: zmm
            }, {
              x: xpp,
              y: ypp,
              z: zmm
            }, {
              x: xpp,
              y: ypp,
              z: zpp
            }, {
              x: xmm,
              y: ypp,
              z: zpp
            }],
            enabled: frame.bottom.visible
          },
          {
            fill: color12(frame.bottom.color).brighten(0.1).get(),
            vertexes: [{
              x: xm,
              y: yp,
              z: zp
            }, {
              x: xp,
              y: yp,
              z: zp
            }, {
              x: xp,
              y: yp,
              z: zm
            }, {
              x: xm,
              y: yp,
              z: zm
            }],
            enabled: frame.bottom.visible
          },
          {
            fill: color12(frame.bottom.color).brighten(-0.1).get(),
            vertexes: [{
              x: xmm,
              y: ypp,
              z: zmm
            }, {
              x: xmm,
              y: ypp,
              z: zpp
            }, {
              x: xm,
              y: yp,
              z: zp
            }, {
              x: xm,
              y: yp,
              z: zm
            }],
            enabled: frame.bottom.visible && !frame.left.visible
          },
          {
            fill: color12(frame.bottom.color).brighten(-0.1).get(),
            vertexes: [{
              x: xpp,
              y: ypp,
              z: zpp
            }, {
              x: xpp,
              y: ypp,
              z: zmm
            }, {
              x: xp,
              y: yp,
              z: zm
            }, {
              x: xp,
              y: yp,
              z: zp
            }],
            enabled: frame.bottom.visible && !frame.right.visible
          },
          {
            fill: color12(frame.bottom.color).get(),
            vertexes: [{
              x: xpp,
              y: ypp,
              z: zmm
            }, {
              x: xmm,
              y: ypp,
              z: zmm
            }, {
              x: xm,
              y: yp,
              z: zm
            }, {
              x: xp,
              y: yp,
              z: zm
            }],
            enabled: frame.bottom.visible && !frame.front.visible
          },
          {
            fill: color12(frame.bottom.color).get(),
            vertexes: [{
              x: xmm,
              y: ypp,
              z: zpp
            }, {
              x: xpp,
              y: ypp,
              z: zpp
            }, {
              x: xp,
              y: yp,
              z: zp
            }, {
              x: xm,
              y: yp,
              z: zp
            }],
            enabled: frame.bottom.visible && !frame.back.visible
          }
        ]
      });
      chart.frameShapes.top[verb]({
        "class": "highcharts-3d-frame highcharts-3d-frame-top",
        zIndex: frame.top.frontFacing ? -1e3 : 1e3,
        faces: [
          {
            fill: color12(frame.top.color).brighten(0.1).get(),
            vertexes: [{
              x: xmm,
              y: ymm,
              z: zpp
            }, {
              x: xpp,
              y: ymm,
              z: zpp
            }, {
              x: xpp,
              y: ymm,
              z: zmm
            }, {
              x: xmm,
              y: ymm,
              z: zmm
            }],
            enabled: frame.top.visible
          },
          {
            fill: color12(frame.top.color).brighten(0.1).get(),
            vertexes: [{
              x: xm,
              y: ym,
              z: zm
            }, {
              x: xp,
              y: ym,
              z: zm
            }, {
              x: xp,
              y: ym,
              z: zp
            }, {
              x: xm,
              y: ym,
              z: zp
            }],
            enabled: frame.top.visible
          },
          {
            fill: color12(frame.top.color).brighten(-0.1).get(),
            vertexes: [{
              x: xmm,
              y: ymm,
              z: zpp
            }, {
              x: xmm,
              y: ymm,
              z: zmm
            }, {
              x: xm,
              y: ym,
              z: zm
            }, {
              x: xm,
              y: ym,
              z: zp
            }],
            enabled: frame.top.visible && !frame.left.visible
          },
          {
            fill: color12(frame.top.color).brighten(-0.1).get(),
            vertexes: [{
              x: xpp,
              y: ymm,
              z: zmm
            }, {
              x: xpp,
              y: ymm,
              z: zpp
            }, {
              x: xp,
              y: ym,
              z: zp
            }, {
              x: xp,
              y: ym,
              z: zm
            }],
            enabled: frame.top.visible && !frame.right.visible
          },
          {
            fill: color12(frame.top.color).get(),
            vertexes: [{
              x: xmm,
              y: ymm,
              z: zmm
            }, {
              x: xpp,
              y: ymm,
              z: zmm
            }, {
              x: xp,
              y: ym,
              z: zm
            }, {
              x: xm,
              y: ym,
              z: zm
            }],
            enabled: frame.top.visible && !frame.front.visible
          },
          {
            fill: color12(frame.top.color).get(),
            vertexes: [{
              x: xpp,
              y: ymm,
              z: zpp
            }, {
              x: xmm,
              y: ymm,
              z: zpp
            }, {
              x: xm,
              y: ym,
              z: zp
            }, {
              x: xp,
              y: ym,
              z: zp
            }],
            enabled: frame.top.visible && !frame.back.visible
          }
        ]
      });
      chart.frameShapes.left[verb]({
        "class": "highcharts-3d-frame highcharts-3d-frame-left",
        zIndex: frame.left.frontFacing ? -1e3 : 1e3,
        faces: [
          {
            fill: color12(frame.left.color).brighten(0.1).get(),
            vertexes: [{
              x: xmm,
              y: ypp,
              z: zmm
            }, {
              x: xm,
              y: yp,
              z: zm
            }, {
              x: xm,
              y: yp,
              z: zp
            }, {
              x: xmm,
              y: ypp,
              z: zpp
            }],
            enabled: frame.left.visible && !frame.bottom.visible
          },
          {
            fill: color12(frame.left.color).brighten(0.1).get(),
            vertexes: [{
              x: xmm,
              y: ymm,
              z: zpp
            }, {
              x: xm,
              y: ym,
              z: zp
            }, {
              x: xm,
              y: ym,
              z: zm
            }, {
              x: xmm,
              y: ymm,
              z: zmm
            }],
            enabled: frame.left.visible && !frame.top.visible
          },
          {
            fill: color12(frame.left.color).brighten(-0.1).get(),
            vertexes: [{
              x: xmm,
              y: ypp,
              z: zpp
            }, {
              x: xmm,
              y: ymm,
              z: zpp
            }, {
              x: xmm,
              y: ymm,
              z: zmm
            }, {
              x: xmm,
              y: ypp,
              z: zmm
            }],
            enabled: frame.left.visible
          },
          {
            fill: color12(frame.left.color).brighten(-0.1).get(),
            vertexes: [{
              x: xm,
              y: ym,
              z: zp
            }, {
              x: xm,
              y: yp,
              z: zp
            }, {
              x: xm,
              y: yp,
              z: zm
            }, {
              x: xm,
              y: ym,
              z: zm
            }],
            enabled: frame.left.visible
          },
          {
            fill: color12(frame.left.color).get(),
            vertexes: [{
              x: xmm,
              y: ypp,
              z: zmm
            }, {
              x: xmm,
              y: ymm,
              z: zmm
            }, {
              x: xm,
              y: ym,
              z: zm
            }, {
              x: xm,
              y: yp,
              z: zm
            }],
            enabled: frame.left.visible && !frame.front.visible
          },
          {
            fill: color12(frame.left.color).get(),
            vertexes: [{
              x: xmm,
              y: ymm,
              z: zpp
            }, {
              x: xmm,
              y: ypp,
              z: zpp
            }, {
              x: xm,
              y: yp,
              z: zp
            }, {
              x: xm,
              y: ym,
              z: zp
            }],
            enabled: frame.left.visible && !frame.back.visible
          }
        ]
      });
      chart.frameShapes.right[verb]({
        "class": "highcharts-3d-frame highcharts-3d-frame-right",
        zIndex: frame.right.frontFacing ? -1e3 : 1e3,
        faces: [
          {
            fill: color12(frame.right.color).brighten(0.1).get(),
            vertexes: [{
              x: xpp,
              y: ypp,
              z: zpp
            }, {
              x: xp,
              y: yp,
              z: zp
            }, {
              x: xp,
              y: yp,
              z: zm
            }, {
              x: xpp,
              y: ypp,
              z: zmm
            }],
            enabled: frame.right.visible && !frame.bottom.visible
          },
          {
            fill: color12(frame.right.color).brighten(0.1).get(),
            vertexes: [{
              x: xpp,
              y: ymm,
              z: zmm
            }, {
              x: xp,
              y: ym,
              z: zm
            }, {
              x: xp,
              y: ym,
              z: zp
            }, {
              x: xpp,
              y: ymm,
              z: zpp
            }],
            enabled: frame.right.visible && !frame.top.visible
          },
          {
            fill: color12(frame.right.color).brighten(-0.1).get(),
            vertexes: [{
              x: xp,
              y: ym,
              z: zm
            }, {
              x: xp,
              y: yp,
              z: zm
            }, {
              x: xp,
              y: yp,
              z: zp
            }, {
              x: xp,
              y: ym,
              z: zp
            }],
            enabled: frame.right.visible
          },
          {
            fill: color12(frame.right.color).brighten(-0.1).get(),
            vertexes: [{
              x: xpp,
              y: ypp,
              z: zmm
            }, {
              x: xpp,
              y: ymm,
              z: zmm
            }, {
              x: xpp,
              y: ymm,
              z: zpp
            }, {
              x: xpp,
              y: ypp,
              z: zpp
            }],
            enabled: frame.right.visible
          },
          {
            fill: color12(frame.right.color).get(),
            vertexes: [{
              x: xpp,
              y: ymm,
              z: zmm
            }, {
              x: xpp,
              y: ypp,
              z: zmm
            }, {
              x: xp,
              y: yp,
              z: zm
            }, {
              x: xp,
              y: ym,
              z: zm
            }],
            enabled: frame.right.visible && !frame.front.visible
          },
          {
            fill: color12(frame.right.color).get(),
            vertexes: [{
              x: xpp,
              y: ypp,
              z: zpp
            }, {
              x: xpp,
              y: ymm,
              z: zpp
            }, {
              x: xp,
              y: ym,
              z: zp
            }, {
              x: xp,
              y: yp,
              z: zp
            }],
            enabled: frame.right.visible && !frame.back.visible
          }
        ]
      });
      chart.frameShapes.back[verb]({
        "class": "highcharts-3d-frame highcharts-3d-frame-back",
        zIndex: frame.back.frontFacing ? -1e3 : 1e3,
        faces: [
          {
            fill: color12(frame.back.color).brighten(0.1).get(),
            vertexes: [{
              x: xpp,
              y: ypp,
              z: zpp
            }, {
              x: xmm,
              y: ypp,
              z: zpp
            }, {
              x: xm,
              y: yp,
              z: zp
            }, {
              x: xp,
              y: yp,
              z: zp
            }],
            enabled: frame.back.visible && !frame.bottom.visible
          },
          {
            fill: color12(frame.back.color).brighten(0.1).get(),
            vertexes: [{
              x: xmm,
              y: ymm,
              z: zpp
            }, {
              x: xpp,
              y: ymm,
              z: zpp
            }, {
              x: xp,
              y: ym,
              z: zp
            }, {
              x: xm,
              y: ym,
              z: zp
            }],
            enabled: frame.back.visible && !frame.top.visible
          },
          {
            fill: color12(frame.back.color).brighten(-0.1).get(),
            vertexes: [{
              x: xmm,
              y: ypp,
              z: zpp
            }, {
              x: xmm,
              y: ymm,
              z: zpp
            }, {
              x: xm,
              y: ym,
              z: zp
            }, {
              x: xm,
              y: yp,
              z: zp
            }],
            enabled: frame.back.visible && !frame.left.visible
          },
          {
            fill: color12(frame.back.color).brighten(-0.1).get(),
            vertexes: [{
              x: xpp,
              y: ymm,
              z: zpp
            }, {
              x: xpp,
              y: ypp,
              z: zpp
            }, {
              x: xp,
              y: yp,
              z: zp
            }, {
              x: xp,
              y: ym,
              z: zp
            }],
            enabled: frame.back.visible && !frame.right.visible
          },
          {
            fill: color12(frame.back.color).get(),
            vertexes: [{
              x: xm,
              y: ym,
              z: zp
            }, {
              x: xp,
              y: ym,
              z: zp
            }, {
              x: xp,
              y: yp,
              z: zp
            }, {
              x: xm,
              y: yp,
              z: zp
            }],
            enabled: frame.back.visible
          },
          {
            fill: color12(frame.back.color).get(),
            vertexes: [{
              x: xmm,
              y: ypp,
              z: zpp
            }, {
              x: xpp,
              y: ypp,
              z: zpp
            }, {
              x: xpp,
              y: ymm,
              z: zpp
            }, {
              x: xmm,
              y: ymm,
              z: zpp
            }],
            enabled: frame.back.visible
          }
        ]
      });
      chart.frameShapes.front[verb]({
        "class": "highcharts-3d-frame highcharts-3d-frame-front",
        zIndex: frame.front.frontFacing ? -1e3 : 1e3,
        faces: [
          {
            fill: color12(frame.front.color).brighten(0.1).get(),
            vertexes: [{
              x: xmm,
              y: ypp,
              z: zmm
            }, {
              x: xpp,
              y: ypp,
              z: zmm
            }, {
              x: xp,
              y: yp,
              z: zm
            }, {
              x: xm,
              y: yp,
              z: zm
            }],
            enabled: frame.front.visible && !frame.bottom.visible
          },
          {
            fill: color12(frame.front.color).brighten(0.1).get(),
            vertexes: [{
              x: xpp,
              y: ymm,
              z: zmm
            }, {
              x: xmm,
              y: ymm,
              z: zmm
            }, {
              x: xm,
              y: ym,
              z: zm
            }, {
              x: xp,
              y: ym,
              z: zm
            }],
            enabled: frame.front.visible && !frame.top.visible
          },
          {
            fill: color12(frame.front.color).brighten(-0.1).get(),
            vertexes: [{
              x: xmm,
              y: ymm,
              z: zmm
            }, {
              x: xmm,
              y: ypp,
              z: zmm
            }, {
              x: xm,
              y: yp,
              z: zm
            }, {
              x: xm,
              y: ym,
              z: zm
            }],
            enabled: frame.front.visible && !frame.left.visible
          },
          {
            fill: color12(frame.front.color).brighten(-0.1).get(),
            vertexes: [{
              x: xpp,
              y: ypp,
              z: zmm
            }, {
              x: xpp,
              y: ymm,
              z: zmm
            }, {
              x: xp,
              y: ym,
              z: zm
            }, {
              x: xp,
              y: yp,
              z: zm
            }],
            enabled: frame.front.visible && !frame.right.visible
          },
          {
            fill: color12(frame.front.color).get(),
            vertexes: [{
              x: xp,
              y: ym,
              z: zm
            }, {
              x: xm,
              y: ym,
              z: zm
            }, {
              x: xm,
              y: yp,
              z: zm
            }, {
              x: xp,
              y: yp,
              z: zm
            }],
            enabled: frame.front.visible
          },
          {
            fill: color12(frame.front.color).get(),
            vertexes: [{
              x: xpp,
              y: ypp,
              z: zmm
            }, {
              x: xmm,
              y: ypp,
              z: zmm
            }, {
              x: xmm,
              y: ymm,
              z: zmm
            }, {
              x: xpp,
              y: ymm,
              z: zmm
            }],
            enabled: frame.front.visible
          }
        ]
      });
    }
  }
  function onAfterGetContainer() {
    if (this.styledMode) {
      this.renderer.definition({
        tagName: "style",
        textContent: ".highcharts-3d-top{filter: url(#highcharts-brighter)}\n.highcharts-3d-side{filter: url(#highcharts-darker)}\n"
      });
      [{
        name: "darker",
        slope: 0.6
      }, {
        name: "brighter",
        slope: 1.4
      }].forEach(function(cfg) {
        this.renderer.definition({
          tagName: "filter",
          attributes: {
            id: "highcharts-" + cfg.name
          },
          children: [{
            tagName: "feComponentTransfer",
            children: [{
              tagName: "feFuncR",
              attributes: {
                type: "linear",
                slope: cfg.slope
              }
            }, {
              tagName: "feFuncG",
              attributes: {
                type: "linear",
                slope: cfg.slope
              }
            }, {
              tagName: "feFuncB",
              attributes: {
                type: "linear",
                slope: cfg.slope
              }
            }]
          }]
        });
      }, this);
    }
  }
  function onAfterInit() {
    var options = this.options;
    if (this.is3d()) {
      (options.series || []).forEach(function(s) {
        var type = s.type || options.chart.type || options.chart.defaultSeriesType;
        if (type === "scatter") {
          s.type = "scatter3d";
        }
      });
    }
  }
  function onAfterSetChartSize() {
    var chart = this, options3d = chart.options.chart.options3d;
    if (chart.chart3d && chart.is3d()) {
      if (options3d) {
        options3d.alpha = options3d.alpha % 360 + (options3d.alpha >= 0 ? 0 : 360);
        options3d.beta = options3d.beta % 360 + (options3d.beta >= 0 ? 0 : 360);
      }
      var inverted = chart.inverted, clipBox = chart.clipBox, margin = chart.margin, x = inverted ? "y" : "x", y = inverted ? "x" : "y", w2 = inverted ? "height" : "width", h = inverted ? "width" : "height";
      clipBox[x] = -(margin[3] || 0);
      clipBox[y] = -(margin[0] || 0);
      clipBox[w2] = chart.chartWidth + (margin[3] || 0) + (margin[1] || 0);
      clipBox[h] = chart.chartHeight + (margin[0] || 0) + (margin[2] || 0);
      chart.scale3d = 1;
      if (options3d.fitToPlot === true) {
        chart.scale3d = chart.chart3d.getScale(options3d.depth);
      }
      chart.chart3d.frame3d = chart.chart3d.get3dFrame();
    }
  }
  function onBeforeRedraw() {
    if (this.is3d()) {
      this.isDirtyBox = true;
    }
  }
  function onBeforeRender() {
    if (this.chart3d && this.is3d()) {
      this.chart3d.frame3d = this.chart3d.get3dFrame();
    }
  }
  function onInit() {
    if (!this.chart3d) {
      this.chart3d = new Composition(this);
    }
  }
  function wrapIsInsidePlot(proceed) {
    return this.is3d() || proceed.apply(this, [].slice.call(arguments, 1));
  }
  function wrapRenderSeries(proceed) {
    var series, i = this.series.length;
    if (this.is3d()) {
      while (i--) {
        series = this.series[i];
        series.translate();
        series.render();
      }
    } else {
      proceed.call(this);
    }
  }
  function wrapSetClassName(proceed) {
    proceed.apply(this, [].slice.call(arguments, 1));
    if (this.is3d()) {
      this.container.className += " highcharts-3d-chart";
    }
  }
})(Chart3D || (Chart3D = {}));
var Chart3D_default = Chart3D;

// node_modules/highcharts/es-modules/Core/Axis/ZAxis.js
var __extends38 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var addEvent46 = Utilities_default.addEvent;
var merge61 = Utilities_default.merge;
var pick71 = Utilities_default.pick;
var splat16 = Utilities_default.splat;
var ZChart = function() {
  function ZChart2() {
  }
  ZChart2.compose = function(ChartClass) {
    addEvent46(ChartClass, "afterGetAxes", ZChart2.onAfterGetAxes);
    var chartProto = ChartClass.prototype;
    chartProto.addZAxis = ZChart2.wrapAddZAxis;
    chartProto.collectionsWithInit.zAxis = [chartProto.addZAxis];
    chartProto.collectionsWithUpdate.push("zAxis");
  };
  ZChart2.onAfterGetAxes = function() {
    var chart = this;
    var options = this.options;
    var zAxisOptions = options.zAxis = splat16(options.zAxis || {});
    if (!chart.is3d()) {
      return;
    }
    chart.zAxis = [];
    zAxisOptions.forEach(function(axisOptions, i) {
      axisOptions.index = i;
      axisOptions.isX = true;
      chart.addZAxis(axisOptions).setScale();
    });
  };
  ZChart2.wrapAddZAxis = function(options) {
    return new ZAxis(this, options);
  };
  return ZChart2;
}();
var ZAxis = function(_super) {
  __extends38(ZAxis2, _super);
  function ZAxis2(chart, userOptions) {
    var _this = _super.call(this, chart, userOptions) || this;
    _this.isZAxis = true;
    return _this;
  }
  ZAxis2.prototype.getSeriesExtremes = function() {
    var axis = this;
    var chart = axis.chart;
    axis.hasVisibleSeries = false;
    axis.dataMin = axis.dataMax = axis.ignoreMinPadding = axis.ignoreMaxPadding = void 0;
    if (axis.stacking) {
      axis.stacking.buildStacks();
    }
    axis.series.forEach(function(series) {
      if (series.visible || !chart.options.chart.ignoreHiddenSeries) {
        var seriesOptions = series.options, zData = void 0, threshold = seriesOptions.threshold;
        axis.hasVisibleSeries = true;
        if (axis.positiveValuesOnly && threshold <= 0) {
          threshold = void 0;
        }
        zData = series.zData;
        if (zData.length) {
          axis.dataMin = Math.min(pick71(axis.dataMin, zData[0]), Math.min.apply(null, zData));
          axis.dataMax = Math.max(pick71(axis.dataMax, zData[0]), Math.max.apply(null, zData));
        }
      }
    });
  };
  ZAxis2.prototype.setAxisSize = function() {
    var axis = this;
    var chart = axis.chart;
    _super.prototype.setAxisSize.call(this);
    axis.width = axis.len = chart.options.chart.options3d && chart.options.chart.options3d.depth || 0;
    axis.right = chart.chartWidth - axis.width - axis.left;
  };
  ZAxis2.prototype.setOptions = function(userOptions) {
    userOptions = merge61({
      offset: 0,
      lineWidth: 0
    }, userOptions);
    this.isZAxis = true;
    _super.prototype.setOptions.call(this, userOptions);
    this.coll = "zAxis";
  };
  ZAxis2.ZChartComposition = ZChart;
  return ZAxis2;
}(Axis_default);
var ZAxis_default = ZAxis;

// node_modules/highcharts/es-modules/Core/Axis/Tick3D.js
var addEvent47 = Utilities_default.addEvent;
var extend63 = Utilities_default.extend;
var wrap8 = Utilities_default.wrap;
var Tick3D = function() {
  function Tick3D2() {
  }
  Tick3D2.compose = function(TickClass) {
    addEvent47(TickClass, "afterGetLabelPosition", Tick3D2.onAfterGetLabelPosition);
    var tickProto = TickClass.prototype;
    wrap8(tickProto, "getMarkPath", Tick3D2.wrapGetMarkPath);
  };
  Tick3D2.onAfterGetLabelPosition = function(e2) {
    var axis3D = this.axis.axis3D;
    if (axis3D) {
      extend63(e2.pos, axis3D.fix3dPosition(e2.pos));
    }
  };
  Tick3D2.wrapGetMarkPath = function(proceed) {
    var chart = this.axis.chart;
    var axis3D = this.axis.axis3D;
    var path = proceed.apply(this, [].slice.call(arguments, 1));
    if (axis3D) {
      var start = path[0];
      var end = path[1];
      if (start[0] === "M" && end[0] === "L") {
        var pArr = [
          axis3D.fix3dPosition({ x: start[1], y: start[2], z: 0 }),
          axis3D.fix3dPosition({ x: end[1], y: end[2], z: 0 })
        ];
        return this.axis.chart.renderer.toLineSegments(pArr);
      }
    }
    return path;
  };
  return Tick3D2;
}();
var Tick3D_default = Tick3D;

// node_modules/highcharts/es-modules/Core/Axis/Axis3D.js
var deg2rad8 = Globals_default.deg2rad;
var perspective4 = Math3D_default.perspective;
var perspective3D2 = Math3D_default.perspective3D;
var shapeArea3 = Math3D_default.shapeArea;
var addEvent48 = Utilities_default.addEvent;
var merge62 = Utilities_default.merge;
var pick72 = Utilities_default.pick;
var wrap9 = Utilities_default.wrap;
var Axis3DAdditions = function() {
  function Axis3DAdditions2(axis) {
    this.axis = axis;
  }
  Axis3DAdditions2.prototype.fix3dPosition = function(pos, isTitle) {
    var axis3D = this;
    var axis = axis3D.axis;
    var chart = axis.chart;
    if (axis.coll === "colorAxis" || !chart.chart3d || !chart.is3d()) {
      return pos;
    }
    var alpha = deg2rad8 * chart.options.chart.options3d.alpha, beta = deg2rad8 * chart.options.chart.options3d.beta, positionMode = pick72(isTitle && axis.options.title.position3d, axis.options.labels.position3d), skew = pick72(isTitle && axis.options.title.skew3d, axis.options.labels.skew3d), frame = chart.chart3d.frame3d, plotLeft = chart.plotLeft, plotRight = chart.plotWidth + plotLeft, plotTop = chart.plotTop, plotBottom = chart.plotHeight + plotTop;
    var offsetX = 0, offsetY = 0, vecX, vecY = { x: 0, y: 1, z: 0 }, reverseFlap = false;
    pos = axis.axis3D.swapZ({ x: pos.x, y: pos.y, z: 0 });
    if (axis.isZAxis) {
      if (axis.opposite) {
        if (frame.axes.z.top === null) {
          return {};
        }
        offsetY = pos.y - plotTop;
        pos.x = frame.axes.z.top.x;
        pos.y = frame.axes.z.top.y;
        vecX = frame.axes.z.top.xDir;
        reverseFlap = !frame.top.frontFacing;
      } else {
        if (frame.axes.z.bottom === null) {
          return {};
        }
        offsetY = pos.y - plotBottom;
        pos.x = frame.axes.z.bottom.x;
        pos.y = frame.axes.z.bottom.y;
        vecX = frame.axes.z.bottom.xDir;
        reverseFlap = !frame.bottom.frontFacing;
      }
    } else if (axis.horiz) {
      if (axis.opposite) {
        if (frame.axes.x.top === null) {
          return {};
        }
        offsetY = pos.y - plotTop;
        pos.y = frame.axes.x.top.y;
        pos.z = frame.axes.x.top.z;
        vecX = frame.axes.x.top.xDir;
        reverseFlap = !frame.top.frontFacing;
      } else {
        if (frame.axes.x.bottom === null) {
          return {};
        }
        offsetY = pos.y - plotBottom;
        pos.y = frame.axes.x.bottom.y;
        pos.z = frame.axes.x.bottom.z;
        vecX = frame.axes.x.bottom.xDir;
        reverseFlap = !frame.bottom.frontFacing;
      }
    } else {
      if (axis.opposite) {
        if (frame.axes.y.right === null) {
          return {};
        }
        offsetX = pos.x - plotRight;
        pos.x = frame.axes.y.right.x;
        pos.z = frame.axes.y.right.z;
        vecX = frame.axes.y.right.xDir;
        vecX = { x: vecX.z, y: vecX.y, z: -vecX.x };
      } else {
        if (frame.axes.y.left === null) {
          return {};
        }
        offsetX = pos.x - plotLeft;
        pos.x = frame.axes.y.left.x;
        pos.z = frame.axes.y.left.z;
        vecX = frame.axes.y.left.xDir;
      }
    }
    if (positionMode === "chart") {
    } else if (positionMode === "flap") {
      if (!axis.horiz) {
        vecX = { x: Math.cos(beta), y: 0, z: Math.sin(beta) };
      } else {
        var sin2 = Math.sin(alpha);
        var cos2 = Math.cos(alpha);
        if (axis.opposite) {
          sin2 = -sin2;
        }
        if (reverseFlap) {
          sin2 = -sin2;
        }
        vecY = { x: vecX.z * sin2, y: cos2, z: -vecX.x * sin2 };
      }
    } else if (positionMode === "ortho") {
      if (!axis.horiz) {
        vecX = { x: Math.cos(beta), y: 0, z: Math.sin(beta) };
      } else {
        var sina = Math.sin(alpha);
        var cosa = Math.cos(alpha);
        var sinb = Math.sin(beta);
        var cosb = Math.cos(beta);
        var vecZ = { x: sinb * cosa, y: -sina, z: -cosa * cosb };
        vecY = {
          x: vecX.y * vecZ.z - vecX.z * vecZ.y,
          y: vecX.z * vecZ.x - vecX.x * vecZ.z,
          z: vecX.x * vecZ.y - vecX.y * vecZ.x
        };
        var scale = 1 / Math.sqrt(vecY.x * vecY.x + vecY.y * vecY.y + vecY.z * vecY.z);
        if (reverseFlap) {
          scale = -scale;
        }
        vecY = { x: scale * vecY.x, y: scale * vecY.y, z: scale * vecY.z };
      }
    } else {
      if (!axis.horiz) {
        vecX = { x: Math.cos(beta), y: 0, z: Math.sin(beta) };
      } else {
        vecY = {
          x: Math.sin(beta) * Math.sin(alpha),
          y: Math.cos(alpha),
          z: -Math.cos(beta) * Math.sin(alpha)
        };
      }
    }
    pos.x += offsetX * vecX.x + offsetY * vecY.x;
    pos.y += offsetX * vecX.y + offsetY * vecY.y;
    pos.z += offsetX * vecX.z + offsetY * vecY.z;
    var projected = perspective4([pos], axis.chart)[0];
    if (skew) {
      var isMirrored = shapeArea3(perspective4([
        pos,
        { x: pos.x + vecX.x, y: pos.y + vecX.y, z: pos.z + vecX.z },
        { x: pos.x + vecY.x, y: pos.y + vecY.y, z: pos.z + vecY.z }
      ], axis.chart)) < 0;
      if (isMirrored) {
        vecX = { x: -vecX.x, y: -vecX.y, z: -vecX.z };
      }
      var pointsProjected = perspective4([
        { x: pos.x, y: pos.y, z: pos.z },
        { x: pos.x + vecX.x, y: pos.y + vecX.y, z: pos.z + vecX.z },
        { x: pos.x + vecY.x, y: pos.y + vecY.y, z: pos.z + vecY.z }
      ], axis.chart);
      projected.matrix = [
        pointsProjected[1].x - pointsProjected[0].x,
        pointsProjected[1].y - pointsProjected[0].y,
        pointsProjected[2].x - pointsProjected[0].x,
        pointsProjected[2].y - pointsProjected[0].y,
        projected.x,
        projected.y
      ];
      projected.matrix[4] -= projected.x * projected.matrix[0] + projected.y * projected.matrix[2];
      projected.matrix[5] -= projected.x * projected.matrix[1] + projected.y * projected.matrix[3];
    }
    return projected;
  };
  Axis3DAdditions2.prototype.swapZ = function(p, insidePlotArea) {
    var axis = this.axis;
    if (axis.isZAxis) {
      var plotLeft = insidePlotArea ? 0 : axis.chart.plotLeft;
      return {
        x: plotLeft + p.z,
        y: p.y,
        z: p.x - plotLeft
      };
    }
    return p;
  };
  return Axis3DAdditions2;
}();
var Axis3D = function() {
  function Axis3D2() {
  }
  Axis3D2.compose = function(AxisClass) {
    merge62(true, AxisClass.defaultOptions, Axis3D2.defaultOptions);
    AxisClass.keepProps.push("axis3D");
    addEvent48(AxisClass, "init", Axis3D2.onInit);
    addEvent48(AxisClass, "afterSetOptions", Axis3D2.onAfterSetOptions);
    addEvent48(AxisClass, "drawCrosshair", Axis3D2.onDrawCrosshair);
    var axisProto = AxisClass.prototype;
    wrap9(axisProto, "getLinePath", Axis3D2.wrapGetLinePath);
    wrap9(axisProto, "getPlotBandPath", Axis3D2.wrapGetPlotBandPath);
    wrap9(axisProto, "getPlotLinePath", Axis3D2.wrapGetPlotLinePath);
    wrap9(axisProto, "getSlotWidth", Axis3D2.wrapGetSlotWidth);
    wrap9(axisProto, "getTitlePosition", Axis3D2.wrapGetTitlePosition);
    Tick3D_default.compose(Tick_default);
  };
  Axis3D2.onAfterSetOptions = function() {
    var axis = this;
    var chart = axis.chart;
    var options = axis.options;
    if (chart.is3d && chart.is3d() && axis.coll !== "colorAxis") {
      options.tickWidth = pick72(options.tickWidth, 0);
      options.gridLineWidth = pick72(options.gridLineWidth, 1);
    }
  };
  Axis3D2.onDrawCrosshair = function(e2) {
    var axis = this;
    if (axis.chart.is3d() && axis.coll !== "colorAxis") {
      if (e2.point) {
        e2.point.crosshairPos = axis.isXAxis ? e2.point.axisXpos : axis.len - e2.point.axisYpos;
      }
    }
  };
  Axis3D2.onInit = function() {
    var axis = this;
    if (!axis.axis3D) {
      axis.axis3D = new Axis3DAdditions(axis);
    }
  };
  Axis3D2.wrapGetLinePath = function(proceed) {
    var axis = this;
    if (!axis.chart.is3d() || axis.coll === "colorAxis") {
      return proceed.apply(axis, [].slice.call(arguments, 1));
    }
    return [];
  };
  Axis3D2.wrapGetPlotBandPath = function(proceed) {
    if (!this.chart.is3d() || this.coll === "colorAxis") {
      return proceed.apply(this, [].slice.call(arguments, 1));
    }
    var args = arguments, from = args[1], to = args[2], path = [], fromPath = this.getPlotLinePath({ value: from }), toPath = this.getPlotLinePath({ value: to });
    if (fromPath && toPath) {
      for (var i = 0; i < fromPath.length; i += 2) {
        var fromStartSeg = fromPath[i], fromEndSeg = fromPath[i + 1], toStartSeg = toPath[i], toEndSeg = toPath[i + 1];
        if (fromStartSeg[0] === "M" && fromEndSeg[0] === "L" && toStartSeg[0] === "M" && toEndSeg[0] === "L") {
          path.push(fromStartSeg, fromEndSeg, toEndSeg, ["L", toStartSeg[1], toStartSeg[2]], ["Z"]);
        }
      }
    }
    return path;
  };
  Axis3D2.wrapGetPlotLinePath = function(proceed) {
    var axis = this, axis3D = axis.axis3D, chart = axis.chart, path = proceed.apply(axis, [].slice.call(arguments, 1));
    if (axis.coll === "colorAxis" || !chart.chart3d || !chart.is3d()) {
      return path;
    }
    if (path === null) {
      return path;
    }
    var options3d = chart.options.chart.options3d, d = axis.isZAxis ? chart.plotWidth : options3d.depth, frame = chart.chart3d.frame3d, startSegment = path[0], endSegment = path[1];
    var pArr, pathSegments = [];
    if (startSegment[0] === "M" && endSegment[0] === "L") {
      pArr = [
        axis3D.swapZ({ x: startSegment[1], y: startSegment[2], z: 0 }),
        axis3D.swapZ({ x: startSegment[1], y: startSegment[2], z: d }),
        axis3D.swapZ({ x: endSegment[1], y: endSegment[2], z: 0 }),
        axis3D.swapZ({ x: endSegment[1], y: endSegment[2], z: d })
      ];
      if (!this.horiz) {
        if (frame.front.visible) {
          pathSegments.push(pArr[0], pArr[2]);
        }
        if (frame.back.visible) {
          pathSegments.push(pArr[1], pArr[3]);
        }
        if (frame.left.visible) {
          pathSegments.push(pArr[0], pArr[1]);
        }
        if (frame.right.visible) {
          pathSegments.push(pArr[2], pArr[3]);
        }
      } else if (this.isZAxis) {
        if (frame.left.visible) {
          pathSegments.push(pArr[0], pArr[2]);
        }
        if (frame.right.visible) {
          pathSegments.push(pArr[1], pArr[3]);
        }
        if (frame.top.visible) {
          pathSegments.push(pArr[0], pArr[1]);
        }
        if (frame.bottom.visible) {
          pathSegments.push(pArr[2], pArr[3]);
        }
      } else {
        if (frame.front.visible) {
          pathSegments.push(pArr[0], pArr[2]);
        }
        if (frame.back.visible) {
          pathSegments.push(pArr[1], pArr[3]);
        }
        if (frame.top.visible) {
          pathSegments.push(pArr[0], pArr[1]);
        }
        if (frame.bottom.visible) {
          pathSegments.push(pArr[2], pArr[3]);
        }
      }
      pathSegments = perspective4(pathSegments, this.chart, false);
    }
    return chart.renderer.toLineSegments(pathSegments);
  };
  Axis3D2.wrapGetSlotWidth = function(proceed, tick) {
    var axis = this, chart = axis.chart, ticks = axis.ticks, gridGroup = axis.gridGroup;
    if (axis.categories && chart.frameShapes && chart.is3d() && gridGroup && tick && tick.label) {
      var firstGridLine = gridGroup.element.childNodes[0].getBBox(), frame3DLeft = chart.frameShapes.left.getBBox(), options3d = chart.options.chart.options3d, origin_1 = {
        x: chart.plotWidth / 2,
        y: chart.plotHeight / 2,
        z: options3d.depth / 2,
        vd: pick72(options3d.depth, 1) * pick72(options3d.viewDistance, 0)
      }, tickId = tick.pos, prevTick = ticks[tickId - 1], nextTick = ticks[tickId + 1];
      var labelPos = void 0, prevLabelPos = void 0, nextLabelPos = void 0;
      if (tickId !== 0 && prevTick && prevTick.label && prevTick.label.xy) {
        prevLabelPos = perspective3D2({
          x: prevTick.label.xy.x,
          y: prevTick.label.xy.y,
          z: null
        }, origin_1, origin_1.vd);
      }
      if (nextTick && nextTick.label && nextTick.label.xy) {
        nextLabelPos = perspective3D2({
          x: nextTick.label.xy.x,
          y: nextTick.label.xy.y,
          z: null
        }, origin_1, origin_1.vd);
      }
      labelPos = {
        x: tick.label.xy.x,
        y: tick.label.xy.y,
        z: null
      };
      labelPos = perspective3D2(labelPos, origin_1, origin_1.vd);
      return Math.abs(prevLabelPos ? labelPos.x - prevLabelPos.x : nextLabelPos ? nextLabelPos.x - labelPos.x : firstGridLine.x - frame3DLeft.x);
    }
    return proceed.apply(axis, [].slice.call(arguments, 1));
  };
  Axis3D2.wrapGetTitlePosition = function(proceed) {
    var pos = proceed.apply(this, [].slice.call(arguments, 1));
    return this.axis3D ? this.axis3D.fix3dPosition(pos, true) : pos;
  };
  Axis3D2.defaultOptions = {
    labels: {
      position3d: "offset",
      skew3d: false
    },
    title: {
      position3d: null,
      skew3d: null
    }
  };
  return Axis3D2;
}();
var Axis3D_default = Axis3D;

// node_modules/highcharts/es-modules/Core/Series/Series3D.js
var __extends39 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var perspective5 = Math3D_default.perspective;
var addEvent49 = Utilities_default.addEvent;
var extend64 = Utilities_default.extend;
var merge63 = Utilities_default.merge;
var pick73 = Utilities_default.pick;
var isNumber43 = Utilities_default.isNumber;
var Series3D = function(_super) {
  __extends39(Series3D2, _super);
  function Series3D2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Series3D2.prototype.translate = function() {
    _super.prototype.translate.apply(this, arguments);
    if (this.chart.is3d()) {
      this.translate3dPoints();
    }
  };
  Series3D2.prototype.translate3dPoints = function() {
    var series = this, seriesOptions = series.options, chart = series.chart, zAxis = pick73(series.zAxis, chart.options.zAxis[0]), rawPoints = [], rawPoint, projectedPoints, projectedPoint, zValue, i, rawPointsX = [], stack = seriesOptions.stacking ? isNumber43(seriesOptions.stack) ? seriesOptions.stack : 0 : series.index || 0;
    series.zPadding = stack * (seriesOptions.depth || 0 + (seriesOptions.groupZPadding || 1));
    for (i = 0; i < series.data.length; i++) {
      rawPoint = series.data[i];
      if (zAxis && zAxis.translate) {
        zValue = zAxis.logarithmic && zAxis.val2lin ? zAxis.val2lin(rawPoint.z) : rawPoint.z;
        rawPoint.plotZ = zAxis.translate(zValue);
        rawPoint.isInside = rawPoint.isInside ? zValue >= zAxis.min && zValue <= zAxis.max : false;
      } else {
        rawPoint.plotZ = series.zPadding;
      }
      rawPoint.axisXpos = rawPoint.plotX;
      rawPoint.axisYpos = rawPoint.plotY;
      rawPoint.axisZpos = rawPoint.plotZ;
      rawPoints.push({
        x: rawPoint.plotX,
        y: rawPoint.plotY,
        z: rawPoint.plotZ
      });
      rawPointsX.push(rawPoint.plotX || 0);
    }
    series.rawPointsX = rawPointsX;
    projectedPoints = perspective5(rawPoints, chart, true);
    for (i = 0; i < series.data.length; i++) {
      rawPoint = series.data[i];
      projectedPoint = projectedPoints[i];
      rawPoint.plotX = projectedPoint.x;
      rawPoint.plotY = projectedPoint.y;
      rawPoint.plotZ = projectedPoint.z;
    }
  };
  Series3D2.defaultOptions = merge63(Series_default.defaultOptions);
  return Series3D2;
}(Series_default);
addEvent49(Series_default, "afterTranslate", function() {
  if (this.chart.is3d()) {
    this.translate3dPoints();
  }
});
extend64(Series_default.prototype, {
  translate3dPoints: Series3D.prototype.translate3dPoints
});

// node_modules/highcharts/es-modules/Series/Column3D/Column3DComposition.js
var columnProto5 = ColumnSeries_default.prototype;
var svg5 = Globals_default.svg;
var perspective6 = Math3D_default.perspective;
var addEvent50 = Utilities_default.addEvent;
var pick74 = Utilities_default.pick;
var wrap10 = Utilities_default.wrap;
function retrieveStacks(chart, stacking) {
  var series = chart.series, stacks = { totalStacks: 0 };
  var stackNumber, i = 1;
  series.forEach(function(s) {
    stackNumber = pick74(s.options.stack, stacking ? 0 : series.length - 1 - s.index);
    if (!stacks[stackNumber]) {
      stacks[stackNumber] = { series: [s], position: i };
      i++;
    } else {
      stacks[stackNumber].series.push(s);
    }
  });
  stacks.totalStacks = i + 1;
  return stacks;
}
wrap10(columnProto5, "translate", function(proceed) {
  proceed.apply(this, [].slice.call(arguments, 1));
  if (this.chart.is3d()) {
    this.translate3dShapes();
  }
});
wrap10(Series_default.prototype, "justifyDataLabel", function(proceed) {
  return !arguments[2].outside3dPlot ? proceed.apply(this, [].slice.call(arguments, 1)) : false;
});
columnProto5.translate3dPoints = function() {
};
columnProto5.translate3dShapes = function() {
  var series = this, chart = series.chart, seriesOptions = series.options, depth = seriesOptions.depth, stack = seriesOptions.stacking ? seriesOptions.stack || 0 : series.index, z = stack * (depth + (seriesOptions.groupZPadding || 1)), borderCrisp = series.borderWidth % 2 ? 0.5 : 0, point2dPos;
  if (chart.inverted && !series.yAxis.reversed) {
    borderCrisp *= -1;
  }
  if (seriesOptions.grouping !== false) {
    z = 0;
  }
  z += seriesOptions.groupZPadding || 1;
  series.data.forEach(function(point) {
    point.outside3dPlot = null;
    if (point.y !== null) {
      var shapeArgs_1 = point.shapeArgs, tooltipPos = point.tooltipPos, dimensions = [["x", "width"], ["y", "height"]], borderlessBase_1;
      dimensions.forEach(function(d) {
        borderlessBase_1 = shapeArgs_1[d[0]] - borderCrisp;
        if (borderlessBase_1 < 0) {
          shapeArgs_1[d[1]] += shapeArgs_1[d[0]] + borderCrisp;
          shapeArgs_1[d[0]] = -borderCrisp;
          borderlessBase_1 = 0;
        }
        if (borderlessBase_1 + shapeArgs_1[d[1]] > series[d[0] + "Axis"].len && shapeArgs_1[d[1]] !== 0) {
          shapeArgs_1[d[1]] = series[d[0] + "Axis"].len - shapeArgs_1[d[0]];
        }
        if (shapeArgs_1[d[1]] !== 0 && (shapeArgs_1[d[0]] >= series[d[0] + "Axis"].len || shapeArgs_1[d[0]] + shapeArgs_1[d[1]] <= borderCrisp)) {
          for (var key in shapeArgs_1) {
            shapeArgs_1[key] = key === "y" ? -9999 : 0;
          }
          point.outside3dPlot = true;
        }
      });
      if (point.shapeType === "rect") {
        point.shapeType = "cuboid";
      }
      shapeArgs_1.z = z;
      shapeArgs_1.depth = depth;
      shapeArgs_1.insidePlotArea = true;
      point2dPos = {
        x: shapeArgs_1.x + shapeArgs_1.width / 2,
        y: shapeArgs_1.y,
        z: z + depth / 2
      };
      if (chart.inverted) {
        point2dPos.x = shapeArgs_1.height;
        point2dPos.y = point.clientX;
      }
      point.plot3d = perspective6([point2dPos], chart, true, false)[0];
      tooltipPos = perspective6([{
        x: tooltipPos[0],
        y: tooltipPos[1],
        z: z + depth / 2
      }], chart, true, false)[0];
      point.tooltipPos = [tooltipPos.x, tooltipPos.y];
    }
  });
  series.z = z;
};
wrap10(columnProto5, "animate", function(proceed) {
  if (!this.chart.is3d()) {
    proceed.apply(this, [].slice.call(arguments, 1));
  } else {
    var args = arguments, init = args[1], yAxis_1 = this.yAxis, series_1 = this, reversed_1 = this.yAxis.reversed;
    if (svg5) {
      if (init) {
        series_1.data.forEach(function(point) {
          if (point.y !== null) {
            point.height = point.shapeArgs.height;
            point.shapey = point.shapeArgs.y;
            point.shapeArgs.height = 1;
            if (!reversed_1) {
              if (point.stackY) {
                point.shapeArgs.y = point.plotY + yAxis_1.translate(point.stackY);
              } else {
                point.shapeArgs.y = point.plotY + (point.negative ? -point.height : point.height);
              }
            }
          }
        });
      } else {
        series_1.data.forEach(function(point) {
          if (point.y !== null) {
            point.shapeArgs.height = point.height;
            point.shapeArgs.y = point.shapey;
            if (point.graphic) {
              point.graphic[point.outside3dPlot ? "attr" : "animate"](point.shapeArgs, series_1.options.animation);
            }
          }
        });
        this.drawDataLabels();
      }
    }
  }
});
wrap10(columnProto5, "plotGroup", function(proceed, prop, _name, _visibility, _zIndex, parent) {
  if (prop !== "dataLabelsGroup") {
    if (this.chart.is3d()) {
      if (this[prop]) {
        delete this[prop];
      }
      if (parent) {
        if (!this.chart.columnGroup) {
          this.chart.columnGroup = this.chart.renderer.g("columnGroup").add(parent);
        }
        this[prop] = this.chart.columnGroup;
        this.chart.columnGroup.attr(this.getPlotBox());
        this[prop].survive = true;
        if (prop === "group" || prop === "markerGroup") {
          arguments[3] = "visible";
        }
      }
    }
  }
  return proceed.apply(this, Array.prototype.slice.call(arguments, 1));
});
wrap10(columnProto5, "setVisible", function(proceed, vis) {
  var series = this;
  if (series.chart.is3d()) {
    series.data.forEach(function(point) {
      point.visible = point.options.visible = vis = typeof vis === "undefined" ? !pick74(series.visible, point.visible) : vis;
      series.options.data[series.data.indexOf(point)] = point.options;
      if (point.graphic) {
        point.graphic.attr({
          visibility: vis ? "visible" : "hidden"
        });
      }
    });
  }
  proceed.apply(this, Array.prototype.slice.call(arguments, 1));
});
addEvent50(ColumnSeries_default, "afterInit", function() {
  if (this.chart.is3d()) {
    var series = this, seriesOptions = this.options, grouping = seriesOptions.grouping, stacking = seriesOptions.stacking, reversedStacks = this.yAxis.options.reversedStacks, z = 0;
    if (!(typeof grouping !== "undefined" && !grouping)) {
      var stacks = retrieveStacks(this.chart, stacking), stack = seriesOptions.stack || 0, i = void 0;
      for (i = 0; i < stacks[stack].series.length; i++) {
        if (stacks[stack].series[i] === this) {
          break;
        }
      }
      z = 10 * (stacks.totalStacks - stacks[stack].position) + (reversedStacks ? i : -i);
      if (!this.xAxis.reversed) {
        z = stacks.totalStacks * 10 - z;
      }
    }
    seriesOptions.depth = seriesOptions.depth || 25;
    series.z = series.z || 0;
    seriesOptions.zIndex = z;
  }
});
function pointAttribs(proceed) {
  var attr10 = proceed.apply(this, [].slice.call(arguments, 1));
  if (this.chart.is3d && this.chart.is3d()) {
    attr10.stroke = this.options.edgeColor || attr10.fill;
    attr10["stroke-width"] = pick74(this.options.edgeWidth, 1);
  }
  return attr10;
}
function setState(proceed, state, inherit) {
  var is3d = this.chart.is3d && this.chart.is3d();
  if (is3d) {
    this.options.inactiveOtherPoints = true;
  }
  proceed.call(this, state, inherit);
  if (is3d) {
    this.options.inactiveOtherPoints = false;
  }
}
function hasNewShapeType(proceed) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  return this.series.chart.is3d() ? this.graphic && this.graphic.element.nodeName !== "g" : proceed.apply(this, args);
}
wrap10(columnProto5, "pointAttribs", pointAttribs);
wrap10(columnProto5, "setState", setState);
wrap10(columnProto5.pointClass.prototype, "hasNewShapeType", hasNewShapeType);
if (SeriesRegistry_default.seriesTypes.columnRange) {
  columnRangeProto = SeriesRegistry_default.seriesTypes.columnrange.prototype;
  wrap10(columnRangeProto, "pointAttribs", pointAttribs);
  wrap10(columnRangeProto, "setState", setState);
  wrap10(columnRangeProto.pointClass.prototype, "hasNewShapeType", hasNewShapeType);
  columnRangeProto.plotGroup = columnProto5.plotGroup;
  columnRangeProto.setVisible = columnProto5.setVisible;
}
var columnRangeProto;
wrap10(Series_default.prototype, "alignDataLabel", function(proceed, point, dataLabel, options, alignTo) {
  var chart = this.chart;
  options.outside3dPlot = point.outside3dPlot;
  if (chart.is3d() && this.is("column")) {
    var series = this, seriesOptions = series.options, inside = pick74(options.inside, !!series.options.stacking), options3d = chart.options.chart.options3d, xOffset = point.pointWidth / 2 || 0;
    var dLPosition = {
      x: alignTo.x + xOffset,
      y: alignTo.y,
      z: series.z + seriesOptions.depth / 2
    };
    if (chart.inverted) {
      if (inside) {
        alignTo.width = 0;
        dLPosition.x += point.shapeArgs.height / 2;
      }
      if (options3d.alpha >= 90 && options3d.alpha <= 270) {
        dLPosition.y += point.shapeArgs.width;
      }
    }
    dLPosition = perspective6([dLPosition], chart, true, false)[0];
    alignTo.x = dLPosition.x - xOffset;
    alignTo.y = point.outside3dPlot ? -9e9 : dLPosition.y;
  }
  proceed.apply(this, [].slice.call(arguments, 1));
});
wrap10(Stacking_default.prototype, "getStackBox", function(proceed, chart, stackItem, x, y, xWidth, h, axis) {
  var stackBox = proceed.apply(this, [].slice.call(arguments, 1));
  if (chart.is3d() && stackItem.base) {
    var baseSeriesInd = +stackItem.base.split(",")[0];
    var columnSeries = chart.series[baseSeriesInd];
    var options3d = chart.options.chart.options3d;
    if (columnSeries && columnSeries instanceof SeriesRegistry_default.seriesTypes.column) {
      var dLPosition = {
        x: stackBox.x + (chart.inverted ? h : xWidth / 2),
        y: stackBox.y,
        z: columnSeries.options.depth / 2
      };
      if (chart.inverted) {
        stackBox.width = 0;
        if (options3d.alpha >= 90 && options3d.alpha <= 270) {
          dLPosition.y += xWidth;
        }
      }
      dLPosition = perspective6([dLPosition], chart, true, false)[0];
      stackBox.x = dLPosition.x - xWidth / 2;
      stackBox.y = dLPosition.y;
    }
  }
  return stackBox;
});

// node_modules/highcharts/es-modules/Series/Pie3D/Pie3DPoint.js
var __extends40 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PiePoint2 = SeriesRegistry_default.seriesTypes.pie.prototype.pointClass;
var superHaloPath = PiePoint2.prototype.haloPath;
var Pie3DPoint = function(_super) {
  __extends40(Pie3DPoint2, _super);
  function Pie3DPoint2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.series = void 0;
    return _this;
  }
  Pie3DPoint2.prototype.haloPath = function() {
    return this.series.chart.is3d() ? [] : superHaloPath.apply(this, arguments);
  };
  return Pie3DPoint2;
}(PiePoint2);
var Pie3DPoint_default = Pie3DPoint;

// node_modules/highcharts/es-modules/Series/Pie3D/Pie3DSeries.js
var __extends41 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var deg2rad9 = Globals_default.deg2rad;
var svg6 = Globals_default.svg;
var PieSeries2 = SeriesRegistry_default.seriesTypes.pie;
var extend65 = Utilities_default.extend;
var pick75 = Utilities_default.pick;
var Pie3DSeries = function(_super) {
  __extends41(Pie3DSeries2, _super);
  function Pie3DSeries2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Pie3DSeries2.prototype.addPoint = function() {
    _super.prototype.addPoint.apply(this, arguments);
    if (this.chart.is3d()) {
      this.update(this.userOptions, true);
    }
  };
  Pie3DSeries2.prototype.animate = function(init) {
    if (!this.chart.is3d()) {
      _super.prototype.animate.apply(this, arguments);
    } else {
      var animation = this.options.animation, attribs = void 0, center = this.center, group = this.group, markerGroup = this.markerGroup;
      if (svg6) {
        if (animation === true) {
          animation = {};
        }
        if (init) {
          group.oldtranslateX = pick75(group.oldtranslateX, group.translateX);
          group.oldtranslateY = pick75(group.oldtranslateY, group.translateY);
          attribs = {
            translateX: center[0],
            translateY: center[1],
            scaleX: 1e-3,
            scaleY: 1e-3
          };
          group.attr(attribs);
          if (markerGroup) {
            markerGroup.attrSetters = group.attrSetters;
            markerGroup.attr(attribs);
          }
        } else {
          attribs = {
            translateX: group.oldtranslateX,
            translateY: group.oldtranslateY,
            scaleX: 1,
            scaleY: 1
          };
          group.animate(attribs, animation);
          if (markerGroup) {
            markerGroup.animate(attribs, animation);
          }
        }
      }
    }
  };
  Pie3DSeries2.prototype.drawDataLabels = function() {
    if (this.chart.is3d()) {
      var series = this, chart = series.chart, options3d_1 = chart.options.chart.options3d;
      series.data.forEach(function(point) {
        var shapeArgs = point.shapeArgs, r = shapeArgs.r, a1 = (shapeArgs.alpha || options3d_1.alpha) * deg2rad9, b1 = (shapeArgs.beta || options3d_1.beta) * deg2rad9, a2 = (shapeArgs.start + shapeArgs.end) / 2, labelPosition = point.labelPosition, connectorPosition = labelPosition.connectorPosition, yOffset = -r * (1 - Math.cos(a1)) * Math.sin(a2), xOffset = r * (Math.cos(b1) - 1) * Math.cos(a2);
        [
          labelPosition.natural,
          connectorPosition.breakAt,
          connectorPosition.touchingSliceAt
        ].forEach(function(coordinates) {
          coordinates.x += xOffset;
          coordinates.y += yOffset;
        });
      });
    }
    _super.prototype.drawDataLabels.apply(this, arguments);
  };
  Pie3DSeries2.prototype.pointAttribs = function(point) {
    var attr10 = _super.prototype.pointAttribs.apply(this, arguments), options = this.options;
    if (this.chart.is3d() && !this.chart.styledMode) {
      attr10.stroke = options.edgeColor || point.color || this.color;
      attr10["stroke-width"] = pick75(options.edgeWidth, 1);
    }
    return attr10;
  };
  Pie3DSeries2.prototype.translate = function() {
    _super.prototype.translate.apply(this, arguments);
    if (!this.chart.is3d()) {
      return;
    }
    var series = this, seriesOptions = series.options, depth = seriesOptions.depth || 0, options3d = series.chart.options.chart.options3d, alpha = options3d.alpha, beta = options3d.beta, z = seriesOptions.stacking ? (seriesOptions.stack || 0) * depth : series._i * depth;
    z += depth / 2;
    if (seriesOptions.grouping !== false) {
      z = 0;
    }
    series.data.forEach(function(point) {
      var shapeArgs = point.shapeArgs, angle;
      point.shapeType = "arc3d";
      shapeArgs.z = z;
      shapeArgs.depth = depth * 0.75;
      shapeArgs.alpha = alpha;
      shapeArgs.beta = beta;
      shapeArgs.center = series.center;
      angle = (shapeArgs.end + shapeArgs.start) / 2;
      point.slicedTranslation = {
        translateX: Math.round(Math.cos(angle) * seriesOptions.slicedOffset * Math.cos(alpha * deg2rad9)),
        translateY: Math.round(Math.sin(angle) * seriesOptions.slicedOffset * Math.cos(alpha * deg2rad9))
      };
    });
  };
  return Pie3DSeries2;
}(PieSeries2);
extend65(Pie3DSeries.prototype, {
  pointClass: Pie3DPoint_default
});
var Pie3DSeries_default = Pie3DSeries;

// node_modules/highcharts/es-modules/Series/Pie3D/Pie3DComposition.js
SeriesRegistry_default.seriesTypes.pie.prototype.pointClass.prototype.haloPath = Pie3DPoint_default.prototype.haloPath;
SeriesRegistry_default.seriesTypes.pie = Pie3DSeries_default;

// node_modules/highcharts/es-modules/Series/Scatter3D/Scatter3DPoint.js
var __extends42 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var defined46 = Utilities_default.defined;
var Scatter3DPoint = function(_super) {
  __extends42(Scatter3DPoint2, _super);
  function Scatter3DPoint2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.options = void 0;
    _this.series = void 0;
    return _this;
  }
  Scatter3DPoint2.prototype.applyOptions = function() {
    _super.prototype.applyOptions.apply(this, arguments);
    if (!defined46(this.z)) {
      this.z = 0;
    }
    return this;
  };
  return Scatter3DPoint2;
}(ScatterSeries_default.prototype.pointClass);
var Scatter3DPoint_default = Scatter3DPoint;

// node_modules/highcharts/es-modules/Series/Scatter3D/Scatter3DSeries.js
var __extends43 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var pointCameraDistance2 = Math3D_default.pointCameraDistance;
var extend66 = Utilities_default.extend;
var merge64 = Utilities_default.merge;
var Scatter3DSeries = function(_super) {
  __extends43(Scatter3DSeries2, _super);
  function Scatter3DSeries2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.data = void 0;
    _this.options = void 0;
    _this.points = void 0;
    return _this;
  }
  Scatter3DSeries2.prototype.pointAttribs = function(point) {
    var attribs = _super.prototype.pointAttribs.apply(this, arguments);
    if (this.chart.is3d() && point) {
      attribs.zIndex = pointCameraDistance2(point, this.chart);
    }
    return attribs;
  };
  Scatter3DSeries2.defaultOptions = merge64(ScatterSeries_default.defaultOptions, {
    tooltip: {
      pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>z: <b>{point.z}</b><br/>"
    }
  });
  return Scatter3DSeries2;
}(ScatterSeries_default);
extend66(Scatter3DSeries.prototype, {
  axisTypes: ["xAxis", "yAxis", "zAxis"],
  directTouch: true,
  parallelArrays: ["x", "y", "z"],
  pointArrayMap: ["x", "y", "z"],
  pointClass: Scatter3DPoint_default
});
SeriesRegistry_default.registerSeriesType("scatter3d", Scatter3DSeries);

// node_modules/highcharts/es-modules/Series/Area3DSeries.js
var perspective7 = Math3D_default.perspective;
var _a8 = SeriesRegistry_default.seriesTypes;
var AreaSeriesClass = _a8.area;
var LineSeriesClass = _a8.line;
var pick76 = Utilities_default.pick;
var wrap11 = Utilities_default.wrap;
wrap11(AreaSeriesClass.prototype, "getGraphPath", function(proceed) {
  var series = this, svgPath = proceed.apply(series, [].slice.call(arguments, 1));
  if (!series.chart.is3d()) {
    return svgPath;
  }
  var getGraphPath = LineSeriesClass.prototype.getGraphPath, graphPath = [], options = series.options, stacking = options.stacking, bottomPath, bottomPoints = [], graphPoints = [], i, areaPath, connectNulls = pick76(options.connectNulls, stacking === "percent"), translatedThreshold = Math.round(series.yAxis.getThreshold(options.threshold)), options3d;
  if (series.rawPointsX) {
    for (var i_1 = 0; i_1 < series.points.length; i_1++) {
      bottomPoints.push({
        x: series.rawPointsX[i_1],
        y: options.stacking ? series.points[i_1].yBottom : translatedThreshold,
        z: series.zPadding
      });
    }
  }
  options3d = series.chart.options.chart.options3d;
  bottomPoints = perspective7(bottomPoints, series.chart, true).map(function(point) {
    return { plotX: point.x, plotY: point.y, plotZ: point.z };
  });
  if (series.group && options3d && options3d.depth && options3d.beta) {
    if (series.markerGroup) {
      series.markerGroup.add(series.group);
      series.markerGroup.attr({
        translateX: 0,
        translateY: 0
      });
    }
    series.group.attr({
      zIndex: Math.max(1, options3d.beta > 270 || options3d.beta < 90 ? options3d.depth - Math.round(series.zPadding || 0) : Math.round(series.zPadding || 0))
    });
  }
  bottomPoints.reversed = true;
  bottomPath = getGraphPath.call(series, bottomPoints, true, true);
  if (bottomPath[0] && bottomPath[0][0] === "M") {
    bottomPath[0] = ["L", bottomPath[0][1], bottomPath[0][2]];
  }
  if (series.areaPath) {
    areaPath = series.areaPath.splice(0, series.areaPath.length / 2).concat(bottomPath);
    areaPath.xMap = series.areaPath.xMap;
    series.areaPath = areaPath;
    graphPath = getGraphPath.call(series, graphPoints, false, connectNulls);
  }
  return svgPath;
});

// node_modules/highcharts/es-modules/masters/highcharts-3d.src.js
var G5 = Globals_default;
SVGRenderer3D_default.compose(G5.SVGRenderer);
Chart3D_default.compose(G5.Chart, G5.Fx);
ZAxis_default.ZChartComposition.compose(G5.Chart);
Axis3D_default.compose(G5.Axis);

// node_modules/highcharts/es-modules/Core/HttpUtilities.js
var doc19 = Globals_default.doc;
var createElement10 = Utilities_default.createElement;
var discardElement7 = Utilities_default.discardElement;
var merge65 = Utilities_default.merge;
var objectEach30 = Utilities_default.objectEach;
function ajax(attr10) {
  var options = merge65(true, {
    url: false,
    type: "get",
    dataType: "json",
    success: false,
    error: false,
    data: false,
    headers: {}
  }, attr10), headers = {
    json: "application/json",
    xml: "application/xml",
    text: "text/plain",
    octet: "application/octet-stream"
  }, r = new XMLHttpRequest();
  function handleError(xhr, err) {
    if (options.error) {
      options.error(xhr, err);
    } else {
    }
  }
  if (!options.url) {
    return false;
  }
  r.open(options.type.toUpperCase(), options.url, true);
  if (!options.headers["Content-Type"]) {
    r.setRequestHeader("Content-Type", headers[options.dataType] || headers.text);
  }
  objectEach30(options.headers, function(val, key) {
    r.setRequestHeader(key, val);
  });
  r.onreadystatechange = function() {
    var res;
    if (r.readyState === 4) {
      if (r.status === 200) {
        res = r.responseText;
        if (options.dataType === "json") {
          try {
            res = JSON.parse(res);
          } catch (e2) {
            return handleError(r, e2);
          }
        }
        return options.success && options.success(res);
      }
      handleError(r, r.responseText);
    }
  };
  try {
    options.data = JSON.stringify(options.data);
  } catch (e2) {
  }
  r.send(options.data || true);
}
function getJSON(url, success) {
  exports2.ajax({
    url,
    success,
    dataType: "json",
    headers: {
      "Content-Type": "text/plain"
    }
  });
}
function post(url, data, formAttributes) {
  var form = createElement10("form", merge65({
    method: "post",
    action: url,
    enctype: "multipart/form-data"
  }, formAttributes), {
    display: "none"
  }, doc19.body);
  objectEach30(data, function(val, name) {
    createElement10("input", {
      type: "hidden",
      name,
      value: val
    }, null, form);
  });
  form.submit();
  discardElement7(form);
}
var exports2 = {
  ajax,
  getJSON,
  post
};
var HttpUtilities_default = exports2;

// node_modules/highcharts/es-modules/Extensions/Data.js
var doc20 = Globals_default.doc;
var ajax2 = HttpUtilities_default.ajax;
var seriesTypes6 = SeriesRegistry_default.seriesTypes;
var addEvent51 = Utilities_default.addEvent;
var defined47 = Utilities_default.defined;
var extend67 = Utilities_default.extend;
var fireEvent28 = Utilities_default.fireEvent;
var isNumber44 = Utilities_default.isNumber;
var merge66 = Utilities_default.merge;
var objectEach31 = Utilities_default.objectEach;
var pick77 = Utilities_default.pick;
var splat17 = Utilities_default.splat;
var Data = function() {
  function Data2(dataOptions, chartOptions, chart) {
    this.chart = void 0;
    this.chartOptions = void 0;
    this.firstRowAsNames = void 0;
    this.rawColumns = void 0;
    this.options = void 0;
    this.dateFormats = {
      "YYYY/mm/dd": {
        regex: /^([0-9]{4})[\-\/\.]([0-9]{1,2})[\-\/\.]([0-9]{1,2})$/,
        parser: function(match) {
          return match ? Date.UTC(+match[1], match[2] - 1, +match[3]) : NaN;
        }
      },
      "dd/mm/YYYY": {
        regex: /^([0-9]{1,2})[\-\/\.]([0-9]{1,2})[\-\/\.]([0-9]{4})$/,
        parser: function(match) {
          return match ? Date.UTC(+match[3], match[2] - 1, +match[1]) : NaN;
        },
        alternative: "mm/dd/YYYY"
      },
      "mm/dd/YYYY": {
        regex: /^([0-9]{1,2})[\-\/\.]([0-9]{1,2})[\-\/\.]([0-9]{4})$/,
        parser: function(match) {
          return match ? Date.UTC(+match[3], match[1] - 1, +match[2]) : NaN;
        }
      },
      "dd/mm/YY": {
        regex: /^([0-9]{1,2})[\-\/\.]([0-9]{1,2})[\-\/\.]([0-9]{2})$/,
        parser: function(match) {
          if (!match) {
            return NaN;
          }
          var year = +match[3], d = new Date();
          if (year > d.getFullYear() - 2e3) {
            year += 1900;
          } else {
            year += 2e3;
          }
          return Date.UTC(year, match[2] - 1, +match[1]);
        },
        alternative: "mm/dd/YY"
      },
      "mm/dd/YY": {
        regex: /^([0-9]{1,2})[\-\/\.]([0-9]{1,2})[\-\/\.]([0-9]{2})$/,
        parser: function(match) {
          return match ? Date.UTC(+match[3] + 2e3, match[1] - 1, +match[2]) : NaN;
        }
      }
    };
    this.init(dataOptions, chartOptions, chart);
  }
  Data2.prototype.init = function(options, chartOptions, chart) {
    var decimalPoint = options.decimalPoint, hasData;
    if (chartOptions) {
      this.chartOptions = chartOptions;
    }
    if (chart) {
      this.chart = chart;
    }
    if (decimalPoint !== "." && decimalPoint !== ",") {
      decimalPoint = void 0;
    }
    this.options = options;
    this.columns = options.columns || this.rowsToColumns(options.rows) || [];
    this.firstRowAsNames = pick77(options.firstRowAsNames, this.firstRowAsNames, true);
    this.decimalRegex = decimalPoint && new RegExp("^(-?[0-9]+)" + decimalPoint + "([0-9]+)$");
    this.rawColumns = [];
    if (this.columns.length) {
      this.dataFound();
      hasData = true;
    }
    if (this.hasURLOption(options)) {
      clearTimeout(this.liveDataTimeout);
      hasData = false;
    }
    if (!hasData) {
      hasData = this.fetchLiveData();
    }
    if (!hasData) {
      hasData = Boolean(this.parseCSV().length);
    }
    if (!hasData) {
      hasData = Boolean(this.parseTable().length);
    }
    if (!hasData) {
      hasData = this.parseGoogleSpreadsheet();
    }
    if (!hasData && options.afterComplete) {
      options.afterComplete();
    }
  };
  Data2.prototype.hasURLOption = function(options) {
    return Boolean(options && (options.rowsURL || options.csvURL || options.columnsURL));
  };
  Data2.prototype.getColumnDistribution = function() {
    var chartOptions = this.chartOptions, options = this.options, xColumns = [], getValueCount = function(type) {
      return (seriesTypes6[type || "line"].prototype.pointArrayMap || [0]).length;
    }, getPointArrayMap = function(type) {
      return seriesTypes6[type || "line"].prototype.pointArrayMap;
    }, globalType = chartOptions && chartOptions.chart && chartOptions.chart.type, individualCounts = [], seriesBuilders = [], seriesIndex = 0, seriesMapping = options && options.seriesMapping || chartOptions && chartOptions.series && chartOptions.series.map(function() {
      return { x: 0 };
    }) || [], i;
    (chartOptions && chartOptions.series || []).forEach(function(series) {
      individualCounts.push(getValueCount(series.type || globalType));
    });
    seriesMapping.forEach(function(mapping) {
      xColumns.push(mapping.x || 0);
    });
    if (xColumns.length === 0) {
      xColumns.push(0);
    }
    seriesMapping.forEach(function(mapping) {
      var builder = new SeriesBuilder(), numberOfValueColumnsNeeded = individualCounts[seriesIndex] || getValueCount(globalType), seriesArr = chartOptions && chartOptions.series || [], series = seriesArr[seriesIndex] || {}, defaultPointArrayMap = getPointArrayMap(series.type || globalType), pointArrayMap = defaultPointArrayMap || ["y"];
      if (defined47(mapping.x) || series.isCartesian || !defaultPointArrayMap) {
        builder.addColumnReader(mapping.x, "x");
      }
      objectEach31(mapping, function(val, name) {
        if (name !== "x") {
          builder.addColumnReader(val, name);
        }
      });
      for (i = 0; i < numberOfValueColumnsNeeded; i++) {
        if (!builder.hasReader(pointArrayMap[i])) {
          builder.addColumnReader(void 0, pointArrayMap[i]);
        }
      }
      seriesBuilders.push(builder);
      seriesIndex++;
    });
    var globalPointArrayMap = getPointArrayMap(globalType);
    if (typeof globalPointArrayMap === "undefined") {
      globalPointArrayMap = ["y"];
    }
    this.valueCount = {
      global: getValueCount(globalType),
      xColumns,
      individual: individualCounts,
      seriesBuilders,
      globalPointArrayMap
    };
  };
  Data2.prototype.dataFound = function() {
    if (this.options.switchRowsAndColumns) {
      this.columns = this.rowsToColumns(this.columns);
    }
    this.getColumnDistribution();
    this.parseTypes();
    if (this.parsed() !== false) {
      this.complete();
    }
  };
  Data2.prototype.parseCSV = function(inOptions) {
    var self = this, options = inOptions || this.options, csv = options.csv, columns, startRow = typeof options.startRow !== "undefined" && options.startRow ? options.startRow : 0, endRow = options.endRow || Number.MAX_VALUE, startColumn = typeof options.startColumn !== "undefined" && options.startColumn ? options.startColumn : 0, endColumn = options.endColumn || Number.MAX_VALUE, itemDelimiter, lines, rowIt = 0, dataTypes = [], potDelimiters = {
      ",": 0,
      ";": 0,
      "	": 0
    };
    columns = this.columns = [];
    function parseRow(columnStr, rowNumber, noAdd, callbacks) {
      var i = 0, c = "", cl = "", cn = "", token = "", actualColumn = 0, column = 0;
      function read(j) {
        c = columnStr[j];
        cl = columnStr[j - 1];
        cn = columnStr[j + 1];
      }
      function pushType(type) {
        if (dataTypes.length < column + 1) {
          dataTypes.push([type]);
        }
        if (dataTypes[column][dataTypes[column].length - 1] !== type) {
          dataTypes[column].push(type);
        }
      }
      function push() {
        if (startColumn > actualColumn || actualColumn > endColumn) {
          ++actualColumn;
          token = "";
          return;
        }
        if (!isNaN(parseFloat(token)) && isFinite(token)) {
          token = parseFloat(token);
          pushType("number");
        } else if (!isNaN(Date.parse(token))) {
          token = token.replace(/\//g, "-");
          pushType("date");
        } else {
          pushType("string");
        }
        if (columns.length < column + 1) {
          columns.push([]);
        }
        if (!noAdd) {
          columns[column][rowNumber] = token;
        }
        token = "";
        ++column;
        ++actualColumn;
      }
      if (!columnStr.trim().length) {
        return;
      }
      if (columnStr.trim()[0] === "#") {
        return;
      }
      for (; i < columnStr.length; i++) {
        read(i);
        if (c === '"') {
          read(++i);
          while (i < columnStr.length) {
            if (c === '"' && cl !== '"' && cn !== '"') {
              break;
            }
            if (c !== '"' || c === '"' && cl !== '"') {
              token += c;
            }
            read(++i);
          }
        } else if (callbacks && callbacks[c]) {
          if (callbacks[c](c, token)) {
            push();
          }
        } else if (c === itemDelimiter) {
          push();
        } else {
          token += c;
        }
      }
      push();
    }
    function guessDelimiter(lines2) {
      var points = 0, commas = 0, guessed = false;
      lines2.some(function(columnStr, i) {
        var inStr = false, c, cn, cl, token = "";
        if (i > 13) {
          return true;
        }
        for (var j = 0; j < columnStr.length; j++) {
          c = columnStr[j];
          cn = columnStr[j + 1];
          cl = columnStr[j - 1];
          if (c === "#") {
            return;
          }
          if (c === '"') {
            if (inStr) {
              if (cl !== '"' && cn !== '"') {
                while (cn === " " && j < columnStr.length) {
                  cn = columnStr[++j];
                }
                if (typeof potDelimiters[cn] !== "undefined") {
                  potDelimiters[cn]++;
                }
                inStr = false;
              }
            } else {
              inStr = true;
            }
          } else if (typeof potDelimiters[c] !== "undefined") {
            token = token.trim();
            if (!isNaN(Date.parse(token))) {
              potDelimiters[c]++;
            } else if (isNaN(token) || !isFinite(token)) {
              potDelimiters[c]++;
            }
            token = "";
          } else {
            token += c;
          }
          if (c === ",") {
            commas++;
          }
          if (c === ".") {
            points++;
          }
        }
      });
      if (potDelimiters[";"] > potDelimiters[","]) {
        guessed = ";";
      } else if (potDelimiters[","] > potDelimiters[";"]) {
        guessed = ",";
      } else {
        guessed = ",";
      }
      if (!options.decimalPoint) {
        if (points > commas) {
          options.decimalPoint = ".";
        } else {
          options.decimalPoint = ",";
        }
        self.decimalRegex = new RegExp("^(-?[0-9]+)" + options.decimalPoint + "([0-9]+)$");
      }
      return guessed;
    }
    function deduceDateFormat(data, limit) {
      var format13 = "YYYY/mm/dd", thing, guessedFormat = [], calculatedFormat, i = 0, madeDeduction = false, stable = [], max = [], j;
      if (!limit || limit > data.length) {
        limit = data.length;
      }
      for (; i < limit; i++) {
        if (typeof data[i] !== "undefined" && data[i] && data[i].length) {
          thing = data[i].trim().replace(/\//g, " ").replace(/\-/g, " ").replace(/\./g, " ").split(" ");
          guessedFormat = [
            "",
            "",
            ""
          ];
          for (j = 0; j < thing.length; j++) {
            if (j < guessedFormat.length) {
              thing[j] = parseInt(thing[j], 10);
              if (thing[j]) {
                max[j] = !max[j] || max[j] < thing[j] ? thing[j] : max[j];
                if (typeof stable[j] !== "undefined") {
                  if (stable[j] !== thing[j]) {
                    stable[j] = false;
                  }
                } else {
                  stable[j] = thing[j];
                }
                if (thing[j] > 31) {
                  if (thing[j] < 100) {
                    guessedFormat[j] = "YY";
                  } else {
                    guessedFormat[j] = "YYYY";
                  }
                } else if (thing[j] > 12 && thing[j] <= 31) {
                  guessedFormat[j] = "dd";
                  madeDeduction = true;
                } else if (!guessedFormat[j].length) {
                  guessedFormat[j] = "mm";
                }
              }
            }
          }
        }
      }
      if (madeDeduction) {
        for (j = 0; j < stable.length; j++) {
          if (stable[j] !== false) {
            if (max[j] > 12 && guessedFormat[j] !== "YY" && guessedFormat[j] !== "YYYY") {
              guessedFormat[j] = "YY";
            }
          } else if (max[j] > 12 && guessedFormat[j] === "mm") {
            guessedFormat[j] = "dd";
          }
        }
        if (guessedFormat.length === 3 && guessedFormat[1] === "dd" && guessedFormat[2] === "dd") {
          guessedFormat[2] = "YY";
        }
        calculatedFormat = guessedFormat.join("/");
        if (!(options.dateFormats || self.dateFormats)[calculatedFormat]) {
          fireEvent28("deduceDateFailed");
          return format13;
        }
        return calculatedFormat;
      }
      return format13;
    }
    function deduceAxisTypes() {
    }
    if (csv && options.beforeParse) {
      csv = options.beforeParse.call(this, csv);
    }
    if (csv) {
      lines = csv.replace(/\r\n/g, "\n").replace(/\r/g, "\n").split(options.lineDelimiter || "\n");
      if (!startRow || startRow < 0) {
        startRow = 0;
      }
      if (!endRow || endRow >= lines.length) {
        endRow = lines.length - 1;
      }
      if (options.itemDelimiter) {
        itemDelimiter = options.itemDelimiter;
      } else {
        itemDelimiter = null;
        itemDelimiter = guessDelimiter(lines);
      }
      var offset3 = 0;
      for (rowIt = startRow; rowIt <= endRow; rowIt++) {
        if (lines[rowIt][0] === "#") {
          offset3++;
        } else {
          parseRow(lines[rowIt], rowIt - startRow - offset3);
        }
      }
      deduceAxisTypes();
      if ((!options.columnTypes || options.columnTypes.length === 0) && dataTypes.length && dataTypes[0].length && dataTypes[0][1] === "date" && !options.dateFormat) {
        options.dateFormat = deduceDateFormat(columns[0]);
      }
      this.dataFound();
    }
    return columns;
  };
  Data2.prototype.parseTable = function() {
    var options = this.options, table = options.table, columns = this.columns || [], startRow = options.startRow || 0, endRow = options.endRow || Number.MAX_VALUE, startColumn = options.startColumn || 0, endColumn = options.endColumn || Number.MAX_VALUE;
    if (table) {
      if (typeof table === "string") {
        table = doc20.getElementById(table);
      }
      [].forEach.call(table.getElementsByTagName("tr"), function(tr, rowNo) {
        if (rowNo >= startRow && rowNo <= endRow) {
          [].forEach.call(tr.children, function(item, colNo) {
            var row = columns[colNo - startColumn];
            var i = 1;
            if ((item.tagName === "TD" || item.tagName === "TH") && colNo >= startColumn && colNo <= endColumn) {
              if (!columns[colNo - startColumn]) {
                columns[colNo - startColumn] = [];
              }
              columns[colNo - startColumn][rowNo - startRow] = item.innerHTML;
              while (rowNo - startRow >= i && row[rowNo - startRow - i] === void 0) {
                row[rowNo - startRow - i] = null;
                i++;
              }
            }
          });
        }
      });
      this.dataFound();
    }
    return columns;
  };
  Data2.prototype.fetchLiveData = function() {
    var data = this, chart = this.chart, options = this.options, maxRetries = 3, currentRetries = 0, pollingEnabled = options.enablePolling, updateIntervalMs = (options.dataRefreshRate || 2) * 1e3, originalOptions = merge66(options);
    if (!this.hasURLOption(options)) {
      return false;
    }
    if (updateIntervalMs < 1e3) {
      updateIntervalMs = 1e3;
    }
    delete options.csvURL;
    delete options.rowsURL;
    delete options.columnsURL;
    function performFetch(initialFetch) {
      function request(url, done, tp) {
        if (!url || !/^(http|\/|\.\/|\.\.\/)/.test(url)) {
          if (url && options.error) {
            options.error("Invalid URL");
          }
          return false;
        }
        if (initialFetch) {
          clearTimeout(data.liveDataTimeout);
          chart.liveDataURL = url;
        }
        function poll() {
          if (pollingEnabled && chart.liveDataURL === url) {
            data.liveDataTimeout = setTimeout(performFetch, updateIntervalMs);
          }
        }
        ajax2({
          url,
          dataType: tp || "json",
          success: function(res) {
            if (chart && chart.series) {
              done(res);
            }
            poll();
          },
          error: function(xhr, text) {
            if (++currentRetries < maxRetries) {
              poll();
            }
            return options.error && options.error(text, xhr);
          }
        });
        return true;
      }
      if (!request(originalOptions.csvURL, function(res) {
        chart.update({
          data: {
            csv: res
          }
        });
      }, "text")) {
        if (!request(originalOptions.rowsURL, function(res) {
          chart.update({
            data: {
              rows: res
            }
          });
        })) {
          request(originalOptions.columnsURL, function(res) {
            chart.update({
              data: {
                columns: res
              }
            });
          });
        }
      }
    }
    performFetch(true);
    return this.hasURLOption(options);
  };
  Data2.prototype.parseGoogleSpreadsheet = function() {
    var data = this, options = this.options, googleSpreadsheetKey = options.googleSpreadsheetKey, chart = this.chart, refreshRate = Math.max((options.dataRefreshRate || 2) * 1e3, 4e3);
    var getRange = function() {
      if (options.googleSpreadsheetRange) {
        return options.googleSpreadsheetRange;
      }
      var alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      var start = (alphabet.charAt(options.startColumn || 0) || "A") + ((options.startRow || 0) + 1);
      var end = alphabet.charAt(pick77(options.endColumn, -1)) || "ZZ";
      if (defined47(options.endRow)) {
        end += options.endRow + 1;
      }
      return start + ":" + end;
    };
    function fetchSheet(fn) {
      var url = [
        "https://sheets.googleapis.com/v4/spreadsheets",
        googleSpreadsheetKey,
        "values",
        getRange(),
        "?alt=json&majorDimension=COLUMNS&valueRenderOption=UNFORMATTED_VALUE&dateTimeRenderOption=FORMATTED_STRING&key=" + options.googleAPIKey
      ].join("/");
      ajax2({
        url,
        dataType: "json",
        success: function(json) {
          fn(json);
          if (options.enablePolling) {
            setTimeout(function() {
              fetchSheet(fn);
            }, refreshRate);
          }
        },
        error: function(xhr, text) {
          return options.error && options.error(text, xhr);
        }
      });
    }
    if (googleSpreadsheetKey) {
      delete options.googleSpreadsheetKey;
      fetchSheet(function(json) {
        var columns = json.values;
        if (!columns || columns.length === 0) {
          return false;
        }
        var rowCount = columns.reduce(function(rowCount2, column) {
          return Math.max(rowCount2, column.length);
        }, 0);
        columns.forEach(function(column) {
          for (var i = 0; i < rowCount; i++) {
            if (typeof column[i] === "undefined") {
              column[i] = null;
            }
          }
        });
        if (chart && chart.series) {
          chart.update({
            data: {
              columns
            }
          });
        } else {
          data.columns = columns;
          data.dataFound();
        }
      });
    }
    return false;
  };
  Data2.prototype.trim = function(str, inside) {
    if (typeof str === "string") {
      str = str.replace(/^\s+|\s+$/g, "");
      if (inside && /^[0-9\s]+$/.test(str)) {
        str = str.replace(/\s/g, "");
      }
      if (this.decimalRegex) {
        str = str.replace(this.decimalRegex, "$1.$2");
      }
    }
    return str;
  };
  Data2.prototype.parseTypes = function() {
    var columns = this.columns, col = columns.length;
    while (col--) {
      this.parseColumn(columns[col], col);
    }
  };
  Data2.prototype.parseColumn = function(column, col) {
    var rawColumns = this.rawColumns, columns = this.columns, row = column.length, val, floatVal, trimVal, trimInsideVal, firstRowAsNames = this.firstRowAsNames, isXColumn = this.valueCount.xColumns.indexOf(col) !== -1, dateVal, backup = [], diff, chartOptions = this.chartOptions, descending, columnTypes = this.options.columnTypes || [], columnType = columnTypes[col], forceCategory = isXColumn && (chartOptions && chartOptions.xAxis && splat17(chartOptions.xAxis)[0].type === "category" || columnType === "string");
    if (!rawColumns[col]) {
      rawColumns[col] = [];
    }
    while (row--) {
      val = backup[row] || column[row];
      trimVal = this.trim(val);
      trimInsideVal = this.trim(val, true);
      floatVal = parseFloat(trimInsideVal);
      if (typeof rawColumns[col][row] === "undefined") {
        rawColumns[col][row] = trimVal;
      }
      if (forceCategory || row === 0 && firstRowAsNames) {
        column[row] = "" + trimVal;
      } else if (+trimInsideVal === floatVal) {
        column[row] = floatVal;
        if (floatVal > 365 * 24 * 3600 * 1e3 && columnType !== "float") {
          column.isDatetime = true;
        } else {
          column.isNumeric = true;
        }
        if (typeof column[row + 1] !== "undefined") {
          descending = floatVal > column[row + 1];
        }
      } else {
        if (trimVal && trimVal.length) {
          dateVal = this.parseDate(val);
        }
        if (isXColumn && isNumber44(dateVal) && columnType !== "float") {
          backup[row] = val;
          column[row] = dateVal;
          column.isDatetime = true;
          if (typeof column[row + 1] !== "undefined") {
            diff = dateVal > column[row + 1];
            if (diff !== descending && typeof descending !== "undefined") {
              if (this.alternativeFormat) {
                this.dateFormat = this.alternativeFormat;
                row = column.length;
                this.alternativeFormat = this.dateFormats[this.dateFormat].alternative;
              } else {
                column.unsorted = true;
              }
            }
            descending = diff;
          }
        } else {
          column[row] = trimVal === "" ? null : trimVal;
          if (row !== 0 && (column.isDatetime || column.isNumeric)) {
            column.mixed = true;
          }
        }
      }
    }
    if (isXColumn && column.mixed) {
      columns[col] = rawColumns[col];
    }
    if (isXColumn && descending && this.options.sort) {
      for (col = 0; col < columns.length; col++) {
        columns[col].reverse();
        if (firstRowAsNames) {
          columns[col].unshift(columns[col].pop());
        }
      }
    }
  };
  Data2.prototype.parseDate = function(val) {
    var parseDate = this.options.parseDate;
    var ret, key, format13, dateFormat2 = this.options.dateFormat || this.dateFormat, match;
    if (parseDate) {
      ret = parseDate(val);
    } else if (typeof val === "string") {
      if (!dateFormat2) {
        for (key in this.dateFormats) {
          format13 = this.dateFormats[key];
          match = val.match(format13.regex);
          if (match) {
            this.dateFormat = dateFormat2 = key;
            this.alternativeFormat = format13.alternative;
            ret = format13.parser(match);
            break;
          }
        }
      } else {
        format13 = this.dateFormats[dateFormat2];
        if (!format13) {
          format13 = this.dateFormats["YYYY/mm/dd"];
        }
        match = val.match(format13.regex);
        if (match) {
          ret = format13.parser(match);
        }
      }
      if (!match) {
        if (val.match(/:.+(GMT|UTC|[Z+-])/)) {
          val = val.replace(/\s*(?:GMT|UTC)?([+-])(\d\d)(\d\d)$/, "$1$2:$3").replace(/(?:\s+|GMT|UTC)([+-])/, "$1").replace(/(\d)\s*(?:GMT|UTC|Z)$/, "$1+00:00");
        }
        match = Date.parse(val);
        if (typeof match === "object" && match !== null && match.getTime) {
          ret = match.getTime() - match.getTimezoneOffset() * 6e4;
        } else if (isNumber44(match)) {
          ret = match - new Date(match).getTimezoneOffset() * 6e4;
        }
      }
    }
    return ret;
  };
  Data2.prototype.rowsToColumns = function(rows) {
    var row, rowsLength, col, colsLength, columns;
    if (rows) {
      columns = [];
      rowsLength = rows.length;
      for (row = 0; row < rowsLength; row++) {
        colsLength = rows[row].length;
        for (col = 0; col < colsLength; col++) {
          if (!columns[col]) {
            columns[col] = [];
          }
          columns[col][row] = rows[row][col];
        }
      }
    }
    return columns;
  };
  Data2.prototype.getData = function() {
    if (this.columns) {
      return this.rowsToColumns(this.columns).slice(1);
    }
  };
  Data2.prototype.parsed = function() {
    if (this.options.parsed) {
      return this.options.parsed.call(this, this.columns);
    }
  };
  Data2.prototype.getFreeIndexes = function(numberOfColumns, seriesBuilders) {
    var s, i, freeIndexes = [], freeIndexValues = [], referencedIndexes;
    for (i = 0; i < numberOfColumns; i = i + 1) {
      freeIndexes.push(true);
    }
    for (s = 0; s < seriesBuilders.length; s = s + 1) {
      referencedIndexes = seriesBuilders[s].getReferencedColumnIndexes();
      for (i = 0; i < referencedIndexes.length; i = i + 1) {
        freeIndexes[referencedIndexes[i]] = false;
      }
    }
    for (i = 0; i < freeIndexes.length; i = i + 1) {
      if (freeIndexes[i]) {
        freeIndexValues.push(i);
      }
    }
    return freeIndexValues;
  };
  Data2.prototype.complete = function() {
    var columns = this.columns, xColumns = [], type, options = this.options, series, data, i, j, r, seriesIndex, chartOptions, allSeriesBuilders = [], builder, freeIndexes, typeCol, index;
    xColumns.length = columns.length;
    if (options.complete || options.afterComplete) {
      if (this.firstRowAsNames) {
        for (i = 0; i < columns.length; i++) {
          columns[i].name = columns[i].shift();
        }
      }
      series = [];
      freeIndexes = this.getFreeIndexes(columns.length, this.valueCount.seriesBuilders);
      for (seriesIndex = 0; seriesIndex < this.valueCount.seriesBuilders.length; seriesIndex++) {
        builder = this.valueCount.seriesBuilders[seriesIndex];
        if (builder.populateColumns(freeIndexes)) {
          allSeriesBuilders.push(builder);
        }
      }
      while (freeIndexes.length > 0) {
        builder = new SeriesBuilder();
        builder.addColumnReader(0, "x");
        index = freeIndexes.indexOf(0);
        if (index !== -1) {
          freeIndexes.splice(index, 1);
        }
        for (i = 0; i < this.valueCount.global; i++) {
          builder.addColumnReader(void 0, this.valueCount.globalPointArrayMap[i]);
        }
        if (builder.populateColumns(freeIndexes)) {
          allSeriesBuilders.push(builder);
        }
      }
      if (allSeriesBuilders.length > 0 && allSeriesBuilders[0].readers.length > 0) {
        typeCol = columns[allSeriesBuilders[0].readers[0].columnIndex];
        if (typeof typeCol !== "undefined") {
          if (typeCol.isDatetime) {
            type = "datetime";
          } else if (!typeCol.isNumeric) {
            type = "category";
          }
        }
      }
      if (type === "category") {
        for (seriesIndex = 0; seriesIndex < allSeriesBuilders.length; seriesIndex++) {
          builder = allSeriesBuilders[seriesIndex];
          for (r = 0; r < builder.readers.length; r++) {
            if (builder.readers[r].configName === "x") {
              builder.readers[r].configName = "name";
            }
          }
        }
      }
      for (seriesIndex = 0; seriesIndex < allSeriesBuilders.length; seriesIndex++) {
        builder = allSeriesBuilders[seriesIndex];
        data = [];
        for (j = 0; j < columns[0].length; j++) {
          data[j] = builder.read(columns, j);
        }
        series[seriesIndex] = {
          data
        };
        if (builder.name) {
          series[seriesIndex].name = builder.name;
        }
        if (type === "category") {
          series[seriesIndex].turboThreshold = 0;
        }
      }
      chartOptions = {
        series
      };
      if (type) {
        chartOptions.xAxis = {
          type
        };
        if (type === "category") {
          chartOptions.xAxis.uniqueNames = false;
        }
      }
      if (options.complete) {
        options.complete(chartOptions);
      }
      if (options.afterComplete) {
        options.afterComplete(chartOptions);
      }
    }
  };
  Data2.prototype.update = function(options, redraw) {
    var chart = this.chart;
    if (options) {
      options.afterComplete = function(dataOptions) {
        if (dataOptions) {
          if (dataOptions.xAxis && chart.xAxis[0] && dataOptions.xAxis.type === chart.xAxis[0].options.type) {
            delete dataOptions.xAxis;
          }
          chart.update(dataOptions, redraw, true);
        }
      };
      merge66(true, chart.options.data, options);
      this.init(chart.options.data);
    }
  };
  return Data2;
}();
Globals_default.data = function(dataOptions, chartOptions, chart) {
  return new Globals_default.Data(dataOptions, chartOptions, chart);
};
addEvent51(Chart_default, "init", function(e2) {
  var chart = this, userOptions = e2.args[0] || {}, callback = e2.args[1];
  if (userOptions && userOptions.data && !chart.hasDataDef) {
    chart.hasDataDef = true;
    chart.data = new Globals_default.Data(extend67(userOptions.data, {
      afterComplete: function(dataOptions) {
        var i, series;
        if (Object.hasOwnProperty.call(userOptions, "series")) {
          if (typeof userOptions.series === "object") {
            i = Math.max(userOptions.series.length, dataOptions && dataOptions.series ? dataOptions.series.length : 0);
            while (i--) {
              series = userOptions.series[i] || {};
              userOptions.series[i] = merge66(series, dataOptions && dataOptions.series ? dataOptions.series[i] : {});
            }
          } else {
            delete userOptions.series;
          }
        }
        userOptions = merge66(dataOptions, userOptions);
        chart.init(userOptions, callback);
      }
    }), userOptions, chart);
    e2.preventDefault();
  }
});
var SeriesBuilder = function() {
  function SeriesBuilder2() {
    this.readers = [];
    this.pointIsArray = true;
    this.name = void 0;
  }
  SeriesBuilder2.prototype.populateColumns = function(freeIndexes) {
    var builder = this, enoughColumns = true;
    builder.readers.forEach(function(reader) {
      if (typeof reader.columnIndex === "undefined") {
        reader.columnIndex = freeIndexes.shift();
      }
    });
    builder.readers.forEach(function(reader) {
      if (typeof reader.columnIndex === "undefined") {
        enoughColumns = false;
      }
    });
    return enoughColumns;
  };
  SeriesBuilder2.prototype.read = function(columns, rowIndex) {
    var builder = this, pointIsArray = builder.pointIsArray, point = pointIsArray ? [] : {}, columnIndexes;
    builder.readers.forEach(function(reader) {
      var value = columns[reader.columnIndex][rowIndex];
      if (pointIsArray) {
        point.push(value);
      } else {
        if (reader.configName.indexOf(".") > 0) {
          Point_default.prototype.setNestedProperty(point, value, reader.configName);
        } else {
          point[reader.configName] = value;
        }
      }
    });
    if (typeof this.name === "undefined" && builder.readers.length >= 2) {
      columnIndexes = builder.getReferencedColumnIndexes();
      if (columnIndexes.length >= 2) {
        columnIndexes.shift();
        columnIndexes.sort(function(a, b) {
          return a - b;
        });
        this.name = columns[columnIndexes.shift()].name;
      }
    }
    return point;
  };
  SeriesBuilder2.prototype.addColumnReader = function(columnIndex, configName) {
    this.readers.push({
      columnIndex,
      configName
    });
    if (!(configName === "x" || configName === "y" || typeof configName === "undefined")) {
      this.pointIsArray = false;
    }
  };
  SeriesBuilder2.prototype.getReferencedColumnIndexes = function() {
    var i, referencedColumnIndexes = [], columnReader;
    for (i = 0; i < this.readers.length; i = i + 1) {
      columnReader = this.readers[i];
      if (typeof columnReader.columnIndex !== "undefined") {
        referencedColumnIndexes.push(columnReader.columnIndex);
      }
    }
    return referencedColumnIndexes;
  };
  SeriesBuilder2.prototype.hasReader = function(configName) {
    var i, columnReader;
    for (i = 0; i < this.readers.length; i = i + 1) {
      columnReader = this.readers[i];
      if (columnReader.configName === configName) {
        return true;
      }
    }
  };
  return SeriesBuilder2;
}();
Globals_default.Data = Data;
var Data_default = Globals_default.Data;

// node_modules/highcharts/es-modules/masters/modules/data.src.js
var G6 = Globals_default;
G6.HttpUtilities = HttpUtilities_default;
G6.ajax = HttpUtilities_default.ajax;
G6.getJSON = HttpUtilities_default.getJSON;
G6.post = HttpUtilities_default.post;

// node_modules/highcharts/es-modules/Extensions/Drilldown.js
var animObject13 = AnimationUtilities_default.animObject;
var format12 = FormatUtilities_default.format;
var noop18 = Globals_default.noop;
var defaultOptions14 = DefaultOptions_default.defaultOptions;
var seriesTypes7 = SeriesRegistry_default.seriesTypes;
var addEvent52 = Utilities_default.addEvent;
var removeEvent11 = Utilities_default.removeEvent;
var extend68 = Utilities_default.extend;
var fireEvent29 = Utilities_default.fireEvent;
var merge67 = Utilities_default.merge;
var objectEach32 = Utilities_default.objectEach;
var pick78 = Utilities_default.pick;
var syncTimeout10 = Utilities_default.syncTimeout;
var PieSeries3 = seriesTypes7.pie;
var ddSeriesId = 1;
extend68(defaultOptions14.lang, {
  drillUpText: "\u25C1 Back to {series.name}"
});
defaultOptions14.drilldown = {
  activeAxisLabelStyle: {
    cursor: "pointer",
    color: Palette_default.highlightColor100,
    fontWeight: "bold",
    textDecoration: "underline"
  },
  activeDataLabelStyle: {
    cursor: "pointer",
    color: Palette_default.highlightColor100,
    fontWeight: "bold",
    textDecoration: "underline"
  },
  animation: {
    duration: 500
  },
  drillUpButton: {
    position: {
      align: "right",
      x: -10,
      y: 10
    }
  }
};
SVGRenderer_default.prototype.Element.prototype.fadeIn = function(animation) {
  this.attr({
    opacity: 0.1,
    visibility: "inherit"
  }).animate({
    opacity: pick78(this.newOpacity, 1)
  }, animation || {
    duration: 250
  });
};
Chart_default.prototype.addSeriesAsDrilldown = function(point, options) {
  this.addSingleSeriesAsDrilldown(point, options);
  this.applyDrilldown();
};
Chart_default.prototype.addSingleSeriesAsDrilldown = function(point, ddOptions) {
  var oldSeries = point.series, xAxis = oldSeries.xAxis, yAxis = oldSeries.yAxis, newSeries, pointIndex, levelSeries = [], levelSeriesOptions = [], level, levelNumber, last, colorProp;
  colorProp = this.styledMode ? { colorIndex: pick78(point.colorIndex, oldSeries.colorIndex) } : { color: point.color || oldSeries.color };
  if (!this.drilldownLevels) {
    this.drilldownLevels = [];
  }
  levelNumber = oldSeries.options._levelNumber || 0;
  last = this.drilldownLevels[this.drilldownLevels.length - 1];
  if (last && last.levelNumber !== levelNumber) {
    last = void 0;
  }
  ddOptions = extend68(extend68({
    _ddSeriesId: ddSeriesId++
  }, colorProp), ddOptions);
  pointIndex = oldSeries.points.indexOf(point);
  oldSeries.chart.series.forEach(function(series) {
    if (series.xAxis === xAxis && !series.isDrilling) {
      series.options._ddSeriesId = series.options._ddSeriesId || ddSeriesId++;
      series.options._colorIndex = series.userOptions._colorIndex;
      series.options._levelNumber = series.options._levelNumber || levelNumber;
      if (last) {
        levelSeries = last.levelSeries;
        levelSeriesOptions = last.levelSeriesOptions;
      } else {
        levelSeries.push(series);
        series.purgedOptions = merge67({
          _ddSeriesId: series.options._ddSeriesId,
          _levelNumber: series.options._levelNumber,
          selected: series.options.selected
        }, series.userOptions);
        levelSeriesOptions.push(series.purgedOptions);
      }
    }
  });
  level = extend68({
    levelNumber,
    seriesOptions: oldSeries.options,
    seriesPurgedOptions: oldSeries.purgedOptions,
    levelSeriesOptions,
    levelSeries,
    shapeArgs: point.shapeArgs,
    bBox: point.graphic ? point.graphic.getBBox() : {},
    color: point.isNull ? Color_default.parse(colorProp.color).setOpacity(0).get() : colorProp.color,
    lowerSeriesOptions: ddOptions,
    pointOptions: oldSeries.options.data[pointIndex],
    pointIndex,
    oldExtremes: {
      xMin: xAxis && xAxis.userMin,
      xMax: xAxis && xAxis.userMax,
      yMin: yAxis && yAxis.userMin,
      yMax: yAxis && yAxis.userMax
    },
    resetZoomButton: this.resetZoomButton
  }, colorProp);
  this.drilldownLevels.push(level);
  if (xAxis && xAxis.names) {
    xAxis.names.length = 0;
  }
  newSeries = level.lowerSeries = this.addSeries(ddOptions, false);
  newSeries.options._levelNumber = levelNumber + 1;
  if (xAxis) {
    xAxis.oldPos = xAxis.pos;
    xAxis.userMin = xAxis.userMax = null;
    yAxis.userMin = yAxis.userMax = null;
  }
  if (oldSeries.type === newSeries.type) {
    newSeries.animate = newSeries.animateDrilldown || noop18;
    newSeries.options.animation = true;
  }
};
Chart_default.prototype.applyDrilldown = function() {
  var drilldownLevels = this.drilldownLevels, levelToRemove;
  if (drilldownLevels && drilldownLevels.length > 0) {
    levelToRemove = drilldownLevels[drilldownLevels.length - 1].levelNumber;
    this.drilldownLevels.forEach(function(level) {
      if (level.levelNumber === levelToRemove) {
        level.levelSeries.forEach(function(series) {
          if (series.options && series.options._levelNumber === levelToRemove) {
            series.remove(false);
          }
        });
      }
    });
  }
  if (this.resetZoomButton) {
    this.resetZoomButton.hide();
    delete this.resetZoomButton;
  }
  this.pointer.reset();
  this.redraw();
  this.showDrillUpButton();
  fireEvent29(this, "afterDrilldown");
};
Chart_default.prototype.getDrilldownBackText = function() {
  var drilldownLevels = this.drilldownLevels, lastLevel;
  if (drilldownLevels && drilldownLevels.length > 0) {
    lastLevel = drilldownLevels[drilldownLevels.length - 1];
    lastLevel.series = lastLevel.seriesOptions;
    return format12(this.options.lang.drillUpText || "", lastLevel);
  }
};
Chart_default.prototype.showDrillUpButton = function() {
  var chart = this, backText = this.getDrilldownBackText(), buttonOptions = chart.options.drilldown.drillUpButton, attr10, states, alignTo = buttonOptions.relativeTo === "chart" || buttonOptions.relativeTo === "spacingBox" ? null : "scrollablePlotBox";
  if (!this.drillUpButton) {
    attr10 = buttonOptions.theme;
    states = attr10 && attr10.states;
    this.drillUpButton = this.renderer.button(backText, null, null, function() {
      chart.drillUp();
    }, attr10, states && states.hover, states && states.select).addClass("highcharts-drillup-button").attr({
      align: buttonOptions.position.align,
      zIndex: 7
    }).add().align(buttonOptions.position, false, alignTo);
  } else {
    this.drillUpButton.attr({
      text: backText
    }).align();
  }
};
Chart_default.prototype.drillUp = function() {
  if (!this.drilldownLevels || this.drilldownLevels.length === 0) {
    return;
  }
  var chart = this, drilldownLevels = chart.drilldownLevels, levelNumber = drilldownLevels[drilldownLevels.length - 1].levelNumber, i = drilldownLevels.length, chartSeries = chart.series, seriesI, level, oldSeries, newSeries, oldExtremes, addSeries = function(seriesOptions) {
    var addedSeries;
    chartSeries.forEach(function(series) {
      if (series.options._ddSeriesId === seriesOptions._ddSeriesId) {
        addedSeries = series;
      }
    });
    addedSeries = addedSeries || chart.addSeries(seriesOptions, false);
    if (addedSeries.type === oldSeries.type && addedSeries.animateDrillupTo) {
      addedSeries.animate = addedSeries.animateDrillupTo;
    }
    if (seriesOptions === level.seriesPurgedOptions) {
      newSeries = addedSeries;
    }
  };
  while (i--) {
    level = drilldownLevels[i];
    if (level.levelNumber === levelNumber) {
      drilldownLevels.pop();
      oldSeries = level.lowerSeries;
      if (!oldSeries.chart) {
        seriesI = chartSeries.length;
        while (seriesI--) {
          if (chartSeries[seriesI].options.id === level.lowerSeriesOptions.id && chartSeries[seriesI].options._levelNumber === levelNumber + 1) {
            oldSeries = chartSeries[seriesI];
            break;
          }
        }
      }
      oldSeries.xData = [];
      level.levelSeriesOptions.forEach(addSeries);
      fireEvent29(chart, "drillup", {
        seriesOptions: level.seriesPurgedOptions || level.seriesOptions
      });
      this.resetZoomButton && this.resetZoomButton.destroy();
      if (newSeries.type === oldSeries.type) {
        newSeries.drilldownLevel = level;
        newSeries.options.animation = chart.options.drilldown.animation;
        if (oldSeries.animateDrillupFrom && oldSeries.chart) {
          oldSeries.animateDrillupFrom(level);
        }
      }
      newSeries.options._levelNumber = levelNumber;
      oldSeries.remove(false);
      if (newSeries.xAxis) {
        oldExtremes = level.oldExtremes;
        newSeries.xAxis.setExtremes(oldExtremes.xMin, oldExtremes.xMax, false);
        newSeries.yAxis.setExtremes(oldExtremes.yMin, oldExtremes.yMax, false);
      }
      if (level.resetZoomButton) {
        chart.resetZoomButton = level.resetZoomButton;
        chart.resetZoomButton.show();
      }
    }
  }
  this.redraw();
  if (this.drilldownLevels.length === 0) {
    this.drillUpButton = this.drillUpButton.destroy();
  } else {
    this.drillUpButton.attr({
      text: this.getDrilldownBackText()
    }).align();
  }
  this.ddDupes.length = [];
  fireEvent29(chart, "drillupall");
};
addEvent52(Chart_default, "afterInit", function() {
  var chart = this;
  chart.drilldown = {
    update: function(options, redraw) {
      merge67(true, chart.options.drilldown, options);
      if (pick78(redraw, true)) {
        chart.redraw();
      }
    }
  };
});
addEvent52(Chart_default, "afterShowResetZoom", function() {
  var chart = this, bbox = chart.resetZoomButton && chart.resetZoomButton.getBBox(), buttonOptions = chart.options.drilldown && chart.options.drilldown.drillUpButton;
  if (this.drillUpButton && bbox && buttonOptions && buttonOptions.position && buttonOptions.position.x) {
    this.drillUpButton.align({
      x: buttonOptions.position.x - bbox.width - 10,
      y: buttonOptions.position.y,
      align: buttonOptions.position.align
    }, false, buttonOptions.relativeTo || "plotBox");
  }
});
addEvent52(Chart_default, "render", function() {
  (this.xAxis || []).forEach(function(axis) {
    axis.ddPoints = {};
    axis.series.forEach(function(series) {
      var i, xData = series.xData || [], points = series.points, p;
      for (i = 0; i < xData.length; i++) {
        p = series.options.data[i];
        if (typeof p !== "number") {
          p = series.pointClass.prototype.optionsToObject.call({ series }, p);
          if (p.drilldown) {
            if (!axis.ddPoints[xData[i]]) {
              axis.ddPoints[xData[i]] = [];
            }
            var index = i - (series.cropStart || 0);
            axis.ddPoints[xData[i]].push(points && index >= 0 && index < points.length ? points[index] : true);
          }
        }
      }
    });
    objectEach32(axis.ticks, Tick_default.prototype.drillable);
  });
});
ColumnSeries_default.prototype.animateDrillupTo = function(init) {
  if (!init) {
    var newSeries_1 = this, level_1 = newSeries_1.drilldownLevel;
    this.points.forEach(function(point) {
      var dataLabel = point.dataLabel;
      if (point.graphic) {
        point.graphic.hide();
      }
      if (dataLabel) {
        dataLabel.hidden = dataLabel.attr("visibility") === "hidden";
        if (!dataLabel.hidden) {
          dataLabel.hide();
          if (point.connector) {
            point.connector.hide();
          }
        }
      }
    });
    syncTimeout10(function() {
      if (newSeries_1.points) {
        var pointsWithNodes_1 = [];
        newSeries_1.data.forEach(function(el) {
          pointsWithNodes_1.push(el);
        });
        if (newSeries_1.nodes) {
          pointsWithNodes_1 = pointsWithNodes_1.concat(newSeries_1.nodes);
        }
        pointsWithNodes_1.forEach(function(point, i) {
          var verb = i === (level_1 && level_1.pointIndex) ? "show" : "fadeIn", inherit = verb === "show" ? true : void 0, dataLabel = point.dataLabel;
          if (point.graphic) {
            point.graphic[verb](inherit);
          }
          if (dataLabel && !dataLabel.hidden) {
            dataLabel.fadeIn();
            if (point.connector) {
              point.connector.fadeIn();
            }
          }
        });
      }
    }, Math.max(this.chart.options.drilldown.animation.duration - 50, 0));
    delete this.animate;
  }
};
ColumnSeries_default.prototype.animateDrilldown = function(init) {
  var series = this, chart = this.chart, drilldownLevels = chart.drilldownLevels, animateFrom, animationOptions = animObject13(chart.options.drilldown.animation), xAxis = this.xAxis, styledMode = chart.styledMode;
  if (!init) {
    drilldownLevels.forEach(function(level) {
      if (series.options._ddSeriesId === level.lowerSeriesOptions._ddSeriesId) {
        animateFrom = level.shapeArgs;
        if (!styledMode) {
          animateFrom.fill = level.color;
        }
      }
    });
    animateFrom.x += pick78(xAxis.oldPos, xAxis.pos) - xAxis.pos;
    this.points.forEach(function(point) {
      var animateTo = point.shapeArgs;
      if (!styledMode) {
        animateTo.fill = point.color;
      }
      if (point.graphic) {
        point.graphic.attr(animateFrom).animate(extend68(point.shapeArgs, { fill: point.color || series.color }), animationOptions);
      }
      if (point.dataLabel) {
        point.dataLabel.fadeIn(animationOptions);
      }
    });
    delete this.animate;
  }
};
ColumnSeries_default.prototype.animateDrillupFrom = function(level) {
  var animationOptions = animObject13(this.chart.options.drilldown.animation), group = this.group, removeGroup = group !== this.chart.columnGroup, series = this;
  series.trackerGroups.forEach(function(key) {
    if (series[key]) {
      series[key].on("mouseover");
    }
  });
  if (removeGroup) {
    delete this.group;
  }
  this.points.forEach(function(point) {
    var graphic = point.graphic, animateTo = level.shapeArgs, complete = function() {
      graphic.destroy();
      if (group && removeGroup) {
        group = group.destroy();
      }
    };
    if (graphic && animateTo) {
      delete point.graphic;
      if (!series.chart.styledMode) {
        animateTo.fill = level.color;
      }
      if (animationOptions.duration) {
        graphic.animate(animateTo, merge67(animationOptions, { complete }));
      } else {
        graphic.attr(animateTo);
        complete();
      }
    }
  });
};
if (PieSeries3) {
  extend68(PieSeries3.prototype, {
    animateDrillupTo: ColumnSeries_default.prototype.animateDrillupTo,
    animateDrillupFrom: ColumnSeries_default.prototype.animateDrillupFrom,
    animateDrilldown: function(init) {
      var level = this.chart.drilldownLevels[this.chart.drilldownLevels.length - 1], animationOptions = this.chart.options.drilldown.animation;
      if (this.is("item")) {
        animationOptions.duration = 0;
      }
      if (this.center) {
        var animateFrom_1 = level.shapeArgs, start_1 = animateFrom_1.start, angle = animateFrom_1.end - start_1, startAngle_1 = angle / this.points.length, styledMode_1 = this.chart.styledMode;
        if (!init) {
          this.points.forEach(function(point, i) {
            var animateTo = point.shapeArgs;
            if (!styledMode_1) {
              animateFrom_1.fill = level.color;
              animateTo.fill = point.color;
            }
            if (point.graphic) {
              point.graphic.attr(merge67(animateFrom_1, {
                start: start_1 + i * startAngle_1,
                end: start_1 + (i + 1) * startAngle_1
              }))[animationOptions ? "animate" : "attr"](animateTo, animationOptions);
            }
          });
          delete this.animate;
        }
      }
    }
  });
}
Point_default.prototype.doDrilldown = function() {
  this.runDrilldown();
};
Point_default.prototype.runDrilldown = function(holdRedraw, category, originalEvent) {
  var series = this.series, chart = series.chart, drilldown = chart.options.drilldown;
  var i = (drilldown.series || []).length, seriesOptions;
  if (!chart.ddDupes) {
    chart.ddDupes = [];
  }
  while (i-- && !seriesOptions) {
    if (drilldown.series[i].id === this.drilldown && chart.ddDupes.indexOf(this.drilldown) === -1) {
      seriesOptions = drilldown.series[i];
      chart.ddDupes.push(this.drilldown);
    }
  }
  fireEvent29(chart, "drilldown", {
    point: this,
    seriesOptions,
    category,
    originalEvent,
    points: typeof category !== "undefined" && this.series.xAxis.getDDPoints(category).slice(0)
  }, function(e2) {
    var chart2 = e2.point.series && e2.point.series.chart, seriesOptions2 = e2.seriesOptions;
    if (chart2 && seriesOptions2) {
      if (holdRedraw) {
        chart2.addSingleSeriesAsDrilldown(e2.point, seriesOptions2);
      } else {
        chart2.addSeriesAsDrilldown(e2.point, seriesOptions2);
      }
    }
  });
};
Axis_default.prototype.drilldownCategory = function(x, originalEvent) {
  this.getDDPoints(x).forEach(function(point) {
    if (point && point.series && point.series.visible && point.runDrilldown) {
      point.runDrilldown(true, x, originalEvent);
    }
  });
  this.chart.applyDrilldown();
};
Axis_default.prototype.getDDPoints = function(x) {
  return this.ddPoints && this.ddPoints[x] || [];
};
Tick_default.prototype.drillable = function() {
  var pos = this.pos, label = this.label, axis = this.axis, isDrillable = axis.coll === "xAxis" && axis.getDDPoints, ddPointsX = isDrillable && axis.getDDPoints(pos), styledMode = axis.chart.styledMode;
  if (isDrillable) {
    if (label && ddPointsX && ddPointsX.length) {
      label.drillable = true;
      if (!label.basicStyles && !styledMode) {
        label.basicStyles = merge67(label.styles);
      }
      label.addClass("highcharts-drilldown-axis-label");
      if (label.removeOnDrillableClick) {
        removeEvent11(label.element, "click");
      }
      label.removeOnDrillableClick = addEvent52(label.element, "click", function(e2) {
        e2.preventDefault();
        axis.drilldownCategory(pos, e2);
      });
      if (!styledMode) {
        label.css(axis.chart.options.drilldown.activeAxisLabelStyle);
      }
    } else if (label && label.drillable && label.removeOnDrillableClick) {
      if (!styledMode) {
        label.styles = {};
        label.css(label.basicStyles);
      }
      label.removeOnDrillableClick();
      label.removeClass("highcharts-drilldown-axis-label");
    }
  }
};
addEvent52(Point_default, "afterInit", function() {
  var point = this;
  if (point.drilldown && !point.unbindDrilldownClick) {
    point.unbindDrilldownClick = addEvent52(point, "click", handlePointClick);
  }
  return point;
});
addEvent52(Point_default, "update", function(e2) {
  var point = this, options = e2.options || {};
  if (options.drilldown && !point.unbindDrilldownClick) {
    point.unbindDrilldownClick = addEvent52(point, "click", handlePointClick);
  } else if (!options.drilldown && options.drilldown !== void 0 && point.unbindDrilldownClick) {
    point.unbindDrilldownClick = point.unbindDrilldownClick();
  }
});
var handlePointClick = function(e2) {
  var point = this, series = point.series;
  if (series.xAxis && series.chart.options.drilldown.allowPointDrilldown === false) {
    series.xAxis.drilldownCategory(point.x, e2);
  } else {
    point.runDrilldown(void 0, void 0, e2);
  }
};
addEvent52(Series_default, "afterDrawDataLabels", function() {
  var css16 = this.chart.options.drilldown.activeDataLabelStyle, renderer = this.chart.renderer, styledMode = this.chart.styledMode;
  this.points.forEach(function(point) {
    var dataLabelsOptions = point.options.dataLabels, pointCSS = pick78(point.dlOptions, dataLabelsOptions && dataLabelsOptions.style, {});
    if (point.drilldown && point.dataLabel) {
      if (css16.color === "contrast" && !styledMode) {
        pointCSS.color = renderer.getContrast(point.color || this.color);
      }
      if (dataLabelsOptions && dataLabelsOptions.color) {
        pointCSS.color = dataLabelsOptions.color;
      }
      point.dataLabel.addClass("highcharts-drilldown-data-label");
      if (!styledMode) {
        point.dataLabel.css(css16).css(pointCSS);
      }
    }
  }, this);
});
var applyCursorCSS = function(element, cursor, addClass3, styledMode) {
  element[addClass3 ? "addClass" : "removeClass"]("highcharts-drilldown-point");
  if (!styledMode) {
    element.css({ cursor });
  }
};
addEvent52(Series_default, "afterDrawTracker", function() {
  var styledMode = this.chart.styledMode;
  this.points.forEach(function(point) {
    if (point.drilldown && point.graphic) {
      applyCursorCSS(point.graphic, "pointer", true, styledMode);
    }
  });
});
addEvent52(Point_default, "afterSetState", function() {
  var styledMode = this.series.chart.styledMode;
  if (this.drilldown && this.series.halo && this.state === "hover") {
    applyCursorCSS(this.series.halo, "pointer", true, styledMode);
  } else if (this.series.halo) {
    applyCursorCSS(this.series.halo, "auto", false, styledMode);
  }
});
addEvent52(Chart_default, "selection", function(event) {
  if (event.resetSelection === true && this.drillUpButton) {
    var buttonOptions = this.options.drilldown && this.options.drilldown.drillUpButton;
    if (buttonOptions && buttonOptions.position) {
      this.drillUpButton.align({
        x: buttonOptions.position.x,
        y: buttonOptions.position.y,
        align: buttonOptions.position.align
      }, false, buttonOptions.relativeTo || "plotBox");
    }
  }
});
addEvent52(Chart_default, "drillup", function() {
  if (this.resetZoomButton) {
    this.resetZoomButton = this.resetZoomButton.destroy();
  }
});

// node_modules/highcharts/es-modules/Extensions/FullScreen.js
var doc21 = Globals_default.doc;
var addEvent53 = Utilities_default.addEvent;
var Fullscreen = function() {
  function Fullscreen2(chart) {
    this.chart = chart;
    this.isOpen = false;
    var container = chart.renderTo;
    if (!this.browserProps) {
      if (typeof container.requestFullscreen === "function") {
        this.browserProps = {
          fullscreenChange: "fullscreenchange",
          requestFullscreen: "requestFullscreen",
          exitFullscreen: "exitFullscreen"
        };
      } else if (container.mozRequestFullScreen) {
        this.browserProps = {
          fullscreenChange: "mozfullscreenchange",
          requestFullscreen: "mozRequestFullScreen",
          exitFullscreen: "mozCancelFullScreen"
        };
      } else if (container.webkitRequestFullScreen) {
        this.browserProps = {
          fullscreenChange: "webkitfullscreenchange",
          requestFullscreen: "webkitRequestFullScreen",
          exitFullscreen: "webkitExitFullscreen"
        };
      } else if (container.msRequestFullscreen) {
        this.browserProps = {
          fullscreenChange: "MSFullscreenChange",
          requestFullscreen: "msRequestFullscreen",
          exitFullscreen: "msExitFullscreen"
        };
      }
    }
  }
  Fullscreen2.prototype.close = function() {
    var fullscreen = this, chart = fullscreen.chart, optionsChart = chart.options.chart;
    if (fullscreen.isOpen && fullscreen.browserProps && chart.container.ownerDocument instanceof Document) {
      chart.container.ownerDocument[fullscreen.browserProps.exitFullscreen]();
    }
    if (fullscreen.unbindFullscreenEvent) {
      fullscreen.unbindFullscreenEvent = fullscreen.unbindFullscreenEvent();
    }
    chart.setSize(fullscreen.origWidth, fullscreen.origHeight, false);
    fullscreen.origWidth = void 0;
    fullscreen.origHeight = void 0;
    optionsChart.width = fullscreen.origWidthOption;
    optionsChart.height = fullscreen.origHeightOption;
    fullscreen.origWidthOption = void 0;
    fullscreen.origHeightOption = void 0;
    fullscreen.isOpen = false;
    fullscreen.setButtonText();
  };
  Fullscreen2.prototype.open = function() {
    var fullscreen = this, chart = fullscreen.chart, optionsChart = chart.options.chart;
    if (optionsChart) {
      fullscreen.origWidthOption = optionsChart.width;
      fullscreen.origHeightOption = optionsChart.height;
    }
    fullscreen.origWidth = chart.chartWidth;
    fullscreen.origHeight = chart.chartHeight;
    if (fullscreen.browserProps) {
      var unbindChange_1 = addEvent53(chart.container.ownerDocument, fullscreen.browserProps.fullscreenChange, function() {
        if (fullscreen.isOpen) {
          fullscreen.isOpen = false;
          fullscreen.close();
        } else {
          chart.setSize(null, null, false);
          fullscreen.isOpen = true;
          fullscreen.setButtonText();
        }
      });
      var unbindDestroy_1 = addEvent53(chart, "destroy", unbindChange_1);
      fullscreen.unbindFullscreenEvent = function() {
        unbindChange_1();
        unbindDestroy_1();
      };
      var promise = chart.renderTo[fullscreen.browserProps.requestFullscreen]();
      if (promise) {
        promise["catch"](function() {
          alert("Full screen is not supported inside a frame.");
        });
      }
    }
  };
  Fullscreen2.prototype.setButtonText = function() {
    var chart = this.chart, exportDivElements = chart.exportDivElements, exportingOptions = chart.options.exporting, menuItems = exportingOptions && exportingOptions.buttons && exportingOptions.buttons.contextButton.menuItems, lang2 = chart.options.lang;
    if (exportingOptions && exportingOptions.menuItemDefinitions && lang2 && lang2.exitFullscreen && lang2.viewFullscreen && menuItems && exportDivElements) {
      var exportDivElement = exportDivElements[menuItems.indexOf("viewFullscreen")];
      if (exportDivElement) {
        AST_default.setElementHTML(exportDivElement, !this.isOpen ? exportingOptions.menuItemDefinitions.viewFullscreen.text || lang2.viewFullscreen : lang2.exitFullscreen);
      }
    }
  };
  Fullscreen2.prototype.toggle = function() {
    var fullscreen = this;
    if (!fullscreen.isOpen) {
      fullscreen.open();
    } else {
      fullscreen.close();
    }
  };
  return Fullscreen2;
}();
Globals_default.Fullscreen = Fullscreen;
var FullScreen_default = Globals_default.Fullscreen;
addEvent53(Chart_default, "beforeRender", function() {
  this.fullscreen = new Globals_default.Fullscreen(this);
});

// node_modules/highcharts/es-modules/Mixins/Navigation.js
var chartNavigation = {
  initUpdate: function(chart) {
    if (!chart.navigation) {
      chart.navigation = {
        updates: [],
        update: function(options, redraw) {
          this.updates.forEach(function(updateConfig) {
            updateConfig.update.call(updateConfig.context, options, redraw);
          });
        }
      };
    }
  },
  addUpdate: function(update, chart) {
    if (!chart.navigation) {
      this.initUpdate(chart);
    }
    chart.navigation.updates.push({
      update,
      context: chart
    });
  }
};
var Navigation_default = chartNavigation;

// node_modules/highcharts/es-modules/Extensions/Exporting/ExportingDefaults.js
var isTouchDevice5 = Globals_default.isTouchDevice;
var exporting = {
  type: "image/png",
  url: "https://export.highcharts.com/",
  printMaxWidth: 780,
  scale: 2,
  buttons: {
    contextButton: {
      className: "highcharts-contextbutton",
      menuClassName: "highcharts-contextmenu",
      symbol: "menu",
      titleKey: "contextButtonTitle",
      menuItems: [
        "viewFullscreen",
        "printChart",
        "separator",
        "downloadPNG",
        "downloadJPEG",
        "downloadPDF",
        "downloadSVG"
      ]
    }
  },
  menuItemDefinitions: {
    viewFullscreen: {
      textKey: "viewFullscreen",
      onclick: function() {
        this.fullscreen.toggle();
      }
    },
    printChart: {
      textKey: "printChart",
      onclick: function() {
        this.print();
      }
    },
    separator: {
      separator: true
    },
    downloadPNG: {
      textKey: "downloadPNG",
      onclick: function() {
        this.exportChart();
      }
    },
    downloadJPEG: {
      textKey: "downloadJPEG",
      onclick: function() {
        this.exportChart({
          type: "image/jpeg"
        });
      }
    },
    downloadPDF: {
      textKey: "downloadPDF",
      onclick: function() {
        this.exportChart({
          type: "application/pdf"
        });
      }
    },
    downloadSVG: {
      textKey: "downloadSVG",
      onclick: function() {
        this.exportChart({
          type: "image/svg+xml"
        });
      }
    }
  }
};
var lang = {
  viewFullscreen: "View in full screen",
  exitFullscreen: "Exit from full screen",
  printChart: "Print chart",
  downloadPNG: "Download PNG image",
  downloadJPEG: "Download JPEG image",
  downloadPDF: "Download PDF document",
  downloadSVG: "Download SVG vector image",
  contextButtonTitle: "Chart context menu"
};
var navigation = {
  buttonOptions: {
    symbolSize: 14,
    symbolX: 12.5,
    symbolY: 10.5,
    align: "right",
    buttonSpacing: 3,
    height: 22,
    verticalAlign: "top",
    width: 24,
    symbolFill: Palette_default.neutralColor60,
    symbolStroke: Palette_default.neutralColor60,
    symbolStrokeWidth: 3,
    theme: {
      padding: 5
    }
  },
  menuStyle: {
    border: "1px solid " + Palette_default.neutralColor40,
    background: Palette_default.backgroundColor,
    padding: "5px 0"
  },
  menuItemStyle: {
    padding: "0.5em 1em",
    color: Palette_default.neutralColor80,
    background: "none",
    fontSize: isTouchDevice5 ? "14px" : "11px",
    transition: "background 250ms, color 250ms"
  },
  menuItemHoverStyle: {
    background: Palette_default.highlightColor80,
    color: Palette_default.backgroundColor
  }
};
var ExportingDefaults = {
  exporting,
  lang,
  navigation
};
var ExportingDefaults_default = ExportingDefaults;

// node_modules/highcharts/es-modules/Extensions/Exporting/ExportingSymbols.js
var ExportingSymbols;
(function(ExportingSymbols2) {
  var modifiedClasses = [];
  function compose(SVGRendererClass) {
    if (modifiedClasses.indexOf(SVGRendererClass) === -1) {
      modifiedClasses.push(SVGRendererClass);
      var symbols4 = SVGRendererClass.prototype.symbols;
      symbols4.menu = menu;
      symbols4.menuball = menuball.bind(symbols4);
    }
  }
  ExportingSymbols2.compose = compose;
  function menu(x, y, width, height) {
    var arr = [
      ["M", x, y + 2.5],
      ["L", x + width, y + 2.5],
      ["M", x, y + height / 2 + 0.5],
      ["L", x + width, y + height / 2 + 0.5],
      ["M", x, y + height - 1.5],
      ["L", x + width, y + height - 1.5]
    ];
    return arr;
  }
  function menuball(x, y, width, height) {
    var h = height / 3 - 2;
    var path = [];
    path = path.concat(this.circle(width - h, y, h, h), this.circle(width - h, y + h + 4, h, h), this.circle(width - h, y + 2 * (h + 4), h, h));
    return path;
  }
})(ExportingSymbols || (ExportingSymbols = {}));
var ExportingSymbols_default = ExportingSymbols;

// node_modules/highcharts/es-modules/Extensions/Exporting/Exporting.js
var defaultOptions15 = DefaultOptions_default.defaultOptions;
var doc22 = Globals_default.doc;
var win16 = Globals_default.win;
var addEvent54 = Utilities_default.addEvent;
var css14 = Utilities_default.css;
var createElement11 = Utilities_default.createElement;
var discardElement8 = Utilities_default.discardElement;
var extend69 = Utilities_default.extend;
var find16 = Utilities_default.find;
var fireEvent30 = Utilities_default.fireEvent;
var isObject9 = Utilities_default.isObject;
var merge68 = Utilities_default.merge;
var objectEach33 = Utilities_default.objectEach;
var pick79 = Utilities_default.pick;
var removeEvent12 = Utilities_default.removeEvent;
var uniqueKey8 = Utilities_default.uniqueKey;
var Exporting;
(function(Exporting2) {
  var composedClasses2 = [];
  var inlineBlacklist = [
    /-/,
    /^(clipPath|cssText|d|height|width)$/,
    /^font$/,
    /[lL]ogical(Width|Height)$/,
    /perspective/,
    /TapHighlightColor/,
    /^transition/,
    /^length$/
  ];
  var inlineToAttributes = [
    "fill",
    "stroke",
    "strokeLinecap",
    "strokeLinejoin",
    "strokeWidth",
    "textAnchor",
    "x",
    "y"
  ];
  Exporting2.inlineWhitelist = [];
  var unstyledElements = [
    "clipPath",
    "defs",
    "desc"
  ];
  var printingChart;
  function addButton(options) {
    var chart = this, renderer = chart.renderer, btnOptions = merge68(chart.options.navigation.buttonOptions, options), onclick = btnOptions.onclick, menuItems = btnOptions.menuItems, symbolSize = btnOptions.symbolSize || 12;
    var symbol;
    if (!chart.btnCount) {
      chart.btnCount = 0;
    }
    if (!chart.exportDivElements) {
      chart.exportDivElements = [];
      chart.exportSVGElements = [];
    }
    if (btnOptions.enabled === false || !btnOptions.theme) {
      return;
    }
    var attr10 = btnOptions.theme, states = attr10.states, hover = states && states.hover, select = states && states.select;
    var callback;
    if (!chart.styledMode) {
      attr10.fill = pick79(attr10.fill, Palette_default.backgroundColor);
      attr10.stroke = pick79(attr10.stroke, "none");
    }
    delete attr10.states;
    if (onclick) {
      callback = function(e2) {
        if (e2) {
          e2.stopPropagation();
        }
        onclick.call(chart, e2);
      };
    } else if (menuItems) {
      callback = function(e2) {
        if (e2) {
          e2.stopPropagation();
        }
        chart.contextMenu(button.menuClassName, menuItems, button.translateX, button.translateY, button.width, button.height, button);
        button.setState(2);
      };
    }
    if (btnOptions.text && btnOptions.symbol) {
      attr10.paddingLeft = pick79(attr10.paddingLeft, 30);
    } else if (!btnOptions.text) {
      extend69(attr10, {
        width: btnOptions.width,
        height: btnOptions.height,
        padding: 0
      });
    }
    if (!chart.styledMode) {
      attr10["stroke-linecap"] = "round";
      attr10.fill = pick79(attr10.fill, Palette_default.backgroundColor);
      attr10.stroke = pick79(attr10.stroke, "none");
    }
    var button = renderer.button(btnOptions.text, 0, 0, callback, attr10, hover, select).addClass(options.className).attr({
      title: pick79(chart.options.lang[btnOptions._titleKey || btnOptions.titleKey], "")
    });
    button.menuClassName = options.menuClassName || "highcharts-menu-" + chart.btnCount++;
    if (btnOptions.symbol) {
      symbol = renderer.symbol(btnOptions.symbol, btnOptions.symbolX - symbolSize / 2, btnOptions.symbolY - symbolSize / 2, symbolSize, symbolSize, {
        width: symbolSize,
        height: symbolSize
      }).addClass("highcharts-button-symbol").attr({
        zIndex: 1
      }).add(button);
      if (!chart.styledMode) {
        symbol.attr({
          stroke: btnOptions.symbolStroke,
          fill: btnOptions.symbolFill,
          "stroke-width": btnOptions.symbolStrokeWidth || 1
        });
      }
    }
    button.add(chart.exportingGroup).align(extend69(btnOptions, {
      width: button.width,
      x: pick79(btnOptions.x, chart.buttonOffset)
    }), true, "spacingBox");
    chart.buttonOffset += (button.width + btnOptions.buttonSpacing) * (btnOptions.align === "right" ? -1 : 1);
    chart.exportSVGElements.push(button, symbol);
  }
  function afterPrint() {
    var chart = this;
    if (!chart.printReverseInfo) {
      return void 0;
    }
    var _a15 = chart.printReverseInfo, childNodes = _a15.childNodes, origDisplay = _a15.origDisplay, resetParams = _a15.resetParams;
    chart.moveContainers(chart.renderTo);
    [].forEach.call(childNodes, function(node, i) {
      if (node.nodeType === 1) {
        node.style.display = origDisplay[i] || "";
      }
    });
    chart.isPrinting = false;
    if (resetParams) {
      chart.setSize.apply(chart, resetParams);
    }
    delete chart.printReverseInfo;
    printingChart = void 0;
    fireEvent30(chart, "afterPrint");
  }
  function beforePrint() {
    var chart = this, body = doc22.body, printMaxWidth = chart.options.exporting.printMaxWidth, printReverseInfo = {
      childNodes: body.childNodes,
      origDisplay: [],
      resetParams: void 0
    };
    chart.isPrinting = true;
    chart.pointer.reset(null, 0);
    fireEvent30(chart, "beforePrint");
    var handleMaxWidth = printMaxWidth && chart.chartWidth > printMaxWidth;
    if (handleMaxWidth) {
      printReverseInfo.resetParams = [
        chart.options.chart.width,
        void 0,
        false
      ];
      chart.setSize(printMaxWidth, void 0, false);
    }
    [].forEach.call(printReverseInfo.childNodes, function(node, i) {
      if (node.nodeType === 1) {
        printReverseInfo.origDisplay[i] = node.style.display;
        node.style.display = "none";
      }
    });
    chart.moveContainers(body);
    chart.printReverseInfo = printReverseInfo;
  }
  function chartCallback(chart) {
    var composition = chart;
    composition.renderExporting();
    addEvent54(chart, "redraw", composition.renderExporting);
    addEvent54(chart, "destroy", composition.destroyExport);
  }
  function compose(ChartClass, SVGRendererClass) {
    ExportingSymbols_default.compose(SVGRendererClass);
    if (composedClasses2.indexOf(ChartClass) === -1) {
      composedClasses2.push(ChartClass);
      var chartProto = ChartClass.prototype;
      chartProto.afterPrint = afterPrint;
      chartProto.exportChart = exportChart;
      chartProto.inlineStyles = inlineStyles;
      chartProto.print = print;
      chartProto.sanitizeSVG = sanitizeSVG;
      chartProto.getChartHTML = getChartHTML;
      chartProto.getSVG = getSVG;
      chartProto.getSVGForExport = getSVGForExport;
      chartProto.getFilename = getFilename;
      chartProto.moveContainers = moveContainers;
      chartProto.beforePrint = beforePrint;
      chartProto.contextMenu = contextMenu;
      chartProto.addButton = addButton;
      chartProto.destroyExport = destroyExport;
      chartProto.renderExporting = renderExporting;
      chartProto.callbacks.push(chartCallback);
      addEvent54(ChartClass, "init", onChartInit);
      if (Globals_default.isSafari) {
        Globals_default.win.matchMedia("print").addListener(function(mqlEvent) {
          if (!printingChart) {
            return void 0;
          }
          if (mqlEvent.matches) {
            printingChart.beforePrint();
          } else {
            printingChart.afterPrint();
          }
        });
      }
    }
  }
  Exporting2.compose = compose;
  function contextMenu(className, items, x, y, width, height, button) {
    var chart = this, navOptions = chart.options.navigation, chartWidth = chart.chartWidth, chartHeight = chart.chartHeight, cacheName = "cache-" + className, menuPadding = Math.max(width, height);
    var innerMenu, menu = chart[cacheName];
    if (!menu) {
      chart.exportContextMenu = chart[cacheName] = menu = createElement11("div", {
        className
      }, {
        position: "absolute",
        zIndex: 1e3,
        padding: menuPadding + "px",
        pointerEvents: "auto"
      }, chart.fixedDiv || chart.container);
      innerMenu = createElement11("ul", { className: "highcharts-menu" }, {
        listStyle: "none",
        margin: 0,
        padding: 0
      }, menu);
      if (!chart.styledMode) {
        css14(innerMenu, extend69({
          MozBoxShadow: "3px 3px 10px #888",
          WebkitBoxShadow: "3px 3px 10px #888",
          boxShadow: "3px 3px 10px #888"
        }, navOptions.menuStyle));
      }
      menu.hideMenu = function() {
        css14(menu, { display: "none" });
        if (button) {
          button.setState(0);
        }
        chart.openMenu = false;
        css14(chart.renderTo, { overflow: "hidden" });
        css14(chart.container, { overflow: "hidden" });
        Utilities_default.clearTimeout(menu.hideTimer);
        fireEvent30(chart, "exportMenuHidden");
      };
      chart.exportEvents.push(addEvent54(menu, "mouseleave", function() {
        menu.hideTimer = win16.setTimeout(menu.hideMenu, 500);
      }), addEvent54(menu, "mouseenter", function() {
        Utilities_default.clearTimeout(menu.hideTimer);
      }), addEvent54(doc22, "mouseup", function(e2) {
        if (!chart.pointer.inClass(e2.target, className)) {
          menu.hideMenu();
        }
      }), addEvent54(menu, "click", function() {
        if (chart.openMenu) {
          menu.hideMenu();
        }
      }));
      items.forEach(function(item) {
        if (typeof item === "string") {
          item = chart.options.exporting.menuItemDefinitions[item];
        }
        if (isObject9(item, true)) {
          var element = void 0;
          if (item.separator) {
            element = createElement11("hr", void 0, void 0, innerMenu);
          } else {
            if (item.textKey === "viewData" && chart.isDataTableVisible) {
              item.textKey = "hideData";
            }
            element = createElement11("li", {
              className: "highcharts-menu-item",
              onclick: function(e2) {
                if (e2) {
                  e2.stopPropagation();
                }
                menu.hideMenu();
                if (item.onclick) {
                  item.onclick.apply(chart, arguments);
                }
              }
            }, void 0, innerMenu);
            AST_default.setElementHTML(element, item.text || chart.options.lang[item.textKey]);
            if (!chart.styledMode) {
              element.onmouseover = function() {
                css14(this, navOptions.menuItemHoverStyle);
              };
              element.onmouseout = function() {
                css14(this, navOptions.menuItemStyle);
              };
              css14(element, extend69({
                cursor: "pointer"
              }, navOptions.menuItemStyle));
            }
          }
          chart.exportDivElements.push(element);
        }
      });
      chart.exportDivElements.push(innerMenu, menu);
      chart.exportMenuWidth = menu.offsetWidth;
      chart.exportMenuHeight = menu.offsetHeight;
    }
    var menuStyle = { display: "block" };
    if (x + chart.exportMenuWidth > chartWidth) {
      menuStyle.right = chartWidth - x - width - menuPadding + "px";
    } else {
      menuStyle.left = x - menuPadding + "px";
    }
    if (y + height + chart.exportMenuHeight > chartHeight && button.alignOptions.verticalAlign !== "top") {
      menuStyle.bottom = chartHeight - y - menuPadding + "px";
    } else {
      menuStyle.top = y + height - menuPadding + "px";
    }
    css14(menu, menuStyle);
    css14(chart.renderTo, { overflow: "" });
    css14(chart.container, { overflow: "" });
    chart.openMenu = true;
    fireEvent30(chart, "exportMenuShown");
  }
  function destroyExport(e2) {
    var chart = e2 ? e2.target : this, exportSVGElements = chart.exportSVGElements, exportDivElements = chart.exportDivElements, exportEvents = chart.exportEvents;
    var cacheName;
    if (exportSVGElements) {
      exportSVGElements.forEach(function(elem, i) {
        if (elem) {
          elem.onclick = elem.ontouchstart = null;
          cacheName = "cache-" + elem.menuClassName;
          if (chart[cacheName]) {
            delete chart[cacheName];
          }
          exportSVGElements[i] = elem.destroy();
        }
      });
      exportSVGElements.length = 0;
    }
    if (chart.exportingGroup) {
      chart.exportingGroup.destroy();
      delete chart.exportingGroup;
    }
    if (exportDivElements) {
      exportDivElements.forEach(function(elem, i) {
        if (elem) {
          Utilities_default.clearTimeout(elem.hideTimer);
          removeEvent12(elem, "mouseleave");
          exportDivElements[i] = elem.onmouseout = elem.onmouseover = elem.ontouchstart = elem.onclick = null;
          discardElement8(elem);
        }
      });
      exportDivElements.length = 0;
    }
    if (exportEvents) {
      exportEvents.forEach(function(unbind) {
        unbind();
      });
      exportEvents.length = 0;
    }
  }
  function exportChart(exportingOptions, chartOptions) {
    var svg7 = this.getSVGForExport(exportingOptions, chartOptions);
    exportingOptions = merge68(this.options.exporting, exportingOptions);
    HttpUtilities_default.post(exportingOptions.url, {
      filename: exportingOptions.filename ? exportingOptions.filename.replace(/\//g, "-") : this.getFilename(),
      type: exportingOptions.type,
      width: exportingOptions.width || 0,
      scale: exportingOptions.scale,
      svg: svg7
    }, exportingOptions.formAttributes);
  }
  function getChartHTML() {
    if (this.styledMode) {
      this.inlineStyles();
    }
    return this.container.innerHTML;
  }
  function getFilename() {
    var s = this.userOptions.title && this.userOptions.title.text;
    var filename = this.options.exporting.filename;
    if (filename) {
      return filename.replace(/\//g, "-");
    }
    if (typeof s === "string") {
      filename = s.toLowerCase().replace(/<\/?[^>]+(>|$)/g, "").replace(/[\s_]+/g, "-").replace(/[^a-z0-9\-]/g, "").replace(/^[\-]+/g, "").replace(/[\-]+/g, "-").substr(0, 24).replace(/[\-]+$/g, "");
    }
    if (!filename || filename.length < 5) {
      filename = "chart";
    }
    return filename;
  }
  function getSVG(chartOptions) {
    var chart = this;
    var svg7, seriesOptions, options = merge68(chart.options, chartOptions);
    options.plotOptions = merge68(chart.userOptions.plotOptions, chartOptions && chartOptions.plotOptions);
    options.time = merge68(chart.userOptions.time, chartOptions && chartOptions.time);
    var sandbox = createElement11("div", null, {
      position: "absolute",
      top: "-9999em",
      width: chart.chartWidth + "px",
      height: chart.chartHeight + "px"
    }, doc22.body);
    var cssWidth = chart.renderTo.style.width, cssHeight = chart.renderTo.style.height, sourceWidth = options.exporting.sourceWidth || options.chart.width || /px$/.test(cssWidth) && parseInt(cssWidth, 10) || (options.isGantt ? 800 : 600), sourceHeight = options.exporting.sourceHeight || options.chart.height || /px$/.test(cssHeight) && parseInt(cssHeight, 10) || 400;
    extend69(options.chart, {
      animation: false,
      renderTo: sandbox,
      forExport: true,
      renderer: "SVGRenderer",
      width: sourceWidth,
      height: sourceHeight
    });
    options.exporting.enabled = false;
    delete options.data;
    options.series = [];
    chart.series.forEach(function(serie) {
      seriesOptions = merge68(serie.userOptions, {
        animation: false,
        enableMouseTracking: false,
        showCheckbox: false,
        visible: serie.visible
      });
      if (!seriesOptions.isInternal) {
        options.series.push(seriesOptions);
      }
    });
    var colls = {};
    chart.axes.forEach(function(axis) {
      if (!axis.userOptions.internalKey) {
        axis.userOptions.internalKey = uniqueKey8();
      }
      if (!axis.options.isInternal) {
        if (!colls[axis.coll]) {
          colls[axis.coll] = true;
          options[axis.coll] = [];
        }
        options[axis.coll].push(merge68(axis.userOptions, {
          visible: axis.visible
        }));
      }
    });
    var chartCopy = new Chart_default(options, chart.callback);
    if (chartOptions) {
      ["xAxis", "yAxis", "series"].forEach(function(coll) {
        var collOptions = {};
        if (chartOptions[coll]) {
          collOptions[coll] = chartOptions[coll];
          chartCopy.update(collOptions);
        }
      });
    }
    chart.axes.forEach(function(axis) {
      var axisCopy = find16(chartCopy.axes, function(copy) {
        return copy.options.internalKey === axis.userOptions.internalKey;
      }), extremes = axis.getExtremes(), userMin = extremes.userMin, userMax = extremes.userMax;
      if (axisCopy && (typeof userMin !== "undefined" && userMin !== axisCopy.min || typeof userMax !== "undefined" && userMax !== axisCopy.max)) {
        axisCopy.setExtremes(userMin, userMax, true, false);
      }
    });
    svg7 = chartCopy.getChartHTML();
    fireEvent30(this, "getSVG", { chartCopy });
    svg7 = chart.sanitizeSVG(svg7, options);
    options = null;
    chartCopy.destroy();
    discardElement8(sandbox);
    return svg7;
  }
  function getSVGForExport(options, chartOptions) {
    var chartExportingOptions = this.options.exporting;
    return this.getSVG(merge68({ chart: { borderRadius: 0 } }, chartExportingOptions.chartOptions, chartOptions, {
      exporting: {
        sourceWidth: options && options.sourceWidth || chartExportingOptions.sourceWidth,
        sourceHeight: options && options.sourceHeight || chartExportingOptions.sourceHeight
      }
    }));
  }
  function hyphenate(prop) {
    return prop.replace(/([A-Z])/g, function(a, b) {
      return "-" + b.toLowerCase();
    });
  }
  function inlineStyles() {
    var blacklist = inlineBlacklist, whitelist = Exporting2.inlineWhitelist, defaultStyles = {};
    var dummySVG;
    var iframe = doc22.createElement("iframe");
    css14(iframe, {
      width: "1px",
      height: "1px",
      visibility: "hidden"
    });
    doc22.body.appendChild(iframe);
    var iframeDoc = iframe.contentWindow.document;
    iframeDoc.open();
    iframeDoc.write('<svg xmlns="http://www.w3.org/2000/svg"></svg>');
    iframeDoc.close();
    function recurse(node) {
      var styles, parentStyles, cssText = "", dummy, styleAttr, blacklisted, whitelisted, i;
      function filterStyles(val, prop) {
        blacklisted = whitelisted = false;
        if (whitelist.length) {
          i = whitelist.length;
          while (i-- && !whitelisted) {
            whitelisted = whitelist[i].test(prop);
          }
          blacklisted = !whitelisted;
        }
        if (prop === "transform" && val === "none") {
          blacklisted = true;
        }
        i = blacklist.length;
        while (i-- && !blacklisted) {
          blacklisted = blacklist[i].test(prop) || typeof val === "function";
        }
        if (!blacklisted) {
          if ((parentStyles[prop] !== val || node.nodeName === "svg") && defaultStyles[node.nodeName][prop] !== val) {
            if (!inlineToAttributes || inlineToAttributes.indexOf(prop) !== -1) {
              if (val) {
                node.setAttribute(hyphenate(prop), val);
              }
            } else {
              cssText += hyphenate(prop) + ":" + val + ";";
            }
          }
        }
      }
      if (node.nodeType === 1 && unstyledElements.indexOf(node.nodeName) === -1) {
        styles = win16.getComputedStyle(node, null);
        parentStyles = node.nodeName === "svg" ? {} : win16.getComputedStyle(node.parentNode, null);
        if (!defaultStyles[node.nodeName]) {
          dummySVG = iframeDoc.getElementsByTagName("svg")[0];
          dummy = iframeDoc.createElementNS(node.namespaceURI, node.nodeName);
          dummySVG.appendChild(dummy);
          defaultStyles[node.nodeName] = merge68(win16.getComputedStyle(dummy, null));
          if (node.nodeName === "text") {
            delete defaultStyles.text.fill;
          }
          dummySVG.removeChild(dummy);
        }
        if (Globals_default.isFirefox || Globals_default.isMS) {
          for (var p in styles) {
            filterStyles(styles[p], p);
          }
        } else {
          objectEach33(styles, filterStyles);
        }
        if (cssText) {
          styleAttr = node.getAttribute("style");
          node.setAttribute("style", (styleAttr ? styleAttr + ";" : "") + cssText);
        }
        if (node.nodeName === "svg") {
          node.setAttribute("stroke-width", "1px");
        }
        if (node.nodeName === "text") {
          return;
        }
        [].forEach.call(node.children || node.childNodes, recurse);
      }
    }
    function tearDown() {
      dummySVG.parentNode.removeChild(dummySVG);
      iframe.parentNode.removeChild(iframe);
    }
    recurse(this.container.querySelector("svg"));
    tearDown();
  }
  function moveContainers(moveTo) {
    var chart = this;
    (chart.fixedDiv ? [chart.fixedDiv, chart.scrollingContainer] : [chart.container]).forEach(function(div) {
      moveTo.appendChild(div);
    });
  }
  function onChartInit() {
    var chart = this, update = function(prop, options, redraw) {
      chart.isDirtyExporting = true;
      merge68(true, chart.options[prop], options);
      if (pick79(redraw, true)) {
        chart.redraw();
      }
    };
    chart.exporting = {
      update: function(options, redraw) {
        update("exporting", options, redraw);
      }
    };
    Navigation_default.addUpdate(function(options, redraw) {
      update("navigation", options, redraw);
    }, chart);
  }
  function print() {
    var chart = this;
    if (chart.isPrinting) {
      return;
    }
    printingChart = chart;
    if (!Globals_default.isSafari) {
      chart.beforePrint();
    }
    setTimeout(function() {
      win16.focus();
      win16.print();
      if (!Globals_default.isSafari) {
        setTimeout(function() {
          chart.afterPrint();
        }, 1e3);
      }
    }, 1);
  }
  function renderExporting() {
    var chart = this, exportingOptions = chart.options.exporting, buttons = exportingOptions.buttons, isDirty = chart.isDirtyExporting || !chart.exportSVGElements;
    chart.buttonOffset = 0;
    if (chart.isDirtyExporting) {
      chart.destroyExport();
    }
    if (isDirty && exportingOptions.enabled !== false) {
      chart.exportEvents = [];
      chart.exportingGroup = chart.exportingGroup || chart.renderer.g("exporting-group").attr({
        zIndex: 3
      }).add();
      objectEach33(buttons, function(button) {
        chart.addButton(button);
      });
      chart.isDirtyExporting = false;
    }
  }
  function sanitizeSVG(svg7, options) {
    var split = svg7.indexOf("</svg>") + 6;
    var html2 = svg7.substr(split);
    svg7 = svg7.substr(0, split);
    if (options && options.exporting && options.exporting.allowHTML) {
      if (html2) {
        html2 = '<foreignObject x="0" y="0" width="' + options.chart.width + '" height="' + options.chart.height + '"><body xmlns="http://www.w3.org/1999/xhtml">' + html2.replace(/(<(?:img|br).*?(?=\>))>/g, "$1 />") + "</body></foreignObject>";
        svg7 = svg7.replace("</svg>", html2 + "</svg>");
      }
    }
    svg7 = svg7.replace(/zIndex="[^"]+"/g, "").replace(/symbolName="[^"]+"/g, "").replace(/jQuery[0-9]+="[^"]+"/g, "").replace(/url\(("|&quot;)(.*?)("|&quot;)\;?\)/g, "url($2)").replace(/url\([^#]+#/g, "url(#").replace(/<svg /, '<svg xmlns:xlink="http://www.w3.org/1999/xlink" ').replace(/ (|NS[0-9]+\:)href=/g, " xlink:href=").replace(/\n/, " ").replace(/(fill|stroke)="rgba\(([ 0-9]+,[ 0-9]+,[ 0-9]+),([ 0-9\.]+)\)"/g, '$1="rgb($2)" $1-opacity="$3"').replace(/&nbsp;/g, "\xA0").replace(/&shy;/g, "\xAD");
    if (this.ieSanitizeSVG) {
      svg7 = this.ieSanitizeSVG(svg7);
    }
    return svg7;
  }
})(Exporting || (Exporting = {}));
defaultOptions15.exporting = merge68(ExportingDefaults_default.exporting, defaultOptions15.exporting);
defaultOptions15.lang = merge68(ExportingDefaults_default.lang, defaultOptions15.lang);
defaultOptions15.navigation = merge68(ExportingDefaults_default.navigation, defaultOptions15.navigation);
var Exporting_default = Exporting;

// node_modules/highcharts/es-modules/masters/modules/exporting.src.js
var G7 = Globals_default;
G7.HttpUtilities = HttpUtilities_default;
G7.ajax = HttpUtilities_default.ajax;
G7.getJSON = HttpUtilities_default.getJSON;
G7.post = HttpUtilities_default.post;
Exporting_default.compose(G7.Chart, G7.Renderer);

// node_modules/highcharts/es-modules/Series/Funnel/FunnelSeries.js
var __extends44 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var noop19 = Globals_default.noop;
var Series8 = SeriesRegistry_default.series;
var PieSeries4 = SeriesRegistry_default.seriesTypes.pie;
var addEvent55 = Utilities_default.addEvent;
var extend70 = Utilities_default.extend;
var fireEvent31 = Utilities_default.fireEvent;
var isArray20 = Utilities_default.isArray;
var merge69 = Utilities_default.merge;
var pick80 = Utilities_default.pick;
var FunnelSeries = function(_super) {
  __extends44(FunnelSeries2, _super);
  function FunnelSeries2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.data = void 0;
    _this.options = void 0;
    _this.points = void 0;
    return _this;
  }
  FunnelSeries2.prototype.alignDataLabel = function(point, dataLabel, options, alignTo, isNew) {
    var series = point.series, reversed = series.options.reversed, dlBox = point.dlBox || point.shapeArgs, align = options.align, verticalAlign = options.verticalAlign, inside = ((series.options || {}).dataLabels || {}).inside, centerY = series.center[1], pointPlotY = reversed ? 2 * centerY - point.plotY : point.plotY, widthAtLabel = series.getWidthAt(pointPlotY - dlBox.height / 2 + dataLabel.height), offset3 = verticalAlign === "middle" ? (dlBox.topWidth - dlBox.bottomWidth) / 4 : (widthAtLabel - dlBox.bottomWidth) / 2, y = dlBox.y, x = dlBox.x;
    if (verticalAlign === "middle") {
      y = dlBox.y - dlBox.height / 2 + dataLabel.height / 2;
    } else if (verticalAlign === "top") {
      y = dlBox.y - dlBox.height + dataLabel.height + options.padding;
    }
    if (verticalAlign === "top" && !reversed || verticalAlign === "bottom" && reversed || verticalAlign === "middle") {
      if (align === "right") {
        x = dlBox.x - options.padding + offset3;
      } else if (align === "left") {
        x = dlBox.x + options.padding - offset3;
      }
    }
    alignTo = {
      x,
      y: reversed ? y - dlBox.height : y,
      width: dlBox.bottomWidth,
      height: dlBox.height
    };
    options.verticalAlign = "bottom";
    if (!inside || point.visible) {
      Series8.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);
    }
    if (inside) {
      if (!point.visible && point.dataLabel) {
        point.dataLabel.placed = false;
      }
      if (point.contrastColor) {
        dataLabel.css({
          color: point.contrastColor
        });
      }
    }
  };
  FunnelSeries2.prototype.drawDataLabels = function() {
    var series = this, data = series.data, labelDistance = series.options.dataLabels.distance, leftSide, sign, point, i = data.length, x, y;
    series.center[2] -= 2 * labelDistance;
    while (i--) {
      point = data[i];
      leftSide = point.half;
      sign = leftSide ? 1 : -1;
      y = point.plotY;
      point.labelDistance = pick80(point.options.dataLabels && point.options.dataLabels.distance, labelDistance);
      series.maxLabelDistance = Math.max(point.labelDistance, series.maxLabelDistance || 0);
      x = series.getX(y, leftSide, point);
      point.labelPosition = {
        natural: {
          x: 0,
          y
        },
        "final": {},
        alignment: leftSide ? "right" : "left",
        connectorPosition: {
          breakAt: {
            x: x + (point.labelDistance - 5) * sign,
            y
          },
          touchingSliceAt: {
            x: x + point.labelDistance * sign,
            y
          }
        }
      };
    }
    SeriesRegistry_default.seriesTypes[series.options.dataLabels.inside ? "column" : "pie"].prototype.drawDataLabels.call(this);
  };
  FunnelSeries2.prototype.translate = function() {
    var sum = 0, series = this, chart = series.chart, options = series.options, reversed = options.reversed, ignoreHiddenPoint = options.ignoreHiddenPoint, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, cumulative = 0, center = options.center, centerX = getLength(center[0], plotWidth), centerY = getLength(center[1], plotHeight), width = getLength(options.width, plotWidth), tempWidth, height = getLength(options.height, plotHeight), neckWidth = getLength(options.neckWidth, plotWidth), neckHeight = getLength(options.neckHeight, plotHeight), neckY = centerY - height / 2 + height - neckHeight, data = series.data, path, fraction, half = options.dataLabels.position === "left" ? 1 : 0, x1, y1, x2, x3, y3, x4, y5;
    function getLength(length, relativeTo) {
      return /%$/.test(length) ? relativeTo * parseInt(length, 10) / 100 : parseInt(length, 10);
    }
    series.getWidthAt = function(y) {
      var top = centerY - height / 2;
      return y > neckY || height === neckHeight ? neckWidth : neckWidth + (width - neckWidth) * (1 - (y - top) / (height - neckHeight));
    };
    series.getX = function(y, half2, point) {
      return centerX + (half2 ? -1 : 1) * (series.getWidthAt(reversed ? 2 * centerY - y : y) / 2 + point.labelDistance);
    };
    series.center = [centerX, centerY, height];
    series.centerX = centerX;
    data.forEach(function(point) {
      if (!ignoreHiddenPoint || point.visible !== false) {
        sum += point.y;
      }
    });
    data.forEach(function(point) {
      y5 = null;
      fraction = sum ? point.y / sum : 0;
      y1 = centerY - height / 2 + cumulative * height;
      y3 = y1 + fraction * height;
      tempWidth = series.getWidthAt(y1);
      x1 = centerX - tempWidth / 2;
      x2 = x1 + tempWidth;
      tempWidth = series.getWidthAt(y3);
      x3 = centerX - tempWidth / 2;
      x4 = x3 + tempWidth;
      if (y1 > neckY) {
        x1 = x3 = centerX - neckWidth / 2;
        x2 = x4 = centerX + neckWidth / 2;
      } else if (y3 > neckY) {
        y5 = y3;
        tempWidth = series.getWidthAt(neckY);
        x3 = centerX - tempWidth / 2;
        x4 = x3 + tempWidth;
        y3 = neckY;
      }
      if (reversed) {
        y1 = 2 * centerY - y1;
        y3 = 2 * centerY - y3;
        if (y5 !== null) {
          y5 = 2 * centerY - y5;
        }
      }
      path = [
        ["M", x1, y1],
        ["L", x2, y1],
        ["L", x4, y3]
      ];
      if (y5 !== null) {
        path.push(["L", x4, y5], ["L", x3, y5]);
      }
      path.push(["L", x3, y3], ["Z"]);
      point.shapeType = "path";
      point.shapeArgs = { d: path };
      point.percentage = fraction * 100;
      point.plotX = centerX;
      point.plotY = (y1 + (y5 || y3)) / 2;
      point.tooltipPos = [
        centerX,
        point.plotY
      ];
      point.dlBox = {
        x: x3,
        y: y1,
        topWidth: x2 - x1,
        bottomWidth: x4 - x3,
        height: Math.abs(pick80(y5, y3) - y1),
        width: NaN
      };
      point.slice = noop19;
      point.half = half;
      if (!ignoreHiddenPoint || point.visible !== false) {
        cumulative += fraction;
      }
    });
    fireEvent31(series, "afterTranslate");
  };
  FunnelSeries2.prototype.sortByAngle = function(points) {
    points.sort(function(a, b) {
      return a.plotY - b.plotY;
    });
  };
  FunnelSeries2.defaultOptions = merge69(PieSeries4.defaultOptions, {
    animation: false,
    center: ["50%", "50%"],
    width: "90%",
    neckWidth: "30%",
    height: "100%",
    neckHeight: "25%",
    reversed: false,
    size: true,
    dataLabels: {
      connectorWidth: 1,
      verticalAlign: "middle"
    },
    states: {
      select: {
        color: Palette_default.neutralColor20,
        borderColor: Palette_default.neutralColor100
      }
    }
  });
  return FunnelSeries2;
}(PieSeries4);
extend70(FunnelSeries.prototype, {
  animate: noop19
});
addEvent55(Chart_default, "afterHideAllOverlappingLabels", function() {
  this.series.forEach(function(series) {
    var dataLabelsOptions = series.options && series.options.dataLabels;
    if (isArray20(dataLabelsOptions)) {
      dataLabelsOptions = dataLabelsOptions[0];
    }
    if (series.is("pie") && series.placeDataLabels && dataLabelsOptions && !dataLabelsOptions.inside) {
      series.placeDataLabels();
    }
  });
});
SeriesRegistry_default.registerSeriesType("funnel", FunnelSeries);
var FunnelSeries_default = FunnelSeries;

// node_modules/highcharts/es-modules/Series/Pyramid/PyramidSeries.js
var __extends45 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var merge70 = Utilities_default.merge;
var PyramidSeries = function(_super) {
  __extends45(PyramidSeries2, _super);
  function PyramidSeries2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.data = void 0;
    _this.options = void 0;
    _this.points = void 0;
    return _this;
  }
  PyramidSeries2.defaultOptions = merge70(FunnelSeries_default.defaultOptions, {
    neckWidth: "0%",
    neckHeight: "0%",
    reversed: true
  });
  return PyramidSeries2;
}(FunnelSeries_default);
SeriesRegistry_default.registerSeriesType("pyramid", PyramidSeries);

// node_modules/highcharts/es-modules/Mixins/ColorSeries.js
var colorPointMixin = {
  setVisible: function(vis) {
    var point = this, method = vis ? "show" : "hide";
    point.visible = point.options.visible = Boolean(vis);
    ["graphic", "dataLabel"].forEach(function(key) {
      if (point[key]) {
        point[key][method]();
      }
    });
    this.series.buildKDTree();
  }
};
var colorSeriesMixin = {
  optionalAxis: "colorAxis",
  translateColors: function() {
    var series = this, points = this.data.length ? this.data : this.points, nullColor = this.options.nullColor, colorAxis = this.colorAxis, colorKey = this.colorKey;
    points.forEach(function(point) {
      var value = point.getNestedProperty(colorKey), color18;
      color18 = point.options.color || (point.isNull || point.value === null ? nullColor : colorAxis && typeof value !== "undefined" ? colorAxis.toColor(value, point) : point.color || series.color);
      if (color18 && point.color !== color18) {
        point.color = color18;
        if (series.options.legendType === "point" && point.legendItem) {
          series.chart.legend.colorizeItem(point, point.visible);
        }
      }
    });
  }
};
var exports3 = {
  colorPointMixin,
  colorSeriesMixin
};
var ColorSeries_default = exports3;

// node_modules/highcharts/es-modules/Core/Axis/Color/ColorAxisComposition.js
var color13 = Color_default.parse;
var colorPointMixin2 = ColorSeries_default.colorPointMixin;
var colorSeriesMixin2 = ColorSeries_default.colorSeriesMixin;
var addEvent56 = Utilities_default.addEvent;
var extend71 = Utilities_default.extend;
var merge71 = Utilities_default.merge;
var pick81 = Utilities_default.pick;
var splat18 = Utilities_default.splat;
var ColorAxisComposition;
(function(ColorAxisComposition2) {
  var composedClasses2 = [];
  var ColorAxisClass;
  function compose(ColorAxisType, ChartClass, FxClass, LegendClass, SeriesClass) {
    if (!ColorAxisClass) {
      ColorAxisClass = ColorAxisType;
    }
    if (composedClasses2.indexOf(ChartClass) === -1) {
      composedClasses2.push(ChartClass);
      var chartProto = ChartClass.prototype;
      chartProto.collectionsWithUpdate.push("colorAxis");
      chartProto.collectionsWithInit.colorAxis = [chartProto.addColorAxis];
      addEvent56(ChartClass, "afterGetAxes", onChartAfterGetAxes);
      wrapChartCreateAxis(ChartClass);
    }
    if (composedClasses2.indexOf(FxClass) === -1) {
      composedClasses2.push(FxClass);
      var fxProto = FxClass.prototype;
      fxProto.fillSetter = wrapFxFillSetter;
      fxProto.strokeSetter = wrapFxStrokeSetter;
    }
    if (composedClasses2.indexOf(LegendClass) === -1) {
      composedClasses2.push(LegendClass);
      addEvent56(LegendClass, "afterGetAllItems", onLegendAfterGetAllItems);
      addEvent56(LegendClass, "afterColorizeItem", onLegendAfterColorizeItem);
      addEvent56(LegendClass, "afterUpdate", onLegendAfterUpdate);
    }
    if (composedClasses2.indexOf(SeriesClass) === -1) {
      composedClasses2.push(SeriesClass);
      extend71(SeriesClass.prototype, colorSeriesMixin2);
      extend71(SeriesClass.prototype.pointClass.prototype, colorPointMixin2);
      addEvent56(SeriesClass, "afterTranslate", onSeriesAfterTranslate);
      addEvent56(SeriesClass, "bindAxes", onSeriesBindAxes);
    }
  }
  ColorAxisComposition2.compose = compose;
  function onChartAfterGetAxes() {
    var _this = this;
    var options = this.options;
    this.colorAxis = [];
    if (options.colorAxis) {
      options.colorAxis = splat18(options.colorAxis);
      options.colorAxis.forEach(function(axisOptions, i) {
        axisOptions.index = i;
        new ColorAxisClass(_this, axisOptions);
      });
    }
  }
  function onLegendAfterGetAllItems(e2) {
    var _this = this;
    var colorAxes = this.chart.colorAxis || [], destroyItem = function(item) {
      var i2 = e2.allItems.indexOf(item);
      if (i2 !== -1) {
        _this.destroyItem(e2.allItems[i2]);
        e2.allItems.splice(i2, 1);
      }
    };
    var colorAxisItems = [], options, i;
    colorAxes.forEach(function(colorAxis) {
      options = colorAxis.options;
      if (options && options.showInLegend) {
        if (options.dataClasses && options.visible) {
          colorAxisItems = colorAxisItems.concat(colorAxis.getDataClassLegendSymbols());
        } else if (options.visible) {
          colorAxisItems.push(colorAxis);
        }
        colorAxis.series.forEach(function(series) {
          if (!series.options.showInLegend || options.dataClasses) {
            if (series.options.legendType === "point") {
              series.points.forEach(function(point) {
                destroyItem(point);
              });
            } else {
              destroyItem(series);
            }
          }
        });
      }
    });
    i = colorAxisItems.length;
    while (i--) {
      e2.allItems.unshift(colorAxisItems[i]);
    }
  }
  function onLegendAfterColorizeItem(e2) {
    if (e2.visible && e2.item.legendColor) {
      e2.item.legendSymbol.attr({
        fill: e2.item.legendColor
      });
    }
  }
  function onLegendAfterUpdate() {
    var colorAxes = this.chart.colorAxis;
    if (colorAxes) {
      colorAxes.forEach(function(colorAxis) {
        colorAxis.update({}, arguments[2]);
      });
    }
  }
  function onSeriesAfterTranslate() {
    if (this.chart.colorAxis && this.chart.colorAxis.length || this.colorAttribs) {
      this.translateColors();
    }
  }
  function onSeriesBindAxes() {
    var axisTypes = this.axisTypes;
    if (!axisTypes) {
      this.axisTypes = ["colorAxis"];
    } else if (axisTypes.indexOf("colorAxis") === -1) {
      axisTypes.push("colorAxis");
    }
  }
  function wrapChartCreateAxis(ChartClass) {
    var superCreateAxis = ChartClass.prototype.createAxis;
    ChartClass.prototype.createAxis = function(type, options) {
      if (type !== "colorAxis") {
        return superCreateAxis.apply(this, arguments);
      }
      var axis = new ColorAxisClass(this, merge71(options.axis, {
        index: this[type].length,
        isX: false
      }));
      this.isDirtyLegend = true;
      this.axes.forEach(function(axis2) {
        axis2.series = [];
      });
      this.series.forEach(function(series) {
        series.bindAxes();
        series.isDirtyData = true;
      });
      if (pick81(options.redraw, true)) {
        this.redraw(options.animation);
      }
      return axis;
    };
  }
  function wrapFxFillSetter() {
    this.elem.attr("fill", color13(this.start).tweenTo(color13(this.end), this.pos), void 0, true);
  }
  function wrapFxStrokeSetter() {
    this.elem.attr("stroke", color13(this.start).tweenTo(color13(this.end), this.pos), void 0, true);
  }
})(ColorAxisComposition || (ColorAxisComposition = {}));
var ColorAxisComposition_default = ColorAxisComposition;

// node_modules/highcharts/es-modules/Core/Axis/Color/ColorAxisDefaults.js
var colorAxisDefaults = {
  lineWidth: 0,
  minPadding: 0,
  maxPadding: 0,
  gridLineWidth: 1,
  tickPixelInterval: 72,
  startOnTick: true,
  endOnTick: true,
  offset: 0,
  marker: {
    animation: {
      duration: 50
    },
    width: 0.01,
    color: Palette_default.neutralColor40
  },
  labels: {
    overflow: "justify",
    rotation: 0
  },
  minColor: Palette_default.highlightColor10,
  maxColor: Palette_default.highlightColor100,
  tickLength: 5,
  showInLegend: true
};
var ColorAxisDefaults_default = colorAxisDefaults;

// node_modules/highcharts/es-modules/Core/Axis/Color/ColorAxis.js
var __extends46 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var color14 = Color_default.parse;
var noop20 = Globals_default.noop;
var Series9 = SeriesRegistry_default.series;
var extend72 = Utilities_default.extend;
var isNumber45 = Utilities_default.isNumber;
var merge72 = Utilities_default.merge;
var pick82 = Utilities_default.pick;
var ColorAxis = function(_super) {
  __extends46(ColorAxis2, _super);
  function ColorAxis2(chart, userOptions) {
    var _this = _super.call(this, chart, userOptions) || this;
    _this.beforePadding = false;
    _this.chart = void 0;
    _this.coll = "colorAxis";
    _this.dataClasses = void 0;
    _this.legendItem = void 0;
    _this.legendItems = void 0;
    _this.name = "";
    _this.options = void 0;
    _this.stops = void 0;
    _this.visible = true;
    _this.init(chart, userOptions);
    return _this;
  }
  ColorAxis2.compose = function(ChartClass, FxClass, LegendClass, SeriesClass) {
    ColorAxisComposition_default.compose(ColorAxis2, ChartClass, FxClass, LegendClass, SeriesClass);
  };
  ColorAxis2.prototype.init = function(chart, userOptions) {
    var axis = this;
    var legend = chart.options.legend || {}, horiz = userOptions.layout ? userOptions.layout !== "vertical" : legend.layout !== "vertical", visible = userOptions.visible;
    var options = merge72(ColorAxis2.defaultColorAxisOptions, userOptions, {
      showEmpty: false,
      title: null,
      visible: legend.enabled && visible !== false
    });
    axis.coll = "colorAxis";
    axis.side = userOptions.side || horiz ? 2 : 1;
    axis.reversed = userOptions.reversed || !horiz;
    axis.opposite = !horiz;
    _super.prototype.init.call(this, chart, options);
    axis.userOptions.visible = visible;
    if (userOptions.dataClasses) {
      axis.initDataClasses(userOptions);
    }
    axis.initStops();
    axis.horiz = horiz;
    axis.zoomEnabled = false;
  };
  ColorAxis2.prototype.initDataClasses = function(userOptions) {
    var axis = this, chart = axis.chart, options = axis.options, len = userOptions.dataClasses.length;
    var dataClasses, colorCounter = 0, colorCount = chart.options.chart.colorCount;
    axis.dataClasses = dataClasses = [];
    axis.legendItems = [];
    (userOptions.dataClasses || []).forEach(function(dataClass, i) {
      var colors;
      dataClass = merge72(dataClass);
      dataClasses.push(dataClass);
      if (!chart.styledMode && dataClass.color) {
        return;
      }
      if (options.dataClassColor === "category") {
        if (!chart.styledMode) {
          colors = chart.options.colors;
          colorCount = colors.length;
          dataClass.color = colors[colorCounter];
        }
        dataClass.colorIndex = colorCounter;
        colorCounter++;
        if (colorCounter === colorCount) {
          colorCounter = 0;
        }
      } else {
        dataClass.color = color14(options.minColor).tweenTo(color14(options.maxColor), len < 2 ? 0.5 : i / (len - 1));
      }
    });
  };
  ColorAxis2.prototype.hasData = function() {
    return !!(this.tickPositions || []).length;
  };
  ColorAxis2.prototype.setTickPositions = function() {
    if (!this.dataClasses) {
      return _super.prototype.setTickPositions.call(this);
    }
  };
  ColorAxis2.prototype.initStops = function() {
    var axis = this;
    axis.stops = axis.options.stops || [
      [0, axis.options.minColor],
      [1, axis.options.maxColor]
    ];
    axis.stops.forEach(function(stop4) {
      stop4.color = color14(stop4[1]);
    });
  };
  ColorAxis2.prototype.setOptions = function(userOptions) {
    var axis = this;
    _super.prototype.setOptions.call(this, userOptions);
    axis.options.crosshair = axis.options.marker;
  };
  ColorAxis2.prototype.setAxisSize = function() {
    var axis = this;
    var symbol = axis.legendSymbol;
    var chart = axis.chart;
    var legendOptions = chart.options.legend || {};
    var x, y, width, height;
    if (symbol) {
      this.left = x = symbol.attr("x");
      this.top = y = symbol.attr("y");
      this.width = width = symbol.attr("width");
      this.height = height = symbol.attr("height");
      this.right = chart.chartWidth - x - width;
      this.bottom = chart.chartHeight - y - height;
      this.len = this.horiz ? width : height;
      this.pos = this.horiz ? x : y;
    } else {
      this.len = (this.horiz ? legendOptions.symbolWidth : legendOptions.symbolHeight) || ColorAxis2.defaultLegendLength;
    }
  };
  ColorAxis2.prototype.normalizedValue = function(value) {
    var axis = this;
    if (axis.logarithmic) {
      value = axis.logarithmic.log2lin(value);
    }
    return 1 - (axis.max - value) / (axis.max - axis.min || 1);
  };
  ColorAxis2.prototype.toColor = function(value, point) {
    var axis = this;
    var dataClasses = axis.dataClasses;
    var stops = axis.stops;
    var pos, from, to, color18, dataClass, i;
    if (dataClasses) {
      i = dataClasses.length;
      while (i--) {
        dataClass = dataClasses[i];
        from = dataClass.from;
        to = dataClass.to;
        if ((typeof from === "undefined" || value >= from) && (typeof to === "undefined" || value <= to)) {
          color18 = dataClass.color;
          if (point) {
            point.dataClass = i;
            point.colorIndex = dataClass.colorIndex;
          }
          break;
        }
      }
    } else {
      pos = axis.normalizedValue(value);
      i = stops.length;
      while (i--) {
        if (pos > stops[i][0]) {
          break;
        }
      }
      from = stops[i] || stops[i + 1];
      to = stops[i + 1] || from;
      pos = 1 - (to[0] - pos) / (to[0] - from[0] || 1);
      color18 = from.color.tweenTo(to.color, pos);
    }
    return color18;
  };
  ColorAxis2.prototype.getOffset = function() {
    var axis = this;
    var group = axis.legendGroup;
    var sideOffset = axis.chart.axisOffset[axis.side];
    if (group) {
      axis.axisParent = group;
      _super.prototype.getOffset.call(this);
      if (!axis.added) {
        axis.added = true;
        axis.labelLeft = 0;
        axis.labelRight = axis.width;
      }
      axis.chart.axisOffset[axis.side] = sideOffset;
    }
  };
  ColorAxis2.prototype.setLegendColor = function() {
    var axis = this;
    var horiz = axis.horiz;
    var reversed = axis.reversed;
    var one = reversed ? 1 : 0;
    var zero = reversed ? 0 : 1;
    var grad = horiz ? [one, 0, zero, 0] : [0, zero, 0, one];
    axis.legendColor = {
      linearGradient: {
        x1: grad[0],
        y1: grad[1],
        x2: grad[2],
        y2: grad[3]
      },
      stops: axis.stops
    };
  };
  ColorAxis2.prototype.drawLegendSymbol = function(legend, item) {
    var axis = this;
    var padding = legend.padding;
    var legendOptions = legend.options;
    var horiz = axis.horiz;
    var width = pick82(legendOptions.symbolWidth, horiz ? ColorAxis2.defaultLegendLength : 12);
    var height = pick82(legendOptions.symbolHeight, horiz ? 12 : ColorAxis2.defaultLegendLength);
    var labelPadding = pick82(legendOptions.labelPadding, horiz ? 16 : 30);
    var itemDistance = pick82(legendOptions.itemDistance, 10);
    this.setLegendColor();
    item.legendSymbol = this.chart.renderer.rect(0, legend.baseline - 11, width, height).attr({
      zIndex: 1
    }).add(item.legendGroup);
    axis.legendItemWidth = width + padding + (horiz ? itemDistance : labelPadding);
    axis.legendItemHeight = height + padding + (horiz ? labelPadding : 0);
  };
  ColorAxis2.prototype.setState = function(state) {
    this.series.forEach(function(series) {
      series.setState(state);
    });
  };
  ColorAxis2.prototype.setVisible = function() {
  };
  ColorAxis2.prototype.getSeriesExtremes = function() {
    var axis = this;
    var series = axis.series;
    var colorValArray, colorKey, colorValIndex, pointArrayMap, calculatedExtremes, cSeries, i = series.length, yData, j;
    this.dataMin = Infinity;
    this.dataMax = -Infinity;
    while (i--) {
      cSeries = series[i];
      colorKey = cSeries.colorKey = pick82(cSeries.options.colorKey, cSeries.colorKey, cSeries.pointValKey, cSeries.zoneAxis, "y");
      pointArrayMap = cSeries.pointArrayMap;
      calculatedExtremes = cSeries[colorKey + "Min"] && cSeries[colorKey + "Max"];
      if (cSeries[colorKey + "Data"]) {
        colorValArray = cSeries[colorKey + "Data"];
      } else {
        if (!pointArrayMap) {
          colorValArray = cSeries.yData;
        } else {
          colorValArray = [];
          colorValIndex = pointArrayMap.indexOf(colorKey);
          yData = cSeries.yData;
          if (colorValIndex >= 0 && yData) {
            for (j = 0; j < yData.length; j++) {
              colorValArray.push(pick82(yData[j][colorValIndex], yData[j]));
            }
          }
        }
      }
      if (calculatedExtremes) {
        cSeries.minColorValue = cSeries[colorKey + "Min"];
        cSeries.maxColorValue = cSeries[colorKey + "Max"];
      } else {
        var cExtremes = Series9.prototype.getExtremes.call(cSeries, colorValArray);
        cSeries.minColorValue = cExtremes.dataMin;
        cSeries.maxColorValue = cExtremes.dataMax;
      }
      if (typeof cSeries.minColorValue !== "undefined") {
        this.dataMin = Math.min(this.dataMin, cSeries.minColorValue);
        this.dataMax = Math.max(this.dataMax, cSeries.maxColorValue);
      }
      if (!calculatedExtremes) {
        Series9.prototype.applyExtremes.call(cSeries);
      }
    }
  };
  ColorAxis2.prototype.drawCrosshair = function(e2, point) {
    var axis = this;
    var plotX = point && point.plotX;
    var plotY = point && point.plotY;
    var axisPos = axis.pos;
    var axisLen = axis.len;
    var crossPos;
    if (point) {
      crossPos = axis.toPixels(point.getNestedProperty(point.series.colorKey));
      if (crossPos < axisPos) {
        crossPos = axisPos - 2;
      } else if (crossPos > axisPos + axisLen) {
        crossPos = axisPos + axisLen + 2;
      }
      point.plotX = crossPos;
      point.plotY = axis.len - crossPos;
      _super.prototype.drawCrosshair.call(this, e2, point);
      point.plotX = plotX;
      point.plotY = plotY;
      if (axis.cross && !axis.cross.addedToColorAxis && axis.legendGroup) {
        axis.cross.addClass("highcharts-coloraxis-marker").add(axis.legendGroup);
        axis.cross.addedToColorAxis = true;
        if (!axis.chart.styledMode && typeof axis.crosshair === "object") {
          axis.cross.attr({
            fill: axis.crosshair.color
          });
        }
      }
    }
  };
  ColorAxis2.prototype.getPlotLinePath = function(options) {
    var axis = this, left = axis.left, pos = options.translatedValue, top = axis.top;
    return isNumber45(pos) ? axis.horiz ? [
      ["M", pos - 4, top - 6],
      ["L", pos + 4, top - 6],
      ["L", pos, top],
      ["Z"]
    ] : [
      ["M", left, pos],
      ["L", left - 6, pos + 6],
      ["L", left - 6, pos - 6],
      ["Z"]
    ] : _super.prototype.getPlotLinePath.call(this, options);
  };
  ColorAxis2.prototype.update = function(newOptions, redraw) {
    var axis = this, chart = axis.chart, legend = chart.legend;
    this.series.forEach(function(series) {
      series.isDirtyData = true;
    });
    if (newOptions.dataClasses && legend.allItems || axis.dataClasses) {
      axis.destroyItems();
    }
    _super.prototype.update.call(this, newOptions, redraw);
    if (axis.legendItem) {
      axis.setLegendColor();
      legend.colorizeItem(this, true);
    }
  };
  ColorAxis2.prototype.destroyItems = function() {
    var axis = this;
    var chart = axis.chart;
    if (axis.legendItem) {
      chart.legend.destroyItem(axis);
    } else if (axis.legendItems) {
      axis.legendItems.forEach(function(item) {
        chart.legend.destroyItem(item);
      });
    }
    chart.isDirtyLegend = true;
  };
  ColorAxis2.prototype.destroy = function() {
    this.chart.isDirtyLegend = true;
    this.destroyItems();
    _super.prototype.destroy.apply(this, [].slice.call(arguments));
  };
  ColorAxis2.prototype.remove = function(redraw) {
    this.destroyItems();
    _super.prototype.remove.call(this, redraw);
  };
  ColorAxis2.prototype.getDataClassLegendSymbols = function() {
    var axis = this;
    var chart = axis.chart;
    var legendItems = axis.legendItems;
    var legendOptions = chart.options.legend;
    var valueDecimals = legendOptions.valueDecimals;
    var valueSuffix = legendOptions.valueSuffix || "";
    var name;
    if (!legendItems.length) {
      axis.dataClasses.forEach(function(dataClass, i) {
        var from = dataClass.from, to = dataClass.to, numberFormatter = chart.numberFormatter;
        var vis = true;
        name = "";
        if (typeof from === "undefined") {
          name = "< ";
        } else if (typeof to === "undefined") {
          name = "> ";
        }
        if (typeof from !== "undefined") {
          name += numberFormatter(from, valueDecimals) + valueSuffix;
        }
        if (typeof from !== "undefined" && typeof to !== "undefined") {
          name += " - ";
        }
        if (typeof to !== "undefined") {
          name += numberFormatter(to, valueDecimals) + valueSuffix;
        }
        legendItems.push(extend72({
          chart,
          name,
          options: {},
          drawLegendSymbol: LegendSymbol_default.drawRectangle,
          visible: true,
          setState: noop20,
          isDataClass: true,
          setVisible: function() {
            vis = axis.visible = !vis;
            axis.series.forEach(function(series) {
              series.points.forEach(function(point) {
                if (point.dataClass === i) {
                  point.setVisible(vis);
                }
              });
            });
            chart.legend.colorizeItem(this, vis);
          }
        }, dataClass));
      });
    }
    return legendItems;
  };
  ColorAxis2.defaultColorAxisOptions = ColorAxisDefaults_default;
  ColorAxis2.defaultLegendLength = 200;
  ColorAxis2.keepProps = [
    "legendGroup",
    "legendItemHeight",
    "legendItemWidth",
    "legendItem",
    "legendSymbol"
  ];
  return ColorAxis2;
}(Axis_default);
Array.prototype.push.apply(Axis_default.keepProps, ColorAxis.keepProps);
var ColorAxis_default = ColorAxis;

// node_modules/highcharts/es-modules/Mixins/ColorMapSeries.js
var defined48 = Utilities_default.defined;
var addEvent57 = Utilities_default.addEvent;
var noop21 = Globals_default.noop;
var seriesTypes8 = Globals_default.seriesTypes;
addEvent57(Point_default, "afterSetState", function(e2) {
  var point = this;
  if (point.moveToTopOnHover && point.graphic) {
    point.graphic.attr({
      zIndex: e2 && e2.state === "hover" ? 1 : 0
    });
  }
});
var colorMapPointMixin = {
  dataLabelOnNull: true,
  moveToTopOnHover: true,
  isValid: function() {
    return this.value !== null && this.value !== Infinity && this.value !== -Infinity;
  }
};
var colorMapSeriesMixin = {
  pointArrayMap: ["value"],
  axisTypes: ["xAxis", "yAxis", "colorAxis"],
  trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
  getSymbol: noop21,
  parallelArrays: ["x", "y", "value"],
  colorKey: "value",
  pointAttribs: seriesTypes8.column.prototype.pointAttribs,
  colorAttribs: function(point) {
    var ret = {};
    if (defined48(point.color) && (!point.state || point.state === "normal")) {
      ret[this.colorProp || "fill"] = point.color;
    }
    return ret;
  }
};
var exports4 = {
  colorMapPointMixin,
  colorMapSeriesMixin
};
var ColorMapSeries_default = exports4;

// node_modules/highcharts/es-modules/Series/Heatmap/HeatmapPoint.js
var __extends47 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var colorMapPointMixin2 = ColorMapSeries_default.colorMapPointMixin;
var ScatterPoint2 = SeriesRegistry_default.seriesTypes.scatter.prototype.pointClass;
var clamp18 = Utilities_default.clamp;
var extend73 = Utilities_default.extend;
var pick83 = Utilities_default.pick;
var HeatmapPoint = function(_super) {
  __extends47(HeatmapPoint2, _super);
  function HeatmapPoint2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.options = void 0;
    _this.series = void 0;
    _this.value = void 0;
    _this.x = void 0;
    _this.y = void 0;
    return _this;
  }
  HeatmapPoint2.prototype.applyOptions = function(options, x) {
    var point = _super.prototype.applyOptions.call(this, options, x);
    point.formatPrefix = point.isNull || point.value === null ? "null" : "point";
    return point;
  };
  HeatmapPoint2.prototype.getCellAttributes = function() {
    var point = this, series = point.series, seriesOptions = series.options, xPad = (seriesOptions.colsize || 1) / 2, yPad = (seriesOptions.rowsize || 1) / 2, xAxis = series.xAxis, yAxis = series.yAxis, markerOptions = point.options.marker || series.options.marker, pointPlacement = series.pointPlacementToXValue(), pointPadding = pick83(point.pointPadding, seriesOptions.pointPadding, 0), cellAttr = {
      x1: clamp18(Math.round(xAxis.len - (xAxis.translate(point.x - xPad, false, true, false, true, -pointPlacement) || 0)), -xAxis.len, 2 * xAxis.len),
      x2: clamp18(Math.round(xAxis.len - (xAxis.translate(point.x + xPad, false, true, false, true, -pointPlacement) || 0)), -xAxis.len, 2 * xAxis.len),
      y1: clamp18(Math.round(yAxis.translate(point.y - yPad, false, true, false, true) || 0), -yAxis.len, 2 * yAxis.len),
      y2: clamp18(Math.round(yAxis.translate(point.y + yPad, false, true, false, true) || 0), -yAxis.len, 2 * yAxis.len)
    };
    [["width", "x"], ["height", "y"]].forEach(function(dimension) {
      var prop = dimension[0], direction = dimension[1];
      var start = direction + "1", end = direction + "2";
      var side = Math.abs(cellAttr[start] - cellAttr[end]), borderWidth = markerOptions && markerOptions.lineWidth || 0, plotPos = Math.abs(cellAttr[start] + cellAttr[end]) / 2;
      if (markerOptions[prop] && markerOptions[prop] < side) {
        cellAttr[start] = plotPos - markerOptions[prop] / 2 - borderWidth / 2;
        cellAttr[end] = plotPos + markerOptions[prop] / 2 + borderWidth / 2;
      }
      if (pointPadding) {
        if (direction === "y") {
          start = end;
          end = direction + "1";
        }
        cellAttr[start] += pointPadding;
        cellAttr[end] -= pointPadding;
      }
    });
    return cellAttr;
  };
  HeatmapPoint2.prototype.haloPath = function(size) {
    if (!size) {
      return [];
    }
    var rect2 = this.shapeArgs;
    return [
      "M",
      rect2.x - size,
      rect2.y - size,
      "L",
      rect2.x - size,
      rect2.y + rect2.height + size,
      rect2.x + rect2.width + size,
      rect2.y + rect2.height + size,
      rect2.x + rect2.width + size,
      rect2.y - size,
      "Z"
    ];
  };
  HeatmapPoint2.prototype.isValid = function() {
    return this.value !== Infinity && this.value !== -Infinity;
  };
  return HeatmapPoint2;
}(ScatterPoint2);
extend73(HeatmapPoint.prototype, {
  dataLabelOnNull: colorMapPointMixin2.dataLabelOnNull,
  moveToTopOnHover: colorMapPointMixin2.moveToTopOnHover
});
var HeatmapPoint_default = HeatmapPoint;

// node_modules/highcharts/es-modules/Series/Heatmap/HeatmapSeries.js
var __extends48 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var colorMapSeriesMixin2 = ColorMapSeries_default.colorMapSeriesMixin;
var Series10 = SeriesRegistry_default.series;
var _a9 = SeriesRegistry_default.seriesTypes;
var ColumnSeries11 = _a9.column;
var ScatterSeries4 = _a9.scatter;
var symbols2 = SVGRenderer_default.prototype.symbols;
var extend74 = Utilities_default.extend;
var fireEvent32 = Utilities_default.fireEvent;
var isNumber46 = Utilities_default.isNumber;
var merge73 = Utilities_default.merge;
var pick84 = Utilities_default.pick;
var HeatmapSeries = function(_super) {
  __extends48(HeatmapSeries3, _super);
  function HeatmapSeries3() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.colorAxis = void 0;
    _this.data = void 0;
    _this.options = void 0;
    _this.points = void 0;
    _this.valueMax = NaN;
    _this.valueMin = NaN;
    return _this;
  }
  HeatmapSeries3.prototype.drawPoints = function() {
    var _this = this;
    var seriesMarkerOptions = this.options.marker || {};
    if (seriesMarkerOptions.enabled || this._hasPointMarkers) {
      Series10.prototype.drawPoints.call(this);
      this.points.forEach(function(point) {
        if (point.graphic) {
          point.graphic[_this.chart.styledMode ? "css" : "animate"](_this.colorAttribs(point));
          if (_this.options.borderRadius) {
            point.graphic.attr({
              r: _this.options.borderRadius
            });
          }
          if (point.value === null) {
            point.graphic.addClass("highcharts-null-point");
          }
        }
      });
    }
  };
  HeatmapSeries3.prototype.getExtremes = function() {
    var _a15 = Series10.prototype.getExtremes.call(this, this.valueData), dataMin = _a15.dataMin, dataMax = _a15.dataMax;
    if (isNumber46(dataMin)) {
      this.valueMin = dataMin;
    }
    if (isNumber46(dataMax)) {
      this.valueMax = dataMax;
    }
    return Series10.prototype.getExtremes.call(this);
  };
  HeatmapSeries3.prototype.getValidPoints = function(points, insideOnly) {
    return Series10.prototype.getValidPoints.call(this, points, insideOnly, true);
  };
  HeatmapSeries3.prototype.hasData = function() {
    return !!this.processedXData.length;
  };
  HeatmapSeries3.prototype.init = function() {
    var options;
    Series10.prototype.init.apply(this, arguments);
    options = this.options;
    options.pointRange = pick84(options.pointRange, options.colsize || 1);
    this.yAxis.axisPointRange = options.rowsize || 1;
    symbols2.ellipse = symbols2.circle;
  };
  HeatmapSeries3.prototype.markerAttribs = function(point, state) {
    var pointMarkerOptions = point.marker || {}, seriesMarkerOptions = this.options.marker || {}, seriesStateOptions, pointStateOptions, shapeArgs = point.shapeArgs || {}, hasImage = point.hasImage, attribs = {};
    if (hasImage) {
      return {
        x: point.plotX,
        y: point.plotY
      };
    }
    if (state) {
      seriesStateOptions = seriesMarkerOptions.states[state] || {};
      pointStateOptions = pointMarkerOptions.states && pointMarkerOptions.states[state] || {};
      [["width", "x"], ["height", "y"]].forEach(function(dimension) {
        attribs[dimension[0]] = (pointStateOptions[dimension[0]] || seriesStateOptions[dimension[0]] || shapeArgs[dimension[0]]) + (pointStateOptions[dimension[0] + "Plus"] || seriesStateOptions[dimension[0] + "Plus"] || 0);
        attribs[dimension[1]] = shapeArgs[dimension[1]] + (shapeArgs[dimension[0]] - attribs[dimension[0]]) / 2;
      });
    }
    return state ? attribs : shapeArgs;
  };
  HeatmapSeries3.prototype.pointAttribs = function(point, state) {
    var series = this, attr10 = Series10.prototype.pointAttribs.call(series, point, state), seriesOptions = series.options || {}, plotOptions = series.chart.options.plotOptions || {}, seriesPlotOptions = plotOptions.series || {}, heatmapPlotOptions = plotOptions.heatmap || {}, stateOptions, brightness, borderColor = point && point.options.borderColor || seriesOptions.borderColor || heatmapPlotOptions.borderColor || seriesPlotOptions.borderColor, borderWidth = point && point.options.borderWidth || seriesOptions.borderWidth || heatmapPlotOptions.borderWidth || seriesPlotOptions.borderWidth || attr10["stroke-width"];
    attr10.stroke = point && point.marker && point.marker.lineColor || seriesOptions.marker && seriesOptions.marker.lineColor || borderColor || this.color;
    attr10["stroke-width"] = borderWidth;
    if (state) {
      stateOptions = merge73(seriesOptions.states[state], seriesOptions.marker && seriesOptions.marker.states[state], point && point.options.states && point.options.states[state] || {});
      brightness = stateOptions.brightness;
      attr10.fill = stateOptions.color || Color_default.parse(attr10.fill).brighten(brightness || 0).get();
      attr10.stroke = stateOptions.lineColor;
    }
    return attr10;
  };
  HeatmapSeries3.prototype.setClip = function(animation) {
    var series = this, chart = series.chart;
    Series10.prototype.setClip.apply(series, arguments);
    if (series.options.clip !== false || animation) {
      series.markerGroup.clip((animation || series.clipBox) && series.sharedClipKey ? chart.sharedClips[series.sharedClipKey] : chart.clipRect);
    }
  };
  HeatmapSeries3.prototype.translate = function() {
    var series = this, options = series.options, symbol = options.marker && options.marker.symbol || "rect", shape = symbols2[symbol] ? symbol : "rect", hasRegularShape = ["circle", "square"].indexOf(shape) !== -1;
    series.generatePoints();
    series.points.forEach(function(point) {
      var pointAttr, sizeDiff, hasImage, cellAttr = point.getCellAttributes(), shapeArgs = {};
      shapeArgs.x = Math.min(cellAttr.x1, cellAttr.x2);
      shapeArgs.y = Math.min(cellAttr.y1, cellAttr.y2);
      shapeArgs.width = Math.max(Math.abs(cellAttr.x2 - cellAttr.x1), 0);
      shapeArgs.height = Math.max(Math.abs(cellAttr.y2 - cellAttr.y1), 0);
      hasImage = point.hasImage = (point.marker && point.marker.symbol || symbol || "").indexOf("url") === 0;
      if (hasRegularShape) {
        sizeDiff = Math.abs(shapeArgs.width - shapeArgs.height);
        shapeArgs.x = Math.min(cellAttr.x1, cellAttr.x2) + (shapeArgs.width < shapeArgs.height ? 0 : sizeDiff / 2);
        shapeArgs.y = Math.min(cellAttr.y1, cellAttr.y2) + (shapeArgs.width < shapeArgs.height ? sizeDiff / 2 : 0);
        shapeArgs.width = shapeArgs.height = Math.min(shapeArgs.width, shapeArgs.height);
      }
      pointAttr = {
        plotX: (cellAttr.x1 + cellAttr.x2) / 2,
        plotY: (cellAttr.y1 + cellAttr.y2) / 2,
        clientX: (cellAttr.x1 + cellAttr.x2) / 2,
        shapeType: "path",
        shapeArgs: merge73(true, shapeArgs, {
          d: symbols2[shape](shapeArgs.x, shapeArgs.y, shapeArgs.width, shapeArgs.height)
        })
      };
      if (hasImage) {
        point.marker = {
          width: shapeArgs.width,
          height: shapeArgs.height
        };
      }
      extend74(point, pointAttr);
    });
    fireEvent32(series, "afterTranslate");
  };
  HeatmapSeries3.defaultOptions = merge73(ScatterSeries4.defaultOptions, {
    animation: false,
    borderRadius: 0,
    borderWidth: 0,
    nullColor: Palette_default.neutralColor3,
    dataLabels: {
      formatter: function() {
        var numberFormatter = this.series.chart.numberFormatter;
        var value = this.point.value;
        return isNumber46(value) ? numberFormatter(value, -1) : "";
      },
      inside: true,
      verticalAlign: "middle",
      crop: false,
      overflow: false,
      padding: 0
    },
    marker: {
      symbol: "rect",
      radius: 0,
      lineColor: void 0,
      states: {
        hover: {
          lineWidthPlus: 0
        },
        select: {}
      }
    },
    clip: true,
    pointRange: null,
    tooltip: {
      pointFormat: "{point.x}, {point.y}: {point.value}<br/>"
    },
    states: {
      hover: {
        halo: false,
        brightness: 0.2
      }
    }
  });
  return HeatmapSeries3;
}(ScatterSeries4);
extend74(HeatmapSeries.prototype, {
  alignDataLabel: ColumnSeries11.prototype.alignDataLabel,
  axisTypes: colorMapSeriesMixin2.axisTypes,
  colorAttribs: colorMapSeriesMixin2.colorAttribs,
  colorKey: colorMapSeriesMixin2.colorKey,
  directTouch: true,
  drawLegendSymbol: LegendSymbol_default.drawRectangle,
  getExtremesFromAll: true,
  getSymbol: Series10.prototype.getSymbol,
  parallelArrays: colorMapSeriesMixin2.parallelArrays,
  pointArrayMap: ["y", "value"],
  pointClass: HeatmapPoint_default,
  trackerGroups: colorMapSeriesMixin2.trackerGroups
});
SeriesRegistry_default.registerSeriesType("heatmap", HeatmapSeries);

// node_modules/highcharts/es-modules/masters/modules/heatmap.src.js
var G8 = Globals_default;
G8.ColorAxis = ColorAxis_default;
ColorAxis_default.compose(G8.Chart, G8.Fx, G8.Legend, G8.Series);

// node_modules/highcharts/es-modules/Core/Axis/SolidGaugeAxis.js
var color15 = Color_default.parse;
var extend75 = Utilities_default.extend;
var merge74 = Utilities_default.merge;
var SolidGaugeAxis;
(function(SolidGaugeAxis2) {
  var methods = {
    initDataClasses: function(userOptions) {
      var chart = this.chart, dataClasses, colorCounter = 0, options = this.options;
      this.dataClasses = dataClasses = [];
      userOptions.dataClasses.forEach(function(dataClass, i) {
        var colors;
        dataClass = merge74(dataClass);
        dataClasses.push(dataClass);
        if (!dataClass.color) {
          if (options.dataClassColor === "category") {
            colors = chart.options.colors;
            dataClass.color = colors[colorCounter++];
            if (colorCounter === colors.length) {
              colorCounter = 0;
            }
          } else {
            dataClass.color = color15(options.minColor).tweenTo(color15(options.maxColor), i / (userOptions.dataClasses.length - 1));
          }
        }
      });
    },
    initStops: function(userOptions) {
      this.stops = userOptions.stops || [
        [0, this.options.minColor],
        [1, this.options.maxColor]
      ];
      this.stops.forEach(function(stop4) {
        stop4.color = color15(stop4[1]);
      });
    },
    toColor: function(value, point) {
      var pos, stops = this.stops, from, to, color18, dataClasses = this.dataClasses, dataClass, i;
      if (dataClasses) {
        i = dataClasses.length;
        while (i--) {
          dataClass = dataClasses[i];
          from = dataClass.from;
          to = dataClass.to;
          if ((typeof from === "undefined" || value >= from) && (typeof to === "undefined" || value <= to)) {
            color18 = dataClass.color;
            if (point) {
              point.dataClass = i;
            }
            break;
          }
        }
      } else {
        if (this.logarithmic) {
          value = this.val2lin(value);
        }
        pos = 1 - (this.max - value) / (this.max - this.min);
        i = stops.length;
        while (i--) {
          if (pos > stops[i][0]) {
            break;
          }
        }
        from = stops[i] || stops[i + 1];
        to = stops[i + 1] || from;
        pos = 1 - (to[0] - pos) / (to[0] - from[0] || 1);
        color18 = from.color.tweenTo(to.color, pos);
      }
      return color18;
    }
  };
  function init(axis) {
    extend75(axis, methods);
  }
  SolidGaugeAxis2.init = init;
})(SolidGaugeAxis || (SolidGaugeAxis = {}));
var SolidGaugeAxis_default = SolidGaugeAxis;

// node_modules/highcharts/es-modules/Series/SolidGauge/SolidGaugeComposition.js
var _a10 = SVGRenderer_default.prototype;
var symbols3 = _a10.symbols;
var arc2 = _a10.symbols.arc;
symbols3.arc = function(x, y, w2, h, options) {
  var path = arc2(x, y, w2, h, options);
  if (options && options.rounded) {
    var r = options.r || w2, smallR = (r - (options.innerR || 0)) / 2, outerArcStart = path[0], innerArcStart = path[2];
    if (outerArcStart[0] === "M" && innerArcStart[0] === "L") {
      var x1 = outerArcStart[1], y1 = outerArcStart[2], x2 = innerArcStart[1], y2 = innerArcStart[2], roundStart = ["A", smallR, smallR, 0, 1, 1, x1, y1], roundEnd = ["A", smallR, smallR, 0, 1, 1, x2, y2];
      path[2] = roundEnd;
      path[4] = roundStart;
    }
  }
  return path;
};

// node_modules/highcharts/es-modules/Series/SolidGauge/SolidGaugeSeries.js
var __extends49 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var _a11 = SeriesRegistry_default.seriesTypes;
var GaugeSeries2 = _a11.gauge;
var pieProto = _a11.pie.prototype;
var clamp19 = Utilities_default.clamp;
var extend76 = Utilities_default.extend;
var isNumber47 = Utilities_default.isNumber;
var merge75 = Utilities_default.merge;
var pick85 = Utilities_default.pick;
var pInt11 = Utilities_default.pInt;
var solidGaugeOptions = {
  colorByPoint: true,
  dataLabels: {
    y: 0
  }
};
var SolidGaugeSeries = function(_super) {
  __extends49(SolidGaugeSeries2, _super);
  function SolidGaugeSeries2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.data = void 0;
    _this.points = void 0;
    _this.options = void 0;
    _this.axis = void 0;
    _this.yAxis = void 0;
    _this.startAngleRad = void 0;
    _this.thresholdAngleRad = void 0;
    return _this;
  }
  SolidGaugeSeries2.prototype.translate = function() {
    var axis = this.yAxis;
    SolidGaugeAxis_default.init(axis);
    if (!axis.dataClasses && axis.options.dataClasses) {
      axis.initDataClasses(axis.options);
    }
    axis.initStops(axis.options);
    GaugeSeries2.prototype.translate.call(this);
  };
  SolidGaugeSeries2.prototype.drawPoints = function() {
    var series = this, yAxis = series.yAxis, center = yAxis.center, options = series.options, renderer = series.chart.renderer, overshoot = options.overshoot, overshootVal = isNumber47(overshoot) ? overshoot / 180 * Math.PI : 0, thresholdAngleRad;
    if (isNumber47(options.threshold)) {
      thresholdAngleRad = yAxis.startAngleRad + yAxis.translate(options.threshold, null, null, null, true);
    }
    this.thresholdAngleRad = pick85(thresholdAngleRad, yAxis.startAngleRad);
    series.points.forEach(function(point) {
      if (!point.isNull) {
        var graphic = point.graphic, rotation = yAxis.startAngleRad + yAxis.translate(point.y, null, null, null, true), radius = pInt11(pick85(point.options.radius, options.radius, 100)) * center[2] / 200, innerRadius = pInt11(pick85(point.options.innerRadius, options.innerRadius, 60)) * center[2] / 200, shapeArgs = void 0, d = void 0, toColor = yAxis.toColor(point.y, point), axisMinAngle = Math.min(yAxis.startAngleRad, yAxis.endAngleRad), axisMaxAngle = Math.max(yAxis.startAngleRad, yAxis.endAngleRad), minAngle = void 0, maxAngle = void 0;
        if (toColor === "none") {
          toColor = point.color || series.color || "none";
        }
        if (toColor !== "none") {
          point.color = toColor;
        }
        rotation = clamp19(rotation, axisMinAngle - overshootVal, axisMaxAngle + overshootVal);
        if (options.wrap === false) {
          rotation = clamp19(rotation, axisMinAngle, axisMaxAngle);
        }
        minAngle = Math.min(rotation, series.thresholdAngleRad);
        maxAngle = Math.max(rotation, series.thresholdAngleRad);
        if (maxAngle - minAngle > 2 * Math.PI) {
          maxAngle = minAngle + 2 * Math.PI;
        }
        point.shapeArgs = shapeArgs = {
          x: center[0],
          y: center[1],
          r: radius,
          innerR: innerRadius,
          start: minAngle,
          end: maxAngle,
          rounded: options.rounded
        };
        point.startR = radius;
        if (graphic) {
          d = shapeArgs.d;
          graphic.animate(extend76({ fill: toColor }, shapeArgs));
          if (d) {
            shapeArgs.d = d;
          }
        } else {
          point.graphic = graphic = renderer.arc(shapeArgs).attr({
            fill: toColor,
            "sweep-flag": 0
          }).add(series.group);
        }
        if (!series.chart.styledMode) {
          if (options.linecap !== "square") {
            graphic.attr({
              "stroke-linecap": "round",
              "stroke-linejoin": "round"
            });
          }
          graphic.attr({
            stroke: options.borderColor || "none",
            "stroke-width": options.borderWidth || 0
          });
        }
        if (graphic) {
          graphic.addClass(point.getClassName(), true);
        }
      }
    });
  };
  SolidGaugeSeries2.prototype.animate = function(init) {
    if (!init) {
      this.startAngleRad = this.thresholdAngleRad;
      pieProto.animate.call(this, init);
    }
  };
  SolidGaugeSeries2.defaultOptions = merge75(GaugeSeries2.defaultOptions, solidGaugeOptions);
  return SolidGaugeSeries2;
}(GaugeSeries2);
extend76(SolidGaugeSeries.prototype, {
  drawLegendSymbol: LegendSymbol_default.drawRectangle
});
SeriesRegistry_default.registerSeriesType("solidgauge", SolidGaugeSeries);

// node_modules/highcharts/es-modules/Series/Treemap/TreemapAlgorithmGroup.js
var TreemapAlgorithmGroup = function() {
  function TreemapAlgorithmGroup2(h, w2, d, p) {
    this.height = h;
    this.width = w2;
    this.plot = p;
    this.direction = d;
    this.startDirection = d;
    this.total = 0;
    this.nW = 0;
    this.lW = 0;
    this.nH = 0;
    this.lH = 0;
    this.elArr = [];
    this.lP = {
      total: 0,
      lH: 0,
      nH: 0,
      lW: 0,
      nW: 0,
      nR: 0,
      lR: 0,
      aspectRatio: function(w3, h2) {
        return Math.max(w3 / h2, h2 / w3);
      }
    };
  }
  TreemapAlgorithmGroup2.prototype.addElement = function(el) {
    this.lP.total = this.elArr[this.elArr.length - 1];
    this.total = this.total + el;
    if (this.direction === 0) {
      this.lW = this.nW;
      this.lP.lH = this.lP.total / this.lW;
      this.lP.lR = this.lP.aspectRatio(this.lW, this.lP.lH);
      this.nW = this.total / this.height;
      this.lP.nH = this.lP.total / this.nW;
      this.lP.nR = this.lP.aspectRatio(this.nW, this.lP.nH);
    } else {
      this.lH = this.nH;
      this.lP.lW = this.lP.total / this.lH;
      this.lP.lR = this.lP.aspectRatio(this.lP.lW, this.lH);
      this.nH = this.total / this.width;
      this.lP.nW = this.lP.total / this.nH;
      this.lP.nR = this.lP.aspectRatio(this.lP.nW, this.nH);
    }
    this.elArr.push(el);
  };
  TreemapAlgorithmGroup2.prototype.reset = function() {
    this.nW = 0;
    this.lW = 0;
    this.elArr = [];
    this.total = 0;
  };
  return TreemapAlgorithmGroup2;
}();
var TreemapAlgorithmGroup_default = TreemapAlgorithmGroup;

// node_modules/highcharts/es-modules/Mixins/DrawPoint.js
var isFn = function(x) {
  return typeof x === "function";
};
var draw = function draw2(params) {
  var _this = this;
  var animatableAttribs = params.animatableAttribs, onComplete = params.onComplete, css16 = params.css, renderer = params.renderer;
  var animation = this.series && this.series.chart.hasRendered ? void 0 : this.series && this.series.options.animation;
  var graphic = this.graphic;
  if (this.shouldDraw()) {
    if (!graphic) {
      this.graphic = graphic = renderer[params.shapeType](params.shapeArgs).add(params.group);
    }
    graphic.css(css16).attr(params.attribs).animate(animatableAttribs, params.isNew ? false : animation, onComplete);
  } else if (graphic) {
    var destroy_1 = function() {
      _this.graphic = graphic = graphic && graphic.destroy();
      if (isFn(onComplete)) {
        onComplete();
      }
    };
    if (Object.keys(animatableAttribs).length) {
      graphic.animate(animatableAttribs, void 0, function() {
        destroy_1();
      });
    } else {
      destroy_1();
    }
  }
};
var drawPoint = function drawPoint2(params) {
  var point = this, attribs = params.attribs = params.attribs || {};
  attribs["class"] = point.getClassName();
  draw.call(point, params);
};
var drawPointModule = {
  draw,
  drawPoint,
  isFn
};
var DrawPoint_default = drawPointModule;

// node_modules/highcharts/es-modules/Series/Treemap/TreemapPoint.js
var __extends50 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Point3 = SeriesRegistry_default.series.prototype.pointClass;
var _a12 = SeriesRegistry_default.seriesTypes;
var PiePoint3 = _a12.pie.prototype.pointClass;
var ScatterPoint3 = _a12.scatter.prototype.pointClass;
var extend77 = Utilities_default.extend;
var isNumber48 = Utilities_default.isNumber;
var pick86 = Utilities_default.pick;
var TreemapPoint = function(_super) {
  __extends50(TreemapPoint2, _super);
  function TreemapPoint2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.name = void 0;
    _this.node = void 0;
    _this.options = void 0;
    _this.series = void 0;
    _this.value = void 0;
    return _this;
  }
  TreemapPoint2.prototype.getClassName = function() {
    var className = Point3.prototype.getClassName.call(this), series = this.series, options = series.options;
    if (this.node.level <= series.nodeMap[series.rootNode].level) {
      className += " highcharts-above-level";
    } else if (!this.node.isLeaf && !pick86(options.interactByLeaf, !options.allowTraversingTree)) {
      className += " highcharts-internal-node-interactive";
    } else if (!this.node.isLeaf) {
      className += " highcharts-internal-node";
    }
    return className;
  };
  TreemapPoint2.prototype.isValid = function() {
    return Boolean(this.id || isNumber48(this.value));
  };
  TreemapPoint2.prototype.setState = function(state) {
    Point3.prototype.setState.call(this, state);
    if (this.graphic) {
      this.graphic.attr({
        zIndex: state === "hover" ? 1 : 0
      });
    }
  };
  TreemapPoint2.prototype.shouldDraw = function() {
    return isNumber48(this.plotY) && this.y !== null;
  };
  return TreemapPoint2;
}(ScatterPoint3);
extend77(TreemapPoint.prototype, {
  draw: DrawPoint_default.drawPoint,
  setVisible: PiePoint3.prototype.setVisible
});
var TreemapPoint_default = TreemapPoint;

// node_modules/highcharts/es-modules/Series/Treemap/TreemapUtilities.js
var objectEach34 = Utilities_default.objectEach;
var TreemapUtilities;
(function(TreemapUtilities2) {
  TreemapUtilities2.AXIS_MAX = 100;
  function isBoolean2(x) {
    return typeof x === "boolean";
  }
  TreemapUtilities2.isBoolean = isBoolean2;
  function eachObject(list, func, context) {
    context = context || this;
    objectEach34(list, function(val, key) {
      func.call(context, val, key, list);
    });
  }
  TreemapUtilities2.eachObject = eachObject;
  function recursive(item, func, context) {
    if (context === void 0) {
      context = this;
    }
    var next;
    next = func.call(context, item);
    if (next !== false) {
      recursive(next, func, context);
    }
  }
  TreemapUtilities2.recursive = recursive;
})(TreemapUtilities || (TreemapUtilities = {}));
var TreemapUtilities_default = TreemapUtilities;

// node_modules/highcharts/es-modules/Mixins/TreeSeries.js
var extend78 = Utilities_default.extend;
var isArray21 = Utilities_default.isArray;
var isNumber49 = Utilities_default.isNumber;
var isObject10 = Utilities_default.isObject;
var merge76 = Utilities_default.merge;
var pick87 = Utilities_default.pick;
var isBoolean = function(x) {
  return typeof x === "boolean";
};
var isFn2 = function(x) {
  return typeof x === "function";
};
var setTreeValues = function setTreeValues2(tree, options) {
  var before = options.before, idRoot = options.idRoot, mapIdToNode = options.mapIdToNode, nodeRoot = mapIdToNode[idRoot], levelIsConstant = isBoolean(options.levelIsConstant) ? options.levelIsConstant : true, points = options.points, point = points[tree.i], optionsPoint = point && point.options || {}, childrenTotal = 0, children = [], value;
  tree.levelDynamic = tree.level - (levelIsConstant ? 0 : nodeRoot.level);
  tree.name = pick87(point && point.name, "");
  tree.visible = idRoot === tree.id || (isBoolean(options.visible) ? options.visible : false);
  if (isFn2(before)) {
    tree = before(tree, options);
  }
  tree.children.forEach(function(child, i) {
    var newOptions = extend78({}, options);
    extend78(newOptions, {
      index: i,
      siblings: tree.children.length,
      visible: tree.visible
    });
    child = setTreeValues2(child, newOptions);
    children.push(child);
    if (child.visible) {
      childrenTotal += child.val;
    }
  });
  value = pick87(optionsPoint.value, childrenTotal);
  tree.visible = value >= 0 && (childrenTotal > 0 || tree.visible);
  tree.children = children;
  tree.childrenTotal = childrenTotal;
  tree.isLeaf = tree.visible && !childrenTotal;
  tree.val = value;
  return tree;
};
var getColor = function getColor2(node, options) {
  var index = options.index, mapOptionsToLevel = options.mapOptionsToLevel, parentColor = options.parentColor, parentColorIndex = options.parentColorIndex, series = options.series, colors = options.colors, siblings = options.siblings, points = series.points, getColorByPoint, chartOptionsChart = series.chart.options.chart, point, level, colorByPoint, colorIndexByPoint, color18, colorIndex;
  function variation(color19) {
    var colorVariation = level && level.colorVariation;
    if (colorVariation) {
      if (colorVariation.key === "brightness") {
        return Color_default.parse(color19).brighten(colorVariation.to * (index / siblings)).get();
      }
    }
    return color19;
  }
  if (node) {
    point = points[node.i];
    level = mapOptionsToLevel[node.level] || {};
    getColorByPoint = point && level.colorByPoint;
    if (getColorByPoint) {
      colorIndexByPoint = point.index % (colors ? colors.length : chartOptionsChart.colorCount);
      colorByPoint = colors && colors[colorIndexByPoint];
    }
    if (!series.chart.styledMode) {
      color18 = pick87(point && point.options.color, level && level.color, colorByPoint, parentColor && variation(parentColor), series.color);
    }
    colorIndex = pick87(point && point.options.colorIndex, level && level.colorIndex, colorIndexByPoint, parentColorIndex, options.colorIndex);
  }
  return {
    color: color18,
    colorIndex
  };
};
var getLevelOptions = function getLevelOptions2(params) {
  var result2 = null, defaults, converted, i, from, to, levels;
  if (isObject10(params)) {
    result2 = {};
    from = isNumber49(params.from) ? params.from : 1;
    levels = params.levels;
    converted = {};
    defaults = isObject10(params.defaults) ? params.defaults : {};
    if (isArray21(levels)) {
      converted = levels.reduce(function(obj, item) {
        var level, levelIsConstant, options;
        if (isObject10(item) && isNumber49(item.level)) {
          options = merge76({}, item);
          levelIsConstant = isBoolean(options.levelIsConstant) ? options.levelIsConstant : defaults.levelIsConstant;
          delete options.levelIsConstant;
          delete options.level;
          level = item.level + (levelIsConstant ? 0 : from - 1);
          if (isObject10(obj[level])) {
            extend78(obj[level], options);
          } else {
            obj[level] = options;
          }
        }
        return obj;
      }, {});
    }
    to = isNumber49(params.to) ? params.to : 1;
    for (i = 0; i <= to; i++) {
      result2[i] = merge76({}, defaults, isObject10(converted[i]) ? converted[i] : {});
    }
  }
  return result2;
};
var updateRootId = function(series) {
  var rootId, options;
  if (isObject10(series)) {
    options = isObject10(series.options) ? series.options : {};
    rootId = pick87(series.rootNode, options.rootId, "");
    if (isObject10(series.userOptions)) {
      series.userOptions.rootId = rootId;
    }
    series.rootNode = rootId;
  }
  return rootId;
};
var result = {
  getColor,
  getLevelOptions,
  setTreeValues,
  updateRootId
};
var TreeSeries_default = result;

// node_modules/highcharts/es-modules/Series/Treemap/TreemapComposition.js
var Series11 = SeriesRegistry_default.series;
var addEvent58 = Utilities_default.addEvent;
var extend79 = Utilities_default.extend;
var treemapAxisDefaultValues = false;
addEvent58(Series11, "afterBindAxes", function() {
  var series = this, xAxis = series.xAxis, yAxis = series.yAxis, treeAxis;
  if (xAxis && yAxis) {
    if (series.is("treemap")) {
      treeAxis = {
        endOnTick: false,
        gridLineWidth: 0,
        lineWidth: 0,
        min: 0,
        minPadding: 0,
        max: TreemapUtilities_default.AXIS_MAX,
        maxPadding: 0,
        startOnTick: false,
        title: void 0,
        tickPositions: []
      };
      extend79(yAxis.options, treeAxis);
      extend79(xAxis.options, treeAxis);
      treemapAxisDefaultValues = true;
    } else if (treemapAxisDefaultValues) {
      yAxis.setOptions(yAxis.userOptions);
      xAxis.setOptions(xAxis.userOptions);
      treemapAxisDefaultValues = false;
    }
  }
});

// node_modules/highcharts/es-modules/Series/Treemap/TreemapSeries.js
var __extends51 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var color16 = Color_default.parse;
var colorMapSeriesMixin3 = ColorMapSeries_default.colorMapSeriesMixin;
var noop22 = Globals_default.noop;
var Series12 = SeriesRegistry_default.series;
var _a13 = SeriesRegistry_default.seriesTypes;
var ColumnSeries12 = _a13.column;
var HeatmapSeries2 = _a13.heatmap;
var ScatterSeries5 = _a13.scatter;
var getColor3 = TreeSeries_default.getColor;
var getLevelOptions3 = TreeSeries_default.getLevelOptions;
var updateRootId2 = TreeSeries_default.updateRootId;
var addEvent59 = Utilities_default.addEvent;
var correctFloat13 = Utilities_default.correctFloat;
var defined49 = Utilities_default.defined;
var error11 = Utilities_default.error;
var extend80 = Utilities_default.extend;
var fireEvent33 = Utilities_default.fireEvent;
var isArray22 = Utilities_default.isArray;
var isObject11 = Utilities_default.isObject;
var isString11 = Utilities_default.isString;
var merge77 = Utilities_default.merge;
var pick88 = Utilities_default.pick;
var stableSort6 = Utilities_default.stableSort;
var TreemapSeries = function(_super) {
  __extends51(TreemapSeries2, _super);
  function TreemapSeries2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.axisRatio = void 0;
    _this.data = void 0;
    _this.mapOptionsToLevel = void 0;
    _this.nodeMap = void 0;
    _this.options = void 0;
    _this.points = void 0;
    _this.rootNode = void 0;
    _this.tree = void 0;
    return _this;
  }
  TreemapSeries2.prototype.algorithmCalcPoints = function(directionChange, last, group, childrenArea) {
    var pX, pY, pW, pH, gW = group.lW, gH = group.lH, plot = group.plot, keep, i = 0, end = group.elArr.length - 1;
    if (last) {
      gW = group.nW;
      gH = group.nH;
    } else {
      keep = group.elArr[group.elArr.length - 1];
    }
    group.elArr.forEach(function(p) {
      if (last || i < end) {
        if (group.direction === 0) {
          pX = plot.x;
          pY = plot.y;
          pW = gW;
          pH = p / pW;
        } else {
          pX = plot.x;
          pY = plot.y;
          pH = gH;
          pW = p / pH;
        }
        childrenArea.push({
          x: pX,
          y: pY,
          width: pW,
          height: correctFloat13(pH)
        });
        if (group.direction === 0) {
          plot.y = plot.y + pH;
        } else {
          plot.x = plot.x + pW;
        }
      }
      i = i + 1;
    });
    group.reset();
    if (group.direction === 0) {
      group.width = group.width - gW;
    } else {
      group.height = group.height - gH;
    }
    plot.y = plot.parent.y + (plot.parent.height - group.height);
    plot.x = plot.parent.x + (plot.parent.width - group.width);
    if (directionChange) {
      group.direction = 1 - group.direction;
    }
    if (!last) {
      group.addElement(keep);
    }
  };
  TreemapSeries2.prototype.algorithmFill = function(directionChange, parent, children) {
    var childrenArea = [], pTot, direction = parent.direction, x = parent.x, y = parent.y, width = parent.width, height = parent.height, pX, pY, pW, pH;
    children.forEach(function(child) {
      pTot = parent.width * parent.height * (child.val / parent.val);
      pX = x;
      pY = y;
      if (direction === 0) {
        pH = height;
        pW = pTot / pH;
        width = width - pW;
        x = x + pW;
      } else {
        pW = width;
        pH = pTot / pW;
        height = height - pH;
        y = y + pH;
      }
      childrenArea.push({
        x: pX,
        y: pY,
        width: pW,
        height: pH
      });
      if (directionChange) {
        direction = 1 - direction;
      }
    });
    return childrenArea;
  };
  TreemapSeries2.prototype.algorithmLowAspectRatio = function(directionChange, parent, children) {
    var childrenArea = [], series = this, pTot, plot = {
      x: parent.x,
      y: parent.y,
      parent
    }, direction = parent.direction, i = 0, end = children.length - 1, group = new TreemapAlgorithmGroup_default(parent.height, parent.width, direction, plot);
    children.forEach(function(child) {
      pTot = parent.width * parent.height * (child.val / parent.val);
      group.addElement(pTot);
      if (group.lP.nR > group.lP.lR) {
        series.algorithmCalcPoints(directionChange, false, group, childrenArea, plot);
      }
      if (i === end) {
        series.algorithmCalcPoints(directionChange, true, group, childrenArea, plot);
      }
      i = i + 1;
    });
    return childrenArea;
  };
  TreemapSeries2.prototype.alignDataLabel = function(point, dataLabel, labelOptions) {
    var style = labelOptions.style;
    if (style && !defined49(style.textOverflow) && dataLabel.text && dataLabel.getBBox().width > dataLabel.text.textWidth) {
      dataLabel.css({
        textOverflow: "ellipsis",
        width: style.width += "px"
      });
    }
    ColumnSeries12.prototype.alignDataLabel.apply(this, arguments);
    if (point.dataLabel) {
      point.dataLabel.attr({ zIndex: (point.node.zIndex || 0) + 1 });
    }
  };
  TreemapSeries2.prototype.buildNode = function(id, i, level, list, parent) {
    var series = this, children = [], point = series.points[i], height = 0, node, child;
    (list[id] || []).forEach(function(i2) {
      child = series.buildNode(series.points[i2].id, i2, level + 1, list, id);
      height = Math.max(child.height + 1, height);
      children.push(child);
    });
    node = {
      id,
      i,
      children,
      height,
      level,
      parent,
      visible: false
    };
    series.nodeMap[node.id] = node;
    if (point) {
      point.node = node;
    }
    return node;
  };
  TreemapSeries2.prototype.calculateChildrenAreas = function(parent, area) {
    var series = this, options = series.options, mapOptionsToLevel = series.mapOptionsToLevel, level = mapOptionsToLevel[parent.level + 1], algorithm = pick88(series[level && level.layoutAlgorithm] && level.layoutAlgorithm, options.layoutAlgorithm), alternate = options.alternateStartingDirection, childrenValues = [], children;
    children = parent.children.filter(function(n) {
      return !n.ignore;
    });
    if (level && level.layoutStartingDirection) {
      area.direction = level.layoutStartingDirection === "vertical" ? 0 : 1;
    }
    childrenValues = series[algorithm](area, children);
    children.forEach(function(child, index) {
      var values = childrenValues[index];
      child.values = merge77(values, {
        val: child.childrenTotal,
        direction: alternate ? 1 - area.direction : area.direction
      });
      child.pointValues = merge77(values, {
        x: values.x / series.axisRatio,
        y: TreemapUtilities_default.AXIS_MAX - values.y - values.height,
        width: values.width / series.axisRatio
      });
      if (child.children.length) {
        series.calculateChildrenAreas(child, child.values);
      }
    });
  };
  TreemapSeries2.prototype.drawDataLabels = function() {
    var series = this, mapOptionsToLevel = series.mapOptionsToLevel, points = series.points.filter(function(n) {
      return n.node.visible;
    }), options, level;
    points.forEach(function(point) {
      level = mapOptionsToLevel[point.node.level];
      options = { style: {} };
      if (!point.node.isLeaf) {
        options.enabled = false;
      }
      if (level && level.dataLabels) {
        options = merge77(options, level.dataLabels);
        series._hasPointLabels = true;
      }
      if (point.shapeArgs) {
        options.style.width = point.shapeArgs.width;
        if (point.dataLabel) {
          point.dataLabel.css({
            width: point.shapeArgs.width + "px"
          });
        }
      }
      point.dlOptions = merge77(options, point.options.dataLabels);
    });
    Series12.prototype.drawDataLabels.call(this);
  };
  TreemapSeries2.prototype.drawPoints = function() {
    var series = this, chart = series.chart, renderer = chart.renderer, points = series.points, styledMode = chart.styledMode, options = series.options, shadow = styledMode ? {} : options.shadow, borderRadius = options.borderRadius, withinAnimationLimit = chart.pointCount < options.animationLimit, allowTraversingTree = options.allowTraversingTree;
    points.forEach(function(point) {
      var levelDynamic = point.node.levelDynamic, animatableAttribs = {}, attribs = {}, css16 = {}, groupKey = "level-group-" + point.node.level, hasGraphic = !!point.graphic, shouldAnimate = withinAnimationLimit && hasGraphic, shapeArgs = point.shapeArgs;
      if (point.shouldDraw()) {
        point.isInside = true;
        if (borderRadius) {
          attribs.r = borderRadius;
        }
        merge77(true, shouldAnimate ? animatableAttribs : attribs, hasGraphic ? shapeArgs : {}, styledMode ? {} : series.pointAttribs(point, point.selected ? "select" : void 0));
        if (series.colorAttribs && styledMode) {
          extend80(css16, series.colorAttribs(point));
        }
        if (!series[groupKey]) {
          series[groupKey] = renderer.g(groupKey).attr({
            zIndex: 1e3 - (levelDynamic || 0)
          }).add(series.group);
          series[groupKey].survive = true;
        }
      }
      point.draw({
        animatableAttribs,
        attribs,
        css: css16,
        group: series[groupKey],
        renderer,
        shadow,
        shapeArgs,
        shapeType: "rect"
      });
      if (allowTraversingTree && point.graphic) {
        point.drillId = options.interactByLeaf ? series.drillToByLeaf(point) : series.drillToByGroup(point);
      }
    });
  };
  TreemapSeries2.prototype.drillToByGroup = function(point) {
    var series = this, drillId = false;
    if (point.node.level - series.nodeMap[series.rootNode].level === 1 && !point.node.isLeaf) {
      drillId = point.id;
    }
    return drillId;
  };
  TreemapSeries2.prototype.drillToByLeaf = function(point) {
    var series = this, drillId = false, nodeParent;
    if (point.node.parent !== series.rootNode && point.node.isLeaf) {
      nodeParent = point.node;
      while (!drillId) {
        nodeParent = series.nodeMap[nodeParent.parent];
        if (nodeParent.parent === series.rootNode) {
          drillId = nodeParent.id;
        }
      }
    }
    return drillId;
  };
  TreemapSeries2.prototype.drillToNode = function(id, redraw) {
    error11(32, false, void 0, { "treemap.drillToNode": "use treemap.setRootNode" });
    this.setRootNode(id, redraw);
  };
  TreemapSeries2.prototype.drillUp = function() {
    var series = this, node = series.nodeMap[series.rootNode];
    if (node && isString11(node.parent)) {
      series.setRootNode(node.parent, true, { trigger: "traverseUpButton" });
    }
  };
  TreemapSeries2.prototype.getExtremes = function() {
    var _a15 = Series12.prototype.getExtremes.call(this, this.colorValueData), dataMin = _a15.dataMin, dataMax = _a15.dataMax;
    this.valueMin = dataMin;
    this.valueMax = dataMax;
    return Series12.prototype.getExtremes.call(this);
  };
  TreemapSeries2.prototype.getListOfParents = function(data, existingIds) {
    var arr = isArray22(data) ? data : [], ids = isArray22(existingIds) ? existingIds : [], listOfParents = arr.reduce(function(prev, curr, i) {
      var parent = pick88(curr.parent, "");
      if (typeof prev[parent] === "undefined") {
        prev[parent] = [];
      }
      prev[parent].push(i);
      return prev;
    }, {
      "": []
    });
    TreemapUtilities_default.eachObject(listOfParents, function(children, parent, list) {
      if (parent !== "" && ids.indexOf(parent) === -1) {
        children.forEach(function(child) {
          list[""].push(child);
        });
        delete list[parent];
      }
    });
    return listOfParents;
  };
  TreemapSeries2.prototype.getTree = function() {
    var series = this, allIds = this.data.map(function(d) {
      return d.id;
    }), parentList = series.getListOfParents(this.data, allIds);
    series.nodeMap = {};
    return series.buildNode("", -1, 0, parentList);
  };
  TreemapSeries2.prototype.hasData = function() {
    return !!this.processedXData.length;
  };
  TreemapSeries2.prototype.init = function(chart, options) {
    var series = this, setOptionsEvent;
    if (colorMapSeriesMixin3) {
      this.colorAttribs = colorMapSeriesMixin3.colorAttribs;
    }
    setOptionsEvent = addEvent59(series, "setOptions", function(event) {
      var options2 = event.userOptions;
      if (defined49(options2.allowDrillToNode) && !defined49(options2.allowTraversingTree)) {
        options2.allowTraversingTree = options2.allowDrillToNode;
        delete options2.allowDrillToNode;
      }
      if (defined49(options2.drillUpButton) && !defined49(options2.traverseUpButton)) {
        options2.traverseUpButton = options2.drillUpButton;
        delete options2.drillUpButton;
      }
    });
    Series12.prototype.init.call(series, chart, options);
    delete series.opacity;
    series.eventsToUnbind.push(setOptionsEvent);
    if (series.options.allowTraversingTree) {
      series.eventsToUnbind.push(addEvent59(series, "click", series.onClickDrillToNode));
    }
  };
  TreemapSeries2.prototype.onClickDrillToNode = function(event) {
    var series = this, point = event.point, drillId = point && point.drillId;
    if (isString11(drillId)) {
      point.setState("");
      series.setRootNode(drillId, true, { trigger: "click" });
    }
  };
  TreemapSeries2.prototype.pointAttribs = function(point, state) {
    var series = this, mapOptionsToLevel = isObject11(series.mapOptionsToLevel) ? series.mapOptionsToLevel : {}, level = point && mapOptionsToLevel[point.node.level] || {}, options = this.options, attr10, stateOptions = state && options.states[state] || {}, className = point && point.getClassName() || "", opacity;
    attr10 = {
      "stroke": point && point.borderColor || level.borderColor || stateOptions.borderColor || options.borderColor,
      "stroke-width": pick88(point && point.borderWidth, level.borderWidth, stateOptions.borderWidth, options.borderWidth),
      "dashstyle": point && point.borderDashStyle || level.borderDashStyle || stateOptions.borderDashStyle || options.borderDashStyle,
      "fill": point && point.color || this.color
    };
    if (className.indexOf("highcharts-above-level") !== -1) {
      attr10.fill = "none";
      attr10["stroke-width"] = 0;
    } else if (className.indexOf("highcharts-internal-node-interactive") !== -1) {
      opacity = pick88(stateOptions.opacity, options.opacity);
      attr10.fill = color16(attr10.fill).setOpacity(opacity).get();
      attr10.cursor = "pointer";
    } else if (className.indexOf("highcharts-internal-node") !== -1) {
      attr10.fill = "none";
    } else if (state) {
      attr10.fill = color16(attr10.fill).brighten(stateOptions.brightness).get();
    }
    return attr10;
  };
  TreemapSeries2.prototype.renderTraverseUpButton = function(rootId) {
    var series = this, nodeMap = series.nodeMap, node = nodeMap[rootId], name = node.name, buttonOptions = series.options.traverseUpButton, backText = pick88(buttonOptions.text, name, "\u25C1 Back"), attr10, states;
    if (rootId === "" || series.is("sunburst") && series.tree.children.length === 1 && rootId === series.tree.children[0].id) {
      if (series.drillUpButton) {
        series.drillUpButton = series.drillUpButton.destroy();
      }
    } else if (!this.drillUpButton) {
      attr10 = buttonOptions.theme;
      states = attr10 && attr10.states;
      this.drillUpButton = this.chart.renderer.button(backText, 0, 0, function() {
        series.drillUp();
      }, attr10, states && states.hover, states && states.select).addClass("highcharts-drillup-button").attr({
        align: buttonOptions.position.align,
        zIndex: 7
      }).add().align(buttonOptions.position, false, buttonOptions.relativeTo || "plotBox");
    } else {
      this.drillUpButton.placed = false;
      this.drillUpButton.attr({
        text: backText
      }).align();
    }
  };
  TreemapSeries2.prototype.setColorRecursive = function(node, parentColor, colorIndex, index, siblings) {
    var series = this, chart = series && series.chart, colors = chart && chart.options && chart.options.colors, colorInfo, point;
    if (node) {
      colorInfo = getColor3(node, {
        colors,
        index,
        mapOptionsToLevel: series.mapOptionsToLevel,
        parentColor,
        parentColorIndex: colorIndex,
        series,
        siblings
      });
      point = series.points[node.i];
      if (point) {
        point.color = colorInfo.color;
        point.colorIndex = colorInfo.colorIndex;
      }
      (node.children || []).forEach(function(child, i) {
        series.setColorRecursive(child, colorInfo.color, colorInfo.colorIndex, i, node.children.length);
      });
    }
  };
  TreemapSeries2.prototype.setPointValues = function() {
    var series = this;
    var points = series.points, xAxis = series.xAxis, yAxis = series.yAxis;
    var styledMode = series.chart.styledMode;
    var getCrispCorrection = function(point) {
      return styledMode ? 0 : (series.pointAttribs(point)["stroke-width"] || 0) % 2 / 2;
    };
    points.forEach(function(point) {
      var _a15 = point.node, values = _a15.pointValues, visible = _a15.visible;
      if (values && visible) {
        var height = values.height, width = values.width, x = values.x, y = values.y;
        var crispCorr = getCrispCorrection(point);
        var x1 = Math.round(xAxis.toPixels(x, true)) - crispCorr;
        var x2 = Math.round(xAxis.toPixels(x + width, true)) - crispCorr;
        var y1 = Math.round(yAxis.toPixels(y, true)) - crispCorr;
        var y2 = Math.round(yAxis.toPixels(y + height, true)) - crispCorr;
        var shapeArgs = {
          x: Math.min(x1, x2),
          y: Math.min(y1, y2),
          width: Math.abs(x2 - x1),
          height: Math.abs(y2 - y1)
        };
        point.plotX = shapeArgs.x + shapeArgs.width / 2;
        point.plotY = shapeArgs.y + shapeArgs.height / 2;
        point.shapeArgs = shapeArgs;
      } else {
        delete point.plotX;
        delete point.plotY;
      }
    });
  };
  TreemapSeries2.prototype.setRootNode = function(id, redraw, eventArguments) {
    var series = this, eventArgs = extend80({
      newRootId: id,
      previousRootId: series.rootNode,
      redraw: pick88(redraw, true),
      series
    }, eventArguments);
    var defaultFn = function(args) {
      var series2 = args.series;
      series2.idPreviousRoot = args.previousRootId;
      series2.rootNode = args.newRootId;
      series2.isDirty = true;
      if (args.redraw) {
        series2.chart.redraw();
      }
    };
    fireEvent33(series, "setRootNode", eventArgs, defaultFn);
  };
  TreemapSeries2.prototype.setState = function(state) {
    this.options.inactiveOtherPoints = true;
    Series12.prototype.setState.call(this, state, false);
    this.options.inactiveOtherPoints = false;
  };
  TreemapSeries2.prototype.setTreeValues = function(tree) {
    var series = this, options = series.options, idRoot = series.rootNode, mapIdToNode = series.nodeMap, nodeRoot = mapIdToNode[idRoot], levelIsConstant = TreemapUtilities_default.isBoolean(options.levelIsConstant) ? options.levelIsConstant : true, childrenTotal = 0, children = [], val, point = series.points[tree.i];
    tree.children.forEach(function(child) {
      child = series.setTreeValues(child);
      children.push(child);
      if (!child.ignore) {
        childrenTotal += child.val;
      }
    });
    stableSort6(children, function(a, b) {
      return (a.sortIndex || 0) - (b.sortIndex || 0);
    });
    val = pick88(point && point.options.value, childrenTotal);
    if (point) {
      point.value = val;
    }
    extend80(tree, {
      children,
      childrenTotal,
      ignore: !(pick88(point && point.visible, true) && val > 0),
      isLeaf: tree.visible && !childrenTotal,
      levelDynamic: tree.level - (levelIsConstant ? 0 : nodeRoot.level),
      name: pick88(point && point.name, ""),
      sortIndex: pick88(point && point.sortIndex, -val),
      val
    });
    return tree;
  };
  TreemapSeries2.prototype.sliceAndDice = function(parent, children) {
    return this.algorithmFill(true, parent, children);
  };
  TreemapSeries2.prototype.squarified = function(parent, children) {
    return this.algorithmLowAspectRatio(true, parent, children);
  };
  TreemapSeries2.prototype.strip = function(parent, children) {
    return this.algorithmLowAspectRatio(false, parent, children);
  };
  TreemapSeries2.prototype.stripes = function(parent, children) {
    return this.algorithmFill(false, parent, children);
  };
  TreemapSeries2.prototype.translate = function() {
    var series = this, options = series.options, rootId = updateRootId2(series), rootNode, pointValues, seriesArea, tree, val;
    Series12.prototype.translate.call(series);
    tree = series.tree = series.getTree();
    rootNode = series.nodeMap[rootId];
    if (rootId !== "" && (!rootNode || !rootNode.children.length)) {
      series.setRootNode("", false);
      rootId = series.rootNode;
      rootNode = series.nodeMap[rootId];
    }
    series.renderTraverseUpButton(rootId);
    series.mapOptionsToLevel = getLevelOptions3({
      from: rootNode.level + 1,
      levels: options.levels,
      to: tree.height,
      defaults: {
        levelIsConstant: series.options.levelIsConstant,
        colorByPoint: options.colorByPoint
      }
    });
    TreemapUtilities_default.recursive(series.nodeMap[series.rootNode], function(node) {
      var next = false, p = node.parent;
      node.visible = true;
      if (p || p === "") {
        next = series.nodeMap[p];
      }
      return next;
    });
    TreemapUtilities_default.recursive(series.nodeMap[series.rootNode].children, function(children) {
      var next = false;
      children.forEach(function(child) {
        child.visible = true;
        if (child.children.length) {
          next = (next || []).concat(child.children);
        }
      });
      return next;
    });
    series.setTreeValues(tree);
    series.axisRatio = series.xAxis.len / series.yAxis.len;
    series.nodeMap[""].pointValues = pointValues = {
      x: 0,
      y: 0,
      width: TreemapUtilities_default.AXIS_MAX,
      height: TreemapUtilities_default.AXIS_MAX
    };
    series.nodeMap[""].values = seriesArea = merge77(pointValues, {
      width: pointValues.width * series.axisRatio,
      direction: options.layoutStartingDirection === "vertical" ? 0 : 1,
      val: tree.val
    });
    series.calculateChildrenAreas(tree, seriesArea);
    if (!series.colorAxis && !options.colorByPoint) {
      series.setColorRecursive(series.tree);
    }
    if (options.allowTraversingTree) {
      val = rootNode.pointValues;
      series.xAxis.setExtremes(val.x, val.x + val.width, false);
      series.yAxis.setExtremes(val.y, val.y + val.height, false);
      series.xAxis.setScale();
      series.yAxis.setScale();
    }
    series.setPointValues();
  };
  TreemapSeries2.defaultOptions = merge77(ScatterSeries5.defaultOptions, {
    allowTraversingTree: false,
    animationLimit: 250,
    borderRadius: 0,
    showInLegend: false,
    marker: void 0,
    colorByPoint: false,
    dataLabels: {
      defer: false,
      enabled: true,
      formatter: function() {
        var point = this && this.point ? this.point : {}, name = isString11(point.name) ? point.name : "";
        return name;
      },
      inside: true,
      verticalAlign: "middle"
    },
    tooltip: {
      headerFormat: "",
      pointFormat: "<b>{point.name}</b>: {point.value}<br/>"
    },
    ignoreHiddenPoint: true,
    layoutAlgorithm: "sliceAndDice",
    layoutStartingDirection: "vertical",
    alternateStartingDirection: false,
    levelIsConstant: true,
    drillUpButton: {
      position: {
        align: "right",
        x: -10,
        y: 10
      }
    },
    traverseUpButton: {
      position: {
        align: "right",
        x: -10,
        y: 10
      }
    },
    borderColor: Palette_default.neutralColor10,
    borderWidth: 1,
    colorKey: "colorValue",
    opacity: 0.15,
    states: {
      hover: {
        borderColor: Palette_default.neutralColor40,
        brightness: HeatmapSeries2 ? 0 : 0.1,
        halo: false,
        opacity: 0.75,
        shadow: false
      }
    }
  });
  return TreemapSeries2;
}(ScatterSeries5);
extend80(TreemapSeries.prototype, {
  buildKDTree: noop22,
  colorKey: "colorValue",
  directTouch: true,
  drawLegendSymbol: LegendSymbol_default.drawRectangle,
  getExtremesFromAll: true,
  getSymbol: noop22,
  optionalAxis: "colorAxis",
  parallelArrays: ["x", "y", "value", "colorValue"],
  pointArrayMap: ["value"],
  pointClass: TreemapPoint_default,
  trackerGroups: ["group", "dataLabelsGroup"],
  utils: {
    recursive: TreemapUtilities_default.recursive
  }
});
SeriesRegistry_default.registerSeriesType("treemap", TreemapSeries);

// node_modules/highcharts/es-modules/Extensions/NoDataToDisplay.js
var getOptions3 = DefaultOptions_default.getOptions;
var addEvent60 = Utilities_default.addEvent;
var extend81 = Utilities_default.extend;
var chartPrototype = Chart_default.prototype;
var defaultOptions16 = getOptions3();
extend81(defaultOptions16.lang, {
  noData: "No data to display"
});
defaultOptions16.noData = {
  attr: {
    zIndex: 1
  },
  position: {
    x: 0,
    y: 0,
    align: "center",
    verticalAlign: "middle"
  },
  style: {
    fontWeight: "bold",
    fontSize: "12px",
    color: Palette_default.neutralColor60
  }
};
chartPrototype.showNoData = function(str) {
  var chart = this, options = chart.options, text = str || options && options.lang.noData || "", noDataOptions = options && (options.noData || {});
  if (chart.renderer) {
    if (!chart.noDataLabel) {
      chart.noDataLabel = chart.renderer.label(text, 0, 0, void 0, void 0, void 0, noDataOptions.useHTML, void 0, "no-data").add();
    }
    if (!chart.styledMode) {
      chart.noDataLabel.attr(AST_default.filterUserAttributes(noDataOptions.attr || {})).css(noDataOptions.style || {});
    }
    chart.noDataLabel.align(extend81(chart.noDataLabel.getBBox(), noDataOptions.position || {}), false, "plotBox");
  }
};
chartPrototype.hideNoData = function() {
  var chart = this;
  if (chart.noDataLabel) {
    chart.noDataLabel = chart.noDataLabel.destroy();
  }
};
chartPrototype.hasData = function() {
  var chart = this, series = chart.series || [], i = series.length;
  while (i--) {
    if (series[i].hasData() && !series[i].options.isInternal) {
      return true;
    }
  }
  return chart.loadingShown;
};
addEvent60(Chart_default, "render", function handleNoData() {
  if (this.hasData()) {
    this.hideNoData();
  } else {
    this.showNoData();
  }
});

// node_modules/highcharts/es-modules/Mixins/Nodes.js
var defined50 = Utilities_default.defined;
var extend82 = Utilities_default.extend;
var find17 = Utilities_default.find;
var pick89 = Utilities_default.pick;
var NodesMixin = Globals_default.NodesMixin = {
  createNode: function(id) {
    function findById(nodes, id2) {
      return find17(nodes, function(node2) {
        return node2.id === id2;
      });
    }
    var node = findById(this.nodes, id), PointClass = this.pointClass, options;
    if (!node) {
      options = this.options.nodes && findById(this.options.nodes, id);
      node = new PointClass().init(this, extend82({
        className: "highcharts-node",
        isNode: true,
        id,
        y: 1
      }, options));
      node.linksTo = [];
      node.linksFrom = [];
      node.formatPrefix = "node";
      node.name = node.name || node.options.id || "";
      node.mass = pick89(node.options.mass, node.options.marker && node.options.marker.radius, this.options.marker && this.options.marker.radius, 4);
      node.getSum = function() {
        var sumTo = 0, sumFrom = 0;
        node.linksTo.forEach(function(link) {
          sumTo += link.weight;
        });
        node.linksFrom.forEach(function(link) {
          sumFrom += link.weight;
        });
        return Math.max(sumTo, sumFrom);
      };
      node.offset = function(point, coll) {
        var offset3 = 0;
        for (var i = 0; i < node[coll].length; i++) {
          if (node[coll][i] === point) {
            return offset3;
          }
          offset3 += node[coll][i].weight;
        }
      };
      node.hasShape = function() {
        var outgoing = 0;
        node.linksTo.forEach(function(link) {
          if (link.outgoing) {
            outgoing++;
          }
        });
        return !node.linksTo.length || outgoing !== node.linksTo.length;
      };
      this.nodes.push(node);
    }
    return node;
  },
  generatePoints: function() {
    var chart = this.chart, nodeLookup = {};
    Series_default.prototype.generatePoints.call(this);
    if (!this.nodes) {
      this.nodes = [];
    }
    this.colorCounter = 0;
    this.nodes.forEach(function(node) {
      node.linksFrom.length = 0;
      node.linksTo.length = 0;
      node.level = node.options.level;
    });
    this.points.forEach(function(point) {
      if (defined50(point.from)) {
        if (!nodeLookup[point.from]) {
          nodeLookup[point.from] = this.createNode(point.from);
        }
        nodeLookup[point.from].linksFrom.push(point);
        point.fromNode = nodeLookup[point.from];
        if (chart.styledMode) {
          point.colorIndex = pick89(point.options.colorIndex, nodeLookup[point.from].colorIndex);
        } else {
          point.color = point.options.color || nodeLookup[point.from].color;
        }
      }
      if (defined50(point.to)) {
        if (!nodeLookup[point.to]) {
          nodeLookup[point.to] = this.createNode(point.to);
        }
        nodeLookup[point.to].linksTo.push(point);
        point.toNode = nodeLookup[point.to];
      }
      point.name = point.name || point.id;
    }, this);
    this.nodeLookup = nodeLookup;
  },
  setData: function() {
    if (this.nodes) {
      this.nodes.forEach(function(node) {
        node.destroy();
      });
      this.nodes.length = 0;
    }
    Series_default.prototype.setData.apply(this, arguments);
  },
  destroy: function() {
    this.data = [].concat(this.points || [], this.nodes);
    return Series_default.prototype.destroy.apply(this, arguments);
  },
  setNodeState: function(state) {
    var args = arguments, others = this.isNode ? this.linksTo.concat(this.linksFrom) : [this.fromNode, this.toNode];
    if (state !== "select") {
      others.forEach(function(linkOrNode) {
        if (linkOrNode && linkOrNode.series) {
          Point_default.prototype.setState.apply(linkOrNode, args);
          if (!linkOrNode.isNode) {
            if (linkOrNode.fromNode.graphic) {
              Point_default.prototype.setState.apply(linkOrNode.fromNode, args);
            }
            if (linkOrNode.toNode && linkOrNode.toNode.graphic) {
              Point_default.prototype.setState.apply(linkOrNode.toNode, args);
            }
          }
        }
      });
    }
    Point_default.prototype.setState.apply(this, args);
  }
};
var Nodes_default = NodesMixin;

// node_modules/highcharts/es-modules/Series/Sankey/SankeyPoint.js
var __extends52 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ColumnSeries13 = SeriesRegistry_default.seriesTypes.column;
var defined51 = Utilities_default.defined;
var extend83 = Utilities_default.extend;
var SankeyPoint = function(_super) {
  __extends52(SankeyPoint3, _super);
  function SankeyPoint3() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.className = void 0;
    _this.fromNode = void 0;
    _this.level = void 0;
    _this.linkBase = void 0;
    _this.linksFrom = void 0;
    _this.linksTo = void 0;
    _this.mass = void 0;
    _this.nodeX = void 0;
    _this.nodeY = void 0;
    _this.options = void 0;
    _this.series = void 0;
    _this.toNode = void 0;
    return _this;
  }
  SankeyPoint3.prototype.applyOptions = function(options, x) {
    Point_default.prototype.applyOptions.call(this, options, x);
    if (defined51(this.options.level)) {
      this.options.column = this.column = this.options.level;
    }
    return this;
  };
  SankeyPoint3.prototype.getClassName = function() {
    return (this.isNode ? "highcharts-node " : "highcharts-link ") + Point_default.prototype.getClassName.call(this);
  };
  SankeyPoint3.prototype.isValid = function() {
    return this.isNode || typeof this.weight === "number";
  };
  return SankeyPoint3;
}(ColumnSeries13.prototype.pointClass);
extend83(SankeyPoint.prototype, {
  setState: Nodes_default.setNodeState
});
var SankeyPoint_default = SankeyPoint;

// node_modules/highcharts/es-modules/Series/Sankey/SankeySeries.js
var __extends53 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Series13 = SeriesRegistry_default.series;
var ColumnSeries14 = SeriesRegistry_default.seriesTypes.column;
var getLevelOptions4 = TreeSeries_default.getLevelOptions;
var defined52 = Utilities_default.defined;
var extend84 = Utilities_default.extend;
var find18 = Utilities_default.find;
var isObject12 = Utilities_default.isObject;
var merge78 = Utilities_default.merge;
var pick90 = Utilities_default.pick;
var relativeLength10 = Utilities_default.relativeLength;
var stableSort7 = Utilities_default.stableSort;
var SankeySeries = function(_super) {
  __extends53(SankeySeries3, _super);
  function SankeySeries3() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.colDistance = void 0;
    _this.data = void 0;
    _this.group = void 0;
    _this.nodeLookup = void 0;
    _this.nodePadding = void 0;
    _this.nodes = void 0;
    _this.nodeWidth = void 0;
    _this.options = void 0;
    _this.points = void 0;
    _this.translationFactor = void 0;
    return _this;
  }
  SankeySeries3.getDLOptions = function(params) {
    var optionsPoint = isObject12(params.optionsPoint) ? params.optionsPoint.dataLabels : {}, optionsLevel = isObject12(params.level) ? params.level.dataLabels : {}, options = merge78({
      style: {}
    }, optionsLevel, optionsPoint);
    return options;
  };
  SankeySeries3.prototype.createNodeColumn = function() {
    var series = this, chart = this.chart, column = [];
    column.sum = function() {
      return this.reduce(function(sum, node) {
        return sum + node.getSum();
      }, 0);
    };
    column.offset = function(node, factor) {
      var offset3 = 0, totalNodeOffset, nodePadding = series.nodePadding;
      for (var i = 0; i < column.length; i++) {
        var sum = column[i].getSum();
        var height = Math.max(sum * factor, series.options.minLinkWidth);
        if (sum) {
          totalNodeOffset = height + nodePadding;
        } else {
          totalNodeOffset = 0;
        }
        if (column[i] === node) {
          return {
            relativeTop: offset3 + relativeLength10(node.options.offset || 0, totalNodeOffset)
          };
        }
        offset3 += totalNodeOffset;
      }
    };
    column.top = function(factor) {
      var nodePadding = series.nodePadding;
      var height = this.reduce(function(height2, node) {
        if (height2 > 0) {
          height2 += nodePadding;
        }
        var nodeHeight = Math.max(node.getSum() * factor, series.options.minLinkWidth);
        height2 += nodeHeight;
        return height2;
      }, 0);
      return (chart.plotSizeY - height) / 2;
    };
    return column;
  };
  SankeySeries3.prototype.createNodeColumns = function() {
    var columns = [];
    this.nodes.forEach(function(node) {
      var fromColumn = -1, fromNode;
      if (!defined52(node.options.column)) {
        if (node.linksTo.length === 0) {
          node.column = 0;
        } else {
          for (var i2 = 0; i2 < node.linksTo.length; i2++) {
            var point = node.linksTo[i2];
            if (point.fromNode.column > fromColumn && point.fromNode !== node) {
              fromNode = point.fromNode;
              fromColumn = fromNode.column;
            }
          }
          node.column = fromColumn + 1;
          if (fromNode && fromNode.options.layout === "hanging") {
            node.hangsFrom = fromNode;
            var i_1 = -1;
            find18(fromNode.linksFrom, function(link, index) {
              var found = link.toNode === node;
              if (found) {
                i_1 = index;
              }
              return found;
            });
            node.column += i_1;
          }
        }
      }
      if (!columns[node.column]) {
        columns[node.column] = this.createNodeColumn();
      }
      columns[node.column].push(node);
    }, this);
    for (var i = 0; i < columns.length; i++) {
      if (typeof columns[i] === "undefined") {
        columns[i] = this.createNodeColumn();
      }
    }
    return columns;
  };
  SankeySeries3.prototype.generatePoints = function() {
    Nodes_default.generatePoints.apply(this, arguments);
    function order(node, level) {
      if (typeof node.level === "undefined") {
        node.level = level;
        node.linksFrom.forEach(function(link) {
          if (link.toNode) {
            order(link.toNode, level + 1);
          }
        });
      }
    }
    if (this.orderNodes) {
      this.nodes.filter(function(node) {
        return node.linksTo.length === 0;
      }).forEach(function(node) {
        order(node, 0);
      });
      stableSort7(this.nodes, function(a, b) {
        return a.level - b.level;
      });
    }
  };
  SankeySeries3.prototype.getNodePadding = function() {
    var nodePadding = this.options.nodePadding || 0;
    if (this.nodeColumns) {
      var maxLength = this.nodeColumns.reduce(function(acc, col) {
        return Math.max(acc, col.length);
      }, 0);
      if (maxLength * nodePadding > this.chart.plotSizeY) {
        nodePadding = this.chart.plotSizeY / maxLength;
      }
    }
    return nodePadding;
  };
  SankeySeries3.prototype.hasData = function() {
    return !!this.processedXData.length;
  };
  SankeySeries3.prototype.pointAttribs = function(point, state) {
    if (!point) {
      return {};
    }
    var series = this, level = point.isNode ? point.level : point.fromNode.level, levelOptions = series.mapOptionsToLevel[level || 0] || {}, options = point.options, stateOptions = levelOptions.states && levelOptions.states[state || ""] || {}, values = [
      "colorByPoint",
      "borderColor",
      "borderWidth",
      "linkOpacity"
    ].reduce(function(obj, key) {
      obj[key] = pick90(stateOptions[key], options[key], levelOptions[key], series.options[key]);
      return obj;
    }, {}), color18 = pick90(stateOptions.color, options.color, values.colorByPoint ? point.color : levelOptions.color);
    if (point.isNode) {
      return {
        fill: color18,
        stroke: values.borderColor,
        "stroke-width": values.borderWidth
      };
    }
    return {
      fill: Color_default.parse(color18).setOpacity(values.linkOpacity).get()
    };
  };
  SankeySeries3.prototype.render = function() {
    var points = this.points;
    this.points = this.points.concat(this.nodes || []);
    ColumnSeries14.prototype.render.call(this);
    this.points = points;
  };
  SankeySeries3.prototype.translate = function() {
    var _this = this;
    var getColumnTranslationFactor = function(column) {
      var nodes = column.slice();
      var minLinkWidth = _this.options.minLinkWidth || 0;
      var exceedsMinLinkWidth;
      var factor = 0;
      var i;
      var remainingHeight = chart.plotSizeY - options.borderWidth - (column.length - 1) * series.nodePadding;
      while (column.length) {
        factor = remainingHeight / column.sum();
        exceedsMinLinkWidth = false;
        i = column.length;
        while (i--) {
          if (column[i].getSum() * factor < minLinkWidth) {
            column.splice(i, 1);
            remainingHeight -= minLinkWidth;
            exceedsMinLinkWidth = true;
          }
        }
        if (!exceedsMinLinkWidth) {
          break;
        }
      }
      column.length = 0;
      nodes.forEach(function(node) {
        return column.push(node);
      });
      return factor;
    };
    if (!this.processedXData) {
      this.processData();
    }
    this.generatePoints();
    this.nodeColumns = this.createNodeColumns();
    this.nodeWidth = relativeLength10(this.options.nodeWidth, this.chart.plotSizeX);
    var series = this, chart = this.chart, options = this.options, nodeWidth = this.nodeWidth, nodeColumns = this.nodeColumns;
    this.nodePadding = this.getNodePadding();
    this.translationFactor = nodeColumns.reduce(function(translationFactor, column) {
      return Math.min(translationFactor, getColumnTranslationFactor(column));
    }, Infinity);
    this.colDistance = (chart.plotSizeX - nodeWidth - options.borderWidth) / Math.max(1, nodeColumns.length - 1);
    series.mapOptionsToLevel = getLevelOptions4({
      from: 1,
      levels: options.levels,
      to: nodeColumns.length - 1,
      defaults: {
        borderColor: options.borderColor,
        borderRadius: options.borderRadius,
        borderWidth: options.borderWidth,
        color: series.color,
        colorByPoint: options.colorByPoint,
        levelIsConstant: true,
        linkColor: options.linkColor,
        linkLineWidth: options.linkLineWidth,
        linkOpacity: options.linkOpacity,
        states: options.states
      }
    });
    nodeColumns.forEach(function(column) {
      column.forEach(function(node) {
        series.translateNode(node, column);
      });
    }, this);
    this.nodes.forEach(function(node) {
      node.linksFrom.forEach(function(linkPoint) {
        if ((linkPoint.weight || linkPoint.isNull) && linkPoint.to) {
          series.translateLink(linkPoint);
          linkPoint.allowShadow = false;
        }
      });
    });
  };
  SankeySeries3.prototype.translateLink = function(point) {
    var getY = function(node, fromOrTo) {
      var linkTop = node.offset(point, fromOrTo) * translationFactor;
      var y = Math.min(node.nodeY + linkTop, node.nodeY + (node.shapeArgs && node.shapeArgs.height || 0) - linkHeight);
      return y;
    };
    var fromNode = point.fromNode, toNode = point.toNode, chart = this.chart, translationFactor = this.translationFactor, linkHeight = Math.max(point.weight * translationFactor, this.options.minLinkWidth), options = this.options, curvy = (chart.inverted ? -this.colDistance : this.colDistance) * options.curveFactor, fromY = getY(fromNode, "linksFrom"), toY = getY(toNode, "linksTo"), nodeLeft = fromNode.nodeX, nodeW = this.nodeWidth, right = toNode.column * this.colDistance, outgoing = point.outgoing, straight = right > nodeLeft + nodeW;
    if (chart.inverted) {
      fromY = chart.plotSizeY - fromY;
      toY = (chart.plotSizeY || 0) - toY;
      right = chart.plotSizeX - right;
      nodeW = -nodeW;
      linkHeight = -linkHeight;
      straight = nodeLeft > right;
    }
    point.shapeType = "path";
    point.linkBase = [
      fromY,
      fromY + linkHeight,
      toY,
      toY + linkHeight
    ];
    if (straight && typeof toY === "number") {
      point.shapeArgs = {
        d: [
          ["M", nodeLeft + nodeW, fromY],
          [
            "C",
            nodeLeft + nodeW + curvy,
            fromY,
            right - curvy,
            toY,
            right,
            toY
          ],
          ["L", right + (outgoing ? nodeW : 0), toY + linkHeight / 2],
          ["L", right, toY + linkHeight],
          [
            "C",
            right - curvy,
            toY + linkHeight,
            nodeLeft + nodeW + curvy,
            fromY + linkHeight,
            nodeLeft + nodeW,
            fromY + linkHeight
          ],
          ["Z"]
        ]
      };
    } else if (typeof toY === "number") {
      var bend = 20, vDist = chart.plotHeight - fromY - linkHeight, x1 = right - bend - linkHeight, x2 = right - bend, x3 = right, x4 = nodeLeft + nodeW, x5 = x4 + bend, x6 = x5 + linkHeight, fy1 = fromY, fy2 = fromY + linkHeight, fy3 = fy2 + bend, y4 = fy3 + vDist, y5 = y4 + bend, y6 = y5 + linkHeight, ty1 = toY, ty2 = ty1 + linkHeight, ty3 = ty2 + bend, cfy1 = fy2 - linkHeight * 0.7, cy2 = y5 + linkHeight * 0.7, cty1 = ty2 - linkHeight * 0.7, cx1 = x3 - linkHeight * 0.7, cx2 = x4 + linkHeight * 0.7;
      point.shapeArgs = {
        d: [
          ["M", x4, fy1],
          ["C", cx2, fy1, x6, cfy1, x6, fy3],
          ["L", x6, y4],
          ["C", x6, cy2, cx2, y6, x4, y6],
          ["L", x3, y6],
          ["C", cx1, y6, x1, cy2, x1, y4],
          ["L", x1, ty3],
          ["C", x1, cty1, cx1, ty1, x3, ty1],
          ["L", x3, ty2],
          ["C", x2, ty2, x2, ty2, x2, ty3],
          ["L", x2, y4],
          ["C", x2, y5, x2, y5, x3, y5],
          ["L", x4, y5],
          ["C", x5, y5, x5, y5, x5, y4],
          ["L", x5, fy3],
          ["C", x5, fy2, x5, fy2, x4, fy2],
          ["Z"]
        ]
      };
    }
    point.dlBox = {
      x: nodeLeft + (right - nodeLeft + nodeW) / 2,
      y: fromY + (toY - fromY) / 2,
      height: linkHeight,
      width: 0
    };
    point.tooltipPos = chart.inverted ? [
      chart.plotSizeY - point.dlBox.y - linkHeight / 2,
      chart.plotSizeX - point.dlBox.x
    ] : [
      point.dlBox.x,
      point.dlBox.y + linkHeight / 2
    ];
    point.y = point.plotY = 1;
    if (!point.color) {
      point.color = fromNode.color;
    }
  };
  SankeySeries3.prototype.translateNode = function(node, column) {
    var translationFactor = this.translationFactor, chart = this.chart, options = this.options, sum = node.getSum(), nodeHeight = Math.max(Math.round(sum * translationFactor), this.options.minLinkWidth), crisp = Math.round(options.borderWidth) % 2 / 2, nodeOffset = column.offset(node, translationFactor), fromNodeTop = Math.floor(pick90(nodeOffset.absoluteTop, column.top(translationFactor) + nodeOffset.relativeTop)) + crisp, left = Math.floor(this.colDistance * node.column + options.borderWidth / 2) + crisp, nodeLeft = chart.inverted ? chart.plotSizeX - left : left, nodeWidth = Math.round(this.nodeWidth);
    node.sum = sum;
    if (sum) {
      node.shapeType = "rect";
      node.nodeX = nodeLeft;
      node.nodeY = fromNodeTop;
      var x = nodeLeft, y = fromNodeTop, width = node.options.width || options.width || nodeWidth, height = node.options.height || options.height || nodeHeight;
      if (chart.inverted) {
        x = nodeLeft - nodeWidth;
        y = chart.plotSizeY - fromNodeTop - nodeHeight;
        width = node.options.height || options.height || nodeWidth;
        height = node.options.width || options.width || nodeHeight;
      }
      node.dlOptions = SankeySeries3.getDLOptions({
        level: this.mapOptionsToLevel[node.level],
        optionsPoint: node.options
      });
      node.plotX = 1;
      node.plotY = 1;
      node.tooltipPos = chart.inverted ? [
        chart.plotSizeY - y - height / 2,
        chart.plotSizeX - x - width / 2
      ] : [
        x + width / 2,
        y + height / 2
      ];
      node.shapeArgs = {
        x,
        y,
        width,
        height,
        display: node.hasShape() ? "" : "none"
      };
    } else {
      node.dlOptions = {
        enabled: false
      };
    }
  };
  SankeySeries3.defaultOptions = merge78(ColumnSeries14.defaultOptions, {
    borderWidth: 0,
    colorByPoint: true,
    curveFactor: 0.33,
    dataLabels: {
      enabled: true,
      backgroundColor: "none",
      crop: false,
      nodeFormat: void 0,
      nodeFormatter: function() {
        return this.point.name;
      },
      format: void 0,
      formatter: function() {
        return;
      },
      inside: true
    },
    inactiveOtherPoints: true,
    linkOpacity: 0.5,
    minLinkWidth: 0,
    nodeWidth: 20,
    nodePadding: 10,
    showInLegend: false,
    states: {
      hover: {
        linkOpacity: 1
      },
      inactive: {
        linkOpacity: 0.1,
        opacity: 0.1,
        animation: {
          duration: 50
        }
      }
    },
    tooltip: {
      followPointer: true,
      headerFormat: '<span style="font-size: 10px">{series.name}</span><br/>',
      pointFormat: "{point.fromNode.name} \u2192 {point.toNode.name}: <b>{point.weight}</b><br/>",
      nodeFormat: "{point.name}: <b>{point.sum}</b><br/>"
    }
  });
  return SankeySeries3;
}(ColumnSeries14);
extend84(SankeySeries.prototype, {
  animate: Series13.prototype.animate,
  createNode: Nodes_default.createNode,
  destroy: Nodes_default.destroy,
  forceDL: true,
  invertible: true,
  isCartesian: false,
  orderNodes: true,
  pointArrayMap: ["from", "to"],
  pointClass: SankeyPoint_default,
  searchPoint: Globals_default.noop,
  setData: Nodes_default.setData
});
SeriesRegistry_default.registerSeriesType("sankey", SankeySeries);

// node_modules/highcharts/es-modules/Series/Timeline/TimelinePoint.js
var __extends54 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Series14 = SeriesRegistry_default.series;
var PiePoint4 = SeriesRegistry_default.seriesTypes.pie.prototype.pointClass;
var defined53 = Utilities_default.defined;
var isNumber50 = Utilities_default.isNumber;
var merge79 = Utilities_default.merge;
var objectEach35 = Utilities_default.objectEach;
var pick91 = Utilities_default.pick;
var TimelinePoint = function(_super) {
  __extends54(TimelinePoint2, _super);
  function TimelinePoint2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.options = void 0;
    _this.series = void 0;
    return _this;
  }
  TimelinePoint2.prototype.alignConnector = function() {
    var point = this, series = point.series, connector = point.connector, dl = point.dataLabel, dlOptions = point.dataLabel.options = merge79(series.options.dataLabels, point.options.dataLabels), chart = point.series.chart, bBox = connector.getBBox(), plotPos = {
      x: bBox.x + dl.translateX,
      y: bBox.y + dl.translateY
    }, isVisible;
    if (chart.inverted) {
      plotPos.y -= dl.options.connectorWidth / 2;
    } else {
      plotPos.x += dl.options.connectorWidth / 2;
    }
    isVisible = chart.isInsidePlot(plotPos.x, plotPos.y);
    connector[isVisible ? "animate" : "attr"]({
      d: point.getConnectorPath()
    });
    if (!series.chart.styledMode) {
      connector.attr({
        stroke: dlOptions.connectorColor || point.color,
        "stroke-width": dlOptions.connectorWidth,
        opacity: dl[defined53(dl.newOpacity) ? "newOpacity" : "opacity"]
      });
    }
  };
  TimelinePoint2.prototype.drawConnector = function() {
    var point = this, series = point.series;
    if (!point.connector) {
      point.connector = series.chart.renderer.path(point.getConnectorPath()).attr({
        zIndex: -1
      }).add(point.dataLabel);
    }
    if (point.series.chart.isInsidePlot(point.dataLabel.x, point.dataLabel.y)) {
      point.alignConnector();
    }
  };
  TimelinePoint2.prototype.getConnectorPath = function() {
    var point = this, chart = point.series.chart, xAxisLen = point.series.xAxis.len, inverted = chart.inverted, direction = inverted ? "x2" : "y2", dl = point.dataLabel, targetDLPos = dl.targetPosition, coords = {
      x1: point.plotX,
      y1: point.plotY,
      x2: point.plotX,
      y2: isNumber50(targetDLPos.y) ? targetDLPos.y : dl.y
    }, negativeDistance = (dl.alignAttr || dl)[direction[0]] < point.series.yAxis.len / 2, path;
    if (inverted) {
      coords = {
        x1: point.plotY,
        y1: xAxisLen - point.plotX,
        x2: targetDLPos.x || dl.x,
        y2: xAxisLen - point.plotX
      };
    }
    if (negativeDistance) {
      coords[direction] += dl[inverted ? "width" : "height"];
    }
    objectEach35(coords, function(_coord, i) {
      coords[i] -= (dl.alignAttr || dl)[i[0]];
    });
    path = chart.renderer.crispLine([
      ["M", coords.x1, coords.y1],
      ["L", coords.x2, coords.y2]
    ], dl.options.connectorWidth);
    return path;
  };
  TimelinePoint2.prototype.init = function() {
    var point = _super.prototype.init.apply(this, arguments);
    point.name = pick91(point.name, "Event");
    point.y = 1;
    return point;
  };
  TimelinePoint2.prototype.isValid = function() {
    return this.options.y !== null;
  };
  TimelinePoint2.prototype.setState = function() {
    var proceed = _super.prototype.setState;
    if (!this.isNull) {
      proceed.apply(this, arguments);
    }
  };
  TimelinePoint2.prototype.setVisible = function(visible, redraw) {
    var point = this, series = point.series;
    redraw = pick91(redraw, series.options.ignoreHiddenPoint);
    PiePoint4.prototype.setVisible.call(point, visible, false);
    series.processData();
    if (redraw) {
      series.chart.redraw();
    }
  };
  TimelinePoint2.prototype.applyOptions = function(options, x) {
    options = Point_default.prototype.optionsToObject.call(this, options);
    this.userDLOptions = merge79(this.userDLOptions, options.dataLabels);
    return _super.prototype.applyOptions.call(this, options, x);
  };
  return TimelinePoint2;
}(Series14.prototype.pointClass);
var TimelinePoint_default = TimelinePoint;

// node_modules/highcharts/es-modules/Series/Timeline/TimelineSeries.js
var __extends55 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var _a14 = SeriesRegistry_default.seriesTypes;
var ColumnSeries15 = _a14.column;
var LineSeries6 = _a14.line;
var addEvent61 = Utilities_default.addEvent;
var arrayMax11 = Utilities_default.arrayMax;
var arrayMin10 = Utilities_default.arrayMin;
var defined54 = Utilities_default.defined;
var extend85 = Utilities_default.extend;
var merge80 = Utilities_default.merge;
var pick92 = Utilities_default.pick;
var TimelineSeries = function(_super) {
  __extends55(TimelineSeries2, _super);
  function TimelineSeries2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.data = void 0;
    _this.options = void 0;
    _this.points = void 0;
    _this.userOptions = void 0;
    _this.visibilityMap = void 0;
    return _this;
  }
  TimelineSeries2.prototype.alignDataLabel = function(point, dataLabel, _options, _alignTo) {
    var series = this, isInverted = series.chart.inverted, visiblePoints = series.visibilityMap.filter(function(point2) {
      return point2;
    }), visiblePointsCount = series.visiblePointsCount, pointIndex = visiblePoints.indexOf(point), isFirstOrLast = !pointIndex || pointIndex === visiblePointsCount - 1, dataLabelsOptions = series.options.dataLabels, userDLOptions = point.userDLOptions || {}, multiplier = dataLabelsOptions.alternate ? isFirstOrLast ? 1.5 : 2 : 1, distance, availableSpace = Math.floor(series.xAxis.len / visiblePointsCount), pad4 = dataLabel.padding, targetDLWidth, styles;
    if (point.visible) {
      distance = Math.abs(userDLOptions.x || point.options.dataLabels.x);
      if (isInverted) {
        targetDLWidth = (distance - pad4) * 2 - point.itemHeight / 2;
        styles = {
          width: targetDLWidth + "px",
          textOverflow: dataLabel.width / targetDLWidth * dataLabel.height / 2 > availableSpace * multiplier ? "ellipsis" : "none"
        };
      } else {
        styles = {
          width: (userDLOptions.width || dataLabelsOptions.width || availableSpace * multiplier - pad4 * 2) + "px"
        };
      }
      dataLabel.css(styles);
      if (!series.chart.styledMode) {
        dataLabel.shadow(dataLabelsOptions.shadow);
      }
    }
    _super.prototype.alignDataLabel.apply(series, arguments);
  };
  TimelineSeries2.prototype.bindAxes = function() {
    var series = this;
    _super.prototype.bindAxes.call(series);
    ["xAxis", "yAxis"].forEach(function(axis) {
      if (axis === "xAxis" && !series[axis].userOptions.type) {
        series[axis].categories = series[axis].hasNames = true;
      }
    });
  };
  TimelineSeries2.prototype.distributeDL = function() {
    var series = this, dataLabelsOptions = series.options.dataLabels;
    var visibilityIndex = 1;
    if (dataLabelsOptions) {
      var distance_1 = dataLabelsOptions.distance || 0;
      series.points.forEach(function(point) {
        var _a15;
        point.options.dataLabels = merge80((_a15 = {}, _a15[series.chart.inverted ? "x" : "y"] = dataLabelsOptions.alternate && visibilityIndex % 2 ? -distance_1 : distance_1, _a15), point.userDLOptions);
        visibilityIndex++;
      });
    }
  };
  TimelineSeries2.prototype.generatePoints = function() {
    var series = this;
    _super.prototype.generatePoints.apply(series);
    series.points.forEach(function(point, i) {
      point.applyOptions({
        x: series.xData[i]
      }, series.xData[i]);
    });
  };
  TimelineSeries2.prototype.getVisibilityMap = function() {
    var series = this, map = (series.data.length ? series.data : series.userOptions.data).map(function(point) {
      return point && point.visible !== false && !point.isNull ? point : false;
    });
    return map;
  };
  TimelineSeries2.prototype.getXExtremes = function(xData) {
    var series = this, filteredData = xData.filter(function(x, i) {
      return series.points[i].isValid() && series.points[i].visible;
    });
    return {
      min: arrayMin10(filteredData),
      max: arrayMax11(filteredData)
    };
  };
  TimelineSeries2.prototype.init = function() {
    var series = this;
    _super.prototype.init.apply(series, arguments);
    series.eventsToUnbind.push(addEvent61(series, "afterTranslate", function() {
      var lastPlotX, closestPointRangePx = Number.MAX_VALUE;
      series.points.forEach(function(point) {
        point.isInside = point.isInside && point.visible;
        if (point.visible && !point.isNull) {
          if (defined54(lastPlotX)) {
            closestPointRangePx = Math.min(closestPointRangePx, Math.abs(point.plotX - lastPlotX));
          }
          lastPlotX = point.plotX;
        }
      });
      series.closestPointRangePx = closestPointRangePx;
    }));
    series.eventsToUnbind.push(addEvent61(series, "drawDataLabels", function() {
      series.distributeDL();
    }));
    series.eventsToUnbind.push(addEvent61(series, "afterDrawDataLabels", function() {
      var dataLabel;
      series.points.forEach(function(point) {
        dataLabel = point.dataLabel;
        if (dataLabel) {
          dataLabel.animate = function(params) {
            if (this.targetPosition) {
              this.targetPosition = params;
            }
            return SVGElement_default.prototype.animate.apply(this, arguments);
          };
          if (!dataLabel.targetPosition) {
            dataLabel.targetPosition = {};
          }
          return point.drawConnector();
        }
      });
    }));
    series.eventsToUnbind.push(addEvent61(series.chart, "afterHideOverlappingLabel", function() {
      series.points.forEach(function(p) {
        if (p.connector && p.dataLabel && p.dataLabel.oldOpacity !== p.dataLabel.newOpacity) {
          p.alignConnector();
        }
      });
    }));
  };
  TimelineSeries2.prototype.markerAttribs = function(point, state) {
    var series = this, seriesMarkerOptions = series.options.marker, seriesStateOptions, pointMarkerOptions = point.marker || {}, symbol = pointMarkerOptions.symbol || seriesMarkerOptions.symbol, pointStateOptions, width = pick92(pointMarkerOptions.width, seriesMarkerOptions.width, series.closestPointRangePx), height = pick92(pointMarkerOptions.height, seriesMarkerOptions.height), radius = 0, attribs;
    if (series.xAxis.dateTime) {
      return _super.prototype.markerAttribs.call(this, point, state);
    }
    if (state) {
      seriesStateOptions = seriesMarkerOptions.states[state] || {};
      pointStateOptions = pointMarkerOptions.states && pointMarkerOptions.states[state] || {};
      radius = pick92(pointStateOptions.radius, seriesStateOptions.radius, radius + (seriesStateOptions.radiusPlus || 0));
    }
    point.hasImage = symbol && symbol.indexOf("url") === 0;
    attribs = {
      x: Math.floor(point.plotX) - width / 2 - radius / 2,
      y: point.plotY - height / 2 - radius / 2,
      width: width + radius,
      height: height + radius
    };
    return attribs;
  };
  TimelineSeries2.prototype.processData = function() {
    var series = this, visiblePoints = 0, i;
    series.visibilityMap = series.getVisibilityMap();
    series.visibilityMap.forEach(function(point) {
      if (point) {
        visiblePoints++;
      }
    });
    series.visiblePointsCount = visiblePoints;
    for (i = 0; i < series.xData.length; i++) {
      series.yData[i] = 1;
    }
    _super.prototype.processData.call(this, arguments);
    return;
  };
  TimelineSeries2.defaultOptions = merge80(LineSeries6.defaultOptions, {
    colorByPoint: true,
    stickyTracking: false,
    ignoreHiddenPoint: true,
    legendType: "point",
    lineWidth: 4,
    tooltip: {
      headerFormat: '<span style="color:{point.color}">\u25CF</span> <span style="font-size: 10px"> {point.key}</span><br/>',
      pointFormat: "{point.description}"
    },
    states: {
      hover: {
        lineWidthPlus: 0
      }
    },
    dataLabels: {
      enabled: true,
      allowOverlap: true,
      alternate: true,
      backgroundColor: Palette_default.backgroundColor,
      borderWidth: 1,
      borderColor: Palette_default.neutralColor40,
      borderRadius: 3,
      color: Palette_default.neutralColor80,
      connectorWidth: 1,
      distance: 100,
      formatter: function() {
        var format13;
        if (!this.series.chart.styledMode) {
          format13 = '<span style="color:' + this.point.color + '">\u25CF </span>';
        } else {
          format13 = "<span>\u25CF </span>";
        }
        format13 += '<span class="highcharts-strong">' + (this.key || "") + "</span><br/>" + (this.point.label || "");
        return format13;
      },
      style: {
        textOutline: "none",
        fontWeight: "normal",
        fontSize: "12px"
      },
      shadow: false,
      verticalAlign: "middle"
    },
    marker: {
      enabledThreshold: 0,
      symbol: "square",
      radius: 6,
      lineWidth: 2,
      height: 15
    },
    showInLegend: false,
    colorKey: "x"
  });
  return TimelineSeries2;
}(LineSeries6);
extend85(TimelineSeries.prototype, {
  drawLegendSymbol: LegendSymbol_default.drawRectangle,
  drawTracker: ColumnSeries15.prototype.drawTracker,
  pointClass: TimelinePoint_default,
  trackerGroups: ["markerGroup", "dataLabelsGroup"]
});
SeriesRegistry_default.registerSeriesType("timeline", TimelineSeries);

// node_modules/highcharts/es-modules/Series/Organization/OrganizationPoint.js
var __extends56 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var SankeyPoint2 = SeriesRegistry_default.seriesTypes.sankey.prototype.pointClass;
var OrganizationPoint = function(_super) {
  __extends56(OrganizationPoint2, _super);
  function OrganizationPoint2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.fromNode = void 0;
    _this.linksFrom = void 0;
    _this.linksTo = void 0;
    _this.options = void 0;
    _this.series = void 0;
    _this.toNode = void 0;
    return _this;
  }
  OrganizationPoint2.prototype.getSum = function() {
    return 1;
  };
  return OrganizationPoint2;
}(SankeyPoint2);
var OrganizationPoint_default = OrganizationPoint;

// node_modules/highcharts/es-modules/Series/Organization/OrganizationSeries.js
var __extends57 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var SankeySeries2 = SeriesRegistry_default.seriesTypes.sankey;
var css15 = Utilities_default.css;
var extend86 = Utilities_default.extend;
var merge81 = Utilities_default.merge;
var pick93 = Utilities_default.pick;
var wrap12 = Utilities_default.wrap;
var OrganizationSeries = function(_super) {
  __extends57(OrganizationSeries2, _super);
  function OrganizationSeries2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.data = void 0;
    _this.options = void 0;
    _this.points = void 0;
    return _this;
  }
  OrganizationSeries2.curvedPath = function(path, r) {
    var d = [];
    for (var i = 0; i < path.length; i++) {
      var x = path[i][1];
      var y = path[i][2];
      if (typeof x === "number" && typeof y === "number") {
        if (i === 0) {
          d.push(["M", x, y]);
        } else if (i === path.length - 1) {
          d.push(["L", x, y]);
        } else if (r) {
          var prevSeg = path[i - 1];
          var nextSeg = path[i + 1];
          if (prevSeg && nextSeg) {
            var x1 = prevSeg[1], y1 = prevSeg[2], x2 = nextSeg[1], y2 = nextSeg[2];
            if (typeof x1 === "number" && typeof x2 === "number" && typeof y1 === "number" && typeof y2 === "number" && x1 !== x2 && y1 !== y2) {
              var directionX = x1 < x2 ? 1 : -1, directionY = y1 < y2 ? 1 : -1;
              d.push([
                "L",
                x - directionX * Math.min(Math.abs(x - x1), r),
                y - directionY * Math.min(Math.abs(y - y1), r)
              ], [
                "C",
                x,
                y,
                x,
                y,
                x + directionX * Math.min(Math.abs(x - x2), r),
                y + directionY * Math.min(Math.abs(y - y2), r)
              ]);
            }
          }
        } else {
          d.push(["L", x, y]);
        }
      }
    }
    return d;
  };
  OrganizationSeries2.prototype.alignDataLabel = function(point, dataLabel, options) {
    if (options.useHTML) {
      var width_1 = point.shapeArgs.width, height_1 = point.shapeArgs.height, padjust = this.options.borderWidth + 2 * this.options.dataLabels.padding;
      if (this.chart.inverted) {
        width_1 = height_1;
        height_1 = point.shapeArgs.width;
      }
      height_1 -= padjust;
      width_1 -= padjust;
      var text = dataLabel.text;
      if (text) {
        css15(text.element.parentNode, {
          width: width_1 + "px",
          height: height_1 + "px"
        });
        css15(text.element, {
          left: 0,
          top: 0,
          width: "100%",
          height: "100%",
          overflow: "hidden"
        });
      }
      dataLabel.getBBox = function() {
        return {
          width: width_1,
          height: height_1
        };
      };
      dataLabel.width = width_1;
      dataLabel.height = height_1;
    }
    _super.prototype.alignDataLabel.apply(this, arguments);
  };
  OrganizationSeries2.prototype.createNode = function(id) {
    var node = _super.prototype.createNode.call(this, id);
    node.getSum = function() {
      return 1;
    };
    return node;
  };
  OrganizationSeries2.prototype.createNodeColumn = function() {
    var column = _super.prototype.createNodeColumn.call(this);
    wrap12(column, "offset", function(proceed, node, factor) {
      var offset3 = proceed.call(this, node, factor);
      if (node.hangsFrom) {
        return {
          absoluteTop: node.hangsFrom.nodeY
        };
      }
      return offset3;
    });
    return column;
  };
  OrganizationSeries2.prototype.pointAttribs = function(point, state) {
    var series = this, attribs = SankeySeries2.prototype.pointAttribs.call(series, point, state), level = point.isNode ? point.level : point.fromNode.level, levelOptions = series.mapOptionsToLevel[level || 0] || {}, options = point.options, stateOptions = levelOptions.states && levelOptions.states[state] || {}, values = ["borderRadius", "linkColor", "linkLineWidth"].reduce(function(obj, key) {
      obj[key] = pick93(stateOptions[key], options[key], levelOptions[key], series.options[key]);
      return obj;
    }, {});
    if (!point.isNode) {
      attribs.stroke = values.linkColor;
      attribs["stroke-width"] = values.linkLineWidth;
      delete attribs.fill;
    } else {
      if (values.borderRadius) {
        attribs.r = values.borderRadius;
      }
    }
    return attribs;
  };
  OrganizationSeries2.prototype.translateLink = function(point) {
    var fromNode = point.fromNode, toNode = point.toNode, crisp = Math.round(this.options.linkLineWidth) % 2 / 2, x1 = Math.floor(fromNode.shapeArgs.x + fromNode.shapeArgs.width) + crisp, y1 = Math.floor(fromNode.shapeArgs.y + fromNode.shapeArgs.height / 2) + crisp, x2 = Math.floor(toNode.shapeArgs.x) + crisp, y2 = Math.floor(toNode.shapeArgs.y + toNode.shapeArgs.height / 2) + crisp, xMiddle, hangingIndent = this.options.hangingIndent, toOffset = toNode.options.offset, percentOffset = /%$/.test(toOffset) && parseInt(toOffset, 10), inverted = this.chart.inverted;
    if (inverted) {
      x1 -= fromNode.shapeArgs.width;
      x2 += toNode.shapeArgs.width;
    }
    xMiddle = Math.floor(x2 + (inverted ? 1 : -1) * (this.colDistance - this.nodeWidth) / 2) + crisp;
    if (percentOffset && (percentOffset >= 50 || percentOffset <= -50)) {
      xMiddle = x2 = Math.floor(x2 + (inverted ? -0.5 : 0.5) * toNode.shapeArgs.width) + crisp;
      y2 = toNode.shapeArgs.y;
      if (percentOffset > 0) {
        y2 += toNode.shapeArgs.height;
      }
    }
    if (toNode.hangsFrom === fromNode) {
      if (this.chart.inverted) {
        y1 = Math.floor(fromNode.shapeArgs.y + fromNode.shapeArgs.height - hangingIndent / 2) + crisp;
        y2 = toNode.shapeArgs.y + toNode.shapeArgs.height;
      } else {
        y1 = Math.floor(fromNode.shapeArgs.y + hangingIndent / 2) + crisp;
      }
      xMiddle = x2 = Math.floor(toNode.shapeArgs.x + toNode.shapeArgs.width / 2) + crisp;
    }
    point.plotY = 1;
    point.shapeType = "path";
    point.shapeArgs = {
      d: OrganizationSeries2.curvedPath([
        ["M", x1, y1],
        ["L", xMiddle, y1],
        ["L", xMiddle, y2],
        ["L", x2, y2]
      ], this.options.linkRadius)
    };
  };
  OrganizationSeries2.prototype.translateNode = function(node, column) {
    SankeySeries2.prototype.translateNode.call(this, node, column);
    if (node.hangsFrom) {
      node.shapeArgs.height -= this.options.hangingIndent;
      if (!this.chart.inverted) {
        node.shapeArgs.y += this.options.hangingIndent;
      }
    }
    node.nodeHeight = this.chart.inverted ? node.shapeArgs.width : node.shapeArgs.height;
  };
  OrganizationSeries2.defaultOptions = merge81(SankeySeries2.defaultOptions, {
    borderColor: Palette_default.neutralColor60,
    borderRadius: 3,
    linkRadius: 10,
    borderWidth: 1,
    dataLabels: {
      nodeFormatter: function() {
        var outerStyle = {
          width: "100%",
          height: "100%",
          display: "flex",
          "flex-direction": "row",
          "align-items": "center",
          "justify-content": "center"
        }, imageStyle = {
          "max-height": "100%",
          "border-radius": "50%"
        }, innerStyle = {
          width: "100%",
          padding: 0,
          "text-align": "center",
          "white-space": "normal"
        }, nameStyle = {
          margin: 0
        }, titleStyle = {
          margin: 0
        }, descriptionStyle = {
          opacity: 0.75,
          margin: "5px"
        };
        function styleAttr(style) {
          return Object.keys(style).reduce(function(str, key) {
            return str + key + ":" + style[key] + ";";
          }, 'style="') + '"';
        }
        if (this.point.image) {
          imageStyle["max-width"] = "30%";
          innerStyle.width = "70%";
        }
        if (this.series.chart.renderer.forExport) {
          outerStyle.display = "block";
          innerStyle.position = "absolute";
          innerStyle.left = this.point.image ? "30%" : 0;
          innerStyle.top = 0;
        }
        var html2 = "<div " + styleAttr(outerStyle) + ">";
        if (this.point.image) {
          html2 += '<img src="' + this.point.image + '" ' + styleAttr(imageStyle) + ">";
        }
        html2 += "<div " + styleAttr(innerStyle) + ">";
        if (this.point.name) {
          html2 += "<h4 " + styleAttr(nameStyle) + ">" + this.point.name + "</h4>";
        }
        if (this.point.title) {
          html2 += "<p " + styleAttr(titleStyle) + ">" + (this.point.title || "") + "</p>";
        }
        if (this.point.description) {
          html2 += "<p " + styleAttr(descriptionStyle) + ">" + this.point.description + "</p>";
        }
        html2 += "</div></div>";
        return html2;
      },
      style: {
        fontWeight: "normal",
        fontSize: "13px"
      },
      useHTML: true
    },
    hangingIndent: 20,
    linkColor: Palette_default.neutralColor60,
    linkLineWidth: 1,
    nodeWidth: 50,
    tooltip: {
      nodeFormat: "{point.name}<br>{point.title}<br>{point.description}"
    }
  });
  return OrganizationSeries2;
}(SankeySeries2);
extend86(OrganizationSeries.prototype, {
  pointClass: OrganizationPoint_default
});
SeriesRegistry_default.registerSeriesType("organization", OrganizationSeries);

// node_modules/highcharts/es-modules/Series/XRange/XRangePoint.js
var __extends58 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ColumnSeries16 = SeriesRegistry_default.seriesTypes.column;
var extend87 = Utilities_default.extend;
var XRangePoint = function(_super) {
  __extends58(XRangePoint2, _super);
  function XRangePoint2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.options = void 0;
    _this.series = void 0;
    return _this;
  }
  XRangePoint2.getColorByCategory = function(series, point) {
    var colors = series.options.colors || series.chart.options.colors, colorCount = colors ? colors.length : series.chart.options.chart.colorCount, colorIndex = point.y % colorCount, color18 = colors && colors[colorIndex];
    return {
      colorIndex,
      color: color18
    };
  };
  XRangePoint2.prototype.resolveColor = function() {
    var series = this.series, colorByPoint;
    if (series.options.colorByPoint && !this.options.color) {
      colorByPoint = XRangePoint2.getColorByCategory(series, this);
      if (!series.chart.styledMode) {
        this.color = colorByPoint.color;
      }
      if (!this.options.colorIndex) {
        this.colorIndex = colorByPoint.colorIndex;
      }
    } else if (!this.color) {
      this.color = series.color;
    }
  };
  XRangePoint2.prototype.init = function() {
    Point_default.prototype.init.apply(this, arguments);
    if (!this.y) {
      this.y = 0;
    }
    return this;
  };
  XRangePoint2.prototype.setState = function() {
    Point_default.prototype.setState.apply(this, arguments);
    this.series.drawPoint(this, this.series.getAnimationVerb());
  };
  XRangePoint2.prototype.getLabelConfig = function() {
    var point = this, cfg = Point_default.prototype.getLabelConfig.call(point), yCats = point.series.yAxis.categories;
    cfg.x2 = point.x2;
    cfg.yCategory = point.yCategory = yCats && yCats[point.y];
    return cfg;
  };
  XRangePoint2.prototype.isValid = function() {
    return typeof this.x === "number" && typeof this.x2 === "number";
  };
  return XRangePoint2;
}(ColumnSeries16.prototype.pointClass);
extend87(XRangePoint.prototype, {
  tooltipDateKeys: ["x", "x2"]
});
var XRangePoint_default = XRangePoint;

// node_modules/highcharts/es-modules/Series/XRange/XRangeComposition.js
var addEvent62 = Utilities_default.addEvent;
var pick94 = Utilities_default.pick;
addEvent62(Axis_default, "afterGetSeriesExtremes", function() {
  var axis = this, axisSeries = axis.series, dataMax, modMax;
  if (axis.isXAxis) {
    dataMax = pick94(axis.dataMax, -Number.MAX_VALUE);
    axisSeries.forEach(function(series) {
      if (series.x2Data) {
        series.x2Data.forEach(function(val) {
          if (val > dataMax) {
            dataMax = val;
            modMax = true;
          }
        });
      }
    });
    if (modMax) {
      axis.dataMax = dataMax;
    }
  }
});

// node_modules/highcharts/es-modules/Series/XRange/XRangeSeries.js
var __extends59 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var color17 = Color_default.parse;
var Series15 = SeriesRegistry_default.series;
var ColumnSeries17 = SeriesRegistry_default.seriesTypes.column;
var columnProto6 = ColumnSeries17.prototype;
var clamp20 = Utilities_default.clamp;
var correctFloat14 = Utilities_default.correctFloat;
var defined55 = Utilities_default.defined;
var extend88 = Utilities_default.extend;
var find19 = Utilities_default.find;
var isNumber51 = Utilities_default.isNumber;
var isObject13 = Utilities_default.isObject;
var merge82 = Utilities_default.merge;
var pick95 = Utilities_default.pick;
var XRangeSeries = function(_super) {
  __extends59(XRangeSeries2, _super);
  function XRangeSeries2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.data = void 0;
    _this.options = void 0;
    _this.points = void 0;
    return _this;
  }
  XRangeSeries2.prototype.init = function() {
    ColumnSeries17.prototype.init.apply(this, arguments);
    this.options.stacking = void 0;
  };
  XRangeSeries2.prototype.getColumnMetrics = function() {
    var metrics, chart = this.chart;
    function swapAxes() {
      chart.series.forEach(function(s) {
        var xAxis = s.xAxis;
        s.xAxis = s.yAxis;
        s.yAxis = xAxis;
      });
    }
    swapAxes();
    metrics = columnProto6.getColumnMetrics.call(this);
    swapAxes();
    return metrics;
  };
  XRangeSeries2.prototype.cropData = function(xData, yData, min, max) {
    var cropData = Series15.prototype.cropData, crop = cropData.call(this, this.x2Data, yData, min, max);
    crop.xData = xData.slice(crop.start, crop.end);
    return crop;
  };
  XRangeSeries2.prototype.findPointIndex = function(options) {
    var _a15 = this, cropped = _a15.cropped, cropStart = _a15.cropStart, points = _a15.points;
    var id = options.id;
    var pointIndex;
    if (id) {
      var point = find19(points, function(point2) {
        return point2.id === id;
      });
      pointIndex = point ? point.index : void 0;
    }
    if (typeof pointIndex === "undefined") {
      var point = find19(points, function(point2) {
        return point2.x === options.x && point2.x2 === options.x2 && !point2.touched;
      });
      pointIndex = point ? point.index : void 0;
    }
    if (cropped && isNumber51(pointIndex) && isNumber51(cropStart) && pointIndex >= cropStart) {
      pointIndex -= cropStart;
    }
    return pointIndex;
  };
  XRangeSeries2.prototype.translatePoint = function(point) {
    var series = this, xAxis = series.xAxis, yAxis = series.yAxis, metrics = series.columnMetrics, options = series.options, minPointLength = options.minPointLength || 0, oldColWidth = (point.shapeArgs && point.shapeArgs.width || 0) / 2, seriesXOffset = series.pointXOffset = metrics.offset, plotX = point.plotX, posX = pick95(point.x2, point.x + (point.len || 0)), plotX2 = xAxis.translate(posX, 0, 0, 0, 1), length = Math.abs(plotX2 - plotX), widthDifference, partialFill, inverted = this.chart.inverted, borderWidth = pick95(options.borderWidth, 1), crisper = borderWidth % 2 / 2, yOffset = metrics.offset, pointHeight = Math.round(metrics.width), dlLeft, dlRight, dlWidth, clipRectWidth, tooltipYOffset;
    if (minPointLength) {
      widthDifference = minPointLength - length;
      if (widthDifference < 0) {
        widthDifference = 0;
      }
      plotX -= widthDifference / 2;
      plotX2 += widthDifference / 2;
    }
    plotX = Math.max(plotX, -10);
    plotX2 = clamp20(plotX2, -10, xAxis.len + 10);
    if (defined55(point.options.pointWidth)) {
      yOffset -= (Math.ceil(point.options.pointWidth) - pointHeight) / 2;
      pointHeight = Math.ceil(point.options.pointWidth);
    }
    if (options.pointPlacement && isNumber51(point.plotY) && yAxis.categories) {
      point.plotY = yAxis.translate(point.y, 0, 1, 0, 1, options.pointPlacement);
    }
    var x = Math.floor(Math.min(plotX, plotX2)) + crisper;
    var x2 = Math.floor(Math.max(plotX, plotX2)) + crisper;
    var shapeArgs = {
      x,
      y: Math.floor(point.plotY + yOffset) + crisper,
      width: x2 - x,
      height: pointHeight,
      r: series.options.borderRadius
    };
    point.shapeArgs = shapeArgs;
    if (!inverted) {
      point.tooltipPos[0] -= oldColWidth + seriesXOffset - shapeArgs.width / 2;
    } else {
      point.tooltipPos[1] += seriesXOffset + oldColWidth;
    }
    dlLeft = shapeArgs.x;
    dlRight = dlLeft + shapeArgs.width;
    if (dlLeft < 0 || dlRight > xAxis.len) {
      dlLeft = clamp20(dlLeft, 0, xAxis.len);
      dlRight = clamp20(dlRight, 0, xAxis.len);
      dlWidth = dlRight - dlLeft;
      point.dlBox = merge82(shapeArgs, {
        x: dlLeft,
        width: dlRight - dlLeft,
        centerX: dlWidth ? dlWidth / 2 : null
      });
    } else {
      point.dlBox = null;
    }
    var tooltipPos = point.tooltipPos;
    var xIndex = !inverted ? 0 : 1;
    var yIndex = !inverted ? 1 : 0;
    tooltipYOffset = series.columnMetrics ? series.columnMetrics.offset : -metrics.width / 2;
    if (!inverted) {
      tooltipPos[xIndex] += (xAxis.reversed ? -1 : 0) * shapeArgs.width;
    } else {
      tooltipPos[xIndex] += shapeArgs.width / 2;
    }
    tooltipPos[yIndex] = clamp20(tooltipPos[yIndex] + (inverted ? -1 : 1) * tooltipYOffset, 0, yAxis.len - 1);
    partialFill = point.partialFill;
    if (partialFill) {
      if (isObject13(partialFill)) {
        partialFill = partialFill.amount;
      }
      if (!isNumber51(partialFill)) {
        partialFill = 0;
      }
      point.partShapeArgs = merge82(shapeArgs, {
        r: series.options.borderRadius
      });
      clipRectWidth = Math.max(Math.round(length * partialFill + point.plotX - plotX), 0);
      point.clipRectArgs = {
        x: xAxis.reversed ? shapeArgs.x + length - clipRectWidth : shapeArgs.x,
        y: shapeArgs.y,
        width: clipRectWidth,
        height: shapeArgs.height
      };
    }
  };
  XRangeSeries2.prototype.translate = function() {
    columnProto6.translate.apply(this, arguments);
    this.points.forEach(function(point) {
      this.translatePoint(point);
    }, this);
  };
  XRangeSeries2.prototype.drawPoint = function(point, verb) {
    var series = this, seriesOpts = series.options, renderer = series.chart.renderer, graphic = point.graphic, type = point.shapeType, shapeArgs = point.shapeArgs, partShapeArgs = point.partShapeArgs, clipRectArgs = point.clipRectArgs, pfOptions = point.partialFill, cutOff = seriesOpts.stacking && !seriesOpts.borderRadius, pointState = point.state, stateOpts = seriesOpts.states[pointState || "normal"] || {}, pointStateVerb = typeof pointState === "undefined" ? "attr" : verb, pointAttr = series.pointAttribs(point, pointState), animation = pick95(series.chart.options.chart.animation, stateOpts.animation), fill;
    if (!point.isNull && point.visible !== false) {
      if (graphic) {
        graphic.rect[verb](shapeArgs);
      } else {
        point.graphic = graphic = renderer.g("point").addClass(point.getClassName()).add(point.group || series.group);
        graphic.rect = renderer[type](merge82(shapeArgs)).addClass(point.getClassName()).addClass("highcharts-partfill-original").add(graphic);
      }
      if (partShapeArgs) {
        if (graphic.partRect) {
          graphic.partRect[verb](merge82(partShapeArgs));
          graphic.partialClipRect[verb](merge82(clipRectArgs));
        } else {
          graphic.partialClipRect = renderer.clipRect(clipRectArgs.x, clipRectArgs.y, clipRectArgs.width, clipRectArgs.height);
          graphic.partRect = renderer[type](partShapeArgs).addClass("highcharts-partfill-overlay").add(graphic).clip(graphic.partialClipRect);
        }
      }
      if (!series.chart.styledMode) {
        graphic.rect[verb](pointAttr, animation).shadow(seriesOpts.shadow, null, cutOff);
        if (partShapeArgs) {
          if (!isObject13(pfOptions)) {
            pfOptions = {};
          }
          if (isObject13(seriesOpts.partialFill)) {
            pfOptions = merge82(seriesOpts.partialFill, pfOptions);
          }
          fill = pfOptions.fill || color17(pointAttr.fill).brighten(-0.3).get() || color17(point.color || series.color).brighten(-0.3).get();
          pointAttr.fill = fill;
          graphic.partRect[pointStateVerb](pointAttr, animation).shadow(seriesOpts.shadow, null, cutOff);
        }
      }
    } else if (graphic) {
      point.graphic = graphic.destroy();
    }
  };
  XRangeSeries2.prototype.drawPoints = function() {
    var series = this, verb = series.getAnimationVerb();
    series.points.forEach(function(point) {
      series.drawPoint(point, verb);
    });
  };
  XRangeSeries2.prototype.getAnimationVerb = function() {
    return this.chart.pointCount < (this.options.animationLimit || 250) ? "animate" : "attr";
  };
  XRangeSeries2.prototype.isPointInside = function(point) {
    var shapeArgs = point.shapeArgs, plotX = point.plotX, plotY = point.plotY;
    if (!shapeArgs) {
      return _super.prototype.isPointInside.apply(this, arguments);
    }
    var isInside = typeof plotX !== "undefined" && typeof plotY !== "undefined" && plotY >= 0 && plotY <= this.yAxis.len && (shapeArgs.x || 0) + (shapeArgs.width || 0) >= 0 && plotX <= this.xAxis.len;
    return isInside;
  };
  XRangeSeries2.defaultOptions = merge82(ColumnSeries17.defaultOptions, {
    colorByPoint: true,
    dataLabels: {
      formatter: function() {
        var point = this.point, amount = point.partialFill;
        if (isObject13(amount)) {
          amount = amount.amount;
        }
        if (isNumber51(amount) && amount > 0) {
          return correctFloat14(amount * 100) + "%";
        }
      },
      inside: true,
      verticalAlign: "middle"
    },
    tooltip: {
      headerFormat: '<span style="font-size: 10px">{point.x} - {point.x2}</span><br/>',
      pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.yCategory}</b><br/>'
    },
    borderRadius: 3,
    pointRange: 0
  });
  return XRangeSeries2;
}(ColumnSeries17);
extend88(XRangeSeries.prototype, {
  type: "xrange",
  parallelArrays: ["x", "x2", "y"],
  requireSorting: false,
  animate: Series15.prototype.animate,
  cropShoulder: 1,
  getExtremesFromAll: true,
  autoIncrement: Globals_default.noop,
  buildKDTree: Globals_default.noop,
  pointClass: XRangePoint_default
});
SeriesRegistry_default.registerSeriesType("xrange", XRangeSeries);

// node_modules/highcharts/es-modules/Series/Bullet/BulletPoint.js
var __extends60 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var BulletPoint = function(_super) {
  __extends60(BulletPoint2, _super);
  function BulletPoint2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.options = void 0;
    _this.series = void 0;
    return _this;
  }
  BulletPoint2.prototype.destroy = function() {
    if (this.targetGraphic) {
      this.targetGraphic = this.targetGraphic.destroy();
    }
    _super.prototype.destroy.apply(this, arguments);
    return;
  };
  return BulletPoint2;
}(ColumnSeries_default.prototype.pointClass);
var BulletPoint_default = BulletPoint;

// node_modules/highcharts/es-modules/Series/Bullet/BulletSeries.js
var __extends61 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ColumnSeries18 = SeriesRegistry_default.seriesTypes.column;
var extend89 = Utilities_default.extend;
var isNumber52 = Utilities_default.isNumber;
var merge83 = Utilities_default.merge;
var pick96 = Utilities_default.pick;
var relativeLength11 = Utilities_default.relativeLength;
var BulletSeries = function(_super) {
  __extends61(BulletSeries2, _super);
  function BulletSeries2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.data = void 0;
    _this.options = void 0;
    _this.points = void 0;
    _this.targetData = void 0;
    return _this;
  }
  BulletSeries2.prototype.drawPoints = function() {
    var series = this, chart = series.chart, options = series.options, animationLimit = options.animationLimit || 250;
    _super.prototype.drawPoints.apply(this, arguments);
    series.points.forEach(function(point) {
      var pointOptions = point.options, targetVal = point.target, pointVal = point.y;
      var targetShapeArgs, targetGraphic = point.targetGraphic, width, height, targetOptions, y;
      if (isNumber52(targetVal) && targetVal !== null) {
        targetOptions = merge83(options.targetOptions, pointOptions.targetOptions);
        height = targetOptions.height;
        var shapeArgs = point.shapeArgs;
        if (point.dlBox && shapeArgs && !isNumber52(shapeArgs.width)) {
          shapeArgs = point.dlBox;
        }
        width = relativeLength11(targetOptions.width, shapeArgs.width);
        y = series.yAxis.translate(targetVal, false, true, false, true) - targetOptions.height / 2 - 0.5;
        targetShapeArgs = series.crispCol.apply({
          chart,
          borderWidth: targetOptions.borderWidth,
          options: {
            crisp: options.crisp
          }
        }, [
          shapeArgs.x + shapeArgs.width / 2 - width / 2,
          y,
          width,
          height
        ]);
        if (targetGraphic) {
          targetGraphic[chart.pointCount < animationLimit ? "animate" : "attr"](targetShapeArgs);
          if (isNumber52(pointVal) && pointVal !== null) {
            targetGraphic.element.point = point;
          } else {
            targetGraphic.element.point = void 0;
          }
        } else {
          point.targetGraphic = targetGraphic = chart.renderer.rect().attr(targetShapeArgs).add(series.group);
        }
        if (!chart.styledMode) {
          targetGraphic.attr({
            fill: pick96(targetOptions.color, pointOptions.color, series.zones.length && (point.getZone.call({
              series,
              x: point.x,
              y: targetVal,
              options: {}
            }).color || series.color) || void 0, point.color, series.color),
            stroke: pick96(targetOptions.borderColor, point.borderColor, series.options.borderColor),
            "stroke-width": targetOptions.borderWidth,
            r: targetOptions.borderRadius
          });
        }
        if (isNumber52(pointVal) && pointVal !== null) {
          targetGraphic.element.point = point;
        }
        targetGraphic.addClass(point.getClassName() + " highcharts-bullet-target", true);
      } else if (targetGraphic) {
        point.targetGraphic = targetGraphic.destroy();
      }
    });
  };
  BulletSeries2.prototype.getExtremes = function(yData) {
    var dataExtremes = _super.prototype.getExtremes.call(this, yData), series = this, targetData = series.targetData;
    var yMax, yMin;
    if (targetData && targetData.length) {
      var targetExtremes = _super.prototype.getExtremes.call(this, targetData);
      if (isNumber52(targetExtremes.dataMin)) {
        dataExtremes.dataMin = Math.min(pick96(dataExtremes.dataMin, Infinity), targetExtremes.dataMin);
      }
      if (isNumber52(targetExtremes.dataMax)) {
        dataExtremes.dataMax = Math.max(pick96(dataExtremes.dataMax, -Infinity), targetExtremes.dataMax);
      }
    }
    return dataExtremes;
  };
  BulletSeries2.defaultOptions = merge83(ColumnSeries18.defaultOptions, {
    targetOptions: {
      width: "140%",
      height: 3,
      borderWidth: 0,
      borderRadius: 0
    },
    tooltip: {
      pointFormat: '<span style="color:{series.color}">\u25CF</span> {series.name}: <b>{point.y}</b>. Target: <b>{point.target}</b><br/>'
    }
  });
  return BulletSeries2;
}(ColumnSeries18);
extend89(BulletSeries.prototype, {
  parallelArrays: ["x", "y", "target"],
  pointArrayMap: ["y", "target"]
});
BulletSeries.prototype.pointClass = BulletPoint_default;
SeriesRegistry_default.registerSeriesType("bullet", BulletSeries);

// node_modules/@vaadin/charts/src/vaadin-chart-series.js
var ChartSeries = class extends PolymerElement {
  static get is() {
    return "vaadin-chart-series";
  }
  get options() {
    const options = deepMerge({}, this.additionalOptions);
    if (this.type) {
      options.type = this.type;
    }
    if (this.title) {
      options.name = this.title;
    }
    if (this.values) {
      options.data = this.values;
    }
    if (this.markers) {
      if (!this.__isMarkersValid()) {
        this.markers = "auto";
      }
      options.marker = this.__markersConfiguration;
    }
    if (this.unit) {
      options.yAxis = this.unit;
    }
    if (this.stack) {
      options.stack = this.stack;
    }
    if (isFinite(this.valueMin)) {
      options.yAxisValueMin = this.valueMin;
    }
    if (isFinite(this.valueMax)) {
      options.yAxisValueMax = this.valueMax;
    }
    if (this.neckWidth) {
      options.neckWidth = this.neckWidth;
    }
    if (this.neckPosition) {
      options.neckHeight = this.neckPosition;
    }
    return options;
  }
  static get properties() {
    return {
      values: {
        type: Array,
        value: () => []
      },
      valueMin: {
        type: Number,
        reflectToAttribute: true
      },
      valueMax: {
        type: Number,
        reflectToAttribute: true
      },
      type: {
        type: String,
        reflectToAttribute: true
      },
      title: {
        type: String,
        reflectToAttribute: true
      },
      markers: {
        type: String,
        reflectToAttribute: true
      },
      unit: {
        type: String,
        reflectToAttribute: true
      },
      stack: {
        type: String,
        reflectToAttribute: true
      },
      neckPosition: {
        type: String,
        reflectToAttribute: true
      },
      neckWidth: {
        type: String,
        reflectToAttribute: true
      },
      options: {
        type: Object
      },
      additionalOptions: {
        type: Object,
        reflectToAttribute: true
      },
      _series: {
        type: Object
      }
    };
  }
  static get observers() {
    return [
      "__additionalOptionsObserver(additionalOptions.*, _series)",
      "__markersObserver(markers, _series)",
      "__neckPositionObserver(neckPosition, _series)",
      "__neckWidthObserver(neckWidth, _series)",
      "__stackObserver(stack, _series)",
      "__titleObserver(title, _series)",
      "__typeObserver(type, _series)",
      "__unitObserver(unit, valueMin, valueMax, _series)",
      "__valueMinObserver(valueMin, _series)",
      "__valueMaxObserver(valueMax, _series)",
      "__valuesObserver(values.splices, _series)"
    ];
  }
  setSeries(series) {
    this._series = series;
  }
  __valuesObserver(splices, series) {
    if (series) {
      series.setData(this.values);
    }
  }
  __additionalOptionsObserver(additionalOptions, series) {
    if (series && additionalOptions.base) {
      series.update(additionalOptions.base);
    }
  }
  __updateAxis(series, value, key) {
    if (!isFinite(value)) {
      this.__showWarn(`value-${key}`, "Numbers or null");
      return;
    }
    if (series && series.yAxis) {
      series.yAxis.update({ [key]: value });
    }
  }
  __valueMinObserver(valueMin, series) {
    if (valueMin === void 0 || series === void 0) {
      return;
    }
    this.__updateAxis(series, valueMin, "min");
  }
  __valueMaxObserver(valueMax, series) {
    if (valueMax === void 0 || series === void 0) {
      return;
    }
    this.__updateAxis(series, valueMax, "max");
  }
  __typeObserver(type, series) {
    if (type && series) {
      series.update({ type });
    }
  }
  __titleObserver(title, series) {
    if (title === void 0 || series === void 0) {
      return;
    }
    series.update({ name: title });
  }
  __stackObserver(stack, series) {
    if (stack === void 0 || series === void 0) {
      return;
    }
    series.update({ stack });
  }
  __neckPositionObserver(neckPosition, series) {
    if (neckPosition === void 0 || series === void 0) {
      return;
    }
    series.update({ neckHeight: neckPosition });
  }
  __neckWidthObserver(neckWidth, series) {
    if (neckWidth === void 0 || series === void 0) {
      return;
    }
    series.update({ neckWidth });
  }
  __unitObserver(unit, valueMin, valueMax, series) {
    if (series && unit !== this.__oldUnit) {
      this.__oldUnit = unit;
      const parent = this.parentNode instanceof _Chart && this.parentNode;
      if (parent && parent instanceof _Chart) {
        if (unit && !parent.__getAxis(unit)) {
          const title = { title: { text: unit } };
          parent.__addAxis(__spreadValues({ id: unit, axisGenerated: true }, title));
        }
        series.update({ yAxis: unit || 0 });
        if (valueMin !== void 0) {
          this.__updateAxis(series, valueMin, "min");
        }
        if (valueMax !== void 0) {
          this.__updateAxis(series, valueMax, "max");
        }
        parent.__removeAxisIfEmpty();
      }
    }
  }
  __isMarkersValid() {
    if (["shown", "hidden", "auto"].indexOf(this.markers) === -1) {
      this.__showWarn("markers", '"shown", "hidden" or "auto"');
      return false;
    }
    return true;
  }
  __markersObserver(markers, series) {
    if (markers === void 0 || series === void 0) {
      return;
    }
    if (!this.__isMarkersValid()) {
      this.markers = "auto";
      return;
    }
    series.update({
      marker: this.__markersConfiguration
    });
  }
  get __markersConfiguration() {
    const config = {};
    switch (this.markers) {
      case "shown":
        config.enabled = true;
        break;
      case "hidden":
        config.enabled = false;
        break;
      case "auto":
      default:
        config.enabled = null;
        break;
    }
    return config;
  }
  __showWarn(propertyName, acceptedValues) {
    console.warn('<vaadin-chart-series> Acceptable values for "' + propertyName + '" are ' + acceptedValues);
  }
};
customElements.define(ChartSeries.is, ChartSeries);

// node_modules/@vaadin/charts/src/vaadin-chart.js
function deepMerge(target, source) {
  const isObject14 = (item) => item && typeof item === "object" && !Array.isArray(item);
  if (isObject14(source) && isObject14(target)) {
    for (const key in source) {
      if (isObject14(source[key])) {
        if (!target[key]) {
          Object.assign(target, { [key]: {} });
        }
        deepMerge(target[key], source[key]);
      } else {
        Object.assign(target, { [key]: source[key] });
      }
    }
  }
  return target;
}
["exportChart", "exportChartLocal", "getSVG"].forEach((methodName) => {
  highstock_src_default.wrap(highstock_src_default.Chart.prototype, methodName, function(proceed, ...args) {
    highstock_src_default.fireEvent(this, "beforeExport");
    const result2 = proceed.apply(this, args);
    highstock_src_default.fireEvent(this, "afterExport");
    return result2;
  });
});
var _Chart = class extends ResizeMixin(ElementMixin(ThemableMixin(PolymerElement))) {
  static get template() {
    return html`
      <style>
        :host {
          display: block;
          width: 100%;
          overflow: hidden;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
      <div id="chart"></div>
      <slot id="slot"></slot>
    `;
  }
  static get is() {
    return "vaadin-chart";
  }
  static __callHighchartsFunction(functionName, redrawCharts, ...args) {
    const functionToCall = highstock_src_default[functionName];
    if (functionToCall && typeof functionToCall === "function") {
      functionToCall.apply(this.configuration, args);
      if (redrawCharts) {
        highstock_src_default.charts.forEach((c) => c.redraw());
      }
    }
  }
  static get properties() {
    return {
      configuration: Object,
      categories: {
        type: Object,
        reflectToAttribute: true
      },
      categoryMax: {
        type: Number,
        reflectToAttribute: true
      },
      categoryMin: {
        type: Number,
        reflectToAttribute: true
      },
      categoryPosition: {
        type: String,
        reflectToAttribute: true
      },
      noLegend: {
        type: Boolean,
        reflectToAttribute: true
      },
      stacking: {
        type: String,
        reflectToAttribute: true
      },
      timeline: {
        type: Boolean,
        reflectToAttribute: true
      },
      title: {
        type: String,
        reflectToAttribute: true
      },
      tooltip: {
        type: Boolean,
        reflectToAttribute: true
      },
      type: {
        type: String,
        reflectToAttribute: true
      },
      subtitle: {
        type: String,
        reflectToAttribute: true
      },
      chart3d: {
        type: Boolean,
        reflectToAttribute: true
      },
      emptyText: {
        type: String,
        value: " ",
        reflectToAttribute: true
      },
      additionalOptions: {
        type: Object,
        reflectToAttribute: true
      },
      polar: {
        type: Boolean,
        reflectToAttribute: true
      }
    };
  }
  static get observers() {
    return [
      "__chart3dObserver(chart3d, configuration)",
      "__emptyTextObserver(emptyText, configuration)",
      "__hideLegend(noLegend, configuration)",
      "__polarObserver(polar, configuration)",
      "__stackingObserver(stacking, configuration)",
      "__tooltipObserver(tooltip, configuration)",
      "__updateCategories(categories, configuration)",
      "__updateCategoryMax(categoryMax, configuration)",
      "__updateCategoryMin(categoryMin, configuration)",
      "__updateCategoryPosition(categoryPosition, configuration)",
      "__updateSubtitle(subtitle, configuration)",
      "__updateTitle(title, configuration)",
      "__updateType(type, configuration)",
      "__updateAdditionalOptions(additionalOptions.*)"
    ];
  }
  static _finalizeClass() {
    super._finalizeClass();
    const devModeCallback = window.Vaadin.developmentModeCallback;
    const licenseChecker = devModeCallback && devModeCallback["vaadin-license-checker"];
    if (typeof licenseChecker === "function") {
      licenseChecker(_Chart);
    }
  }
  constructor() {
    super();
    this._baseConfig = {
      chart: {
        styledMode: true
      },
      credits: {
        enabled: false
      },
      exporting: {
        enabled: false
      },
      title: {
        text: null
      },
      series: [],
      xAxis: {},
      yAxis: {
        axisGenerated: true
      }
    };
    this._baseChart3d = {
      enabled: true,
      alpha: 15,
      beta: 15,
      depth: 50
    };
  }
  connectedCallback() {
    super.connectedCallback();
    this.__updateStyles();
    beforeNextRender(this, () => {
      if (this.configuration) {
        this.__reflow();
        return;
      }
      const options = __spreadValues(__spreadValues({}, this.options), this._jsonConfigurationBuffer);
      this._jsonConfigurationBuffer = null;
      this.__initChart(options);
      this.__addChildObserver();
    });
  }
  get options() {
    const options = __spreadValues({}, this._baseConfig);
    deepMerge(options, this.additionalOptions);
    if (this.type) {
      options.chart = options.chart || {};
      options.chart.type = this.type;
    }
    if (this.polar) {
      options.chart = options.chart || {};
      options.chart.polar = true;
    }
    if (this.title) {
      options.title = {
        text: this.title
      };
    }
    if (!options.tooltip) {
      options.tooltip = {};
      if (!this.tooltip) {
        options.tooltip.enabled = false;
      }
    }
    if (this.subtitle) {
      options.subtitle = {
        text: this.subtitle
      };
    }
    if (this.categories) {
      options.xAxis = options.xAxis || {};
      if (Array.isArray(options.xAxis)) {
        options.xAxis[0].categories = this.categories;
      } else {
        options.xAxis.categories = this.categories;
      }
    }
    if (isFinite(this.categoryMin)) {
      options.xAxis = options.xAxis || {};
      if (Array.isArray(options.xAxis)) {
        options.xAxis[0].min = this.categoryMin;
      } else {
        options.xAxis.min = this.categoryMin;
      }
    }
    if (isFinite(this.categoryMax)) {
      options.xAxis = options.xAxis || {};
      if (Array.isArray(options.xAxis)) {
        options.xAxis[0].max = this.categoryMax;
      } else {
        options.xAxis.max = this.categoryMax;
      }
    }
    if (this.noLegend) {
      options.legend = {
        enabled: false
      };
    }
    if (this.emptyText) {
      options.lang = options.lang || {};
      options.lang.noData = this.emptyText;
    }
    if (this.categoryPosition) {
      options.chart = options.chart || {};
      options.chart.inverted = this.__shouldInvert();
      if (Array.isArray(options.xAxis)) {
        options.xAxis.forEach((e2) => e2.opposite = this.__shouldFlipOpposite());
      } else if (options.xAxis) {
        options.xAxis.opposite = this.__shouldFlipOpposite();
      }
    }
    if (this.stacking) {
      options.plotOptions = options.plotOptions || {};
      options.plotOptions.series = options.plotOptions.series || {};
      options.plotOptions.series.stacking = this.stacking;
    }
    if (this.chart3d) {
      options.chart = options.chart || {};
      options.chart.options3d = __spreadValues(__spreadValues({}, this._baseChart3d), options.chart.options3d);
    }
    return options;
  }
  get __chartEventNames() {
    return {
      addSeries: "chart-add-series",
      afterExport: "chart-after-export",
      afterPrint: "chart-after-print",
      beforeExport: "chart-before-export",
      beforePrint: "chart-before-print",
      click: "chart-click",
      drilldown: "chart-drilldown",
      drillup: "chart-drillup",
      drillupall: "chart-drillupall",
      load: "chart-load",
      redraw: "chart-redraw",
      selection: "chart-selection"
    };
  }
  get __seriesEventNames() {
    return {
      afterAnimate: "series-after-animate",
      checkboxClick: "series-checkbox-click",
      click: "series-click",
      hide: "series-hide",
      legendItemClick: "series-legend-item-click",
      mouseOut: "series-mouse-out",
      mouseOver: "series-mouse-over",
      show: "series-show"
    };
  }
  get __pointEventNames() {
    return {
      click: "point-click",
      legendItemClick: "point-legend-item-click",
      mouseOut: "point-mouse-out",
      mouseOver: "point-mouse-over",
      remove: "point-remove",
      select: "point-select",
      unselect: "point-unselect",
      update: "point-update"
    };
  }
  get __xAxesEventNames() {
    return {
      afterSetExtremes: "xaxes-extremes-set"
    };
  }
  get __yAxesEventNames() {
    return {
      afterSetExtremes: "yaxes-extremes-set"
    };
  }
  _onResize(contentRect) {
    if (!this.configuration) {
      return;
    }
    const { height, width } = contentRect;
    const { chartHeight, chartWidth } = this.configuration;
    if (height !== chartHeight || width !== chartWidth) {
      this.__reflow();
    }
  }
  __reflow() {
    if (!this.configuration) {
      return;
    }
    this.configuration.reflow();
  }
  __addChildObserver() {
    this._childObserver = new FlattenedNodesObserver(this.$.slot, (info) => {
      this.__addSeries(info.addedNodes.filter(this.__filterSeriesNodes));
      this.__removeSeries(info.removedNodes.filter(this.__filterSeriesNodes));
      this.__cleanupAfterSeriesRemoved(info.removedNodes.filter(this.__filterSeriesNodes));
    });
  }
  __filterSeriesNodes(node) {
    return node.nodeType === Node.ELEMENT_NODE && node instanceof ChartSeries;
  }
  __addSeries(series) {
    if (this.__isSeriesEmpty(series)) {
      return;
    }
    const seriesNodes = Array.from(this.childNodes).filter(this.__filterSeriesNodes);
    const yAxes = this.configuration.yAxis.reduce((acc, axis, index) => {
      acc[axis.options.id || index] = axis;
      return acc;
    }, {});
    for (let i = 0, len = series.length; i < len; i++) {
      const seriesElement = series[i];
      const { yAxis: unit, yAxisValueMin: valueMin, yAxisValueMax: valueMax } = seriesElement.options;
      const idxOnChildList = seriesNodes.indexOf(seriesElement);
      if (!unit && !this.configuration.yAxis.some((e2) => e2.userOptions.id === void 0)) {
        yAxes[unit] = this.__addAxis({ axisGenerated: true });
      } else if (unit && !yAxes[unit]) {
        yAxes[unit] = this.__addAxis({ id: unit, title: { text: unit }, axisGenerated: true });
      }
      if (isFinite(valueMin)) {
        this.__setYAxisProps(yAxes, unit, { min: valueMin });
      }
      if (isFinite(valueMax)) {
        this.__setYAxisProps(yAxes, unit, { max: valueMax });
      }
      const seriesConfiguration = this.__updateOrAddSeriesInstance(seriesElement.options, idxOnChildList, false);
      seriesElement.setSeries(seriesConfiguration);
    }
    this.__removeAxisIfEmpty();
    this.configuration.redraw();
  }
  __removeSeries(seriesNodes) {
    if (this.__isSeriesEmpty(seriesNodes)) {
      return;
    }
    seriesNodes.forEach((series) => {
      if (series instanceof ChartSeries) {
        series._series.remove();
      }
    });
  }
  __setYAxisProps(yAxes, yAxisId, props) {
    if (yAxisId) {
      yAxes[yAxisId].update(props);
    } else {
      this.configuration.yAxis[0].update(props);
    }
  }
  __isSeriesEmpty(series) {
    return series === null || series.length === 0;
  }
  __cleanupAfterSeriesRemoved(series) {
    if (this.__isSeriesEmpty(series)) {
      return;
    }
    this.__removeAxisIfEmpty();
    const isEmpty = this.configuration.series.length === 0 || this.configuration.series.map((e2) => e2.data.length === 0).reduce((e1, e2) => e1 && e2, true);
    if (isEmpty) {
      this.configuration.hideNoData();
      this.configuration.showNoData(this.emptyText);
    }
  }
  __initChart(options) {
    this.__initEventsListeners(options);
    this.__updateStyledMode(options);
    if (this.timeline) {
      this.configuration = highstock_src_default.stockChart(this.$.chart, options);
    } else {
      this.configuration = highstock_src_default.chart(this.$.chart, options);
    }
  }
  __updateStyledMode(options) {
    const styledMode = options.chart.styledMode;
    this.$.chart.toggleAttribute("styled-mode", !!styledMode);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this._childObserver && this._childObserver.disconnect();
  }
  __getAxis(id, isXAxis) {
    id = Number.parseInt(id) || id;
    if (this.configuration) {
      return (isXAxis ? this.configuration.xAxis : this.configuration.yAxis).find((axis) => axis.options.id === id);
    }
  }
  __addAxis(options, isXAxis) {
    if (this.configuration) {
      this.__createEventListeners(isXAxis ? this.__xAxesEventNames : this.__yAxesEventNames, options, "events", "axis");
      return this.configuration.addAxis(options, isXAxis);
    }
  }
  __removeAxisIfEmpty(isXAxis) {
    if (this.configuration) {
      (isXAxis ? this.configuration.xAxis : this.configuration.yAxis).forEach((axis) => {
        if (axis.userOptions.axisGenerated && axis.series.length === 0) {
          axis.remove();
        }
      });
    }
  }
  updateConfiguration(jsonConfiguration2, resetConfiguration) {
    if (resetConfiguration || !this._jsonConfigurationBuffer) {
      this._jsonConfigurationBuffer = {};
    }
    const configCopy = deepMerge({}, jsonConfiguration2);
    this.__inflateFunctions(configCopy);
    this._jsonConfigurationBuffer = this.__makeConfigurationBuffer(this._jsonConfigurationBuffer, configCopy);
    beforeNextRender(this, () => {
      if (!this.configuration || !this._jsonConfigurationBuffer) {
        return;
      }
      if (resetConfiguration) {
        const initialOptions = __spreadValues(__spreadValues({}, this.options), this._jsonConfigurationBuffer);
        this.__initChart(initialOptions);
        this._jsonConfigurationBuffer = null;
        return;
      }
      this.configuration.update(this._jsonConfigurationBuffer, false);
      if (this._jsonConfigurationBuffer.credits) {
        this.__updateOrAddCredits(this._jsonConfigurationBuffer.credits);
      }
      if (this._jsonConfigurationBuffer.xAxis) {
        this.__updateOrAddAxes(this._jsonConfigurationBuffer.xAxis, true, false);
      }
      if (this._jsonConfigurationBuffer.yAxis) {
        this.__updateOrAddAxes(this._jsonConfigurationBuffer.yAxis, false, false);
      }
      if (this._jsonConfigurationBuffer.series) {
        this.__updateOrAddSeries(this._jsonConfigurationBuffer.series, false);
      }
      this._jsonConfigurationBuffer = null;
      this.configuration.redraw();
    });
  }
  __makeConfigurationBuffer(target, source) {
    const _source = highstock_src_default.merge(source);
    const _target = highstock_src_default.merge(target);
    this.__mergeConfigurationArray(_target, _source, "series");
    this.__mergeConfigurationArray(_target, _source, "xAxis");
    this.__mergeConfigurationArray(_target, _source, "yAxis");
    return highstock_src_default.merge(_target, _source);
  }
  __mergeConfigurationArray(target, configuration, entry) {
    if (!configuration || !configuration[entry] || !Array.isArray(configuration[entry])) {
      return;
    }
    if (!target[entry]) {
      target[entry] = Array.from(configuration[entry]);
      return;
    }
    const maxLength = Math.max(target[entry].length, configuration[entry].length);
    for (let i = 0; i < maxLength; i++) {
      target[entry][i] = highstock_src_default.merge(target[entry][i], configuration[entry][i]);
    }
    delete configuration[entry];
  }
  __inflateFunctions(jsonConfiguration) {
    for (const attr in jsonConfiguration) {
      if (jsonConfiguration.hasOwnProperty(attr)) {
        const targetProperty = jsonConfiguration[attr];
        if (attr.indexOf("_fn_") === 0 && (typeof targetProperty === "string" || targetProperty instanceof String)) {
          try {
            jsonConfiguration[attr.substr(4)] = eval("(" + targetProperty + ")");
          } catch (e) {
            jsonConfiguration[attr.substr(4)] = eval("(function(){" + targetProperty + "})");
          }
          delete jsonConfiguration[attr];
        } else if (targetProperty instanceof Object) {
          this.__inflateFunctions(targetProperty);
        }
      }
    }
  }
  __initEventsListeners(configuration) {
    this.__initChartEventsListeners(configuration);
    this.__initSeriesEventsListeners(configuration);
    this.__initPointsEventsListeners(configuration);
    this.__initAxisEventsListeners(configuration, true);
    this.__initAxisEventsListeners(configuration, false);
  }
  __initChartEventsListeners(configuration) {
    this.__createEventListeners(this.__chartEventNames, configuration, "chart.events", "chart");
  }
  __initSeriesEventsListeners(configuration) {
    this.__createEventListeners(this.__seriesEventNames, configuration, "plotOptions.series.events", "series");
  }
  __initPointsEventsListeners(configuration) {
    this.__createEventListeners(this.__pointEventNames, configuration, "plotOptions.series.point.events", "point");
  }
  __initAxisEventsListeners(configuration, isXAxis) {
    let eventNames, axes;
    if (isXAxis) {
      eventNames = this.__xAxesEventNames;
      axes = configuration.xAxis;
    } else {
      eventNames = this.__yAxesEventNames;
      axes = configuration.yAxis;
    }
    if (Array.isArray(axes)) {
      axes.forEach((axis) => this.__createEventListeners(eventNames, axis, "events", "axis"));
    } else {
      this.__createEventListeners(eventNames, axes, "events", "axis");
    }
  }
  __createEventListeners(eventList, configuration, pathToAdd, eventType) {
    const eventObject = this.__ensureObjectPath(configuration, pathToAdd);
    for (let keys2 = Object.keys(eventList), i = 0; i < keys2.length; i++) {
      const key = keys2[i];
      if (!eventObject[key]) {
        eventObject[key] = (event) => {
          const customEvent = {
            bubbles: false,
            composed: true,
            detail: {
              originalEvent: event,
              [eventType]: event.target
            }
          };
          if (event.type === "afterSetExtremes") {
            if (event.min == null || event.max == null) {
              return;
            }
          }
          if (event.type === "selection") {
            if (event.xAxis && event.xAxis[0]) {
              customEvent.detail.xAxisMin = event.xAxis[0].min;
              customEvent.detail.xAxisMax = event.xAxis[0].max;
            }
            if (event.yAxis && event.yAxis[0]) {
              customEvent.detail.yAxisMin = event.yAxis[0].min;
              customEvent.detail.yAxisMax = event.yAxis[0].max;
            }
          }
          if (event.type === "click") {
            if (event.xAxis && event.xAxis[0]) {
              customEvent.detail.xValue = event.xAxis[0].value;
            }
            if (event.yAxis && event.yAxis[0]) {
              customEvent.detail.yValue = event.yAxis[0].value;
            }
          }
          if (["beforePrint", "beforeExport"].indexOf(event.type) >= 0) {
            if (!this.tempBodyStyle) {
              let effectiveCss = "";
              const shadowStyles = this.shadowRoot.querySelectorAll("style");
              for (let i2 = 0; i2 < shadowStyles.length; i2++) {
                effectiveCss += shadowStyles[i2].textContent;
              }
              effectiveCss = effectiveCss.replace(/:host\(.+?\)/g, (match) => {
                const selector = match.substr(6, match.length - 7);
                return this.matches(selector) ? "" : match;
              });
              effectiveCss = effectiveCss + "body {    -moz-transform: scale(0.9, 0.9);    zoom: 0.9;    zoom: 90%;}";
              this.tempBodyStyle = document.createElement("style");
              this.tempBodyStyle.textContent = effectiveCss;
              document.body.appendChild(this.tempBodyStyle);
            }
          }
          if (["afterPrint", "afterExport"].indexOf(event.type) >= 0) {
            if (this.tempBodyStyle) {
              document.body.removeChild(this.tempBodyStyle);
              delete this.tempBodyStyle;
            }
          }
          this.dispatchEvent(new CustomEvent(eventList[key], customEvent));
          if (event.type === "legendItemClick" && this._visibilityTogglingDisabled) {
            return false;
          }
        };
      }
    }
  }
  __ensureObjectPath(object, path) {
    if (typeof path !== "string") {
      return;
    }
    path = path.split(".");
    return path.reduce((obj, key) => {
      obj[key] = obj[key] || {};
      return obj[key];
    }, object);
  }
  __updateOrAddCredits(credits) {
    if (this.configuration.credits) {
      this.configuration.credits.update(credits);
    } else {
      this.configuration.addCredits(credits);
    }
  }
  __updateOrAddAxes(axes, isX, redraw) {
    if (!Array.isArray(axes)) {
      axes = [axes];
    }
    const confAxes = isX ? this.configuration.xAxis : this.configuration.yAxis;
    for (let i = 0; i < axes.length; i++) {
      const axis = axes[i];
      if (confAxes[i]) {
        confAxes[i].update(axis, redraw);
      } else {
        this.configuration.addAxis(axis, isX, redraw);
      }
    }
  }
  __updateOrAddSeries(series, redraw) {
    if (!Array.isArray(series)) {
      throw new Error("The type of jsonConfiguration.series should be Object[]");
    }
    for (let i = 0; i < series.length; i++) {
      const currentSeries = series[i];
      this.__updateOrAddSeriesInstance(currentSeries, i, redraw);
    }
  }
  __updateOrAddSeriesInstance(seriesOptions, position, redraw) {
    if (this.configuration.series[position]) {
      this.configuration.series[position].update(seriesOptions, redraw);
    } else {
      this.configuration.addSeries(seriesOptions, redraw);
    }
    return this.configuration.series[position];
  }
  __updateCategories(categories, config) {
    if (categories === void 0 || !config) {
      return;
    }
    this.__updateOrAddAxes([{ categories }], true);
  }
  __updateCategoryMax(max, config) {
    if (max === void 0 || !config) {
      return;
    }
    if (!isFinite(max)) {
      console.warn('<vaadin-chart> Acceptable value for "category-max" are Numbers or null');
      return;
    }
    this.__updateOrAddAxes([{ max }], true);
  }
  __updateCategoryMin(min, config) {
    if (min === void 0 || !config) {
      return;
    }
    if (!isFinite(min)) {
      console.warn('<vaadin-chart> Acceptable value for "category-min" are Numbers or null');
      return;
    }
    this.__updateOrAddAxes([{ min }], true);
  }
  __shouldInvert() {
    if (this.type === "bar" && ["top", "bottom"].indexOf(this.categoryPosition) >= 0) {
      console.warn(`<vaadin-chart> Acceptable "category-position" values for bar charts are
          "left" and "right". For "top" and "bottom" positions please consider using a column chart.`);
      return;
    }
    const inverted = ["left", "right"];
    return inverted.indexOf(this.categoryPosition) >= 0;
  }
  __shouldFlipOpposite() {
    const opposite = ["top", "right"];
    const oppositeBar = ["right"];
    return (this.type === "bar" ? oppositeBar : opposite).indexOf(this.categoryPosition) >= 0;
  }
  __updateCategoryPosition(categoryPosition, config) {
    if (categoryPosition === void 0 || !config) {
      return;
    }
    const validPositions = ["left", "right", "top", "bottom"];
    if (validPositions.indexOf(categoryPosition) < 0) {
      console.warn(`<vaadin-chart> Acceptable "category-position" values are ${validPositions}`);
      return;
    }
    config.update({
      chart: {
        inverted: this.__shouldInvert()
      }
    });
    config.xAxis.forEach((e2) => e2.update({
      opposite: this.__shouldFlipOpposite()
    }));
  }
  __hideLegend(noLegend, config) {
    if (noLegend === void 0 || !config) {
      return;
    }
    if (config.legend) {
      config.legend.update({ enabled: !noLegend });
    } else {
      config.legend = { enabled: !noLegend };
    }
  }
  __updateTitle(title, config) {
    if (title === void 0 || !config) {
      return;
    }
    if (title && title.length > 0) {
      config.title.update({ text: title });
    }
  }
  __tooltipObserver(tooltip, config) {
    if (tooltip === void 0 || !config) {
      return;
    }
    config.tooltip.update({ enabled: tooltip });
  }
  __updateType(type, config) {
    if (type === void 0 || !config) {
      return;
    }
    if (type && type.length > 0) {
      config.update({
        chart: { type }
      });
    }
  }
  __updateSubtitle(subtitle, config) {
    if (subtitle === void 0 || !config) {
      return;
    }
    if (subtitle && subtitle.length > 0) {
      if (!config.subtitle) {
        config.setSubtitle({ text: subtitle });
      } else {
        config.subtitle.update({ text: subtitle });
      }
    }
  }
  __updateAdditionalOptions(options) {
    if (this.configuration && options.base) {
      this.updateConfiguration(options.base);
    }
  }
  __isStackingValid() {
    if (["normal", "percent", null].indexOf(this.stacking) === -1) {
      this.__showWarn("stacking", '"normal", "percent" or null');
      return false;
    }
    return true;
  }
  __stackingObserver(stacking, config) {
    if (stacking === void 0 || !config) {
      return;
    }
    if (!this.__isStackingValid()) {
      this.stacking = null;
      return;
    }
    config.update({
      plotOptions: {
        series: { stacking }
      }
    });
  }
  __chart3dObserver(chart3d, config) {
    if (chart3d === void 0 || !config) {
      return;
    }
    if (chart3d) {
      config.update({
        chart: {
          options3d: __spreadProps(__spreadValues(__spreadValues({}, this._baseChart3d), this.additionalOptions && this.additionalOptions.chart && this.additionalOptions.chart.options3d), {
            enabled: true
          })
        }
      });
    } else {
      config.update({
        chart: {
          options3d: {
            enabled: false
          }
        }
      });
    }
  }
  __polarObserver(polar, config) {
    if (polar === void 0 || !config) {
      return;
    }
    config.update({
      chart: { polar }
    });
  }
  __emptyTextObserver(emptyText, config) {
    if (emptyText === void 0 || !config) {
      return;
    }
    config.update({
      lang: {
        noData: emptyText
      }
    });
    config.hideNoData();
    config.showNoData(emptyText);
  }
  __callChartFunction(functionName, ...args) {
    if (this.configuration) {
      const functionToCall = this.configuration[functionName];
      if (functionToCall && typeof functionToCall === "function") {
        functionToCall.apply(this.configuration, args);
      }
    }
  }
  __callSeriesFunction(functionName, seriesIndex, ...args) {
    if (this.configuration && this.configuration.series[seriesIndex]) {
      const series = this.configuration.series[seriesIndex];
      const functionToCall = series[functionName];
      if (functionToCall && typeof functionToCall === "function") {
        functionToCall.apply(series, args);
      }
    }
  }
  __callAxisFunction(functionName, axisCategory, axisIndex, ...args) {
    if (this.configuration) {
      let axes;
      switch (axisCategory) {
        case 0:
          axes = this.configuration.xAxis;
          break;
        case 1:
          axes = this.configuration.yAxis;
          break;
        case 2:
          axes = this.configuration.zAxis;
          break;
        case 3:
          axes = this.configuration.colorAxis;
          break;
        default:
          break;
      }
      if (axes && axes[axisIndex]) {
        const axis = axes[axisIndex];
        const functionToCall = axis[functionName];
        if (functionToCall && typeof functionToCall === "function") {
          functionToCall.apply(axis, args);
        }
      }
    }
  }
  __callPointFunction(functionName, seriesIndex, pointIndex, ...args) {
    if (this.configuration && this.configuration.series[seriesIndex] && this.configuration.series[seriesIndex].data[pointIndex]) {
      const point = this.configuration.series[seriesIndex].data[pointIndex];
      const functionToCall = point[functionName];
      if (functionToCall && typeof functionToCall === "function") {
        functionToCall.apply(point, args);
      }
    }
  }
  __updateStyles() {
    const isFlex = getComputedStyle(this).flex != "0 1 auto";
    if (isFlex) {
      this.$.chart.setAttribute("style", "flex: 1; ");
      let style = "";
      if (this.hasAttribute("style")) {
        style = this.getAttribute("style");
        if (style.charAt(style.length - 1) !== ";") {
          style += ";";
        }
      }
      style += "display: flex;";
      this.setAttribute("style", style);
    } else {
      this.$.chart.setAttribute("style", "height:100%; width:100%;");
    }
  }
  __showWarn(propertyName, acceptedValues) {
    console.warn('<vaadin-chart> Acceptable values for "' + propertyName + '" are ' + acceptedValues);
  }
};
customElements.define(_Chart.is, _Chart);
/**
 * @license
 * Copyright (c) 2015 - 2022 Vaadin Ltd.
 * This program is available under Commercial Vaadin Developer License 4.0, available at https://vaadin.com/license/cvdl-4.0.
 */
/**
 * @license Highcharts
 *
 * (c) 2009-2016 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
/**
 * @license Highcharts JS v9.2.2 (2021-08-24)
 * @module highcharts/highcharts
 *
 * (c) 2009-2021 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
/**
 * @license Highcharts JS v9.2.2 (2021-08-24)
 * @module highcharts/highcharts-3d
 * @requires highcharts
 *
 * 3D features for Highcharts JS
 *
 * License: www.highcharts.com/license
 */
/**
 * @license Highcharts JS v9.2.2 (2021-08-24)
 * @module highcharts/highcharts-more
 * @requires highcharts
 *
 * (c) 2009-2021 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
/**
 * @license Highcharts JS v9.2.2 (2021-08-24)
 * @module highcharts/modules/accessibility
 * @requires highcharts
 *
 * Accessibility module
 *
 * (c) 2010-2021 Highsoft AS
 * Author: Oystein Moseng
 *
 * License: www.highcharts.com/license
 */
/**
 * @license Highcharts JS v9.2.2 (2021-08-24)
 * @module highcharts/modules/broken-axis
 * @requires highcharts
 *
 * (c) 2009-2021 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
/**
 * @license Highcharts JS v9.2.2 (2021-08-24)
 * @module highcharts/modules/bullet
 * @requires highcharts
 *
 * Bullet graph series type for Highcharts
 *
 * (c) 2010-2021 Kacper Madej
 *
 * License: www.highcharts.com/license
 */
/**
 * @license Highcharts JS v9.2.2 (2021-08-24)
 * @module highcharts/modules/data
 * @requires highcharts
 *
 * Data module
 *
 * (c) 2012-2021 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
/**
 * @license Highcharts JS v9.2.2 (2021-08-24)
 * @module highcharts/modules/drilldown
 * @requires highcharts
 *
 * Highcharts Drilldown module
 *
 * Author: Torstein Honsi
 * License: www.highcharts.com/license
 *
 */
/**
 * @license Highcharts JS v9.2.2 (2021-08-24)
 * @module highcharts/modules/exporting
 * @requires highcharts
 *
 * Exporting module
 *
 * (c) 2010-2021 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
/**
 * @license Highcharts JS v9.2.2 (2021-08-24)
 * @module highcharts/modules/funnel
 * @requires highcharts
 *
 * Highcharts funnel module
 *
 * (c) 2010-2021 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
/**
 * @license Highcharts JS v9.2.2 (2021-08-24)
 * @module highcharts/modules/no-data-to-display
 * @requires highcharts
 *
 * Plugin for displaying a message when there is no data visible in chart.
 *
 * (c) 2010-2021 Highsoft AS
 * Author: Oystein Moseng
 *
 * License: www.highcharts.com/license
 */
/**
 * @license Highcharts JS v9.2.2 (2021-08-24)
 * @module highcharts/modules/sankey
 * @requires highcharts
 *
 * Sankey diagram module
 *
 * (c) 2010-2021 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
/**
 * @license Highcharts JS v9.2.2 (2021-08-24)
 * @module highcharts/modules/solid-gauge
 * @requires highcharts
 * @requires highcharts/highcharts-more
 *
 * Solid angular gauge module
 *
 * (c) 2010-2021 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
/**
 * @license Highcharts JS v9.2.2 (2021-08-24)
 * @module highcharts/modules/timeline
 * @requires highcharts
 *
 * Timeline series
 *
 * (c) 2010-2021 Highsoft AS
 * Author: Daniel Studencki
 *
 * License: www.highcharts.com/license
 */
/**
 * @license Highcharts JS v9.2.2 (2021-08-24)
 * @module highcharts/modules/treemap
 * @requires highcharts
 *
 * (c) 2014-2021 Highsoft AS
 * Authors: Jon Arild Nygard / Oystein Moseng
 *
 * License: www.highcharts.com/license
 */
/**
 * @license Highcharts JS v9.2.2 (2021-08-24)
 * @module highcharts/modules/xrange
 * @requires highcharts
 *
 * X-range series
 *
 * (c) 2010-2021 Torstein Honsi, Lars A. V. Cabrera
 *
 * License: www.highcharts.com/license
 */
/**
 * @license Highcharts JS v9.2.2 (2021-08-24)
 * Organization chart series type
 * @module highcharts/modules/organization
 * @requires highcharts
 * @requires highcharts/modules/sankey
 *
 * (c) 2019-2021 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
/**
 * @license Highmaps JS v9.2.2 (2021-08-24)
 * @module highcharts/modules/heatmap
 * @requires highcharts
 *
 * (c) 2009-2021 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
/**
 * @license Highstock JS v9.2.2 (2021-08-24)
 * @module highcharts/highstock
 *
 * (c) 2009-2021 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
/**
 * @license Highstock JS v9.2.2 (2021-08-24)
 * @module highcharts/modules/stock
 * @requires highcharts
 *
 * Highcharts Stock as a plugin for Highcharts
 *
 * (c) 2010-2021 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
//# sourceMappingURL=@vaadin_charts_theme_lumo_vaadin-chart_js.js.map
