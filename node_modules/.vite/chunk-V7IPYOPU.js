import {
  announce
} from "./chunk-D6PB52TV.js";
import {
  OverlayElement
} from "./chunk-O5EIIYDR.js";
import {
  calculateSplices
} from "./chunk-IASAGYPQ.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-PALO6AVQ.js";
import {
  css
} from "./chunk-PYLEJJK2.js";
import {
  Debouncer
} from "./chunk-KCWZ32HQ.js";
import {
  timeOut
} from "./chunk-QNRFZUBX.js";
import {
  DirMixin
} from "./chunk-ZFVP5VBM.js";
import {
  PolymerElement,
  html
} from "./chunk-EMDRMWGL.js";

// node_modules/@vaadin/field-highlighter/src/vaadin-field-outline.js
var FieldOutline = class extends ThemableMixin(DirMixin(PolymerElement)) {
  static get is() {
    return "vaadin-field-outline";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: block;
          box-sizing: border-box;
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          width: 100%;
          height: 100%;
          pointer-events: none;
          user-select: none;
          opacity: 0;
          --_active-user-color: transparent;
        }

        :host([has-active-user]) {
          opacity: 1;
        }
      </style>
    `;
  }
  static get properties() {
    return {
      user: {
        type: Object,
        value: null,
        observer: "_userChanged"
      }
    };
  }
  ready() {
    super.ready();
    this.setAttribute("part", "outline");
    this._field = this.getRootNode().host;
  }
  _userChanged(user) {
    this.toggleAttribute("has-active-user", Boolean(user));
    const value = user ? `var(--vaadin-user-color-${user.colorIndex})` : "transparent";
    const prop = "--_active-user-color";
    this.style.setProperty(prop, value);
    if (this._field) {
      this._field.style.setProperty(prop, value);
    }
  }
};
customElements.define(FieldOutline.is, FieldOutline);

// node_modules/@vaadin/field-highlighter/src/vaadin-user-tag.js
var UserTag = class extends ThemableMixin(DirMixin(PolymerElement)) {
  static get is() {
    return "vaadin-user-tag";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: block;
          box-sizing: border-box;
          margin: 0 0 var(--vaadin-user-tag-offset);
          opacity: 0;
          height: 1.3rem;
          transition: opacity 0.2s ease-in-out;
          background-color: var(--vaadin-user-tag-color);
          color: #fff;
          cursor: default;
          -webkit-user-select: none;
          user-select: none;
          --vaadin-user-tag-offset: 4px;
        }

        :host(.show) {
          opacity: 1;
        }

        :host(:last-of-type) {
          margin-bottom: 0;
        }

        [part='name'] {
          overflow: hidden;
          white-space: nowrap;
          text-overflow: ellipsis;
          box-sizing: border-box;
          padding: 2px 4px;
          height: 1.3rem;
          font-size: 13px;
        }
      </style>
      <div part="name">[[name]]</div>
    `;
  }
  static get properties() {
    return {
      name: {
        type: String
      },
      uid: {
        type: String
      },
      colorIndex: {
        type: Number,
        observer: "_colorIndexChanged"
      }
    };
  }
  ready() {
    super.ready();
    this.addEventListener("mousedown", this._onClick.bind(this), true);
  }
  _colorIndexChanged(index) {
    if (index != null) {
      this.style.setProperty("--vaadin-user-tag-color", `var(--vaadin-user-color-${index})`);
    }
  }
  _onClick(e) {
    e.preventDefault();
    this.dispatchEvent(new CustomEvent("user-tag-click", {
      bubbles: true,
      composed: true,
      detail: {
        name: this.name
      }
    }));
  }
};
customElements.define(UserTag.is, UserTag);

// node_modules/@vaadin/field-highlighter/src/vaadin-user-tags-overlay.js
registerStyles("vaadin-user-tags-overlay", css`
    :host {
      align-items: stretch;
      justify-content: flex-start;
      background: transparent;
      box-shadow: none;
      bottom: auto;
    }

    [part='overlay'] {
      box-shadow: none;
      background: transparent;
      position: relative;
      left: -4px;
      padding: 4px;
      outline: none;
      overflow: visible;
    }

    ::slotted([part='tags']) {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }

    :host([dir='rtl']) [part='overlay'] {
      left: auto;
      right: -4px;
    }

    [part='content'] {
      padding: 0;
    }

    :host([dir='rtl']) {
      left: auto;
    }

    :host(:not([dir='rtl'])) {
      right: auto;
    }

    :host([opening]),
    :host([closing]) {
      animation: 0.14s user-tags-overlay-dummy-animation;
    }

    @keyframes user-tags-overlay-dummy-animation {
      0% {
        opacity: 1;
      }

      100% {
        opacity: 1;
      }
    }
  `);
var UserTagsOverlay = class extends OverlayElement {
  static get is() {
    return "vaadin-user-tags-overlay";
  }
  ready() {
    super.ready();
    this.$.overlay.setAttribute("tabindex", "-1");
  }
};
customElements.define(UserTagsOverlay.is, UserTagsOverlay);

// node_modules/@vaadin/field-highlighter/src/vaadin-user-tags.js
var DURATION = 200;
var DELAY = 2e3;
var listenOnce = (elem, type) => {
  return new Promise((resolve) => {
    const listener = () => {
      elem.removeEventListener(type, listener);
      resolve();
    };
    elem.addEventListener(type, listener);
  });
};
var UserTags = class extends PolymerElement {
  static get is() {
    return "vaadin-user-tags";
  }
  static get template() {
    return html`
      <style>
        :host {
          position: absolute;
        }
      </style>
      <vaadin-user-tags-overlay
        id="overlay"
        modeless
        opened="[[opened]]"
        on-vaadin-overlay-open="_onOverlayOpen"
      ></vaadin-user-tags-overlay>
    `;
  }
  static get properties() {
    return {
      hasFocus: {
        type: Boolean,
        value: false,
        observer: "_hasFocusChanged"
      },
      opened: {
        type: Boolean,
        value: false,
        observer: "_openedChanged"
      },
      flashing: {
        type: Boolean,
        value: false
      },
      target: {
        type: Object
      },
      users: {
        type: Array,
        value: () => []
      },
      _flashQueue: {
        type: Array,
        value: () => []
      }
    };
  }
  constructor() {
    super();
    this._boundSetPosition = this._debounceSetPosition.bind(this);
  }
  connectedCallback() {
    super.connectedCallback();
    window.addEventListener("resize", this._boundSetPosition);
    window.addEventListener("scroll", this._boundSetPosition);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    window.removeEventListener("resize", this._boundSetPosition);
    window.removeEventListener("scroll", this._boundSetPosition);
    this.opened = false;
  }
  ready() {
    super.ready();
    this.$.overlay.renderer = (root) => {
      if (!root.firstChild) {
        const tags = document.createElement("div");
        tags.setAttribute("part", "tags");
        root.appendChild(tags);
      }
    };
    this.$.overlay.requestContentUpdate();
  }
  _debounceSetPosition() {
    this._debouncePosition = Debouncer.debounce(this._debouncePosition, timeOut.after(16), () => this._setPosition());
  }
  _openedChanged(opened) {
    if (opened) {
      this._setPosition();
    }
  }
  _hasFocusChanged(hasFocus) {
    if (hasFocus && this.flashing) {
      this.stopFlash();
    }
  }
  _setPosition() {
    if (!this.opened) {
      return;
    }
    const targetRect = this.target.getBoundingClientRect();
    const overlayRect = this.$.overlay.getBoundingClientRect();
    this._translateX = this.getAttribute("dir") === "rtl" ? targetRect.right - overlayRect.right + (this._translateX || 0) : targetRect.left - overlayRect.left + (this._translateX || 0);
    this._translateY = targetRect.top - overlayRect.top + (this._translateY || 0) + targetRect.height;
    const devicePixelRatio = window.devicePixelRatio || 1;
    this._translateX = Math.round(this._translateX * devicePixelRatio) / devicePixelRatio;
    this._translateY = Math.round(this._translateY * devicePixelRatio) / devicePixelRatio;
    this.$.overlay.style.transform = `translate3d(${this._translateX}px, ${this._translateY}px, 0)`;
  }
  get wrapper() {
    return this.$.overlay.content.querySelector('[part="tags"]');
  }
  createUserTag(user) {
    const tag = document.createElement("vaadin-user-tag");
    tag.name = user.name;
    tag.uid = user.id;
    tag.colorIndex = user.colorIndex;
    return tag;
  }
  getTagForUser(user) {
    return Array.from(this.wrapper.children).filter((tag) => tag.uid === user.id)[0];
  }
  getChangedTags(addedUsers, removedUsers) {
    const removed = removedUsers.map((user) => this.getTagForUser(user));
    const added = addedUsers.map((user) => this.getTagForUser(user) || this.createUserTag(user));
    return { added, removed };
  }
  getChangedUsers(users, splices) {
    const usersToAdd = [];
    const usersToRemove = [];
    splices.forEach((splice) => {
      for (let i = 0; i < splice.removed.length; i++) {
        usersToRemove.push(splice.removed[i]);
      }
      for (let i = splice.addedCount - 1; i >= 0; i--) {
        usersToAdd.push(users[splice.index + i]);
      }
    });
    const addedUsers = usersToAdd.filter((u) => !usersToRemove.some((u2) => u.id === u2.id));
    const removedUsers = usersToRemove.filter((u) => !usersToAdd.some((u2) => u.id === u2.id));
    return { addedUsers, removedUsers };
  }
  applyTagsStart({ added, removed }) {
    const wrapper = this.wrapper;
    removed.forEach((tag) => {
      if (tag) {
        tag.classList.add("removing");
        tag.classList.remove("show");
      }
    });
    added.forEach((tag) => wrapper.insertBefore(tag, wrapper.firstChild));
  }
  applyTagsEnd({ added, removed }) {
    const wrapper = this.wrapper;
    removed.forEach((tag) => {
      if (tag && tag.parentNode === wrapper) {
        wrapper.removeChild(tag);
      }
    });
    added.forEach((tag) => tag && tag.classList.add("show"));
  }
  setUsers(users) {
    this.requestContentUpdate();
    const splices = calculateSplices(users, this.users);
    if (splices.length === 0) {
      return;
    }
    const { addedUsers, removedUsers } = this.getChangedUsers(users, splices);
    if (addedUsers.length === 0 && removedUsers.length === 0) {
      return;
    }
    const changedTags = this.getChangedTags(addedUsers, removedUsers);
    if (this._flashQueue.length > 0) {
      for (let i = 0; i < removedUsers.length; i++) {
        if (changedTags.removed[i] === null) {
          for (let j = 0; j < this._flashQueue.length; j++) {
            if (this._flashQueue[j].some((tag) => tag.uid === removedUsers[i].id)) {
              this.splice("_flashQueue", i, 1);
            }
          }
        }
      }
    }
    if (this.opened && this.hasFocus) {
      this.updateTags(users, changedTags);
    } else if (addedUsers.length && document.visibilityState !== "hidden") {
      const tags = changedTags.added;
      if (this.flashing) {
        this.push("_flashQueue", tags);
      } else {
        this.flashTags(tags);
      }
      this.set("users", users);
    } else {
      this.updateTagsSync(users, changedTags);
    }
  }
  _onOverlayOpen() {
    Array.from(this.wrapper.children).forEach((tag) => {
      if (!tag.classList.contains("removing")) {
        tag.classList.add("show");
      }
    });
  }
  flashTags(added) {
    this.flashing = true;
    const wrapper = this.wrapper;
    const hidden = Array.from(wrapper.children);
    hidden.forEach((tag) => tag.style.display = "none");
    added.forEach((tag) => {
      wrapper.insertBefore(tag, wrapper.firstChild);
    });
    this.flashPromise = new Promise((resolve) => {
      listenOnce(this.$.overlay, "vaadin-overlay-open").then(() => {
        this._debounceFlashStart = Debouncer.debounce(this._debounceFlashStart, timeOut.after(DURATION + DELAY), () => {
          if (!this.hasFocus) {
            added.forEach((tag) => tag.classList.remove("show"));
          }
          this._debounceFlashEnd = Debouncer.debounce(this._debounceFlashEnd, timeOut.after(DURATION), () => {
            const finishFlash = () => {
              hidden.forEach((tag) => tag.style.display = "block");
              this.flashing = false;
              resolve();
            };
            if (this.hasFocus) {
              finishFlash();
            } else {
              listenOnce(this.$.overlay, "animationend").then(() => {
                finishFlash();
              });
              this.opened = false;
            }
          });
        });
      });
    }).then(() => {
      if (this._flashQueue.length > 0) {
        const tags = this._flashQueue[0];
        this.splice("_flashQueue", 0, 1);
        this.flashTags(tags);
      }
    });
    this.opened = true;
  }
  stopFlash() {
    this._debounceFlashStart && this._debounceFlashStart.flush();
    this._debounceFlashEnd && this._debounceFlashEnd.flush();
    this.$.overlay._flushAnimation("closing");
  }
  updateTags(users, changed) {
    this.applyTagsStart(changed);
    this._debounceRender = Debouncer.debounce(this._debounceRender, timeOut.after(DURATION), () => {
      this.set("users", users);
      this.applyTagsEnd(changed);
      if (users.length === 0 && this.opened) {
        this.opened = false;
      }
    });
  }
  updateTagsSync(users, changed) {
    this.applyTagsStart(changed);
    this.set("users", users);
    this.applyTagsEnd(changed);
  }
  show() {
    this.hasFocus = true;
    this.opened = true;
  }
  hide() {
    this.hasFocus = false;
    this.opened = false;
  }
  requestContentUpdate() {
    if (this._debounceRender && this._debounceRender.isActive()) {
      this._debounceRender.flush();
    }
  }
};
customElements.define(UserTags.is, UserTags);

// node_modules/@vaadin/field-highlighter/src/fields/outline.js
var getOutlineTarget = (element, tagName) => {
  switch (tagName) {
    case "vaadin-big-decimal-field":
    case "vaadin-combo-box":
    case "vaadin-date-picker":
    case "vaadin-date-time-picker-date-picker":
    case "vaadin-date-time-picker-time-picker":
    case "vaadin-email-field":
    case "vaadin-integer-field":
    case "vaadin-number-field":
    case "vaadin-password-field":
    case "vaadin-select":
    case "vaadin-text-area":
    case "vaadin-text-field":
    case "vaadin-time-picker":
      return element.shadowRoot.querySelector('[part="input-field"]');
    case "vaadin-checkbox":
      return element.shadowRoot.querySelector('[part="checkbox"]');
    case "vaadin-radio-button":
      return element.shadowRoot.querySelector('[part="radio"]');
    default:
      return element;
  }
};
var fields = /* @__PURE__ */ new WeakMap();
var initOutline = (field) => {
  if (!fields.has(field)) {
    const tagName = field.tagName.toLowerCase();
    const target = getOutlineTarget(field, tagName);
    target.style.position = "relative";
    if (tagName.endsWith("text-area")) {
      target.style.overflow = "visible";
    }
    const style = document.createElement("style");
    style.textContent = `
      :host([active]) [part="outline"],
      :host([focus-ring]) [part="outline"] {
        display: none;
      }
    `;
    field.shadowRoot.appendChild(style);
    const outline = document.createElement("vaadin-field-outline");
    (target === field ? field.shadowRoot : target).appendChild(outline);
    outline.setAttribute("context", tagName);
    fields.set(field, { root: field, target, outline });
  }
  return fields.get(field);
};

// node_modules/@vaadin/field-highlighter/src/fields/vaadin-component-observer.js
var ComponentObserver = class {
  constructor(component) {
    this.component = component;
    this.initTags(component);
  }
  getFields() {
    return [this.component];
  }
  getFieldIndex(field) {
    return this.getFields().indexOf(field);
  }
  getFocusTarget(_event) {
    return this.component;
  }
  initTags(component) {
    const tags = document.createElement("vaadin-user-tags");
    component.shadowRoot.appendChild(tags);
    tags.target = component;
    this._tags = tags;
    component.addEventListener("mouseenter", (event) => {
      if (event.relatedTarget === this._tags.$.overlay) {
        return;
      }
      this._mouse = true;
      this._mouseDebouncer = Debouncer.debounce(this._mouseDebouncer, timeOut.after(200), () => {
        if (this._mouse) {
          this._tags.show();
        }
      });
    });
    component.addEventListener("mouseleave", (event) => {
      if (event.relatedTarget === this._tags.$.overlay) {
        return;
      }
      this._mouse = false;
      if (!this._hasFocus) {
        this._tags.hide();
      }
    });
    component.addEventListener("vaadin-highlight-show", (_event) => {
      this._hasFocus = true;
      if (this._debouncer && this._debouncer.isActive()) {
        this._debouncer.cancel();
      } else {
        this._tags.show();
      }
    });
    component.addEventListener("vaadin-highlight-hide", (_event) => {
      this._hasFocus = false;
      if (!this._mouse) {
        this._debouncer = Debouncer.debounce(this._debouncer, timeOut.after(1), () => {
          this._tags.hide();
        });
      }
    });
    this._tags.$.overlay.addEventListener("mouseleave", (event) => {
      if (event.relatedTarget === component) {
        return;
      }
      this._mouse = false;
      if (!component.hasAttribute("focused")) {
        this._tags.hide();
      }
    });
  }
  setOutlines(users) {
    const fields2 = this.getFields();
    fields2.forEach((field, idx) => {
      const { outline } = initOutline(field);
      const index = fields2.length === 1 ? 0 : users.map((user) => user.fieldIndex).indexOf(idx);
      outline.user = users[index];
    });
  }
  showOutline(field) {
    this.fire("show", field);
  }
  hideOutline(field) {
    this.fire("hide", field);
  }
  fire(action, field) {
    this.component.dispatchEvent(new CustomEvent(`vaadin-highlight-${action}`, {
      bubbles: true,
      composed: true,
      detail: { fieldIndex: this.getFieldIndex(field) }
    }));
  }
  redraw(users) {
    this._tags.setUsers(users);
    this.setOutlines(users);
  }
};

// node_modules/@vaadin/field-highlighter/src/fields/vaadin-field-observer.js
var FieldObserver = class extends ComponentObserver {
  constructor(field) {
    super(field);
    this.addListeners(field);
  }
  addListeners(field) {
    field.addEventListener("focusin", (event) => this.onFocusIn(event));
    field.addEventListener("focusout", (event) => this.onFocusOut(event));
  }
  onFocusIn(event) {
    const target = this.getFocusTarget(event);
    this.showOutline(target);
  }
  onFocusOut(event) {
    const target = this.getFocusTarget(event);
    this.hideOutline(target);
  }
};

// node_modules/@vaadin/field-highlighter/src/fields/vaadin-checkbox-group-observer.js
var CheckboxGroupObserver = class extends FieldObserver {
  getFields() {
    return this.component.__checkboxes;
  }
  getFocusTarget(event) {
    const fields2 = this.getFields();
    return Array.from(event.composedPath()).filter((node) => fields2.indexOf(node) !== -1)[0];
  }
};

// node_modules/@vaadin/field-highlighter/src/fields/vaadin-date-picker-observer.js
var DatePickerObserver = class extends ComponentObserver {
  constructor(datePicker) {
    super(datePicker);
    this.datePicker = datePicker;
    this.fullscreenFocus = false;
    this.blurWhileOpened = false;
    this.addListeners(datePicker);
  }
  addListeners(datePicker) {
    this.overlay = datePicker.$.overlay;
    datePicker.addEventListener("blur", (event) => this.onBlur(event), true);
    datePicker.addEventListener("opened-changed", (event) => this.onOpenedChanged(event));
    this.overlay.addEventListener("focusout", (event) => this.onOverlayFocusOut(event));
    datePicker.addEventListener("focusin", (event) => this.onFocusIn(event));
    datePicker.addEventListener("focusout", (event) => this.onFocusOut(event));
  }
  onBlur(event) {
    const datePicker = this.datePicker;
    if (datePicker._fullscreen && event.relatedTarget !== this.overlay) {
      this.fullscreenFocus = true;
    }
  }
  onFocusIn(event) {
    if (event.relatedTarget === this.overlay) {
      return;
    }
    if (this.blurWhileOpened) {
      this.blurWhileOpened = false;
      return;
    }
    this.showOutline(this.datePicker);
  }
  onFocusOut(event) {
    if (this.fullscreenFocus || event.relatedTarget === this.overlay) {
    } else if (!this.datePicker.opened) {
      this.hideOutline(this.datePicker);
    } else {
      this.blurWhileOpened = true;
    }
  }
  onOverlayFocusOut(event) {
    if (!this.datePicker.contains(event.relatedTarget)) {
      this.blurWhileOpened = true;
    }
  }
  onOpenedChanged(event) {
    if (event.detail.value === true && this.fullscreenFocus) {
      this.fullscreenFocus = false;
      this.showOutline(this.datePicker);
    }
    if (event.detail.value === false && this.blurWhileOpened) {
      this.blurWhileOpened = false;
      this.hideOutline(this.datePicker);
    }
  }
};

// node_modules/@vaadin/field-highlighter/src/fields/vaadin-date-time-picker-observer.js
var DateObserver = class extends DatePickerObserver {
  constructor(datePicker, host) {
    super(datePicker);
    this.component = host;
  }
  getFieldIndex() {
    return 0;
  }
};
var TimeObserver = class extends FieldObserver {
  constructor(timePicker, host) {
    super(timePicker);
    this.component = host;
    this.timePicker = timePicker;
  }
  getFocusTarget(_event) {
    return this.timePicker;
  }
  getFieldIndex() {
    return 1;
  }
};
var DateTimePickerObserver = class extends ComponentObserver {
  constructor(picker) {
    super(picker);
    const [datePicker, timePicker] = this.getFields();
    this.dateObserver = new DateObserver(datePicker, picker);
    this.timeObserver = new TimeObserver(timePicker, picker);
  }
  getFields() {
    return this.component.__inputs;
  }
};

// node_modules/@vaadin/field-highlighter/src/fields/vaadin-list-box-observer.js
var ListBoxObserver = class extends FieldObserver {
  getFields() {
    return this.component.items || [];
  }
  getFocusTarget(event) {
    const fields2 = this.getFields();
    return Array.from(event.composedPath()).filter((node) => fields2.indexOf(node) !== -1)[0];
  }
};

// node_modules/@vaadin/field-highlighter/src/fields/vaadin-radio-group-observer.js
var RadioGroupObserver = class extends FieldObserver {
  getFields() {
    return this.component.__radioButtons;
  }
  getFocusTarget(event) {
    const fields2 = this.getFields();
    return Array.from(event.composedPath()).filter((node) => fields2.indexOf(node) !== -1)[0];
  }
};

// node_modules/@vaadin/field-highlighter/src/fields/vaadin-select-observer.js
var SelectObserver = class extends FieldObserver {
  constructor(select) {
    super(select);
    this.blurWhileOpened = false;
    this.overlay = select._overlayElement;
  }
  addListeners(select) {
    super.addListeners(select);
    select.addEventListener("opened-changed", (event) => {
      if (select._phone && event.detail.value === false) {
        this.hideOutline(select);
      }
    });
  }
  onFocusIn(event) {
    if (this.overlay.contains(event.relatedTarget)) {
      return;
    }
    if (!this.component._phone && this.overlay.hasAttribute("closing")) {
      return;
    }
    super.onFocusIn(event);
  }
  onFocusOut(event) {
    if (this.overlay.contains(event.relatedTarget)) {
      return;
    }
    super.onFocusOut(event);
  }
};

// node_modules/@vaadin/field-highlighter/src/vaadin-field-highlighter.js
var initFieldObserver = (field) => {
  let result;
  switch (field.tagName.toLowerCase()) {
    case "vaadin-date-picker":
      result = new DatePickerObserver(field);
      break;
    case "vaadin-date-time-picker":
      result = new DateTimePickerObserver(field);
      break;
    case "vaadin-select":
      result = new SelectObserver(field);
      break;
    case "vaadin-checkbox-group":
      result = new CheckboxGroupObserver(field);
      break;
    case "vaadin-radio-group":
      result = new RadioGroupObserver(field);
      break;
    case "vaadin-list-box":
      result = new ListBoxObserver(field);
      break;
    default:
      result = new FieldObserver(field);
  }
  return result;
};
var FieldHighlighterController = class {
  get user() {
    return this._user;
  }
  set user(user) {
    this._user = user;
    if (user) {
      const msg = `${user.name} started editing`;
      const { label } = this.host;
      announce(label ? `${msg} ${label}` : msg);
    }
  }
  constructor(host) {
    this.host = host;
    this.user = null;
    this.users = [];
  }
  hostConnected() {
    this.redraw();
  }
  addUser(user) {
    if (user) {
      this.users.push(user);
      this.redraw();
      this.user = user;
    }
  }
  setUsers(users) {
    if (Array.isArray(users)) {
      this.users = users;
      this.redraw();
      this.user = users[users.length - 1] || null;
    }
  }
  removeUser(user) {
    if (user && user.id !== void 0) {
      let index;
      for (let i = 0; i < this.users.length; i++) {
        if (this.users[i].id === user.id) {
          index = i;
          break;
        }
      }
      if (index !== void 0) {
        this.users.splice(index, 1);
        this.redraw();
        if (this.users.length > 0) {
          this.user = this.users[this.users.length - 1];
        } else {
          this.user = null;
        }
      }
    }
  }
  redraw() {
    this.observer.redraw([...this.users].reverse());
  }
};
var FieldHighlighter = class extends HTMLElement {
  static init(field) {
    if (!field._highlighterController) {
      const instance = new FieldHighlighterController(field);
      field.setAttribute("has-highlighter", "");
      instance.observer = initFieldObserver(field);
      field.addController(instance);
      field._highlighterController = instance;
    }
    return field._highlighterController;
  }
  static addUser(field, user) {
    this.init(field).addUser(user);
  }
  static removeUser(field, user) {
    this.init(field).removeUser(user);
  }
  static setUsers(field, users) {
    this.init(field).setUsers(users);
  }
};
customElements.define("vaadin-field-highlighter", FieldHighlighter);
/**
 * @license
 * Copyright (c) 2021 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-V7IPYOPU.js.map
