import {
  VirtualKeyboardController
} from "./chunk-3GYD24OI.js";
import {
  PositionMixin
} from "./chunk-YBQVYLTV.js";
import {
  InputControlMixin,
  inputFieldShared as inputFieldShared2
} from "./chunk-QCXVEWEJ.js";
import {
  inputFieldShared
} from "./chunk-3ZYBSPTG.js";
import {
  MediaQueryController
} from "./chunk-I4XSFGAQ.js";
import {
  OverlayElement
} from "./chunk-BPZR2M5B.js";
import {
  InputController
} from "./chunk-NENT67AA.js";
import {
  InputMixin,
  LabelledInputController
} from "./chunk-YESAUM4I.js";
import {
  addListener,
  setTouchAction
} from "./chunk-6FZMJTZI.js";
import {
  menuOverlay
} from "./chunk-75G4VMZU.js";
import {
  DisableUpgradeMixin
} from "./chunk-BSWEWLID.js";
import {
  templatize
} from "./chunk-VRMTXLCJ.js";
import {
  DelegateFocusMixin
} from "./chunk-W2FE6W4J.js";
import {
  KeyboardMixin
} from "./chunk-CHZ6BFNC.js";
import {
  FocusMixin
} from "./chunk-Q3ITW52D.js";
import {
  isFirefox,
  isIOS
} from "./chunk-2GZ522BV.js";
import {
  ControllerMixin
} from "./chunk-BUARF445.js";
import {
  afterNextRender
} from "./chunk-ZGILPT2L.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-PALO6AVQ.js";
import {
  ElementMixin
} from "./chunk-OKCEHAIA.js";
import {
  Debouncer
} from "./chunk-KCWZ32HQ.js";
import {
  DirMixin
} from "./chunk-ZFVP5VBM.js";
import {
  timeOut
} from "./chunk-QNRFZUBX.js";
import {
  css
} from "./chunk-PYLEJJK2.js";
import {
  PolymerElement,
  html
} from "./chunk-EMDRMWGL.js";

// node_modules/@vaadin/date-picker/theme/lumo/vaadin-date-picker-overlay-styles.js
var datePickerOverlay = css`
  [part='overlay'] {
    /*
  Width:
      date cell widths
    + month calendar side padding
    + year scroller width
  */
    /* prettier-ignore */
    width:
    calc(
        var(--lumo-size-m) * 7
      + var(--lumo-space-xs) * 2
      + 57px
    );
    height: 100%;
    max-height: calc(var(--lumo-size-m) * 14);
    overflow: hidden;
    -webkit-tap-highlight-color: transparent;
  }

  [part='overlay'] {
    flex-direction: column;
  }

  [part='content'] {
    padding: 0;
    height: 100%;
    overflow: hidden;
    -webkit-mask-image: none;
    mask-image: none;
  }

  :host([top-aligned]) [part~='overlay'] {
    margin-top: var(--lumo-space-xs);
  }

  :host([bottom-aligned]) [part~='overlay'] {
    margin-bottom: var(--lumo-space-xs);
  }

  @media (max-width: 420px), (max-height: 420px) {
    [part='overlay'] {
      width: 100vw;
      height: 70vh;
      max-height: 70vh;
    }
  }
`;
registerStyles("vaadin-date-picker-overlay", [menuOverlay, datePickerOverlay], {
  moduleId: "lumo-date-picker-overlay"
});

// node_modules/@vaadin/date-picker/theme/lumo/vaadin-date-picker-overlay-content-styles.js
registerStyles("vaadin-date-picker-overlay-content", css`
    :host {
      position: relative;
      background-color: transparent;
      /* Background for the year scroller, placed here as we are using a mask image on the actual years part */
      background-image: linear-gradient(var(--lumo-shade-5pct), var(--lumo-shade-5pct));
      background-size: 57px 100%;
      background-position: top right;
      background-repeat: no-repeat;
      cursor: default;
    }

    /* Month scroller */

    [part='months'] {
      /* Month calendar height:
              header height + margin-bottom
            + weekdays height + margin-bottom
            + date cell heights
            + small margin between month calendars
        */
      /* prettier-ignore */
      --vaadin-infinite-scroller-item-height:
          calc(
              var(--lumo-font-size-l) + var(--lumo-space-m)
            + var(--lumo-font-size-xs) + var(--lumo-space-s)
            + var(--lumo-size-m) * 6
            + var(--lumo-space-s)
          );
      --vaadin-infinite-scroller-buffer-offset: 20%;
      -webkit-mask-image: linear-gradient(transparent, #000 10%, #000 85%, transparent);
      mask-image: linear-gradient(transparent, #000 10%, #000 85%, transparent);
      position: relative;
      margin-right: 57px;
    }

    /* Year scroller */
    [part='years'] {
      /* TODO get rid of fixed magic number */
      --vaadin-infinite-scroller-buffer-width: 97px;
      width: 57px;
      height: auto;
      top: 0;
      bottom: 0;
      font-size: var(--lumo-font-size-s);
      box-shadow: inset 2px 0 4px 0 var(--lumo-shade-5pct);
      -webkit-mask-image: linear-gradient(transparent, #000 35%, #000 65%, transparent);
      mask-image: linear-gradient(transparent, #000 35%, #000 65%, transparent);
      cursor: var(--lumo-clickable-cursor);
    }

    [part='year-number']:not([current]),
    [part='year-separator'] {
      opacity: 0.7;
      transition: 0.2s opacity;
    }

    [part='years']:hover [part='year-number'],
    [part='years']:hover [part='year-separator'] {
      opacity: 1;
    }

    /* TODO unsupported selector */
    #scrollers {
      position: static;
      display: block;
    }

    /* TODO unsupported selector, should fix this in vaadin-date-picker that it adapts to the
       * width of the year scroller */
    #scrollers[desktop] [part='months'] {
      right: auto;
    }

    /* Year scroller position indicator */
    [part='years']::before {
      border: none;
      width: 1em;
      height: 1em;
      background-color: var(--lumo-base-color);
      background-image: linear-gradient(var(--lumo-tint-5pct), var(--lumo-tint-5pct));
      transform: translate(-75%, -50%) rotate(45deg);
      border-top-right-radius: var(--lumo-border-radius-s);
      box-shadow: 2px -2px 6px 0 var(--lumo-shade-5pct);
      z-index: 1;
    }

    [part='year-number'],
    [part='year-separator'] {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 50%;
      transform: translateY(-50%);
    }

    [part='years'] [part='year-separator']::after {
      color: var(--lumo-disabled-text-color);
      content: 'â€¢';
    }

    /* Current year */

    [part='years'] [part='year-number'][current] {
      color: var(--lumo-primary-text-color);
    }

    /* Toolbar (footer) */

    [part='toolbar'] {
      padding: var(--lumo-space-s);
      box-shadow: 0 -1px 0 0 var(--lumo-contrast-10pct);
      border-bottom-left-radius: var(--lumo-border-radius-l);
      margin-right: 57px;
    }

    @supports (mask-image: linear-gradient(#000, #000)) or (-webkit-mask-image: linear-gradient(#000, #000)) {
      [part='toolbar'] {
        box-shadow: none;
      }
    }

    /* Today and Cancel buttons */

    [part='toolbar'] [part\$='button'] {
      margin: 0;
    }

    /* Narrow viewport mode (fullscreen) */

    :host([fullscreen]) [part='toolbar'] {
      order: -1;
      background-color: var(--lumo-base-color);
    }

    :host([fullscreen]) [part='overlay-header'] {
      order: -2;
      height: var(--lumo-size-m);
      padding: var(--lumo-space-s);
      position: absolute;
      left: 0;
      right: 0;
      justify-content: center;
    }

    :host([fullscreen]) [part='toggle-button'],
    :host([fullscreen]) [part='clear-button'],
    [part='overlay-header'] [part='label'] {
      display: none;
    }

    /* Very narrow screen (year scroller initially hidden) */

    [part='years-toggle-button'] {
      position: relative;
      right: auto;
      display: flex;
      align-items: center;
      height: var(--lumo-size-s);
      padding: 0 0.5em;
      border-radius: var(--lumo-border-radius-m);
      z-index: 3;
      color: var(--lumo-primary-text-color);
      font-weight: 500;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    :host([years-visible]) [part='years-toggle-button'] {
      background-color: var(--lumo-primary-color);
      color: var(--lumo-primary-contrast-color);
    }

    [part='years-toggle-button']::before {
      content: none;
    }

    /* TODO magic number (same as used for iron-media-query in vaadin-date-picker-overlay-content) */
    @media screen and (max-width: 374px) {
      :host {
        background-image: none;
      }

      [part='years'] {
        background-color: var(--lumo-shade-5pct);
      }

      [part='toolbar'],
      [part='months'] {
        margin-right: 0;
      }

      /* TODO make date-picker adapt to the width of the years part */
      [part='years'] {
        --vaadin-infinite-scroller-buffer-width: 90px;
        width: 50px;
      }

      :host([years-visible]) [part='months'] {
        padding-left: 50px;
      }
    }
  `, { moduleId: "lumo-date-picker-overlay-content" });

// node_modules/@vaadin/date-picker/theme/lumo/vaadin-month-calendar-styles.js
registerStyles("vaadin-month-calendar", css`
    :host {
      -moz-user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      font-size: var(--lumo-font-size-m);
      color: var(--lumo-body-text-color);
      text-align: center;
      padding: 0 var(--lumo-space-xs);
    }

    /* Month header */

    [part='month-header'] {
      color: var(--lumo-header-text-color);
      font-size: var(--lumo-font-size-l);
      line-height: 1;
      font-weight: 500;
      margin-bottom: var(--lumo-space-m);
    }

    /* Week days and numbers */

    [part='weekdays'],
    [part='weekday'],
    [part='week-numbers'] {
      font-size: var(--lumo-font-size-xxs);
      line-height: 1;
      color: var(--lumo-secondary-text-color);
    }

    [part='weekdays'] {
      margin-bottom: var(--lumo-space-s);
    }

    /* TODO should have part="week-number" for the cell in weekdays-container */
    [part='weekday']:empty,
    [part='week-numbers'] {
      width: var(--lumo-size-xs);
    }

    /* Date and week number cells */

    [part='date'],
    [part='week-number'] {
      box-sizing: border-box;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      height: var(--lumo-size-m);
      position: relative;
    }

    [part='date'] {
      transition: color 0.1s;
    }

    [part='date']:not(:empty) {
      cursor: var(--lumo-clickable-cursor);
    }

    /* Today date */

    [part='date'][today] {
      color: var(--lumo-primary-text-color);
    }

    /* Focused date */

    [part='date']::before {
      content: '';
      position: absolute;
      z-index: -1;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      min-width: 2em;
      min-height: 2em;
      width: 80%;
      height: 80%;
      max-height: 100%;
      max-width: 100%;
      border-radius: var(--lumo-border-radius-m);
    }

    [part='date'][focused]::before {
      box-shadow: 0 0 0 1px var(--lumo-base-color), 0 0 0 3px var(--lumo-primary-color-50pct);
    }

    :host(:not([focused])) [part='date'][focused]::before {
      animation: vaadin-date-picker-month-calendar-focus-date 1.4s infinite;
    }

    @keyframes vaadin-date-picker-month-calendar-focus-date {
      50% {
        box-shadow: 0 0 0 1px var(--lumo-base-color), 0 0 0 3px transparent;
      }
    }

    /* TODO should not rely on the role attribute */
    [part='date'][role='button']:not([disabled]):not([selected]):hover::before {
      background-color: var(--lumo-primary-color-10pct);
    }

    [part='date'][selected] {
      color: var(--lumo-primary-contrast-color);
    }

    [part='date'][selected]::before {
      background-color: var(--lumo-primary-color);
    }

    [part='date'][disabled] {
      color: var(--lumo-disabled-text-color);
    }

    @media (pointer: coarse) {
      [part='date']:hover:not([selected])::before,
      [part='date'][focused]:not([selected])::before {
        display: none;
      }

      [part='date'][role='button']:not([disabled]):active::before {
        display: block;
      }

      [part='date'][selected]::before {
        box-shadow: none;
      }
    }

    /* Disabled */

    :host([disabled]) * {
      color: var(--lumo-disabled-text-color) !important;
    }
  `, { moduleId: "lumo-month-calendar" });
var $_documentContainer = document.createElement("template");
$_documentContainer.innerHTML = `
  <style>
    @keyframes vaadin-date-picker-month-calendar-focus-date {
      50% {
        box-shadow: 0 0 0 2px transparent;
      }
    }
  </style>
`;
document.head.appendChild($_documentContainer.content);

// node_modules/@vaadin/date-picker/theme/lumo/vaadin-date-picker-styles.js
var datePicker = css`
  :host {
    outline: none;
  }

  [part='toggle-button']::before {
    content: var(--lumo-icons-calendar);
  }

  [part='clear-button']::before {
    content: var(--lumo-icons-cross);
  }

  @media (max-width: 420px), (max-height: 420px) {
    [part='overlay-content'] {
      height: 70vh;
    }
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input) {
    --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent, #000 1.25em);
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input:placeholder-shown) {
    --_lumo-text-field-overflow-mask-image: none;
  }
`;
registerStyles("vaadin-date-picker", [inputFieldShared, datePicker], { moduleId: "lumo-date-picker" });

// node_modules/@vaadin/date-picker/src/vaadin-date-picker-styles.js
var datePickerStyles = css`
  :host([dir='rtl']) [part='input-field'] {
    direction: ltr;
  }

  :host([dir='rtl']) [part='value']::placeholder {
    direction: rtl;
    text-align: left;
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input)::placeholder {
    direction: rtl;
    text-align: left;
  }
`;
var datePickerOverlayStyles = css`
  [part='overlay'] {
    display: flex;
    flex: auto;
  }

  [part~='content'] {
    flex: auto;
  }
`;

// node_modules/@vaadin/date-picker/src/vaadin-date-picker-overlay.js
registerStyles("vaadin-date-picker-overlay", datePickerOverlayStyles, {
  moduleId: "vaadin-date-picker-overlay-styles"
});
var memoizedTemplate;
var DatePickerOverlay = class extends DisableUpgradeMixin(PositionMixin(OverlayElement)) {
  static get is() {
    return "vaadin-date-picker-overlay";
  }
  static get template() {
    if (!memoizedTemplate) {
      memoizedTemplate = super.template.cloneNode(true);
      memoizedTemplate.content.querySelector('[part~="overlay"]').removeAttribute("tabindex");
    }
    return memoizedTemplate;
  }
};
customElements.define(DatePickerOverlay.is, DatePickerOverlay);

// node_modules/@vaadin/date-picker/src/vaadin-date-picker-helper.js
function getISOWeekNumber(date) {
  let dayOfWeek = date.getDay();
  if (dayOfWeek === 0) {
    dayOfWeek = 7;
  }
  const nearestThursdayDiff = 4 - dayOfWeek;
  const nearestThursday = new Date(date.getTime() + nearestThursdayDiff * 24 * 3600 * 1e3);
  const firstOfJanuary = new Date(0, 0);
  firstOfJanuary.setFullYear(nearestThursday.getFullYear());
  const timeDiff = nearestThursday.getTime() - firstOfJanuary.getTime();
  const daysSinceFirstOfJanuary = Math.round(timeDiff / (24 * 3600 * 1e3));
  return Math.floor(daysSinceFirstOfJanuary / 7 + 1);
}
function dateEquals(date1, date2) {
  return date1 instanceof Date && date2 instanceof Date && date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
}
function dateAllowed(date, min, max) {
  return (!min || date >= min) && (!max || date <= max);
}
function getClosestDate(date, dates) {
  return dates.filter((date2) => date2 !== void 0).reduce((closestDate, candidate) => {
    if (!candidate) {
      return closestDate;
    }
    if (!closestDate) {
      return candidate;
    }
    var candidateDiff = Math.abs(date.getTime() - candidate.getTime());
    var closestDateDiff = Math.abs(closestDate.getTime() - date.getTime());
    return candidateDiff < closestDateDiff ? candidate : closestDate;
  });
}
function extractDateParts(date) {
  return {
    day: date.getDate(),
    month: date.getMonth(),
    year: date.getFullYear()
  };
}

// node_modules/@vaadin/date-picker/src/vaadin-month-calendar.js
var MonthCalendar = class extends FocusMixin(ThemableMixin(PolymerElement)) {
  static get template() {
    return html`
      <style>
        :host {
          display: block;
        }

        #monthGrid {
          display: block;
        }

        #monthGrid thead,
        #monthGrid tbody {
          display: block;
          width: 100%;
        }

        [part='weekdays'] {
          display: flex;
          flex-grow: 1;
        }

        #days-container tr,
        #weekdays-container tr {
          display: flex;
        }

        [part='week-numbers'] {
          display: flex;
          flex-direction: column;
          justify-content: space-between;
          flex-shrink: 0;
        }

        [part='date'] {
          outline: none;
        }

        [part='week-number'][hidden],
        [part='week-numbers'][hidden],
        [part='weekday'][hidden] {
          display: none;
        }

        [part='weekday'],
        [part='date'] {
          display: block;
          /* Would use calc(100% / 7) but it doesn't work nice on IE */
          width: 14.285714286%;
          padding: 0;
          font-weight: normal;
        }

        [part='weekday']:empty,
        [part='week-numbers'] {
          width: 12.5%;
          flex-shrink: 0;
        }
      </style>

      <div part="month-header" id="month-header" aria-hidden="true">[[_getTitle(month, i18n.monthNames)]]</div>
      <table
        id="monthGrid"
        role="grid"
        aria-labelledby="month-header"
        on-touchend="_preventDefault"
        on-touchstart="_onMonthGridTouchStart"
      >
        <thead id="weekdays-container">
          <tr role="row" part="weekdays">
            <th
              part="weekday"
              aria-hidden="true"
              hidden$="[[!_showWeekSeparator(showWeekNumbers, i18n.firstDayOfWeek)]]"
            ></th>
            <template
              is="dom-repeat"
              items="[[_getWeekDayNames(i18n.weekdays, i18n.weekdaysShort, showWeekNumbers, i18n.firstDayOfWeek)]]"
            >
              <th role="columnheader" part="weekday" scope="col" abbr$="[[item.weekDay]]">[[item.weekDayShort]]</th>
            </template>
          </tr>
        </thead>
        <tbody id="days-container">
          <template is="dom-repeat" items="[[_weeks]]" as="week">
            <tr role="row">
              <td
                part="week-number"
                aria-hidden="true"
                hidden$="[[!_showWeekSeparator(showWeekNumbers, i18n.firstDayOfWeek)]]"
              >
                [[__getWeekNumber(week)]]
              </td>
              <template is="dom-repeat" items="[[week]]">
                <td
                  role="gridcell"
                  part="date"
                  date="[[item]]"
                  today$="[[_isToday(item)]]"
                  focused$="[[__isDayFocused(item, focusedDate)]]"
                  tabindex$="[[__getDayTabindex(item, focusedDate)]]"
                  selected$="[[__isDaySelected(item, selectedDate)]]"
                  disabled$="[[__isDayDisabled(item, minDate, maxDate)]]"
                  aria-selected$="[[__getDayAriaSelected(item, selectedDate)]]"
                  aria-disabled$="[[__getDayAriaDisabled(item, minDate, maxDate)]]"
                  aria-label$="[[__getDayAriaLabel(item)]]"
                  >[[_getDate(item)]]</td
                >
              </template>
            </tr>
          </template>
        </tbody>
      </table>
    `;
  }
  static get is() {
    return "vaadin-month-calendar";
  }
  static get properties() {
    return {
      month: {
        type: Date,
        value: new Date()
      },
      selectedDate: {
        type: Date,
        notify: true
      },
      focusedDate: Date,
      showWeekNumbers: {
        type: Boolean,
        value: false
      },
      i18n: {
        type: Object
      },
      ignoreTaps: Boolean,
      _notTapping: Boolean,
      minDate: {
        type: Date,
        value: null
      },
      maxDate: {
        type: Date,
        value: null
      },
      _days: {
        type: Array,
        computed: "_getDays(month, i18n.firstDayOfWeek, minDate, maxDate)"
      },
      _weeks: {
        type: Array,
        computed: "_getWeeks(_days)"
      },
      disabled: {
        type: Boolean,
        reflectToAttribute: true,
        computed: "_isDisabled(month, minDate, maxDate)"
      }
    };
  }
  static get observers() {
    return [
      "_showWeekNumbersChanged(showWeekNumbers, i18n.firstDayOfWeek)",
      "__focusedDateChanged(focusedDate, _days)"
    ];
  }
  ready() {
    super.ready();
    addListener(this.$.monthGrid, "tap", this._handleTap.bind(this));
  }
  get focusableDateElement() {
    return [...this.shadowRoot.querySelectorAll("[part=date]")].find((datePart) => {
      return dateEquals(datePart.date, this.focusedDate);
    });
  }
  _isDisabled(month, minDate, maxDate) {
    var firstDate = new Date(0, 0);
    firstDate.setFullYear(month.getFullYear());
    firstDate.setMonth(month.getMonth());
    firstDate.setDate(1);
    var lastDate = new Date(0, 0);
    lastDate.setFullYear(month.getFullYear());
    lastDate.setMonth(month.getMonth() + 1);
    lastDate.setDate(0);
    if (minDate && maxDate && minDate.getMonth() === maxDate.getMonth() && minDate.getMonth() === month.getMonth() && maxDate.getDate() - minDate.getDate() >= 0) {
      return false;
    }
    return !dateAllowed(firstDate, minDate, maxDate) && !dateAllowed(lastDate, minDate, maxDate);
  }
  _getTitle(month, monthNames) {
    if (month === void 0 || monthNames === void 0) {
      return;
    }
    return this.i18n.formatTitle(monthNames[month.getMonth()], month.getFullYear());
  }
  _onMonthGridTouchStart() {
    this._notTapping = false;
    setTimeout(() => this._notTapping = true, 300);
  }
  _dateAdd(date, delta) {
    date.setDate(date.getDate() + delta);
  }
  _applyFirstDayOfWeek(weekDayNames, firstDayOfWeek) {
    if (weekDayNames === void 0 || firstDayOfWeek === void 0) {
      return;
    }
    return weekDayNames.slice(firstDayOfWeek).concat(weekDayNames.slice(0, firstDayOfWeek));
  }
  _getWeekDayNames(weekDayNames, weekDayNamesShort, showWeekNumbers, firstDayOfWeek) {
    if (weekDayNames === void 0 || weekDayNamesShort === void 0 || showWeekNumbers === void 0 || firstDayOfWeek === void 0) {
      return;
    }
    weekDayNames = this._applyFirstDayOfWeek(weekDayNames, firstDayOfWeek);
    weekDayNamesShort = this._applyFirstDayOfWeek(weekDayNamesShort, firstDayOfWeek);
    weekDayNames = weekDayNames.map((day, index) => {
      return {
        weekDay: day,
        weekDayShort: weekDayNamesShort[index]
      };
    });
    return weekDayNames;
  }
  __focusedDateChanged(focusedDate, days) {
    if (days.some((date) => dateEquals(date, focusedDate))) {
      this.removeAttribute("aria-hidden");
    } else {
      this.setAttribute("aria-hidden", "true");
    }
  }
  _getDate(date) {
    return date ? date.getDate() : "";
  }
  _showWeekNumbersChanged(showWeekNumbers, firstDayOfWeek) {
    if (showWeekNumbers && firstDayOfWeek === 1) {
      this.setAttribute("week-numbers", "");
    } else {
      this.removeAttribute("week-numbers");
    }
  }
  _showWeekSeparator(showWeekNumbers, firstDayOfWeek) {
    return showWeekNumbers && firstDayOfWeek === 1;
  }
  _isToday(date) {
    return dateEquals(new Date(), date);
  }
  _getDays(month, firstDayOfWeek) {
    if (month === void 0 || firstDayOfWeek === void 0) {
      return;
    }
    var date = new Date(0, 0);
    date.setFullYear(month.getFullYear());
    date.setMonth(month.getMonth());
    date.setDate(1);
    while (date.getDay() !== firstDayOfWeek) {
      this._dateAdd(date, -1);
    }
    var days = [];
    var startMonth = date.getMonth();
    var targetMonth = month.getMonth();
    while (date.getMonth() === targetMonth || date.getMonth() === startMonth) {
      days.push(date.getMonth() === targetMonth ? new Date(date.getTime()) : null);
      this._dateAdd(date, 1);
    }
    return days;
  }
  _getWeeks(days) {
    return days.reduce((acc, day, i) => {
      if (i % 7 === 0) {
        acc.push([]);
      }
      acc[acc.length - 1].push(day);
      return acc;
    }, []);
  }
  _handleTap(e) {
    if (!this.ignoreTaps && !this._notTapping && e.target.date && !e.target.hasAttribute("disabled")) {
      this.selectedDate = e.target.date;
      this.dispatchEvent(new CustomEvent("date-tap", { bubbles: true, composed: true }));
    }
  }
  _preventDefault(e) {
    e.preventDefault();
  }
  __getWeekNumber(days) {
    const date = days.reduce((acc, d) => {
      return !acc && d ? d : acc;
    });
    return getISOWeekNumber(date);
  }
  __isDayFocused(date, focusedDate) {
    return dateEquals(date, focusedDate);
  }
  __isDaySelected(date, selectedDate) {
    return dateEquals(date, selectedDate);
  }
  __getDayAriaSelected(date, selectedDate) {
    if (this.__isDaySelected(date, selectedDate)) {
      return "true";
    }
  }
  __isDayDisabled(date, minDate, maxDate) {
    return !dateAllowed(date, minDate, maxDate);
  }
  __getDayAriaDisabled(date, min, max) {
    if (date === void 0 || min === void 0 || max === void 0) {
      return;
    }
    if (this.__isDayDisabled(date, min, max)) {
      return "true";
    }
  }
  __getDayAriaLabel(date) {
    if (!date) {
      return "";
    }
    var ariaLabel = this._getDate(date) + " " + this.i18n.monthNames[date.getMonth()] + " " + date.getFullYear() + ", " + this.i18n.weekdays[date.getDay()];
    if (this._isToday(date)) {
      ariaLabel += ", " + this.i18n.today;
    }
    return ariaLabel;
  }
  __getDayTabindex(date, focusedDate) {
    if (this.__isDayFocused(date, focusedDate)) {
      return "0";
    }
    return "-1";
  }
  __getWeekNumbers(dates) {
    return dates.map((date) => this.__getWeekNumber(date, dates)).filter((week, index, arr) => arr.indexOf(week) === index);
  }
};
customElements.define(MonthCalendar.is, MonthCalendar);

// node_modules/@vaadin/date-picker/src/vaadin-infinite-scroller.js
var InfiniteScroller = class extends PolymerElement {
  static get template() {
    return html`
      <style>
        :host {
          display: block;
          overflow: hidden;
          height: 500px;
        }

        #scroller {
          position: relative;
          height: 100%;
          overflow: auto;
          outline: none;
          margin-right: -40px;
          -webkit-overflow-scrolling: touch;
          overflow-x: hidden;
        }

        #scroller.notouchscroll {
          -webkit-overflow-scrolling: auto;
        }

        #scroller::-webkit-scrollbar {
          display: none;
        }

        .buffer {
          position: absolute;
          width: var(--vaadin-infinite-scroller-buffer-width, 100%);
          box-sizing: border-box;
          padding-right: 40px;
          top: var(--vaadin-infinite-scroller-buffer-offset, 0);
          animation: fadein 0.2s;
        }

        @keyframes fadein {
          from {
            opacity: 0;
          }
          to {
            opacity: 1;
          }
        }
      </style>

      <div id="scroller" on-scroll="_scroll">
        <div class="buffer"></div>
        <div class="buffer"></div>
        <div id="fullHeight"></div>
      </div>
    `;
  }
  static get is() {
    return "vaadin-infinite-scroller";
  }
  static get properties() {
    return {
      bufferSize: {
        type: Number,
        value: 20
      },
      _initialScroll: {
        value: 5e5
      },
      _initialIndex: {
        value: 0
      },
      _buffers: Array,
      _preventScrollEvent: Boolean,
      _mayHaveMomentum: Boolean,
      _initialized: Boolean,
      active: {
        type: Boolean,
        observer: "_activated"
      }
    };
  }
  ready() {
    super.ready();
    this._buffers = Array.prototype.slice.call(this.root.querySelectorAll(".buffer"));
    this.$.fullHeight.style.height = this._initialScroll * 2 + "px";
    const tpl = this.querySelector("template");
    this._TemplateClass = templatize(tpl, this, {
      forwardHostProp: function(prop, value) {
        if (prop !== "index") {
          this._buffers.forEach((buffer) => {
            [].forEach.call(buffer.children, (insertionPoint) => {
              insertionPoint._itemWrapper.instance[prop] = value;
            });
          });
        }
      }
    });
    if (isFirefox) {
      this.$.scroller.tabIndex = -1;
    }
  }
  _activated(active) {
    if (active && !this._initialized) {
      this._createPool();
      this._initialized = true;
    }
  }
  _finishInit() {
    if (!this._initDone) {
      this._buffers.forEach((buffer) => {
        [].forEach.call(buffer.children, (insertionPoint) => this._ensureStampedInstance(insertionPoint._itemWrapper));
      }, this);
      if (!this._buffers[0].translateY) {
        this._reset();
      }
      this._initDone = true;
    }
  }
  _translateBuffer(up) {
    const index = up ? 1 : 0;
    this._buffers[index].translateY = this._buffers[index ? 0 : 1].translateY + this._bufferHeight * (index ? -1 : 1);
    this._buffers[index].style.transform = "translate3d(0, " + this._buffers[index].translateY + "px, 0)";
    this._buffers[index].updated = false;
    this._buffers.reverse();
  }
  _scroll() {
    if (this._scrollDisabled) {
      return;
    }
    const scrollTop = this.$.scroller.scrollTop;
    if (scrollTop < this._bufferHeight || scrollTop > this._initialScroll * 2 - this._bufferHeight) {
      this._initialIndex = ~~this.position;
      this._reset();
    }
    const offset = this.itemHeight + this.bufferOffset;
    const upperThresholdReached = scrollTop > this._buffers[1].translateY + offset;
    const lowerThresholdReached = scrollTop < this._buffers[0].translateY + offset;
    if (upperThresholdReached || lowerThresholdReached) {
      this._translateBuffer(lowerThresholdReached);
      this._updateClones();
    }
    if (!this._preventScrollEvent) {
      this.dispatchEvent(new CustomEvent("custom-scroll", { bubbles: false, composed: true }));
      this._mayHaveMomentum = true;
    }
    this._preventScrollEvent = false;
    this._debouncerScrollFinish = Debouncer.debounce(this._debouncerScrollFinish, timeOut.after(200), () => {
      const scrollerRect = this.$.scroller.getBoundingClientRect();
      if (!this._isVisible(this._buffers[0], scrollerRect) && !this._isVisible(this._buffers[1], scrollerRect)) {
        this.position = this.position;
      }
    });
  }
  get bufferOffset() {
    return this._buffers[0].offsetTop;
  }
  get position() {
    return (this.$.scroller.scrollTop - this._buffers[0].translateY) / this.itemHeight + this._firstIndex;
  }
  set position(index) {
    this._preventScrollEvent = true;
    if (index > this._firstIndex && index < this._firstIndex + this.bufferSize * 2) {
      this.$.scroller.scrollTop = this.itemHeight * (index - this._firstIndex) + this._buffers[0].translateY;
    } else {
      this._initialIndex = ~~index;
      this._reset();
      this._scrollDisabled = true;
      this.$.scroller.scrollTop += index % 1 * this.itemHeight;
      this._scrollDisabled = false;
    }
    if (this._mayHaveMomentum) {
      this.$.scroller.classList.add("notouchscroll");
      this._mayHaveMomentum = false;
      setTimeout(() => {
        this.$.scroller.classList.remove("notouchscroll");
      }, 10);
    }
  }
  get itemHeight() {
    if (!this._itemHeightVal) {
      const itemHeight = getComputedStyle(this).getPropertyValue("--vaadin-infinite-scroller-item-height");
      const tmpStyleProp = "background-position";
      this.$.fullHeight.style.setProperty(tmpStyleProp, itemHeight);
      const itemHeightPx = getComputedStyle(this.$.fullHeight).getPropertyValue(tmpStyleProp);
      this.$.fullHeight.style.removeProperty(tmpStyleProp);
      this._itemHeightVal = parseFloat(itemHeightPx);
    }
    return this._itemHeightVal;
  }
  get _bufferHeight() {
    return this.itemHeight * this.bufferSize;
  }
  _reset() {
    this._scrollDisabled = true;
    this.$.scroller.scrollTop = this._initialScroll;
    this._buffers[0].translateY = this._initialScroll - this._bufferHeight;
    this._buffers[1].translateY = this._initialScroll;
    this._buffers.forEach((buffer) => {
      buffer.style.transform = "translate3d(0, " + buffer.translateY + "px, 0)";
    });
    this._buffers[0].updated = this._buffers[1].updated = false;
    this._updateClones(true);
    this._debouncerUpdateClones = Debouncer.debounce(this._debouncerUpdateClones, timeOut.after(200), () => {
      this._buffers[0].updated = this._buffers[1].updated = false;
      this._updateClones();
    });
    this._scrollDisabled = false;
  }
  _createPool() {
    const container = this.getBoundingClientRect();
    this._buffers.forEach((buffer) => {
      for (let i = 0; i < this.bufferSize; i++) {
        const itemWrapper = document.createElement("div");
        itemWrapper.style.height = this.itemHeight + "px";
        itemWrapper.instance = {};
        const contentId = InfiniteScroller._contentIndex = InfiniteScroller._contentIndex + 1 || 0;
        const slotName = "vaadin-infinite-scroller-item-content-" + contentId;
        const insertionPoint = document.createElement("slot");
        insertionPoint.setAttribute("name", slotName);
        insertionPoint._itemWrapper = itemWrapper;
        buffer.appendChild(insertionPoint);
        itemWrapper.setAttribute("slot", slotName);
        this.appendChild(itemWrapper);
        setTimeout(() => {
          if (this._isVisible(itemWrapper, container)) {
            this._ensureStampedInstance(itemWrapper);
          }
        }, 1);
      }
    }, this);
    setTimeout(() => {
      afterNextRender(this, this._finishInit.bind(this));
    }, 1);
  }
  _ensureStampedInstance(itemWrapper) {
    if (itemWrapper.firstElementChild) {
      return;
    }
    var tmpInstance = itemWrapper.instance;
    itemWrapper.instance = new this._TemplateClass({});
    itemWrapper.appendChild(itemWrapper.instance.root);
    Object.keys(tmpInstance).forEach((prop) => {
      itemWrapper.instance.set(prop, tmpInstance[prop]);
    });
  }
  _updateClones(viewPortOnly) {
    this._firstIndex = ~~((this._buffers[0].translateY - this._initialScroll) / this.itemHeight) + this._initialIndex;
    var scrollerRect = viewPortOnly ? this.$.scroller.getBoundingClientRect() : void 0;
    this._buffers.forEach((buffer, bufferIndex) => {
      if (!buffer.updated) {
        var firstIndex = this._firstIndex + this.bufferSize * bufferIndex;
        [].forEach.call(buffer.children, (insertionPoint, index) => {
          const itemWrapper = insertionPoint._itemWrapper;
          if (!viewPortOnly || this._isVisible(itemWrapper, scrollerRect)) {
            itemWrapper.instance.index = firstIndex + index;
          }
        });
        buffer.updated = true;
      }
    }, this);
  }
  _isVisible(element, container) {
    var rect = element.getBoundingClientRect();
    return rect.bottom > container.top && rect.top < container.bottom;
  }
};
customElements.define(InfiniteScroller.is, InfiniteScroller);

// node_modules/@vaadin/date-picker/src/vaadin-date-picker-overlay-content.js
var DatePickerOverlayContent = class extends ControllerMixin(ThemableMixin(DirMixin(PolymerElement))) {
  static get template() {
    return html`
      <style>
        :host {
          display: flex;
          flex-direction: column;
          height: 100%;
          width: 100%;
          outline: none;
          background: #fff;
        }

        [part='overlay-header'] {
          display: flex;
          flex-shrink: 0;
          flex-wrap: nowrap;
          align-items: center;
        }

        :host(:not([fullscreen])) [part='overlay-header'] {
          display: none;
        }

        [part='label'] {
          flex-grow: 1;
        }

        [part='clear-button']:not([showclear]) {
          display: none;
        }

        [part='years-toggle-button'] {
          display: flex;
        }

        [part='years-toggle-button'][desktop] {
          display: none;
        }

        :host(:not([years-visible])) [part='years-toggle-button']::before {
          transform: rotate(180deg);
        }

        #scrollers {
          display: flex;
          height: 100%;
          width: 100%;
          position: relative;
          overflow: hidden;
        }

        [part='months'],
        [part='years'] {
          height: 100%;
        }

        [part='months'] {
          --vaadin-infinite-scroller-item-height: 270px;
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
        }

        #scrollers[desktop] [part='months'] {
          right: 50px;
          transform: none !important;
        }

        [part='years'] {
          --vaadin-infinite-scroller-item-height: 80px;
          width: 50px;
          position: absolute;
          right: 0;
          transform: translateX(100%);
          -webkit-tap-highlight-color: transparent;
          -webkit-user-select: none;
          -moz-user-select: none;
          user-select: none;
          /* Center the year scroller position. */
          --vaadin-infinite-scroller-buffer-offset: 50%;
        }

        #scrollers[desktop] [part='years'] {
          position: absolute;
          transform: none !important;
        }

        [part='years']::before {
          content: '';
          display: block;
          background: transparent;
          width: 0;
          height: 0;
          position: absolute;
          left: 0;
          top: 50%;
          transform: translateY(-50%);
          border-width: 6px;
          border-style: solid;
          border-color: transparent;
          border-left-color: #000;
        }

        :host(.animate) [part='months'],
        :host(.animate) [part='years'] {
          transition: all 200ms;
        }

        [part='toolbar'] {
          display: flex;
          justify-content: space-between;
          z-index: 2;
          flex-shrink: 0;
        }

        [part~='overlay-header']:not([desktop]) {
          padding-bottom: 40px;
        }

        [part~='years-toggle-button'] {
          position: absolute;
          top: auto;
          right: 8px;
          bottom: 0;
          z-index: 1;
          padding: 8px;
        }
      </style>

      <div part="overlay-header" on-touchend="_preventDefault" desktop$="[[_desktopMode]]" aria-hidden="true">
        <div part="label">[[_formatDisplayed(selectedDate, i18n.formatDate, label)]]</div>
        <div part="clear-button" showclear$="[[_showClear(selectedDate)]]"></div>
        <div part="toggle-button"></div>

        <div part="years-toggle-button" desktop$="[[_desktopMode]]" aria-hidden="true">
          [[_yearAfterXMonths(_visibleMonthIndex)]]
        </div>
      </div>

      <div id="scrollers" desktop$="[[_desktopMode]]">
        <vaadin-infinite-scroller
          id="monthScroller"
          on-custom-scroll="_onMonthScroll"
          on-touchstart="_onMonthScrollTouchStart"
          buffer-size="3"
          active="[[initialPosition]]"
          part="months"
        >
          <template>
            <vaadin-month-calendar
              i18n="[[i18n]]"
              month="[[_dateAfterXMonths(index)]]"
              selected-date="{{selectedDate}}"
              focused-date="[[focusedDate]]"
              ignore-taps="[[_ignoreTaps]]"
              show-week-numbers="[[showWeekNumbers]]"
              min-date="[[minDate]]"
              max-date="[[maxDate]]"
              part="month"
              theme$="[[theme]]"
              on-keydown="__onMonthCalendarKeyDown"
            >
            </vaadin-month-calendar>
          </template>
        </vaadin-infinite-scroller>
        <vaadin-infinite-scroller
          id="yearScroller"
          on-custom-scroll="_onYearScroll"
          on-touchstart="_onYearScrollTouchStart"
          buffer-size="12"
          active="[[initialPosition]]"
          part="years"
          aria-hidden="true"
        >
          <template>
            <div
              part="year-number"
              current$="[[_isCurrentYear(index)]]"
              selected$="[[_isSelectedYear(index, selectedDate)]]"
            >
              [[_yearAfterXYears(index)]]
            </div>
            <div part="year-separator" aria-hidden="true"></div>
          </template>
        </vaadin-infinite-scroller>
      </div>

      <div on-touchend="_preventDefault" role="toolbar" part="toolbar">
        <vaadin-button
          id="todayButton"
          part="today-button"
          theme="tertiary"
          disabled="[[!_isTodayAllowed(minDate, maxDate)]]"
          on-keydown="__onTodayButtonKeyDown"
        >
          [[i18n.today]]
        </vaadin-button>
        <vaadin-button id="cancelButton" part="cancel-button" theme="tertiary" on-keydown="__onCancelButtonKeyDown">
          [[i18n.cancel]]
        </vaadin-button>
      </div>
    `;
  }
  static get is() {
    return "vaadin-date-picker-overlay-content";
  }
  static get properties() {
    return {
      selectedDate: {
        type: Date,
        notify: true
      },
      focusedDate: {
        type: Date,
        notify: true,
        observer: "_focusedDateChanged"
      },
      _focusedMonthDate: Number,
      initialPosition: {
        type: Date,
        observer: "_initialPositionChanged"
      },
      _originDate: {
        value: new Date()
      },
      _visibleMonthIndex: Number,
      _desktopMode: Boolean,
      _desktopMediaQuery: {
        type: String,
        value: "(min-width: 375px)"
      },
      _translateX: {
        observer: "_translateXChanged"
      },
      _yearScrollerWidth: {
        value: 50
      },
      i18n: {
        type: Object
      },
      showWeekNumbers: {
        type: Boolean
      },
      _ignoreTaps: Boolean,
      _notTapping: Boolean,
      minDate: Date,
      maxDate: Date,
      label: String
    };
  }
  get __isRTL() {
    return this.getAttribute("dir") === "rtl";
  }
  get focusableDateElement() {
    return [...this.shadowRoot.querySelectorAll("vaadin-month-calendar")].map((calendar) => calendar.focusableDateElement).find(Boolean);
  }
  ready() {
    super.ready();
    addListener(this, "tap", this._stopPropagation);
    addListener(this.$.scrollers, "track", this._track.bind(this));
    addListener(this.shadowRoot.querySelector('[part="clear-button"]'), "tap", this._clear.bind(this));
    addListener(this.shadowRoot.querySelector('[part="today-button"]'), "tap", this._onTodayTap.bind(this));
    addListener(this.shadowRoot.querySelector('[part="cancel-button"]'), "tap", this._cancel.bind(this));
    addListener(this.shadowRoot.querySelector('[part="toggle-button"]'), "tap", this._cancel.bind(this));
    addListener(this.shadowRoot.querySelector('[part="years"]'), "tap", this._onYearTap.bind(this));
    addListener(this.shadowRoot.querySelector('[part="years-toggle-button"]'), "tap", this._toggleYearScroller.bind(this));
    this.addController(new MediaQueryController(this._desktopMediaQuery, (matches) => {
      this._desktopMode = matches;
    }));
  }
  connectedCallback() {
    super.connectedCallback();
    this._closeYearScroller();
    this._toggleAnimateClass(true);
    setTouchAction(this.$.scrollers, "pan-y");
  }
  focusCancel() {
    this.$.cancelButton.focus();
  }
  scrollToDate(date, animate) {
    this._scrollToPosition(this._differenceInMonths(date, this._originDate), animate);
  }
  _focusedDateChanged(focusedDate) {
    this.revealDate(focusedDate);
  }
  _isCurrentYear(yearsFromNow) {
    return yearsFromNow === 0;
  }
  _isSelectedYear(yearsFromNow, selectedDate) {
    if (selectedDate) {
      return selectedDate.getFullYear() === this._originDate.getFullYear() + yearsFromNow;
    }
  }
  revealDate(date, animate = true) {
    if (date) {
      const diff = this._differenceInMonths(date, this._originDate);
      const scrolledAboveViewport = this.$.monthScroller.position > diff;
      const visibleArea = Math.max(this.$.monthScroller.itemHeight, this.$.monthScroller.clientHeight - this.$.monthScroller.bufferOffset * 2);
      const visibleItems = visibleArea / this.$.monthScroller.itemHeight;
      const scrolledBelowViewport = this.$.monthScroller.position + visibleItems - 1 < diff;
      if (scrolledAboveViewport) {
        this._scrollToPosition(diff, animate);
      } else if (scrolledBelowViewport) {
        this._scrollToPosition(diff - visibleItems + 1, animate);
      }
    }
  }
  _initialPositionChanged(initialPosition) {
    this.scrollToDate(initialPosition);
  }
  _repositionYearScroller() {
    this._visibleMonthIndex = Math.floor(this.$.monthScroller.position);
    this.$.yearScroller.position = (this.$.monthScroller.position + this._originDate.getMonth()) / 12;
  }
  _repositionMonthScroller() {
    this.$.monthScroller.position = this.$.yearScroller.position * 12 - this._originDate.getMonth();
    this._visibleMonthIndex = Math.floor(this.$.monthScroller.position);
  }
  _onMonthScroll() {
    this._repositionYearScroller();
    this._doIgnoreTaps();
  }
  _onYearScroll() {
    this._repositionMonthScroller();
    this._doIgnoreTaps();
  }
  _onYearScrollTouchStart() {
    this._notTapping = false;
    setTimeout(() => this._notTapping = true, 300);
    this._repositionMonthScroller();
  }
  _onMonthScrollTouchStart() {
    this._repositionYearScroller();
  }
  _doIgnoreTaps() {
    this._ignoreTaps = true;
    this._debouncer = Debouncer.debounce(this._debouncer, timeOut.after(300), () => this._ignoreTaps = false);
  }
  _formatDisplayed(date, formatDate, label) {
    if (date) {
      return formatDate(extractDateParts(date));
    }
    return label;
  }
  _onTodayTap() {
    var today = new Date();
    if (Math.abs(this.$.monthScroller.position - this._differenceInMonths(today, this._originDate)) < 1e-3) {
      this.selectedDate = today;
      this._close();
    } else {
      this._scrollToCurrentMonth();
    }
  }
  _scrollToCurrentMonth() {
    if (this.focusedDate) {
      this.focusedDate = new Date();
    }
    this.scrollToDate(new Date(), true);
  }
  _showClear(selectedDate) {
    return !!selectedDate;
  }
  _onYearTap(e) {
    if (!this._ignoreTaps && !this._notTapping) {
      var scrollDelta = e.detail.y - (this.$.yearScroller.getBoundingClientRect().top + this.$.yearScroller.clientHeight / 2);
      var yearDelta = scrollDelta / this.$.yearScroller.itemHeight;
      this._scrollToPosition(this.$.monthScroller.position + yearDelta * 12, true);
    }
  }
  _scrollToPosition(targetPosition, animate) {
    if (this._targetPosition !== void 0) {
      this._targetPosition = targetPosition;
      return;
    }
    if (!animate) {
      this.$.monthScroller.position = targetPosition;
      this._targetPosition = void 0;
      this._repositionYearScroller();
      this.__tryFocusDate();
      return;
    }
    this._targetPosition = targetPosition;
    var easingFunction = (t, b, c, d) => {
      t /= d / 2;
      if (t < 1) {
        return c / 2 * t * t + b;
      }
      t -= 1;
      return -c / 2 * (t * (t - 2) - 1) + b;
    };
    var duration = animate ? 300 : 0;
    var start = 0;
    var initialPosition = this.$.monthScroller.position;
    var smoothScroll = (timestamp) => {
      start = start || timestamp;
      var currentTime = timestamp - start;
      if (currentTime < duration) {
        var currentPos = easingFunction(currentTime, initialPosition, this._targetPosition - initialPosition, duration);
        this.$.monthScroller.position = currentPos;
        window.requestAnimationFrame(smoothScroll);
      } else {
        this.dispatchEvent(new CustomEvent("scroll-animation-finished", {
          bubbles: true,
          composed: true,
          detail: {
            position: this._targetPosition,
            oldPosition: initialPosition
          }
        }));
        this.$.monthScroller.position = this._targetPosition;
        this._targetPosition = void 0;
        this.__tryFocusDate();
      }
      setTimeout(this._repositionYearScroller.bind(this), 1);
    };
    window.requestAnimationFrame(smoothScroll);
  }
  _limit(value, range) {
    return Math.min(range.max, Math.max(range.min, value));
  }
  _handleTrack(e) {
    if (Math.abs(e.detail.dx) < 10 || Math.abs(e.detail.ddy) > 10) {
      return;
    }
    if (Math.abs(e.detail.ddx) > this._yearScrollerWidth / 3) {
      this._toggleAnimateClass(true);
    }
    var newTranslateX = this._translateX + e.detail.ddx;
    this._translateX = this._limit(newTranslateX, {
      min: 0,
      max: this._yearScrollerWidth
    });
  }
  _track(e) {
    if (this._desktopMode) {
      return;
    }
    switch (e.detail.state) {
      case "start":
        this._toggleAnimateClass(false);
        break;
      case "track":
        this._handleTrack(e);
        break;
      case "end":
        this._toggleAnimateClass(true);
        if (this._translateX >= this._yearScrollerWidth / 2) {
          this._closeYearScroller();
        } else {
          this._openYearScroller();
        }
        break;
      default:
        break;
    }
  }
  _toggleAnimateClass(enable) {
    if (enable) {
      this.classList.add("animate");
    } else {
      this.classList.remove("animate");
    }
  }
  _toggleYearScroller() {
    this._isYearScrollerVisible() ? this._closeYearScroller() : this._openYearScroller();
  }
  _openYearScroller() {
    this._translateX = 0;
    this.setAttribute("years-visible", "");
  }
  _closeYearScroller() {
    this.removeAttribute("years-visible");
    this._translateX = this._yearScrollerWidth;
  }
  _isYearScrollerVisible() {
    return this._translateX < this._yearScrollerWidth / 2;
  }
  _translateXChanged(x) {
    if (!this._desktopMode) {
      this.$.monthScroller.style.transform = "translateX(" + (x - this._yearScrollerWidth) + "px)";
      this.$.yearScroller.style.transform = "translateX(" + x + "px)";
    }
  }
  _yearAfterXYears(index) {
    var result = new Date(this._originDate);
    result.setFullYear(parseInt(index) + this._originDate.getFullYear());
    return result.getFullYear();
  }
  _yearAfterXMonths(months) {
    return this._dateAfterXMonths(months).getFullYear();
  }
  _dateAfterXMonths(months) {
    var result = new Date(this._originDate);
    result.setDate(1);
    result.setMonth(parseInt(months) + this._originDate.getMonth());
    return result;
  }
  _differenceInMonths(date1, date2) {
    var months = (date1.getFullYear() - date2.getFullYear()) * 12;
    return months - date2.getMonth() + date1.getMonth();
  }
  _differenceInYears(date1, date2) {
    return this._differenceInMonths(date1, date2) / 12;
  }
  _clear() {
    this.selectedDate = "";
  }
  _close() {
    const overlayContent = this.getRootNode().host;
    const overlay = overlayContent ? overlayContent.getRootNode().host : null;
    if (overlay) {
      overlay.opened = false;
    }
    this.dispatchEvent(new CustomEvent("close", { bubbles: true, composed: true }));
  }
  _cancel() {
    this.focusedDate = this.selectedDate;
    this._close();
  }
  _preventDefault(e) {
    e.preventDefault();
  }
  __toggleDate(date) {
    if (dateEquals(date, this.selectedDate)) {
      this.selectedDate = "";
      this.focusedDate = date;
    } else {
      this.selectedDate = date;
    }
  }
  __onMonthCalendarKeyDown(event) {
    let handled = false;
    switch (event.key) {
      case "ArrowDown":
        this._moveFocusByDays(7);
        handled = true;
        break;
      case "ArrowUp":
        this._moveFocusByDays(-7);
        handled = true;
        break;
      case "ArrowRight":
        this._moveFocusByDays(this.__isRTL ? -1 : 1);
        handled = true;
        break;
      case "ArrowLeft":
        this._moveFocusByDays(this.__isRTL ? 1 : -1);
        handled = true;
        break;
      case "Enter":
        this.selectedDate = this.focusedDate;
        this._close();
        handled = true;
        break;
      case " ":
        this.__toggleDate(this.focusedDate);
        handled = true;
        break;
      case "Home":
        this._moveFocusInsideMonth(this.focusedDate, "minDate");
        handled = true;
        break;
      case "End":
        this._moveFocusInsideMonth(this.focusedDate, "maxDate");
        handled = true;
        break;
      case "PageDown":
        this._moveFocusByMonths(event.shiftKey ? 12 : 1);
        handled = true;
        break;
      case "PageUp":
        this._moveFocusByMonths(event.shiftKey ? -12 : -1);
        handled = true;
        break;
      case "Escape":
        this._cancel();
        handled = true;
        break;
      default:
        break;
    }
    if (handled) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  __onTodayButtonKeyDown(event) {
    if (this.hasAttribute("fullscreen")) {
      event.stopPropagation();
      return;
    }
    if (event.key === "Tab" && event.shiftKey) {
      event.stopPropagation();
      setTimeout(() => this.revealDate(this.focusedDate), 1);
    }
    if (event.key === "Escape") {
      this._cancel();
      event.preventDefault();
      event.stopPropagation();
    }
  }
  __onCancelButtonKeyDown(event) {
    if (this.hasAttribute("fullscreen")) {
      event.stopPropagation();
      return;
    }
    if (event.key === "Tab" && !event.shiftKey) {
      event.preventDefault();
      event.stopPropagation();
      this.dispatchEvent(new CustomEvent("focus-input", { bubbles: true, composed: true }));
    }
    if (event.key === "Escape") {
      this._cancel();
      event.preventDefault();
      event.stopPropagation();
    }
  }
  __tryFocusDate() {
    const dateToFocus = this.__pendingDateFocus;
    if (dateToFocus) {
      const dateElement = this.focusableDateElement;
      if (dateElement && dateEquals(dateElement.date, this.__pendingDateFocus)) {
        delete this.__pendingDateFocus;
        dateElement.focus();
      }
    }
  }
  async focusDate(date, keepMonth) {
    const dateToFocus = date || this.selectedDate || this.initialPosition || new Date();
    this.focusedDate = dateToFocus;
    if (!keepMonth) {
      this._focusedMonthDate = dateToFocus.getDate();
    }
    await this.focusDateElement();
  }
  async focusDateElement() {
    this.__pendingDateFocus = this.focusedDate;
    await new Promise((resolve) => {
      requestAnimationFrame(resolve);
    });
    this.__tryFocusDate();
  }
  _focusClosestDate(focus) {
    this.focusDate(getClosestDate(focus, [this.minDate, this.maxDate]));
  }
  _moveFocusByDays(days) {
    var focus = this.focusedDate;
    var dateToFocus = new Date(0, 0);
    dateToFocus.setFullYear(focus.getFullYear());
    dateToFocus.setMonth(focus.getMonth());
    dateToFocus.setDate(focus.getDate() + days);
    if (this._dateAllowed(dateToFocus, this.minDate, this.maxDate)) {
      this.focusDate(dateToFocus);
    } else if (this._dateAllowed(focus, this.minDate, this.maxDate)) {
      if (days > 0) {
        this.focusDate(this.maxDate);
      } else {
        this.focusDate(this.minDate);
      }
    } else {
      this._focusClosestDate(focus);
    }
  }
  _moveFocusByMonths(months) {
    var focus = this.focusedDate;
    var dateToFocus = new Date(0, 0);
    dateToFocus.setFullYear(focus.getFullYear());
    dateToFocus.setMonth(focus.getMonth() + months);
    var targetMonth = dateToFocus.getMonth();
    dateToFocus.setDate(this._focusedMonthDate || (this._focusedMonthDate = focus.getDate()));
    if (dateToFocus.getMonth() !== targetMonth) {
      dateToFocus.setDate(0);
    }
    if (this._dateAllowed(dateToFocus, this.minDate, this.maxDate)) {
      this.focusDate(dateToFocus, true);
    } else if (this._dateAllowed(focus, this.minDate, this.maxDate)) {
      if (months > 0) {
        this.focusDate(this.maxDate);
      } else {
        this.focusDate(this.minDate);
      }
    } else {
      this._focusClosestDate(focus);
    }
  }
  _moveFocusInsideMonth(focusedDate, property) {
    var dateToFocus = new Date(0, 0);
    dateToFocus.setFullYear(focusedDate.getFullYear());
    if (property === "minDate") {
      dateToFocus.setMonth(focusedDate.getMonth());
      dateToFocus.setDate(1);
    } else {
      dateToFocus.setMonth(focusedDate.getMonth() + 1);
      dateToFocus.setDate(0);
    }
    if (this._dateAllowed(dateToFocus, this.minDate, this.maxDate)) {
      this.focusDate(dateToFocus);
    } else if (this._dateAllowed(focusedDate, this.minDate, this.maxDate)) {
      this.focusDate(this[property]);
    } else {
      this._focusClosestDate(focusedDate);
    }
  }
  _dateAllowed(date, min, max) {
    return (!min || date >= min) && (!max || date <= max);
  }
  _isTodayAllowed(min, max) {
    var today = new Date();
    var todayMidnight = new Date(0, 0);
    todayMidnight.setFullYear(today.getFullYear());
    todayMidnight.setMonth(today.getMonth());
    todayMidnight.setDate(today.getDate());
    return this._dateAllowed(todayMidnight, min, max);
  }
  _stopPropagation(e) {
    e.stopPropagation();
  }
};
customElements.define(DatePickerOverlayContent.is, DatePickerOverlayContent);

// node_modules/@vaadin/date-picker/src/vaadin-date-picker-mixin.js
var DatePickerMixin = (subclass) => class VaadinDatePickerMixin extends ControllerMixin(DelegateFocusMixin(InputMixin(KeyboardMixin(subclass)))) {
  static get properties() {
    return {
      _selectedDate: {
        type: Date
      },
      _focusedDate: Date,
      value: {
        type: String,
        observer: "_valueChanged",
        notify: true,
        value: ""
      },
      initialPosition: String,
      opened: {
        type: Boolean,
        reflectToAttribute: true,
        notify: true,
        observer: "_openedChanged"
      },
      autoOpenDisabled: Boolean,
      showWeekNumbers: {
        type: Boolean
      },
      _fullscreen: {
        type: Boolean,
        value: false
      },
      _fullscreenMediaQuery: {
        value: "(max-width: 420px), (max-height: 420px)"
      },
      _touchPrevented: Array,
      i18n: {
        type: Object,
        value: () => {
          return {
            monthNames: [
              "January",
              "February",
              "March",
              "April",
              "May",
              "June",
              "July",
              "August",
              "September",
              "October",
              "November",
              "December"
            ],
            weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            firstDayOfWeek: 0,
            week: "Week",
            calendar: "Calendar",
            today: "Today",
            cancel: "Cancel",
            formatDate: (d) => {
              const yearStr = String(d.year).replace(/\d+/, (y) => "0000".substr(y.length) + y);
              return [d.month + 1, d.day, yearStr].join("/");
            },
            parseDate: (text) => {
              const parts = text.split("/");
              const today = new Date();
              let date, month = today.getMonth(), year = today.getFullYear();
              if (parts.length === 3) {
                year = parseInt(parts[2]);
                if (parts[2].length < 3 && year >= 0) {
                  year += year < 50 ? 2e3 : 1900;
                }
                month = parseInt(parts[0]) - 1;
                date = parseInt(parts[1]);
              } else if (parts.length === 2) {
                month = parseInt(parts[0]) - 1;
                date = parseInt(parts[1]);
              } else if (parts.length === 1) {
                date = parseInt(parts[0]);
              }
              if (date !== void 0) {
                return { day: date, month, year };
              }
            },
            formatTitle: (monthName, fullYear) => {
              return monthName + " " + fullYear;
            }
          };
        }
      },
      min: {
        type: String,
        observer: "_minChanged"
      },
      max: {
        type: String,
        observer: "_maxChanged"
      },
      _minDate: {
        type: Date,
        value: ""
      },
      _maxDate: {
        type: Date,
        value: ""
      },
      _noInput: {
        type: Boolean,
        computed: "_isNoInput(inputElement, _fullscreen, _ios, i18n, opened, autoOpenDisabled)"
      },
      _ios: {
        type: Boolean,
        value: isIOS
      },
      _webkitOverflowScroll: {
        type: Boolean,
        value: document.createElement("div").style.webkitOverflowScrolling === ""
      },
      _focusOverlayOnOpen: Boolean,
      _overlayInitialized: Boolean
    };
  }
  static get observers() {
    return [
      "_selectedDateChanged(_selectedDate, i18n.formatDate)",
      "_focusedDateChanged(_focusedDate, i18n.formatDate)"
    ];
  }
  get clearElement() {
    return null;
  }
  get _inputValue() {
    return this.inputElement ? this.inputElement.value : void 0;
  }
  set _inputValue(value) {
    if (this.inputElement) {
      this.inputElement.value = value;
    }
  }
  get _nativeInput() {
    if (this.inputElement) {
      return this.inputElement.focusElement || this.inputElement;
    }
    return null;
  }
  constructor() {
    super();
    this._boundOnScroll = this._onScroll.bind(this);
  }
  _onFocus(event) {
    super._onFocus(event);
    this._noInput && event.target.blur();
  }
  _onBlur(event) {
    super._onBlur(event);
    if (!this.opened) {
      if (this.autoOpenDisabled) {
        const parsedDate = this._getParsedDate();
        if (this._isValidDate(parsedDate)) {
          this._selectedDate = parsedDate;
        }
      }
      if (this.inputElement.value === "" && this.__dispatchChange) {
        this.validate();
        this.value = "";
        this.__dispatchChange = false;
      } else {
        this.validate();
      }
    }
  }
  ready() {
    super.ready();
    this.addEventListener("click", (e) => {
      if (!this._isClearButton(e) && (!this.autoOpenDisabled || this._noInput)) {
        this.open();
      }
    });
    this.addController(new MediaQueryController(this._fullscreenMediaQuery, (matches) => {
      this._fullscreen = matches;
    }));
    this.addController(new VirtualKeyboardController(this));
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.opened = false;
  }
  open() {
    if (!this.disabled && !this.readonly) {
      this.opened = true;
    }
  }
  close() {
    if (this._overlayInitialized || this.autoOpenDisabled) {
      this.$.overlay.close();
    }
  }
  _initOverlay() {
    this.$.overlay.removeAttribute("disable-upgrade");
    this._overlayInitialized = true;
    this.$.overlay.addEventListener("opened-changed", (e) => this.opened = e.detail.value);
    this._overlayContent.addEventListener("close", this._close.bind(this));
    this._overlayContent.addEventListener("focus-input", this._focusAndSelect.bind(this));
    this._overlayContent.addEventListener("focus", () => {
      this._setFocused(true);
    });
    this.$.overlay.addEventListener("vaadin-overlay-close", this._onVaadinOverlayClose.bind(this));
    this.addEventListener("mousedown", () => this.__bringToFront());
    this.addEventListener("touchstart", () => this.__bringToFront());
  }
  validate() {
    return !(this.invalid = !this.checkValidity());
  }
  checkValidity() {
    const inputValid = !this._inputValue || this._selectedDate && this._inputValue === this._getFormattedDate(this.i18n.formatDate, this._selectedDate);
    const minMaxValid = !this._selectedDate || dateAllowed(this._selectedDate, this._minDate, this._maxDate);
    let inputValidity = true;
    if (this.inputElement) {
      if (this.inputElement.checkValidity) {
        inputValidity = this.inputElement.checkValidity();
      } else if (this.inputElement.validate) {
        inputValidity = this.inputElement.validate();
      }
    }
    return inputValid && minMaxValid && inputValidity;
  }
  _close(e) {
    if (e) {
      e.stopPropagation();
    }
    this._focus();
    this.close();
  }
  __bringToFront() {
    requestAnimationFrame(() => {
      this.$.overlay.bringToFront();
    });
  }
  _parseDate(str) {
    const parts = /^([-+]\d{1}|\d{2,4}|[-+]\d{6})-(\d{1,2})-(\d{1,2})$/.exec(str);
    if (!parts) {
      return;
    }
    const date = new Date(0, 0);
    date.setFullYear(parseInt(parts[1], 10));
    date.setMonth(parseInt(parts[2], 10) - 1);
    date.setDate(parseInt(parts[3], 10));
    return date;
  }
  _isNoInput(inputElement, fullscreen, ios, i18n, opened, autoOpenDisabled) {
    const noInputOnFullscreenMode = fullscreen && (!autoOpenDisabled || opened);
    const noInputOnIos = ios && opened;
    return !inputElement || noInputOnFullscreenMode || noInputOnIos || !i18n.parseDate;
  }
  _formatISO(date) {
    if (!(date instanceof Date)) {
      return "";
    }
    const pad = (num, fmt = "00") => (fmt + num).substr((fmt + num).length - fmt.length);
    let yearSign = "";
    let yearFmt = "0000";
    let yearAbs = date.getFullYear();
    if (yearAbs < 0) {
      yearAbs = -yearAbs;
      yearSign = "-";
      yearFmt = "000000";
    } else if (date.getFullYear() >= 1e4) {
      yearSign = "+";
      yearFmt = "000000";
    }
    const year = yearSign + pad(yearAbs, yearFmt);
    const month = pad(date.getMonth() + 1);
    const day = pad(date.getDate());
    return [year, month, day].join("-");
  }
  _inputElementChanged(input) {
    super._inputElementChanged(input);
    if (input) {
      input.autocomplete = "off";
      input.setAttribute("role", "combobox");
      input.setAttribute("aria-haspopup", "dialog");
      input.setAttribute("aria-expanded", !!this.opened);
      this._applyInputValue(this._selectedDate);
    }
  }
  _openedChanged(opened) {
    if (opened && !this._overlayInitialized) {
      this._initOverlay();
    }
    if (this._overlayInitialized) {
      this.$.overlay.opened = opened;
    }
    if (this.inputElement) {
      this.inputElement.setAttribute("aria-expanded", opened);
    }
  }
  _selectedDateChanged(selectedDate, formatDate) {
    if (selectedDate === void 0 || formatDate === void 0) {
      return;
    }
    if (this.__userInputOccurred) {
      this.__dispatchChange = true;
    }
    const value = this._formatISO(selectedDate);
    this.__keepInputValue || this._applyInputValue(selectedDate);
    if (value !== this.value) {
      this.validate();
      this.value = value;
    }
    this.__userInputOccurred = false;
    this.__dispatchChange = false;
    this._ignoreFocusedDateChange = true;
    this._focusedDate = selectedDate;
    this._ignoreFocusedDateChange = false;
  }
  _focusedDateChanged(focusedDate, formatDate) {
    if (focusedDate === void 0 || formatDate === void 0) {
      return;
    }
    this.__userInputOccurred = true;
    if (!this._ignoreFocusedDateChange && !this._noInput) {
      this._applyInputValue(focusedDate);
    }
  }
  __getOverlayTheme(theme, overlayInitialized) {
    if (overlayInitialized) {
      return theme;
    }
  }
  _handleDateChange(property, value, oldValue) {
    if (!value) {
      this[property] = "";
      return;
    }
    const date = this._parseDate(value);
    if (!date) {
      this.value = oldValue;
      return;
    }
    if (!dateEquals(this[property], date)) {
      this[property] = date;
      this.value && this.validate();
    }
  }
  _valueChanged(value, oldValue) {
    if (this.__dispatchChange) {
      this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
      this.__dispatchChange = false;
    }
    this._handleDateChange("_selectedDate", value, oldValue);
    this._toggleHasValue(!!value);
  }
  _minChanged(value, oldValue) {
    this._handleDateChange("_minDate", value, oldValue);
  }
  _maxChanged(value, oldValue) {
    this._handleDateChange("_maxDate", value, oldValue);
  }
  _onOverlayOpened() {
    this._openedWithFocusRing = this.hasAttribute("focus-ring");
    const parsedInitialPosition = this._parseDate(this.initialPosition);
    const initialPosition = this._selectedDate || this._overlayContent.initialPosition || parsedInitialPosition || new Date();
    if (parsedInitialPosition || dateAllowed(initialPosition, this._minDate, this._maxDate)) {
      this._overlayContent.initialPosition = initialPosition;
    } else {
      this._overlayContent.initialPosition = getClosestDate(initialPosition, [this._minDate, this._maxDate]);
    }
    this._overlayContent.scrollToDate(this._overlayContent.focusedDate || this._overlayContent.initialPosition);
    this._ignoreFocusedDateChange = true;
    this._overlayContent.focusedDate = this._overlayContent.focusedDate || this._overlayContent.initialPosition;
    this._ignoreFocusedDateChange = false;
    window.addEventListener("scroll", this._boundOnScroll, true);
    if (this._webkitOverflowScroll) {
      this._touchPrevented = this._preventWebkitOverflowScrollingTouch(this.parentElement);
    }
    if (this._focusOverlayOnOpen) {
      this._overlayContent.focusDateElement();
      this._focusOverlayOnOpen = false;
    } else {
      this._focus();
    }
    if (this._noInput && this.focusElement) {
      this.focusElement.blur();
    }
  }
  _preventWebkitOverflowScrollingTouch(element) {
    const result = [];
    while (element) {
      if (window.getComputedStyle(element).webkitOverflowScrolling === "touch") {
        const oldInlineValue = element.style.webkitOverflowScrolling;
        element.style.webkitOverflowScrolling = "auto";
        result.push({
          element,
          oldInlineValue
        });
      }
      element = element.parentElement;
    }
    return result;
  }
  _selectParsedOrFocusedDate() {
    this._ignoreFocusedDateChange = true;
    if (this.i18n.parseDate) {
      const inputValue = this._inputValue || "";
      const parsedDate = this._getParsedDate(inputValue);
      if (this._isValidDate(parsedDate)) {
        this._selectedDate = parsedDate;
      } else {
        this.__keepInputValue = true;
        this._selectedDate = null;
        this.__keepInputValue = false;
      }
    } else if (this._focusedDate) {
      this._selectedDate = this._focusedDate;
    }
    this._ignoreFocusedDateChange = false;
  }
  _onOverlayClosed() {
    window.removeEventListener("scroll", this._boundOnScroll, true);
    if (this._touchPrevented) {
      this._touchPrevented.forEach((prevented) => prevented.element.style.webkitOverflowScrolling = prevented.oldInlineValue);
      this._touchPrevented = [];
    }
    this._selectParsedOrFocusedDate();
    if (this._nativeInput && this._nativeInput.selectionStart) {
      this._nativeInput.selectionStart = this._nativeInput.selectionEnd;
    }
    if (!this.value) {
      this.validate();
    }
    if (this.getRootNode().activeElement !== this.inputElement) {
      this._setFocused(false);
    }
  }
  _onScroll(e) {
    if (e.target === window || !this._overlayContent.contains(e.target)) {
      this._overlayContent._repositionYearScroller();
    }
  }
  _focus() {
    if (this._noInput) {
      this._overlayInitialized && this._overlayContent.focus();
    } else {
      this.inputElement.focus();
    }
  }
  _focusAndSelect() {
    this._focus();
    this._setSelectionRange(0, this._inputValue.length);
  }
  _applyInputValue(date) {
    this._inputValue = date ? this._getFormattedDate(this.i18n.formatDate, date) : "";
  }
  _getFormattedDate(formatDate, date) {
    return formatDate(extractDateParts(date));
  }
  _setSelectionRange(a, b) {
    if (this._nativeInput && this._nativeInput.setSelectionRange) {
      this._nativeInput.setSelectionRange(a, b);
    }
  }
  _isValidDate(d) {
    return d && !isNaN(d.getTime());
  }
  _onChange(event) {
    if (this.inputElement.value === "" && !(event.detail && event.detail.sourceEvent && event.detail.sourceEvent.__fromClearButton)) {
      this.__dispatchChange = true;
    }
    event.stopPropagation();
  }
  _onClearButtonClick() {
    this.value = "";
    this._inputValue = "";
    this.validate();
    this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
  }
  _onKeyDown(e) {
    if (this._noInput) {
      var allowedKeys = [
        9
      ];
      if (allowedKeys.indexOf(e.keyCode) === -1) {
        e.preventDefault();
      }
    }
    switch (e.key) {
      case "ArrowDown":
      case "ArrowUp":
        e.preventDefault();
        if (this.opened) {
          this._overlayContent.focusDateElement();
        } else {
          this._focusOverlayOnOpen = true;
          this.open();
        }
        break;
      case "Enter": {
        const parsedDate = this._getParsedDate();
        const isValidDate = this._isValidDate(parsedDate);
        if (this.opened) {
          if (this._overlayInitialized && this._overlayContent.focusedDate && isValidDate) {
            this._selectedDate = this._overlayContent.focusedDate;
          }
          this.close();
        } else if (!isValidDate && this.inputElement.value !== "") {
          this.validate();
        } else {
          const oldValue = this.value;
          this._selectParsedOrFocusedDate();
          if (oldValue === this.value) {
            this.validate();
          }
        }
        break;
      }
      case "Escape":
        if (this.opened) {
          this._focusedDate = this._selectedDate;
          this._close();
        } else if (this.clearButtonVisible) {
          this._onClearButtonClick();
        } else if (this.autoOpenDisabled) {
          if (this.inputElement.value === "") {
            this._selectedDate = null;
          }
          this._applyInputValue(this._selectedDate);
        } else {
          this._focusedDate = this._selectedDate;
          this._selectParsedOrFocusedDate();
        }
        break;
      case "Tab":
        if (this.opened) {
          e.preventDefault();
          this._setSelectionRange(0, 0);
          if (e.shiftKey) {
            this._overlayContent.focusCancel();
          } else {
            this._overlayContent.focusDate(this._focusedDate);
          }
        }
        break;
      default:
        break;
    }
  }
  _getParsedDate(inputValue = this._inputValue) {
    const dateObject = this.i18n.parseDate && this.i18n.parseDate(inputValue);
    const parsedDate = dateObject && this._parseDate(dateObject.year + "-" + (dateObject.month + 1) + "-" + dateObject.day);
    return parsedDate;
  }
  _isClearButton(event) {
    return event.composedPath()[0] === this.clearElement;
  }
  _onInput() {
    if (!this.opened && this.inputElement.value && !this.autoOpenDisabled) {
      this.open();
    }
    this._userInputValueChanged();
  }
  _userInputValueChanged() {
    if (this.opened && this._inputValue) {
      const parsedDate = this._getParsedDate();
      if (this._isValidDate(parsedDate)) {
        this._ignoreFocusedDateChange = true;
        if (!dateEquals(parsedDate, this._focusedDate)) {
          this._focusedDate = parsedDate;
        }
        this._ignoreFocusedDateChange = false;
      }
    }
  }
  get _overlayContent() {
    return this.$.overlay.content.querySelector("#overlay-content");
  }
};

// node_modules/@vaadin/date-picker/src/vaadin-date-picker.js
registerStyles("vaadin-date-picker", [inputFieldShared2, datePickerStyles], { moduleId: "vaadin-date-picker-styles" });
var DatePicker = class extends DatePickerMixin(InputControlMixin(ThemableMixin(ElementMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-date-picker";
  }
  static get template() {
    return html`
      <style>
        :host([opened]) {
          pointer-events: auto;
        }
      </style>

      <div class="vaadin-date-picker-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-input-container
          part="input-field"
          readonly="[[readonly]]"
          disabled="[[disabled]]"
          invalid="[[invalid]]"
          theme$="[[theme]]"
        >
          <slot name="prefix" slot="prefix"></slot>
          <slot name="input"></slot>
          <div id="clearButton" part="clear-button" slot="suffix" aria-hidden="true"></div>
          <div part="toggle-button" slot="suffix" aria-hidden="true" on-click="_toggle"></div>
        </vaadin-input-container>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <vaadin-date-picker-overlay
        id="overlay"
        fullscreen$="[[_fullscreen]]"
        theme$="[[__getOverlayTheme(theme, _overlayInitialized)]]"
        on-vaadin-overlay-open="_onOverlayOpened"
        on-vaadin-overlay-close="_onOverlayClosed"
        restore-focus-on-close
        restore-focus-node="[[inputElement]]"
        disable-upgrade
      >
        <template>
          <vaadin-date-picker-overlay-content
            id="overlay-content"
            i18n="[[i18n]]"
            fullscreen$="[[_fullscreen]]"
            label="[[label]]"
            selected-date="{{_selectedDate}}"
            slot="dropdown-content"
            focused-date="{{_focusedDate}}"
            show-week-numbers="[[showWeekNumbers]]"
            min-date="[[_minDate]]"
            max-date="[[_maxDate]]"
            role="dialog"
            on-date-tap="_close"
            part="overlay-content"
            theme$="[[__getOverlayTheme(theme, _overlayInitialized)]]"
          ></vaadin-date-picker-overlay-content>
        </template>
      </vaadin-date-picker-overlay>
    `;
  }
  get clearElement() {
    return this.$.clearButton;
  }
  ready() {
    super.ready();
    this.addController(new InputController(this, (input) => {
      this._setInputElement(input);
      this._setFocusElement(input);
      this.stateTarget = input;
      this.ariaTarget = input;
    }));
    this.addController(new LabelledInputController(this.inputElement, this._labelController));
    const toggleButton = this.shadowRoot.querySelector('[part="toggle-button"]');
    toggleButton.addEventListener("mousedown", (e) => e.preventDefault());
  }
  _onVaadinOverlayClose(e) {
    if (this._openedWithFocusRing && this.hasAttribute("focused")) {
      this.setAttribute("focus-ring", "");
    } else if (!this.hasAttribute("focused")) {
      this.blur();
    }
    if (e.detail.sourceEvent && e.detail.sourceEvent.composedPath().indexOf(this) !== -1) {
      e.preventDefault();
    }
  }
  _toggle(e) {
    e.stopPropagation();
    this[this._overlayInitialized && this.$.overlay.opened ? "close" : "open"]();
  }
  _openedChanged(opened) {
    super._openedChanged(opened);
    this.$.overlay.positionTarget = this.shadowRoot.querySelector('[part="input-field"]');
    this.$.overlay.noVerticalOverlap = true;
  }
};
customElements.define(DatePicker.is, DatePicker);

export {
  dateEquals,
  DatePicker
};
/**
 * @license
 * Copyright (c) 2016 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-ISC5BUKI.js.map
