import {
  isTemplateResult
} from "./chunk-3P5X7Z5H.js";
import {
  processTemplates
} from "./chunk-VPQC7TEI.js";
import {
  isIOS
} from "./chunk-2GZ522BV.js";
import {
  ThemableMixin,
  ThemePropertyMixin
} from "./chunk-PALO6AVQ.js";
import {
  render
} from "./chunk-PYLEJJK2.js";
import {
  ElementMixin
} from "./chunk-ZAXSWEEW.js";
import {
  PolymerElement,
  html
} from "./chunk-EMDRMWGL.js";

// node_modules/@vaadin/notification/src/vaadin-notification.js
var NotificationContainer = class extends ThemableMixin(ElementMixin(PolymerElement)) {
  static get template() {
    return html`
      <style>
        :host {
          position: fixed;
          z-index: 1000;
          top: 0;
          left: 0;
          bottom: 0;
          right: 0;
          box-sizing: border-box;

          display: flex;
          flex-direction: column;
          align-items: stretch;
          pointer-events: none;
        }

        [region-group] {
          flex: 1 1 0%;
          display: flex;
        }

        [region-group='top'] {
          align-items: flex-start;
        }

        [region-group='bottom'] {
          align-items: flex-end;
        }

        [region-group] > [region] {
          flex: 1 1 0%;
        }

        @media (max-width: 420px) {
          [region-group] {
            flex-direction: column;
            align-items: stretch;
          }

          [region-group='top'] {
            justify-content: flex-start;
          }

          [region-group='bottom'] {
            justify-content: flex-end;
          }

          [region-group] > [region] {
            flex: initial;
          }
        }
      </style>

      <div region="top-stretch"><slot name="top-stretch"></slot></div>
      <div region-group="top">
        <div region="top-start"><slot name="top-start"></slot></div>
        <div region="top-center"><slot name="top-center"></slot></div>
        <div region="top-end"><slot name="top-end"></slot></div>
      </div>
      <div region="middle"><slot name="middle"></slot></div>
      <div region-group="bottom">
        <div region="bottom-start"><slot name="bottom-start"></slot></div>
        <div region="bottom-center"><slot name="bottom-center"></slot></div>
        <div region="bottom-end"><slot name="bottom-end"></slot></div>
      </div>
      <div region="bottom-stretch"><slot name="bottom-stretch"></slot></div>
    `;
  }
  static get is() {
    return "vaadin-notification-container";
  }
  static get properties() {
    return {
      opened: {
        type: Boolean,
        value: false,
        observer: "_openedChanged"
      }
    };
  }
  _openedChanged(opened) {
    if (opened) {
      document.body.appendChild(this);
      document.addEventListener("vaadin-overlay-close", this._boundVaadinOverlayClose);
      if (this._boundIosResizeListener) {
        this._detectIosNavbar();
        window.addEventListener("resize", this._boundIosResizeListener);
      }
    } else {
      document.body.removeChild(this);
      document.removeEventListener("vaadin-overlay-close", this._boundVaadinOverlayClose);
      if (this._boundIosResizeListener) {
        window.removeEventListener("resize", this._boundIosResizeListener);
      }
    }
  }
  constructor() {
    super();
    this._boundVaadinOverlayClose = this._onVaadinOverlayClose.bind(this);
    if (isIOS) {
      this._boundIosResizeListener = () => this._detectIosNavbar();
    }
  }
  _detectIosNavbar() {
    const innerHeight = window.innerHeight;
    const innerWidth = window.innerWidth;
    const landscape = innerWidth > innerHeight;
    const clientHeight = document.documentElement.clientHeight;
    if (landscape && clientHeight > innerHeight) {
      this.style.bottom = clientHeight - innerHeight + "px";
    } else {
      this.style.bottom = "0";
    }
  }
  _onVaadinOverlayClose(event) {
    const sourceEvent = event.detail.sourceEvent;
    const isFromNotification = sourceEvent && sourceEvent.composedPath().indexOf(this) >= 0;
    if (isFromNotification) {
      event.preventDefault();
    }
  }
};
var NotificationCard = class extends ThemableMixin(PolymerElement) {
  static get template() {
    return html`
      <style>
        :host {
          display: block;
        }

        [part='overlay'] {
          pointer-events: auto;
        }
      </style>

      <div part="overlay">
        <div part="content">
          <slot></slot>
        </div>
      </div>
    `;
  }
  static get is() {
    return "vaadin-notification-card";
  }
  ready() {
    super.ready();
    this.setAttribute("role", "alert");
    this.setAttribute("aria-live", "polite");
  }
};
var Notification = class extends ThemePropertyMixin(ElementMixin(PolymerElement)) {
  static get template() {
    return html`
      <style>
        :host {
          display: none;
        }
      </style>
      <vaadin-notification-card theme$="[[theme]]"> </vaadin-notification-card>
    `;
  }
  static get is() {
    return "vaadin-notification";
  }
  static get properties() {
    return {
      duration: {
        type: Number,
        value: 5e3
      },
      opened: {
        type: Boolean,
        value: false,
        notify: true,
        observer: "_openedChanged"
      },
      position: {
        type: String,
        value: "bottom-start",
        observer: "_positionChanged"
      },
      renderer: Function
    };
  }
  static get observers() {
    return ["_durationChanged(duration, opened)", "_rendererChanged(renderer, opened, _card)"];
  }
  ready() {
    super.ready();
    this._card = this.shadowRoot.querySelector("vaadin-notification-card");
    processTemplates(this);
  }
  requestContentUpdate() {
    if (!this.renderer) {
      return;
    }
    this.renderer(this._card, this);
  }
  _rendererChanged(renderer, opened, card) {
    if (!card) {
      return;
    }
    const rendererChanged = this._oldRenderer !== renderer;
    this._oldRenderer = renderer;
    if (rendererChanged) {
      card.innerHTML = "";
      delete card._$litPart$;
    }
    if (opened) {
      if (!this._didAnimateNotificationAppend) {
        this._animatedAppendNotificationCard();
      }
      this.requestContentUpdate();
    }
  }
  open() {
    this.opened = true;
  }
  close() {
    this.opened = false;
  }
  get _container() {
    if (!Notification._container) {
      Notification._container = document.createElement("vaadin-notification-container");
      document.body.appendChild(Notification._container);
    }
    return Notification._container;
  }
  _openedChanged(opened) {
    if (opened) {
      this._container.opened = true;
      this._animatedAppendNotificationCard();
    } else if (this._card) {
      this._closeNotificationCard();
    }
  }
  _animatedAppendNotificationCard() {
    if (this._card) {
      this._card.setAttribute("opening", "");
      this._appendNotificationCard();
      const listener = () => {
        this._card.removeEventListener("animationend", listener);
        this._card.removeAttribute("opening");
      };
      this._card.addEventListener("animationend", listener);
      this._didAnimateNotificationAppend = true;
    } else {
      this._didAnimateNotificationAppend = false;
    }
  }
  _appendNotificationCard() {
    if (!this._card) {
      return;
    }
    if (!this._container.shadowRoot.querySelector(`slot[name="${this.position}"]`)) {
      console.warn(`Invalid alignment parameter provided: position=${this.position}`);
      return;
    }
    this._card.slot = this.position;
    if (this._container.firstElementChild && /top/.test(this.position)) {
      this._container.insertBefore(this._card, this._container.firstElementChild);
    } else {
      this._container.appendChild(this._card);
    }
  }
  _removeNotificationCard() {
    this._card.parentNode && this._card.parentNode.removeChild(this._card);
    this._card.removeAttribute("closing");
    this._container.opened = Boolean(this._container.firstElementChild);
  }
  _closeNotificationCard() {
    this._durationTimeoutId && clearTimeout(this._durationTimeoutId);
    this._animatedRemoveNotificationCard();
  }
  _animatedRemoveNotificationCard() {
    this._card.setAttribute("closing", "");
    const name = getComputedStyle(this._card).getPropertyValue("animation-name");
    if (name && name != "none") {
      const listener = () => {
        this._removeNotificationCard();
        this._card.removeEventListener("animationend", listener);
      };
      this._card.addEventListener("animationend", listener);
    } else {
      this._removeNotificationCard();
    }
  }
  _positionChanged() {
    if (this.opened) {
      this._animatedAppendNotificationCard();
    }
  }
  _durationChanged(duration, opened) {
    if (opened) {
      clearTimeout(this._durationTimeoutId);
      if (duration > 0) {
        this._durationTimeoutId = setTimeout(() => this.close(), duration);
      }
    }
  }
  static show(contents, options) {
    if (isTemplateResult(contents)) {
      return Notification._createAndShowNotification((root) => {
        render(contents, root);
      }, options);
    }
    return Notification._createAndShowNotification((root) => {
      root.innerText = contents;
    }, options);
  }
  static _createAndShowNotification(renderer, options) {
    const notification = document.createElement(Notification.is);
    if (options && Number.isFinite(options.duration)) {
      notification.duration = options.duration;
    }
    if (options && options.position) {
      notification.position = options.position;
    }
    if (options && options.theme) {
      notification.setAttribute("theme", options.theme);
    }
    notification.renderer = renderer;
    document.body.appendChild(notification);
    notification.opened = true;
    notification.addEventListener("opened-changed", (e) => {
      if (!e.detail.value) {
        notification.remove();
      }
    });
    return notification;
  }
};
customElements.define(NotificationContainer.is, NotificationContainer);
customElements.define(NotificationCard.is, NotificationCard);
customElements.define(Notification.is, Notification);
/**
 * @license
 * Copyright (c) 2017 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-NJGP2OHF.js.map
