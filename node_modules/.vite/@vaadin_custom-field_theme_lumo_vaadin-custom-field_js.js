import "./chunk-PAZO4RLR.js";
import {
  FieldMixin
} from "./chunk-YJVFTOSG.js";
import "./chunk-DN7NE4EQ.js";
import "./chunk-4JL67NGK.js";
import "./chunk-2PREY5TQ.js";
import {
  isChrome
} from "./chunk-2GZ522BV.js";
import "./chunk-BUARF445.js";
import {
  FlattenedNodesObserver
} from "./chunk-IASAGYPQ.js";
import "./chunk-5B3W7TLP.js";
import "./chunk-75WEHVQA.js";
import {
  FocusMixin
} from "./chunk-Q3ITW52D.js";
import "./chunk-SYJMCSOT.js";
import "./chunk-TSMFV5J4.js";
import "./chunk-WUR5UZ22.js";
import "./chunk-YZXPUGLM.js";
import {
  ThemableMixin
} from "./chunk-PALO6AVQ.js";
import {
  ElementMixin
} from "./chunk-OKCEHAIA.js";
import "./chunk-KCWZ32HQ.js";
import "./chunk-ZFVP5VBM.js";
import "./chunk-QNRFZUBX.js";
import "./chunk-PYLEJJK2.js";
import {
  PolymerElement,
  html
} from "./chunk-EMDRMWGL.js";
import "./chunk-H3KD7FYF.js";
import "./chunk-NZ6RMXB7.js";
import "./chunk-RQI6IG5T.js";
import "./chunk-KTZKXPFA.js";

// node_modules/@vaadin/custom-field/src/vaadin-custom-field.js
var CustomField = class extends FieldMixin(FocusMixin(ThemableMixin(ElementMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-custom-field";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: inline-flex;
        }

        :host::before {
          content: '\\2003';
          width: 0;
          display: inline-block;
          /* Size and position this element on the same vertical position as the input-field element
           to make vertical align for the host element work as expected */
        }

        :host([hidden]) {
          display: none !important;
        }

        .vaadin-custom-field-container {
          width: 100%;
          display: flex;
          flex-direction: column;
        }

        .inputs-wrapper {
          flex: none;
        }
      </style>

      <div class="vaadin-custom-field-container">
        <div part="label" on-click="focus">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true"></span>
        </div>

        <div class="inputs-wrapper" on-change="__onInputChange">
          <slot id="slot"></slot>
        </div>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>
    `;
  }
  static get properties() {
    return {
      name: String,
      value: {
        type: String,
        observer: "__valueChanged",
        notify: true
      },
      inputs: {
        type: Array,
        readOnly: true
      },
      i18n: {
        type: Object,
        value: () => {
          return {
            parseValue: function(value) {
              return value.split("	");
            },
            formatValue: function(inputValues) {
              return inputValues.join("	");
            }
          };
        }
      }
    };
  }
  connectedCallback() {
    super.connectedCallback();
    if (this.__observer) {
      this.__observer.connect();
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this.__observer) {
      this.__observer.disconnect();
    }
  }
  ready() {
    super.ready();
    this.setAttribute("role", "group");
    this.ariaTarget = this;
    this.__setInputsFromSlot();
    this.__observer = new FlattenedNodesObserver(this.$.slot, () => {
      this.__setInputsFromSlot();
    });
    this.__fixChromeFocus();
  }
  focus() {
    this.inputs && this.inputs[0] && this.inputs[0].focus();
  }
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused) {
      this.validate();
    }
  }
  _shouldRemoveFocus(event) {
    const { relatedTarget } = event;
    return !this.inputs.some((el) => relatedTarget === (el.focusElement || el));
  }
  checkValidity() {
    const invalidFields = this.inputs.filter((input) => !(input.validate || input.checkValidity).call(input));
    if (invalidFields.length || this.required && !this.value.trim()) {
      return false;
    }
    return true;
  }
  __fixChromeFocus() {
    this.addEventListener("keydown", (e) => {
      if (e.keyCode === 9) {
        if (e.target.parentElement.localName === "slot" && !e.defaultPrevented && isChrome) {
          const slot = e.target.parentElement;
          slot.setAttribute("tabindex", -1);
          setTimeout(() => slot.removeAttribute("tabindex"));
        }
        if (this.inputs.indexOf(e.target) < this.inputs.length - 1 && !e.shiftKey || this.inputs.indexOf(e.target) > 0 && e.shiftKey) {
          this.dispatchEvent(new CustomEvent("internal-tab"));
        } else {
          this.__setValue();
        }
      }
    });
  }
  __onInputChange(event) {
    event.stopPropagation();
    this.__setValue();
    this.validate();
    this.dispatchEvent(new CustomEvent("change", {
      bubbles: true,
      cancelable: false,
      detail: {
        value: this.value
      }
    }));
  }
  __setValue() {
    this.__settingValue = true;
    this.value = this.i18n.formatValue.apply(this, [this.inputs.map((input) => input.value)]);
    this.__settingValue = false;
  }
  __queryAllAssignedElements(elem) {
    const result = [];
    let elements;
    if (elem.tagName === "SLOT") {
      elements = elem.assignedElements({ flatten: true });
    } else {
      result.push(elem);
      elements = Array.from(elem.children);
    }
    elements.forEach((elem2) => result.push(...this.__queryAllAssignedElements(elem2)));
    return result;
  }
  __isInput(node) {
    const isSlottedInput = node.getAttribute("slot") === "input" || node.getAttribute("slot") === "textarea";
    return !isSlottedInput && (node.validate || node.checkValidity);
  }
  __getInputsFromSlot() {
    return this.__queryAllAssignedElements(this.$.slot).filter((node) => this.__isInput(node));
  }
  __setInputsFromSlot() {
    this._setInputs(this.__getInputsFromSlot());
    this.__setValue();
  }
  __toggleHasValue(value) {
    this.toggleAttribute("has-value", value !== null && value.trim() !== "");
  }
  __valueChanged(value, oldValue) {
    if (this.__settingValue || !this.inputs) {
      return;
    }
    this.__toggleHasValue(value);
    const valuesArray = this.i18n.parseValue(value);
    if (!valuesArray || valuesArray.length == 0) {
      console.warn("Value parser has not provided values array");
      return;
    }
    this.inputs.forEach((input, id) => input.value = valuesArray[id]);
    if (oldValue !== void 0) {
      this.validate();
    }
  }
};
customElements.define(CustomField.is, CustomField);
/**
 * @license
 * Copyright (c) 2019 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=@vaadin_custom-field_theme_lumo_vaadin-custom-field_js.js.map
