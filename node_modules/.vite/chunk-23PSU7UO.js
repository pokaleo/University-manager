import {
  ComboBoxPlaceholder
} from "./chunk-YIXZHRC6.js";
import {
  Virtualizer
} from "./chunk-2P64M2FJ.js";
import {
  processTemplates
} from "./chunk-VPQC7TEI.js";
import {
  VirtualKeyboardController
} from "./chunk-3GYD24OI.js";
import {
  PositionMixin
} from "./chunk-YBQVYLTV.js";
import {
  OverlayElement
} from "./chunk-O5EIIYDR.js";
import {
  isTouch
} from "./chunk-2GZ522BV.js";
import {
  InputMixin
} from "./chunk-YESAUM4I.js";
import {
  ControllerMixin
} from "./chunk-BUARF445.js";
import {
  KeyboardMixin
} from "./chunk-CHZ6BFNC.js";
import {
  DisabledMixin
} from "./chunk-TNYX3KNS.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-PALO6AVQ.js";
import {
  css
} from "./chunk-PYLEJJK2.js";
import {
  DirMixin
} from "./chunk-ZFVP5VBM.js";
import {
  PolymerElement,
  html
} from "./chunk-EMDRMWGL.js";

// node_modules/@vaadin/combo-box/src/vaadin-combo-box-item.js
var ComboBoxItem = class extends ThemableMixin(DirMixin(PolymerElement)) {
  static get template() {
    return html`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none;
        }
      </style>
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
  }
  static get is() {
    return "vaadin-combo-box-item";
  }
  static get properties() {
    return {
      index: Number,
      item: Object,
      label: String,
      selected: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      focused: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      renderer: Function,
      _oldRenderer: Function
    };
  }
  static get observers() {
    return ["__rendererOrItemChanged(renderer, index, item.*, selected, focused)", "__updateLabel(label, renderer)"];
  }
  connectedCallback() {
    super.connectedCallback();
    this._comboBox = this.parentNode.comboBox;
    const hostDir = this._comboBox.getAttribute("dir");
    if (hostDir) {
      this.setAttribute("dir", hostDir);
    }
  }
  requestContentUpdate() {
    if (!this.renderer) {
      return;
    }
    const model = {
      index: this.index,
      item: this.item,
      focused: this.focused,
      selected: this.selected
    };
    this.renderer(this, this._comboBox, model);
  }
  __rendererOrItemChanged(renderer, index, item) {
    if (item === void 0 || index === void 0) {
      return;
    }
    if (this._oldRenderer !== renderer) {
      this.innerHTML = "";
      delete this._$litPart$;
    }
    if (renderer) {
      this._oldRenderer = renderer;
      this.requestContentUpdate();
    }
  }
  __updateLabel(label, renderer) {
    if (renderer) {
      return;
    }
    this.textContent = label;
  }
};
customElements.define(ComboBoxItem.is, ComboBoxItem);

// node_modules/@vaadin/combo-box/src/vaadin-combo-box-overlay.js
registerStyles("vaadin-combo-box-overlay", css`
    #overlay {
      width: var(--vaadin-combo-box-overlay-width, var(--_vaadin-combo-box-overlay-default-width, auto));
    }

    [part='content'] {
      display: flex;
      flex-direction: column;
      height: 100%;
    }
  `, { moduleId: "vaadin-combo-box-overlay-styles" });
var memoizedTemplate;
var ComboBoxOverlay = class extends PositionMixin(OverlayElement) {
  static get is() {
    return "vaadin-combo-box-overlay";
  }
  static get template() {
    if (!memoizedTemplate) {
      memoizedTemplate = super.template.cloneNode(true);
      memoizedTemplate.content.querySelector('[part~="overlay"]').removeAttribute("tabindex");
    }
    return memoizedTemplate;
  }
  connectedCallback() {
    super.connectedCallback();
    const dropdown = this.__dataHost;
    const comboBox = dropdown && dropdown.getRootNode().host;
    const hostDir = comboBox && comboBox.getAttribute("dir");
    if (hostDir) {
      this.setAttribute("dir", hostDir);
    }
  }
  ready() {
    super.ready();
    const loader = document.createElement("div");
    loader.setAttribute("part", "loader");
    const content = this.shadowRoot.querySelector('[part~="content"]');
    content.parentNode.insertBefore(loader, content);
  }
  _outsideClickListener(event) {
    const eventPath = event.composedPath();
    if (!eventPath.includes(this.positionTarget) && !eventPath.includes(this)) {
      this.close();
    }
  }
};
customElements.define(ComboBoxOverlay.is, ComboBoxOverlay);

// node_modules/@vaadin/combo-box/src/vaadin-combo-box-scroller.js
var ComboBoxScroller = class extends PolymerElement {
  static get is() {
    return "vaadin-combo-box-scroller";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: block;
          min-height: 1px;
          overflow: auto;

          /* Fixes item background from getting on top of scrollbars on Safari */
          transform: translate3d(0, 0, 0);

          /* Enable momentum scrolling on iOS */
          -webkit-overflow-scrolling: touch;

          /* Fixes scrollbar disappearing when 'Show scroll bars: Always' enabled in Safari */
          box-shadow: 0 0 0 white;
        }

        #selector {
          border-width: var(--_vaadin-combo-box-items-container-border-width);
          border-style: var(--_vaadin-combo-box-items-container-border-style);
          border-color: var(--_vaadin-combo-box-items-container-border-color);
        }
      </style>
      <div id="selector">
        <slot></slot>
      </div>
    `;
  }
  static get properties() {
    return {
      items: {
        type: Array,
        observer: "__itemsChanged"
      },
      focusedIndex: {
        type: Number,
        observer: "__focusedIndexChanged"
      },
      loading: {
        type: Boolean,
        observer: "__loadingChanged"
      },
      opened: {
        type: Boolean,
        observer: "__openedChanged"
      },
      selectedItem: {
        type: Object
      },
      itemIdPath: {
        type: String
      },
      comboBox: {
        type: Object
      },
      getItemLabel: {
        type: Object
      },
      renderer: {
        type: Object,
        observer: "__rendererChanged"
      },
      theme: {
        type: String
      }
    };
  }
  constructor() {
    super();
    this.__boundOnItemClick = this.__onItemClick.bind(this);
  }
  __openedChanged(opened) {
    if (opened) {
      this.requestContentUpdate();
    }
  }
  ready() {
    super.ready();
    this.__hostTagName = this.constructor.is.replace("-scroller", "");
    this.setAttribute("role", "listbox");
    this.addEventListener("click", (e) => e.stopPropagation());
    this.__patchWheelOverScrolling();
    this.__virtualizer = new Virtualizer({
      createElements: this.__createElements.bind(this),
      updateElement: this.__updateElement.bind(this),
      elementsContainer: this,
      scrollTarget: this,
      scrollContainer: this.$.selector
    });
  }
  requestContentUpdate() {
    if (this.__virtualizer) {
      this.__virtualizer.update();
    }
  }
  scrollIntoView(index) {
    if (!(this.opened && index >= 0)) {
      return;
    }
    const visibleItemsCount = this._visibleItemsCount();
    let targetIndex = index;
    if (index > this.__virtualizer.lastVisibleIndex - 1) {
      this.__virtualizer.scrollToIndex(index);
      targetIndex = index - visibleItemsCount + 1;
    } else if (index > this.__virtualizer.firstVisibleIndex) {
      targetIndex = this.__virtualizer.firstVisibleIndex;
    }
    this.__virtualizer.scrollToIndex(Math.max(0, targetIndex));
    const lastPhysicalItem = [...this.children].find((el) => !el.hidden && el.index === this.__virtualizer.lastVisibleIndex);
    if (!lastPhysicalItem || index !== lastPhysicalItem.index) {
      return;
    }
    const lastPhysicalItemRect = lastPhysicalItem.getBoundingClientRect();
    const scrollerRect = this.getBoundingClientRect();
    const scrollTopAdjust = lastPhysicalItemRect.bottom - scrollerRect.bottom + this._viewportTotalPaddingBottom;
    if (scrollTopAdjust > 0) {
      this.scrollTop += scrollTopAdjust;
    }
  }
  __getAriaRole(itemIndex) {
    return itemIndex !== void 0 ? "option" : false;
  }
  __getAriaSelected(focusedIndex, itemIndex) {
    return this.__isItemFocused(focusedIndex, itemIndex).toString();
  }
  __isItemFocused(focusedIndex, itemIndex) {
    return focusedIndex == itemIndex;
  }
  __isItemSelected(item, selectedItem, itemIdPath) {
    if (item instanceof ComboBoxPlaceholder) {
      return false;
    } else if (itemIdPath && item !== void 0 && selectedItem !== void 0) {
      return this.get(itemIdPath, item) === this.get(itemIdPath, selectedItem);
    }
    return item === selectedItem;
  }
  __itemsChanged(items) {
    if (this.__virtualizer && items) {
      this.__virtualizer.size = items.length;
      this.__virtualizer.flush();
      this.setAttribute("aria-setsize", items.length);
      this.requestContentUpdate();
    }
  }
  __loadingChanged(loading) {
    if (this.__virtualizer && !loading) {
      setTimeout(() => this.requestContentUpdate());
    }
  }
  __focusedIndexChanged(index) {
    if (this.__virtualizer && index >= 0) {
      this.requestContentUpdate();
      this.scrollIntoView(index);
    }
  }
  __rendererChanged(renderer, oldRenderer) {
    if (renderer || oldRenderer) {
      this.requestContentUpdate();
    }
  }
  __createElements(count) {
    return [...Array(count)].map(() => {
      const item = document.createElement(`${this.__hostTagName}-item`);
      item.addEventListener("click", this.__boundOnItemClick);
      item.tabIndex = "-1";
      item.style.width = "100%";
      return item;
    });
  }
  __updateElement(el, index) {
    const item = this.items[index];
    const focusedIndex = this.focusedIndex;
    el.setProperties({
      item,
      index: this.__requestItemByIndex(item, index),
      label: this.getItemLabel(item),
      selected: this.__isItemSelected(item, this.selectedItem, this.itemIdPath),
      renderer: this.renderer,
      focused: this.__isItemFocused(focusedIndex, index)
    });
    el.id = `${this.__hostTagName}-item-${index}`;
    el.setAttribute("role", this.__getAriaRole(index));
    el.setAttribute("aria-selected", this.__getAriaSelected(focusedIndex, index));
    el.setAttribute("aria-posinset", index + 1);
    if (this.theme) {
      el.setAttribute("theme", this.theme);
    } else {
      el.removeAttribute("theme");
    }
  }
  __onItemClick(e) {
    this.dispatchEvent(new CustomEvent("selection-changed", { detail: { item: e.currentTarget.item } }));
  }
  __patchWheelOverScrolling() {
    this.$.selector.addEventListener("wheel", (e) => {
      const scrolledToTop = this.scrollTop === 0;
      const scrolledToBottom = this.scrollHeight - this.scrollTop - this.clientHeight <= 1;
      if (scrolledToTop && e.deltaY < 0) {
        e.preventDefault();
      } else if (scrolledToBottom && e.deltaY > 0) {
        e.preventDefault();
      }
    });
  }
  get _viewportTotalPaddingBottom() {
    if (this._cachedViewportTotalPaddingBottom === void 0) {
      const itemsStyle = window.getComputedStyle(this.$.selector);
      this._cachedViewportTotalPaddingBottom = [itemsStyle.paddingBottom, itemsStyle.borderBottomWidth].map((v) => {
        return parseInt(v, 10);
      }).reduce((sum, v) => {
        return sum + v;
      });
    }
    return this._cachedViewportTotalPaddingBottom;
  }
  __requestItemByIndex(item, index) {
    if (item instanceof ComboBoxPlaceholder && index !== void 0) {
      this.dispatchEvent(new CustomEvent("index-requested", { detail: { index, currentScrollerPos: this._oldScrollerPosition } }));
    }
    return index;
  }
  _visibleItemsCount() {
    this.__virtualizer.scrollToIndex(this.__virtualizer.firstVisibleIndex);
    const hasItems = this.__virtualizer.size > 0;
    return hasItems ? this.__virtualizer.lastVisibleIndex - this.__virtualizer.firstVisibleIndex + 1 : 0;
  }
};
customElements.define(ComboBoxScroller.is, ComboBoxScroller);

// node_modules/@vaadin/combo-box/src/vaadin-combo-box-dropdown.js
var ComboBoxDropdown = class extends PolymerElement {
  static get is() {
    return "vaadin-combo-box-dropdown";
  }
  static get template() {
    return html`
      <vaadin-combo-box-overlay
        id="overlay"
        hidden$="[[_isOverlayHidden(_items.*, loading)]]"
        loading$="[[loading]]"
        opened="{{_overlayOpened}}"
        theme$="[[theme]]"
        position-target="[[positionTarget]]"
        no-vertical-overlap
        restore-focus-on-close="[[restoreFocusOnClose]]"
        restore-focus-node="[[restoreFocusNode]]"
      ></vaadin-combo-box-overlay>
    `;
  }
  static get properties() {
    return {
      opened: Boolean,
      positionTarget: {
        type: Object,
        observer: "_positionTargetChanged"
      },
      renderer: Function,
      loading: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      theme: String,
      _selectedItem: {
        type: Object
      },
      _items: {
        type: Array
      },
      _focusedIndex: {
        type: Number,
        value: -1
      },
      focusedItem: {
        type: String,
        computed: "_getFocusedItem(_focusedIndex)"
      },
      _itemLabelPath: {
        type: String,
        value: "label"
      },
      _itemValuePath: {
        type: String,
        value: "value"
      },
      _scroller: Object,
      _itemIdPath: String,
      _overlayOpened: {
        type: Boolean,
        observer: "_openedChanged"
      }
    };
  }
  static get observers() {
    return [
      "_openedOrItemsChanged(opened, _items, loading)",
      "__updateScroller(_scroller, _items, opened, loading, _selectedItem, _itemIdPath, _focusedIndex, renderer, theme)"
    ];
  }
  constructor() {
    super();
    const uniqueId = ComboBoxDropdown._uniqueId = 1 + ComboBoxDropdown._uniqueId || 0;
    this.scrollerId = `${this.localName}-scroller-${uniqueId}`;
  }
  ready() {
    super.ready();
    this.__hostTagName = this.constructor.is.replace("-dropdown", "");
    const overlay = this.$.overlay;
    const scrollerTag = `${this.__hostTagName}-scroller`;
    overlay.renderer = (root) => {
      if (!root.firstChild) {
        const scroller = document.createElement(scrollerTag);
        root.appendChild(scroller);
      }
    };
    overlay.requestContentUpdate();
    this._scroller = overlay.content.querySelector(scrollerTag);
    this._scroller.id = this.scrollerId;
    this._scroller.getItemLabel = this.getItemLabel.bind(this);
    this._scroller.comboBox = this.getRootNode().host;
    this._scroller.addEventListener("selection-changed", (e) => this._forwardScrollerEvent(e));
    this._scroller.addEventListener("index-requested", (e) => this._forwardScrollerEvent(e));
    overlay.addEventListener("touchend", (e) => this._fireTouchAction(e));
    overlay.addEventListener("touchmove", (e) => this._fireTouchAction(e));
    overlay.addEventListener("mousedown", (e) => e.preventDefault());
    overlay.addEventListener("vaadin-overlay-outside-click", (e) => {
      e.preventDefault();
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this._overlayOpened = false;
  }
  _fireTouchAction(sourceEvent) {
    this.dispatchEvent(new CustomEvent("vaadin-overlay-touch-action", {
      detail: { sourceEvent }
    }));
  }
  _forwardScrollerEvent(event) {
    this.dispatchEvent(new CustomEvent(event.type, { detail: event.detail }));
  }
  _openedChanged(opened, wasOpened) {
    if (opened) {
      this._setOverlayWidth();
      this._scroller.style.maxHeight = getComputedStyle(this).getPropertyValue(`--${this.__hostTagName}-overlay-max-height`) || "65vh";
      this.dispatchEvent(new CustomEvent("vaadin-combo-box-dropdown-opened", { bubbles: true, composed: true }));
    } else if (wasOpened && !this.__emptyItems) {
      this.dispatchEvent(new CustomEvent("vaadin-combo-box-dropdown-closed", { bubbles: true, composed: true }));
    }
  }
  _openedOrItemsChanged(opened, items, loading) {
    const hasItems = items && items.length;
    if (!hasItems) {
      this.__emptyItems = true;
    }
    this._overlayOpened = !!(opened && (loading || hasItems));
    this.__emptyItems = false;
  }
  _getFocusedItem(focusedIndex) {
    if (focusedIndex >= 0) {
      return this._items[focusedIndex];
    }
  }
  indexOfLabel(label) {
    if (this._items && label) {
      for (let i = 0; i < this._items.length; i++) {
        if (this.getItemLabel(this._items[i]).toString().toLowerCase() === label.toString().toLowerCase()) {
          return i;
        }
      }
    }
    return -1;
  }
  getItemLabel(item, itemLabelPath) {
    itemLabelPath = itemLabelPath || this._itemLabelPath;
    let label = item && itemLabelPath ? this.get(itemLabelPath, item) : void 0;
    if (label === void 0 || label === null) {
      label = item ? item.toString() : "";
    }
    return label;
  }
  _scrollIntoView(index) {
    if (!this._scroller) {
      return;
    }
    this._scroller.scrollIntoView(index);
  }
  adjustScrollPosition() {
    if (this.opened && this._items) {
      this._scrollIntoView(this._focusedIndex);
    }
  }
  __updateScroller(scroller, items, opened, loading, selectedItem, itemIdPath, focusedIndex, renderer, theme) {
    if (scroller) {
      scroller.setProperties({
        items: opened ? items : [],
        opened,
        loading,
        selectedItem,
        itemIdPath,
        focusedIndex,
        renderer,
        theme
      });
    }
  }
  _isOverlayHidden() {
    return !this.loading && !(this._items && this._items.length);
  }
  _positionTargetChanged(target) {
    if (target) {
      this._setOverlayWidth();
    }
  }
  _setOverlayWidth() {
    if (!this.positionTarget) {
      return;
    }
    const inputWidth = this.positionTarget.clientWidth + "px";
    const propPrefix = `${this.__hostTagName}-overlay`;
    const customWidth = getComputedStyle(this).getPropertyValue(`--${propPrefix}-width`);
    this.$.overlay.style.setProperty(`--_${propPrefix}-default-width`, inputWidth);
    if (customWidth === "") {
      this.$.overlay.style.removeProperty(`--${propPrefix}-width`);
    } else {
      this.$.overlay.style.setProperty(`--${propPrefix}-width`, customWidth);
    }
    this.$.overlay._updatePosition();
  }
};
customElements.define(ComboBoxDropdown.is, ComboBoxDropdown);

// node_modules/@vaadin/combo-box/src/vaadin-combo-box-mixin.js
var ComboBoxMixin = (subclass) => class VaadinComboBoxMixinElement extends ControllerMixin(KeyboardMixin(InputMixin(DisabledMixin(subclass)))) {
  static get properties() {
    return {
      opened: {
        type: Boolean,
        notify: true,
        value: false,
        reflectToAttribute: true,
        observer: "_openedChanged"
      },
      autoOpenDisabled: {
        type: Boolean
      },
      readonly: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      renderer: Function,
      items: {
        type: Array,
        observer: "_itemsChanged"
      },
      allowCustomValue: {
        type: Boolean,
        value: false
      },
      filteredItems: {
        type: Array
      },
      _lastCommittedValue: String,
      loading: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        observer: "_loadingChanged"
      },
      _focusedIndex: {
        type: Number,
        observer: "_focusedIndexChanged",
        value: -1
      },
      filter: {
        type: String,
        value: "",
        notify: true
      },
      selectedItem: {
        type: Object,
        notify: true
      },
      itemLabelPath: {
        type: String,
        value: "label",
        observer: "_itemLabelPathChanged"
      },
      itemValuePath: {
        type: String,
        value: "value"
      },
      itemIdPath: String,
      _toggleElement: {
        type: Object,
        observer: "_toggleElementChanged"
      },
      _closeOnBlurIsPrevented: Boolean,
      __restoreFocusOnClose: Boolean
    };
  }
  static get observers() {
    return [
      "_filterChanged(filter, itemValuePath, itemLabelPath)",
      "_itemsOrPathsChanged(items.*, itemValuePath, itemLabelPath)",
      "_filteredItemsChanged(filteredItems.*, itemValuePath, itemLabelPath)",
      "_selectedItemChanged(selectedItem, itemValuePath, itemLabelPath)"
    ];
  }
  constructor() {
    super();
    this._boundOnFocusout = this._onFocusout.bind(this);
    this._boundOverlaySelectedItemChanged = this._overlaySelectedItemChanged.bind(this);
    this._boundOnClearButtonMouseDown = this.__onClearButtonMouseDown.bind(this);
    this._boundClose = this.close.bind(this);
    this._boundOnOpened = this._onOpened.bind(this);
    this._boundOnClick = this._onClick.bind(this);
    this._boundOnOverlayTouchAction = this._onOverlayTouchAction.bind(this);
    this._boundOnTouchend = this._onTouchend.bind(this);
  }
  get _inputElementValue() {
    return this.inputElement ? this.inputElement[this._propertyForValue] : void 0;
  }
  set _inputElementValue(value) {
    if (this.inputElement) {
      this.inputElement[this._propertyForValue] = value;
    }
  }
  _inputElementChanged(input) {
    super._inputElementChanged(input);
    if (input) {
      input.autocomplete = "off";
      input.autocapitalize = "off";
      input.setAttribute("role", "combobox");
      input.setAttribute("aria-autocomplete", "list");
      input.setAttribute("aria-expanded", !!this.opened);
      input.setAttribute("spellcheck", "false");
      input.setAttribute("autocorrect", "off");
      this._revertInputValueToValue();
      if (this.clearElement) {
        this.clearElement.addEventListener("mousedown", this._boundOnClearButtonMouseDown);
      }
    }
  }
  ready() {
    super.ready();
    this.addEventListener("focusout", this._boundOnFocusout);
    this._lastCommittedValue = this.value;
    this.$.dropdown.addEventListener("selection-changed", this._boundOverlaySelectedItemChanged);
    this.addEventListener("vaadin-combo-box-dropdown-closed", this._boundClose);
    this.addEventListener("vaadin-combo-box-dropdown-opened", this._boundOnOpened);
    this.addEventListener("click", this._boundOnClick);
    this.$.dropdown.addEventListener("vaadin-overlay-touch-action", this._boundOnOverlayTouchAction);
    this.addEventListener("touchend", this._boundOnTouchend);
    const bringToFrontListener = () => {
      requestAnimationFrame(() => {
        this.$.dropdown.$.overlay.bringToFront();
      });
    };
    this.addEventListener("mousedown", bringToFrontListener);
    this.addEventListener("touchstart", bringToFrontListener);
    processTemplates(this);
    this.addController(new VirtualKeyboardController(this));
  }
  requestContentUpdate() {
    if (!this.$.dropdown._scroller) {
      return;
    }
    this.$.dropdown._scroller.requestContentUpdate();
    this._getItemElements().forEach((item) => {
      item.requestContentUpdate();
    });
  }
  open() {
    if (!this.disabled && !this.readonly) {
      this.opened = true;
    }
  }
  close() {
    this.opened = false;
  }
  _focusedIndexChanged(index, oldIndex) {
    if (oldIndex === void 0) {
      return;
    }
    this._updateActiveDescendant(index);
  }
  _updateActiveDescendant(index) {
    const input = this.inputElement;
    if (!input) {
      return;
    }
    const item = this._getItemElements().find((el) => el.index === index);
    if (item) {
      input.setAttribute("aria-activedescendant", item.id);
    } else {
      input.removeAttribute("aria-activedescendant");
    }
  }
  _openedChanged(opened, wasOpened) {
    if (wasOpened === void 0) {
      return;
    }
    if (opened) {
      this._openedWithFocusRing = this.hasAttribute("focus-ring");
      if (!this.hasAttribute("focused") && !isTouch) {
        this.focus();
      }
      this.__restoreFocusOnClose = true;
    } else {
      this._onClosed();
      if (this._openedWithFocusRing && this.hasAttribute("focused")) {
        this.setAttribute("focus-ring", "");
      }
    }
    const input = this.inputElement;
    if (input) {
      input.setAttribute("aria-expanded", !!opened);
      if (opened) {
        input.setAttribute("aria-controls", this.$.dropdown.scrollerId);
      } else {
        input.removeAttribute("aria-controls");
      }
    }
  }
  _onOverlayTouchAction() {
    this._closeOnBlurIsPrevented = true;
    this.inputElement.blur();
    this._closeOnBlurIsPrevented = false;
  }
  _isClearButton(event) {
    return event.composedPath()[0] === this.clearElement;
  }
  _handleClearButtonClick(event) {
    event.preventDefault();
    this._clear();
    if (this.opened) {
      this.requestContentUpdate();
    }
  }
  _onHostClick(_event) {
    if (!this.autoOpenDisabled) {
      this.open();
    }
  }
  _onClick(e) {
    this._closeOnBlurIsPrevented = true;
    const path = e.composedPath();
    if (this._isClearButton(e)) {
      this._handleClearButtonClick(e);
    } else if (path.indexOf(this._toggleElement) > -1) {
      if (this.opened) {
        this.close();
      } else {
        this.open();
      }
    } else {
      this._onHostClick(e);
    }
    this._closeOnBlurIsPrevented = false;
  }
  _onKeyDown(e) {
    if (e.key === "Tab") {
      this.__restoreFocusOnClose = false;
    } else if (e.key === "ArrowDown") {
      this._closeOnBlurIsPrevented = true;
      this._onArrowDown();
      this._closeOnBlurIsPrevented = false;
      e.preventDefault();
    } else if (e.key === "ArrowUp") {
      this._closeOnBlurIsPrevented = true;
      this._onArrowUp();
      this._closeOnBlurIsPrevented = false;
      e.preventDefault();
    } else if (e.key === "Enter") {
      this._onEnter(e);
    } else if (e.key === "Escape") {
      this._onEscape(e);
    }
  }
  _getItemLabel(item) {
    return this.$.dropdown.getItemLabel(item);
  }
  _getItemValue(item) {
    let value = item && this.itemValuePath ? this.get(this.itemValuePath, item) : void 0;
    if (value === void 0) {
      value = item ? item.toString() : "";
    }
    return value;
  }
  _onArrowDown() {
    if (this.opened) {
      const items = this._getOverlayItems();
      if (items) {
        this._focusedIndex = Math.min(items.length - 1, this._focusedIndex + 1);
        this._prefillFocusedItemLabel();
      }
    } else {
      this.open();
    }
  }
  _onArrowUp() {
    if (this.opened) {
      if (this._focusedIndex > -1) {
        this._focusedIndex = Math.max(0, this._focusedIndex - 1);
      } else {
        const items = this._getOverlayItems();
        if (items) {
          this._focusedIndex = items.length - 1;
        }
      }
      this._prefillFocusedItemLabel();
    } else {
      this.open();
    }
  }
  _prefillFocusedItemLabel() {
    if (this._focusedIndex > -1) {
      this._inputElementValue = this._getItemLabel(this.$.dropdown.focusedItem);
      this._markAllSelectionRange();
    }
  }
  _setSelectionRange(start, end) {
    if (this.hasAttribute("focused")) {
      this.inputElement.setSelectionRange(start, end);
    }
  }
  _markAllSelectionRange() {
    if (this._inputElementValue !== void 0) {
      this._setSelectionRange(0, this._inputElementValue.length);
    }
  }
  _clearSelectionRange() {
    if (this._inputElementValue !== void 0) {
      const pos = this._inputElementValue ? this._inputElementValue.length : 0;
      this._setSelectionRange(pos, pos);
    }
  }
  _closeOrCommit() {
    if (!this.opened && !this.loading) {
      this._commitValue();
    } else {
      this.close();
    }
  }
  _onEnter(e) {
    if ((this.opened || this.autoOpenDisabled) && (this.allowCustomValue || this._inputElementValue === "" || this._focusedIndex > -1)) {
      this._closeOrCommit();
      e.preventDefault();
      e.stopPropagation();
    }
  }
  _onEscape(e) {
    if (this.autoOpenDisabled) {
      if (this.opened || this.value !== this._inputElementValue && this._inputElementValue.length > 0) {
        e.stopPropagation();
        this._focusedIndex = -1;
        this.cancel();
      } else if (this.clearButtonVisible && !this.opened && !!this.value) {
        e.stopPropagation();
        this._clear();
      }
    } else if (this.opened) {
      e.stopPropagation();
      if (this._focusedIndex > -1) {
        this._focusedIndex = -1;
        this._revertInputValue();
      } else {
        this.cancel();
      }
    } else if (this.clearButtonVisible && !!this.value) {
      e.stopPropagation();
      this._clear();
    }
  }
  _toggleElementChanged(toggleElement) {
    if (toggleElement) {
      toggleElement.addEventListener("mousedown", (e) => e.preventDefault());
      toggleElement.addEventListener("click", () => {
        if (isTouch && !this.hasAttribute("focused")) {
          document.activeElement.blur();
        }
      });
    }
  }
  _clear() {
    this.selectedItem = null;
    if (this.allowCustomValue) {
      this.value = "";
    }
    this._detectAndDispatchChange();
  }
  cancel() {
    this._revertInputValueToValue();
    this._lastCommittedValue = this.value;
    this._closeOrCommit();
  }
  _onOpened() {
    requestAnimationFrame(() => {
      this.$.dropdown.adjustScrollPosition();
      this._updateActiveDescendant(this._focusedIndex);
    });
    this._lastCommittedValue = this.value;
  }
  _onClosed() {
    if (this.opened) {
      this.close();
    }
    if (!this.loading || this.allowCustomValue) {
      this._commitValue();
    }
  }
  _commitValue() {
    const items = this._getOverlayItems();
    if (items && this._focusedIndex > -1) {
      const focusedItem = items[this._focusedIndex];
      if (this.selectedItem !== focusedItem) {
        this.selectedItem = focusedItem;
      }
      this._inputElementValue = this._getItemLabel(this.selectedItem);
    } else if (this._inputElementValue === "" || this._inputElementValue === void 0) {
      this.selectedItem = null;
      if (this.allowCustomValue) {
        this.value = "";
      }
    } else {
      const toLowerCase = (item) => item && item.toLowerCase && item.toLowerCase();
      const itemMatchingByLabel = [...this.filteredItems || [], this.selectedItem].find((item) => {
        return toLowerCase(this._getItemLabel(item)) === toLowerCase(this._inputElementValue);
      });
      if (this.allowCustomValue && !itemMatchingByLabel) {
        const customValue = this._inputElementValue;
        this._lastCustomValue = customValue;
        const e = new CustomEvent("custom-value-set", {
          detail: customValue,
          composed: true,
          cancelable: true,
          bubbles: true
        });
        this.dispatchEvent(e);
        if (!e.defaultPrevented) {
          this._selectItemForValue(customValue);
          this.value = customValue;
        }
      } else if (!this.allowCustomValue && !this.opened && itemMatchingByLabel) {
        this.value = this._getItemValue(itemMatchingByLabel);
      } else {
        this._inputElementValue = this.selectedItem ? this._getItemLabel(this.selectedItem) : this.value || "";
      }
    }
    this._detectAndDispatchChange();
    this._clearSelectionRange();
    if (!this.dataProvider) {
      this.filter = "";
    }
  }
  get _propertyForValue() {
    return "value";
  }
  _onInput(event) {
    if (!this.opened && !this._isClearButton(event) && !this.autoOpenDisabled) {
      this.open();
    }
    const value = this._inputElementValue;
    if (this.filter === value) {
      this._filterChanged(this.filter, this.itemValuePath, this.itemLabelPath);
    } else {
      this.filter = value;
    }
  }
  _onChange(event) {
    event.stopPropagation();
  }
  _itemLabelPathChanged(itemLabelPath) {
    if (typeof itemLabelPath !== "string") {
      console.error("You should set itemLabelPath to a valid string");
    }
  }
  _filterChanged(filter, itemValuePath, itemLabelPath) {
    if (filter === void 0) {
      return;
    }
    this.$.dropdown._scrollIntoView(0);
    if (this.items) {
      this.filteredItems = this._filterItems(this.items, filter);
    } else {
      this._filteredItemsChanged({ path: "filteredItems", value: this.filteredItems }, itemValuePath, itemLabelPath);
    }
  }
  _loadingChanged(loading) {
    if (loading) {
      this._focusedIndex = -1;
    }
  }
  _revertInputValue() {
    if (this.filter !== "") {
      this._inputElementValue = this.filter;
    } else {
      this._revertInputValueToValue();
    }
    this._clearSelectionRange();
  }
  _revertInputValueToValue() {
    if (this.allowCustomValue && !this.selectedItem) {
      this._inputElementValue = this.value;
    } else {
      this._inputElementValue = this._getItemLabel(this.selectedItem);
    }
  }
  _selectedItemChanged(selectedItem) {
    if (selectedItem === null || selectedItem === void 0) {
      if (this.filteredItems) {
        if (!this.allowCustomValue) {
          this.value = "";
        }
        this._toggleHasValue(this.value !== "");
        this._inputElementValue = this.value;
      }
    } else {
      const value = this._getItemValue(selectedItem);
      if (this.value !== value) {
        this.value = value;
        if (this.value !== value) {
          return;
        }
      }
      this._toggleHasValue(true);
      this._inputElementValue = this._getItemLabel(selectedItem);
    }
    this.$.dropdown._selectedItem = selectedItem;
    const items = this._getOverlayItems();
    if (this.filteredItems && items) {
      this._focusedIndex = this.filteredItems.indexOf(selectedItem);
    }
  }
  _valueChanged(value, oldVal) {
    if (value === "" && oldVal === void 0) {
      return;
    }
    if (this._isValidValue(value)) {
      let item;
      if (this._getItemValue(this.selectedItem) !== value) {
        this._selectItemForValue(value);
      } else {
        item = this.selectedItem;
      }
      if (!item && this.allowCustomValue) {
        this._inputElementValue = value;
      }
      this._toggleHasValue(this.value !== "");
    } else {
      this.selectedItem = null;
    }
    this._lastCommittedValue = void 0;
  }
  _detectAndDispatchChange() {
    if (this.value !== this._lastCommittedValue) {
      this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
      this._lastCommittedValue = this.value;
    }
  }
  _itemsChanged(items, oldItems) {
    this._ensureItemsOrDataProvider(() => {
      this.items = oldItems;
    });
  }
  _itemsOrPathsChanged(e) {
    if (e.path === "items" || e.path === "items.splices") {
      if (this.items) {
        this.filteredItems = this.items.slice(0);
      } else if (this.__previousItems) {
        this.filteredItems = null;
      }
      const valueIndex = this._indexOfValue(this.value, this.items);
      this._focusedIndex = valueIndex;
      const item = valueIndex > -1 && this.items[valueIndex];
      if (item) {
        this.selectedItem = item;
      }
    }
    this.__previousItems = e.value;
  }
  _filteredItemsChanged(e) {
    if (e.path === "filteredItems" || e.path === "filteredItems.splices") {
      this._setOverlayItems(this.filteredItems);
      const filterIndex = this.$.dropdown.indexOfLabel(this.filter);
      if (this.opened) {
        this._focusedIndex = filterIndex;
      } else {
        const valueIndex = this._indexOfValue(this.value, this.filteredItems);
        this._focusedIndex = filterIndex === -1 ? valueIndex : filterIndex;
      }
      if (this.selectedItem === null && this._focusedIndex >= 0) {
        const filteredItem = this.filteredItems[this._focusedIndex];
        if (this._getItemValue(filteredItem) === this.value) {
          this._selectItemForValue(this.value);
        }
      }
    }
  }
  _filterItems(arr, filter) {
    if (!arr) {
      return arr;
    }
    const filteredItems = arr.filter((item) => {
      filter = filter ? filter.toString().toLowerCase() : "";
      return this._getItemLabel(item).toString().toLowerCase().indexOf(filter) > -1;
    });
    return filteredItems;
  }
  _selectItemForValue(value) {
    const valueIndex = this._indexOfValue(value, this.filteredItems);
    const previouslySelectedItem = this.selectedItem;
    this.selectedItem = valueIndex >= 0 ? this.filteredItems[valueIndex] : this.dataProvider && this.selectedItem === void 0 ? void 0 : null;
    if (this.selectedItem === null && previouslySelectedItem === null) {
      this._selectedItemChanged(this.selectedItem);
    }
  }
  _getItemElements() {
    return Array.from(this.$.dropdown._scroller.querySelectorAll("vaadin-combo-box-item"));
  }
  _getOverlayItems() {
    return this.$.dropdown._items;
  }
  _setOverlayItems(items) {
    this.$.dropdown.set("_items", items);
  }
  _indexOfValue(value, items) {
    if (items && this._isValidValue(value)) {
      for (let i = 0; i < items.length; i++) {
        if (items[i] !== this.__placeHolder && this._getItemValue(items[i]) === value) {
          return i;
        }
      }
    }
    return -1;
  }
  _isValidValue(value) {
    return value !== void 0 && value !== null;
  }
  _overlaySelectedItemChanged(e) {
    e.stopPropagation();
    if (e.detail.item instanceof ComboBoxPlaceholder) {
      return;
    }
    if (this.opened) {
      this._focusedIndex = this.filteredItems.indexOf(e.detail.item);
      this.close();
    } else if (this.selectedItem !== e.detail.item) {
      this.selectedItem = e.detail.item;
      this._detectAndDispatchChange();
    }
  }
  __onClearButtonMouseDown(event) {
    event.preventDefault();
    this.inputElement.focus();
  }
  _onFocusout(event) {
    if (event.relatedTarget === this.$.dropdown.$.overlay) {
      event.composedPath()[0].focus();
      return;
    }
    if (!this.readonly && !this._closeOnBlurIsPrevented) {
      if (!this.opened && this.allowCustomValue && this._inputElementValue === this._lastCustomValue) {
        delete this._lastCustomValue;
        return;
      }
      this._closeOrCommit();
    }
  }
  _onTouchend(event) {
    if (!this.clearElement || event.composedPath()[0] !== this.clearElement) {
      return;
    }
    event.preventDefault();
    this._clear();
  }
  validate() {
    return !(this.invalid = !this.checkValidity());
  }
  checkValidity() {
    if (super.checkValidity) {
      return super.checkValidity();
    }
    return !this.required || !!this.value;
  }
};

export {
  ComboBoxItem,
  ComboBoxOverlay,
  ComboBoxScroller,
  ComboBoxDropdown,
  ComboBoxMixin
};
/**
 * @license
 * Copyright (c) 2015 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-23PSU7UO.js.map
