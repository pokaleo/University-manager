{
  "version": 3,
  "sources": ["../@vaadin/flow-frontend/gridConnector.js"],
  "sourcesContent": ["import { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\nimport { timeOut, animationFrame } from '@polymer/polymer/lib/utils/async.js';\nimport { Grid } from '@vaadin/grid/src/vaadin-grid.js';\nimport { ItemCache } from '@vaadin/grid/src/vaadin-grid-data-provider-mixin.js';\nimport { isFocusable } from '@vaadin/grid/src/vaadin-grid-active-item-mixin.js';\n\n(function () {\n  const tryCatchWrapper = function (callback) {\n    return window.Vaadin.Flow.tryCatchWrapper(callback, 'Vaadin Grid');\n  };\n\n  let isItemCacheInitialized = false;\n\n  window.Vaadin.Flow.gridConnector = {\n    initLazy: grid => tryCatchWrapper(function(grid) {\n      // Check whether the connector was already initialized for the grid\n      if (grid.$connector){\n        return;\n      }\n\n      // Make sure ItemCache patching is done only once, but delay it for when\n      // a server grid is initialized\n      if (!isItemCacheInitialized) {\n        isItemCacheInitialized = true;\n        // Storing original implementation of the method to be used for client\n        // side only grids\n        ItemCache.prototype.ensureSubCacheForScaledIndexOriginal = ItemCache.prototype.ensureSubCacheForScaledIndex;\n        ItemCache.prototype.ensureSubCacheForScaledIndex = tryCatchWrapper(function(scaledIndex) {\n          if (!this.grid.$connector) {\n            this.ensureSubCacheForScaledIndexOriginal(scaledIndex);\n            return;\n          }\n\n          if (!this.itemCaches[scaledIndex]) {\n            this.grid.$connector.beforeEnsureSubCacheForScaledIndex(this, scaledIndex);\n          }\n        });\n\n        ItemCache.prototype.isLoadingOriginal = ItemCache.prototype.isLoading;\n        ItemCache.prototype.isLoading = tryCatchWrapper(function() {\n          if (!this.grid.$connector) {\n            return this.isLoadingOriginal();\n          }\n\n          return Boolean(this.grid.$connector.hasEnsureSubCacheQueue() || Object.keys(this.pendingRequests).length || Object.keys(this.itemCaches).filter(index => {\n            return this.itemCaches[index].isLoading();\n          })[0]);\n        });\n\n        ItemCache.prototype.doEnsureSubCacheForScaledIndex = tryCatchWrapper(function(scaledIndex) {\n          if (!this.itemCaches[scaledIndex]) {\n            const subCache = new ItemCache.prototype.constructor(this.grid, this, this.items[scaledIndex]);\n            subCache.itemkeyCaches = {};\n            if(!this.itemkeyCaches) {\n              this.itemkeyCaches = {};\n            }\n            this.itemCaches[scaledIndex] = subCache;\n            this.itemkeyCaches[this.grid.getItemId(subCache.parentItem)] = subCache;\n            this.grid._loadPage(0, subCache);\n          }\n        });\n\n        ItemCache.prototype.getCacheAndIndexByKey = tryCatchWrapper(function(key) {\n          for (let index in this.items) {\n            if(this.grid.getItemId(this.items[index]) === key) {\n              return {cache: this, scaledIndex: index};\n            }\n          }\n          const keys = Object.keys(this.itemkeyCaches);\n          for (let i = 0; i < keys.length; i++) {\n            const expandedKey = keys[i];\n            const subCache = this.itemkeyCaches[expandedKey];\n            let cacheAndIndex = subCache.getCacheAndIndexByKey(key);\n            if(cacheAndIndex) {\n              return cacheAndIndex;\n            }\n          }\n          return undefined;\n        });\n\n        ItemCache.prototype.getLevel = tryCatchWrapper(function() {\n          let cache = this;\n          let level = 0;\n          while (cache.parentCache) {\n            cache = cache.parentCache;\n            level++;\n          }\n          return level;\n        });\n      }\n\n      const rootPageCallbacks = {};\n      const treePageCallbacks = {};\n      const cache = {};\n\n      /* parentRequestDelay - optimizes parent requests by batching several requests\n      *  into one request. Delay in milliseconds. Disable by setting to 0.\n      *  parentRequestBatchMaxSize - maximum size of the batch.\n      */\n      const parentRequestDelay = 50;\n      const parentRequestBatchMaxSize = 20;\n\n      let parentRequestQueue = [];\n      let parentRequestDebouncer;\n      let ensureSubCacheQueue = [];\n      let ensureSubCacheDebouncer;\n\n      const rootRequestDelay = 150;\n      let rootRequestDebouncer;\n\n      let lastRequestedRanges = {};\n      const root = 'null';\n      lastRequestedRanges[root] = [0, 0];\n\n      const validSelectionModes = ['SINGLE', 'NONE', 'MULTI'];\n      let selectedKeys = {};\n      let selectionMode = 'SINGLE';\n\n      let sorterDirectionsSetFromServer = false;\n\n      grid.size = 0; // To avoid NaN here and there before we get proper data\n      grid.itemIdPath = 'key';\n\n      grid.$connector = {};\n\n      grid.$connector.hasEnsureSubCacheQueue = tryCatchWrapper(() => ensureSubCacheQueue.length > 0);\n\n      grid.$connector.hasParentRequestQueue = tryCatchWrapper(() => parentRequestQueue.length > 0);\n\n      grid.$connector.hasRootRequestQueue = tryCatchWrapper(() => {\n        return Object.keys(rootPageCallbacks).length > 0 || (rootRequestDebouncer && rootRequestDebouncer.isActive());\n      })\n\n      grid.$connector.beforeEnsureSubCacheForScaledIndex = tryCatchWrapper(function(targetCache, scaledIndex) {\n        // add call to queue\n        ensureSubCacheQueue.push({\n          cache: targetCache,\n          scaledIndex: scaledIndex,\n          itemkey: grid.getItemId(targetCache.items[scaledIndex]),\n          level: targetCache.getLevel()\n        });\n        // sort by ascending scaledIndex and level\n        ensureSubCacheQueue.sort(function(a, b) {\n          return a.scaledIndex - b.scaledIndex || a.level - b.level;\n        });\n\n        ensureSubCacheDebouncer = Debouncer.debounce(ensureSubCacheDebouncer, animationFrame,\n          () => {\n            while (ensureSubCacheQueue.length) {\n              grid.$connector.flushEnsureSubCache();\n            }\n          }\n        );\n      })\n\n      grid.$connector.doSelection = tryCatchWrapper(function(items, userOriginated) {\n        if (selectionMode === 'NONE' || !items.length ||\n            (userOriginated && grid.hasAttribute('disabled'))) {\n          return;\n        }\n        if (selectionMode === 'SINGLE') {\n          grid.selectedItems = [];\n          selectedKeys = {};\n        }\n\n        grid.selectedItems = grid.selectedItems.concat(items);\n        items.forEach(item => {\n          if (item) {\n            selectedKeys[item.key] = item;\n            if (userOriginated) {\n              item.selected = true;\n              grid.$server.select(item.key);\n            }\n          }\n          const isSelectedItemDifferentOrNull = !grid.activeItem || !item || item.key != grid.activeItem.key;\n          if (!userOriginated && selectionMode === 'SINGLE' && isSelectedItemDifferentOrNull) {\n            grid.activeItem = item;\n          }\n        });\n      });\n\n      grid.$connector.doDeselection = tryCatchWrapper(function(items, userOriginated) {\n        if (selectionMode === 'NONE' || !items.length ||\n            (userOriginated && grid.hasAttribute('disabled'))) {\n          return;\n        }\n\n        const updatedSelectedItems = grid.selectedItems.slice();\n        while (items.length) {\n          const itemToDeselect = items.shift();\n          for (let i = 0; i < updatedSelectedItems.length; i++) {\n            const selectedItem = updatedSelectedItems[i];\n            if (itemToDeselect && itemToDeselect.key === selectedItem.key) {\n              updatedSelectedItems.splice(i, 1);\n              break;\n            }\n          }\n          if (itemToDeselect) {\n            delete selectedKeys[itemToDeselect.key];\n            if (userOriginated) {\n              delete itemToDeselect.selected;\n              grid.$server.deselect(itemToDeselect.key);\n            }\n          }\n        }\n        grid.selectedItems = updatedSelectedItems;\n      });\n\n      grid.__activeItemChanged = tryCatchWrapper(function(newVal, oldVal) {\n        if (selectionMode != 'SINGLE') {\n          return;\n        }\n        if (!newVal) {\n          if (oldVal && selectedKeys[oldVal.key]) {\n            if (grid.__deselectDisallowed) {\n              grid.activeItem = oldVal;\n            } else {\n              grid.$connector.doDeselection([oldVal], true);\n            }\n          }\n        } else if (!selectedKeys[newVal.key]) {\n          grid.$connector.doSelection([newVal], true);\n        }\n      });\n      grid._createPropertyObserver('activeItem', '__activeItemChanged', true);\n\n      grid.__activeItemChangedDetails = tryCatchWrapper(function(newVal, oldVal) {\n        if (grid.__disallowDetailsOnClick) {\n          return;\n        }\n        // when grid is attached, newVal is not set and oldVal is undefined\n        // do nothing\n        if ((newVal == null) && (oldVal === undefined)) {\n          return;\n        }\n        if (newVal && !newVal.detailsOpened) {\n          grid.$server.setDetailsVisible(newVal.key);\n        } else {\n          grid.$server.setDetailsVisible(null);\n        }\n      })\n      grid._createPropertyObserver('activeItem', '__activeItemChangedDetails', true);\n\n      grid.$connector._getPageIfSameLevel = tryCatchWrapper(function(parentKey, index, defaultPage) {\n        let cacheAndIndex = grid._cache.getCacheAndIndex(index);\n        let parentItem = cacheAndIndex.cache.parentItem;\n        let parentKeyOfIndex = (parentItem) ? grid.getItemId(parentItem) : root;\n        if(parentKey !== parentKeyOfIndex) {\n          return defaultPage;\n        } else {\n          return grid._getPageForIndex(cacheAndIndex.scaledIndex);\n        }\n      })\n\n      grid.$connector.getCacheByKey = tryCatchWrapper(function(key) {\n        let cacheAndIndex = grid._cache.getCacheAndIndexByKey(key);\n        if(cacheAndIndex) {\n          return cacheAndIndex.cache;\n        }\n        return undefined;\n      });\n\n      grid.$connector.flushEnsureSubCache = tryCatchWrapper(function() {\n        let pendingFetch = ensureSubCacheQueue.splice(0, 1)[0];\n        let itemkey =  pendingFetch.itemkey;\n\n        const visibleRows = grid._getVisibleRows();\n        let start = visibleRows[0].index;\n        let end = visibleRows[visibleRows.length - 1].index;\n\n        let buffer = end - start;\n        let firstNeededIndex = Math.max(0, start - buffer);\n        let lastNeededIndex = Math.min(end + buffer, grid._effectiveSize);\n\n        // only fetch if given item is still in visible range\n        for(let index = firstNeededIndex; index <= lastNeededIndex; index++) {\n          let item = grid._cache.getItemForIndex(index);\n\n          if(grid.getItemId(item) === itemkey) {\n            if(grid._isExpanded(item)) {\n              pendingFetch.cache.doEnsureSubCacheForScaledIndex(pendingFetch.scaledIndex);\n              return true;\n            } else {\n              break;\n            }\n          }\n        }\n        return false;\n      })\n\n      grid.$connector.flushParentRequests = tryCatchWrapper(function() {\n        let pendingFetches = parentRequestQueue.splice(0, parentRequestBatchMaxSize);\n\n        if(pendingFetches.length) {\n          grid.$server.setParentRequestedRanges(pendingFetches);\n          return true;\n        }\n        return false;\n      })\n\n      grid.$connector.beforeParentRequest = tryCatchWrapper(function(firstIndex, size, parentKey) {\n        // add request in queue\n        parentRequestQueue.push({\n          firstIndex: firstIndex,\n          size: size,\n          parentKey: parentKey\n        });\n\n        parentRequestDebouncer = Debouncer.debounce(parentRequestDebouncer, timeOut.after(parentRequestDelay),\n          () => {\n            while (parentRequestQueue.length) {\n              grid.$connector.flushParentRequests();\n            }\n          }\n        );\n      })\n\n      grid.$connector.fetchPage = tryCatchWrapper(function(fetch, page, parentKey) {\n        // Determine what to fetch based on scroll position and not only\n        // what grid asked for\n\n        // The buffer size could be multiplied by some constant defined by the user,\n        // if he needs to reduce the number of items sent to the Grid to improve performance\n        // or to increase it to make Grid smoother when scrolling\n        const visibleRows = grid._getVisibleRows();\n        let start = visibleRows.length > 0 ? visibleRows[0].index : 0;\n        let end = visibleRows.length > 0 ? visibleRows[visibleRows.length - 1].index : 0;\n        let buffer = end - start;\n\n        let firstNeededIndex = Math.max(0, start - buffer);\n        let lastNeededIndex = Math.min(end + buffer, grid._effectiveSize);\n\n        let firstNeededPage = page;\n        let lastNeededPage = page;\n        for(let idx = firstNeededIndex; idx <= lastNeededIndex; idx++) {\n          firstNeededPage = Math.min(firstNeededPage, grid.$connector._getPageIfSameLevel(parentKey, idx, firstNeededPage));\n          lastNeededPage = Math.max(lastNeededPage, grid.$connector._getPageIfSameLevel(parentKey, idx, lastNeededPage));\n        }\n\n        let firstPage = Math.max(0,  firstNeededPage);\n        let lastPage = (parentKey !== root) ? lastNeededPage: Math.min(lastNeededPage, Math.floor(grid.size / grid.pageSize));\n        let lastRequestedRange = lastRequestedRanges[parentKey];\n        if(!lastRequestedRange) {\n          lastRequestedRange = [-1, -1];\n        }\n        if (lastRequestedRange[0] != firstPage || lastRequestedRange[1] != lastPage) {\n          lastRequestedRange = [firstPage, lastPage];\n          lastRequestedRanges[parentKey] = lastRequestedRange;\n          let count = lastPage - firstPage + 1;\n          fetch(firstPage * grid.pageSize, count * grid.pageSize);\n        }\n      })\n\n      grid.dataProvider = tryCatchWrapper(function(params, callback) {\n        if (params.pageSize != grid.pageSize) {\n          throw 'Invalid pageSize';\n        }\n\n        let page = params.page;\n\n        if(params.parentItem) {\n          let parentUniqueKey = grid.getItemId(params.parentItem);\n          if(!treePageCallbacks[parentUniqueKey]) {\n            treePageCallbacks[parentUniqueKey] = {};\n          }\n\n          let parentCache = grid.$connector.getCacheByKey(parentUniqueKey);\n          let itemCache = (parentCache && parentCache.itemkeyCaches) ? parentCache.itemkeyCaches[parentUniqueKey] : undefined;\n          if(cache[parentUniqueKey] && cache[parentUniqueKey][page] && itemCache) {\n            // workaround: sometimes grid-element gives page index that overflows\n            page = Math.min(page, Math.floor(cache[parentUniqueKey].size / grid.pageSize));\n\n            callback(cache[parentUniqueKey][page], cache[parentUniqueKey].size);\n          } else {\n            treePageCallbacks[parentUniqueKey][page] = callback;\n          }\n          grid.$connector.fetchPage(\n            (firstIndex, size) => grid.$connector.beforeParentRequest(firstIndex, size, params.parentItem.key),\n            page,\n            parentUniqueKey\n          );\n\n        } else {\n          // workaround: sometimes grid-element gives page index that overflows\n          page = Math.min(page, Math.floor(grid.size / grid.pageSize));\n\n          if (cache[root] && cache[root][page]) {\n            callback(cache[root][page]);\n          } else {\n            rootPageCallbacks[page] = callback;\n          }\n\n          rootRequestDebouncer = Debouncer.debounce(rootRequestDebouncer, timeOut.after(grid._hasData ? rootRequestDelay : 0),\n            () => {\n              grid.$connector.fetchPage((firstIndex, size) => grid.$server.setRequestedRange(firstIndex, size), page, root);\n            }\n          );\n        }\n      })\n\n      const sorterChangeListener = tryCatchWrapper(function(_, oldValue) {\n        if (oldValue !== undefined && !sorterDirectionsSetFromServer) {\n          grid.$server.sortersChanged(grid._sorters.map(function (sorter) {\n            return {\n              path: sorter.path,\n              direction: sorter.direction\n            };\n          }));\n        }\n      })\n\n      grid.$connector.setSorterDirections = tryCatchWrapper(function(directions) {\n        sorterDirectionsSetFromServer = true;\n        setTimeout(tryCatchWrapper(() => {\n          try {\n            const sorters = Array.from(grid.querySelectorAll('vaadin-grid-sorter'));\n\n            sorters.forEach(sorter => {\n              if (!directions.filter(d => d.column === sorter.getAttribute('path'))[0]) {\n                sorter.direction = null;\n              }\n            });\n\n            directions.reverse().forEach(({column, direction}) => {\n              sorters.forEach(sorter => {\n                if (sorter.getAttribute('path') === column && sorter.direction !== direction) {\n                  sorter.direction = direction\n                }\n              });\n            });\n          } finally {\n            sorterDirectionsSetFromServer = false;\n          }\n        }));\n      })\n      grid._createPropertyObserver(\"_previousSorters\", sorterChangeListener);\n\n      grid._updateItem = tryCatchWrapper(function(row, item) {\n        Grid.prototype._updateItem.call(grid, row, item);\n\n        // There might be inactive component renderers on hidden rows that still refer to the\n        // same component instance as one of the renderers on a visible row. Making the\n        // inactive/hidden renderer attach the component might steal it from a visible/active one.\n        if (!row.hidden) {\n          // make sure that component renderers are updated\n          Array.from(row.children).forEach(cell => {\n            if (cell._content && cell._content.__templateInstance && cell._content.__templateInstance.children) {\n              Array.from(cell._content.__templateInstance.children).forEach(content => {\n                if(content._attachRenderedComponentIfAble) {\n                  content._attachRenderedComponentIfAble();\n                }\n                // In hierarchy column of tree grid, the component renderer is inside its content,\n                // this updates it renderer from innerContent\n                if (content.children) {\n                  Array.from(content.children).forEach(innerContent => {\n                    if(innerContent._attachRenderedComponentIfAble) {\n                        innerContent._attachRenderedComponentIfAble();\n                    }\n                  });\n                }\n             });\n            }\n          });\n        }\n        // since no row can be selected when selection mode is NONE\n        // if selectionMode is set to NONE, remove aria-selected attribute from the row\n        if (selectionMode === validSelectionModes[1]) { // selectionMode === NONE\n          row.removeAttribute('aria-selected');\n          Array.from(row.children).forEach(cell => cell.removeAttribute('aria-selected'));\n        }\n      })\n\n      const itemExpandedChanged = tryCatchWrapper(function(item, expanded) {\n        // method available only for the TreeGrid server-side component\n        if (item == undefined || grid.$server.updateExpandedState == undefined) {\n          return;\n        }\n        let parentKey = grid.getItemId(item);\n        grid.$server.updateExpandedState(parentKey, expanded);\n\n        if (!expanded) {\n          delete cache[parentKey];\n          let parentCache = grid.$connector.getCacheByKey(parentKey);\n          if (parentCache && parentCache.itemkeyCaches && parentCache.itemkeyCaches[parentKey]) {\n            delete parentCache.itemkeyCaches[parentKey];\n          }\n          if (parentCache && parentCache.itemkeyCaches) {\n            Object.keys(parentCache.itemCaches)\n                .filter(idx => parentCache.items[idx].key === parentKey)\n                .forEach(idx => delete parentCache.itemCaches[idx]);\n          }\n          delete lastRequestedRanges[parentKey];\n        }\n      });\n\n      // Patch grid.expandItem and grid.collapseItem to have\n      // itemExpandedChanged run when either happens.\n      grid.expandItem = tryCatchWrapper(function(item) {\n        itemExpandedChanged(item, true);\n        Grid.prototype.expandItem.call(grid, item);\n      });\n\n      grid.collapseItem = tryCatchWrapper(function(item) {\n        itemExpandedChanged(item, false);\n        Grid.prototype.collapseItem.call(grid, item);\n      });\n\n      const itemsUpdated = function(items) {\n        if (!items || !Array.isArray(items)) {\n          throw 'Attempted to call itemsUpdated with an invalid value: ' + JSON.stringify(items);\n        }\n        let detailsOpenedItems = Array.from(grid.detailsOpenedItems);\n        let updatedSelectedItem = false;\n        for (let i = 0; i < items.length; ++i) {\n          const item = items[i];\n          if(!item) {\n            continue;\n          }\n          if (item.detailsOpened) {\n            if(grid._getItemIndexInArray(item, detailsOpenedItems) < 0) {\n              detailsOpenedItems.push(item);\n            }\n          } else if(grid._getItemIndexInArray(item, detailsOpenedItems) >= 0) {\n            detailsOpenedItems.splice(grid._getItemIndexInArray(item, detailsOpenedItems), 1)\n          }\n          if (selectedKeys[item.key]) {\n            selectedKeys[item.key] = item;\n            item.selected = true;\n            updatedSelectedItem = true;\n          }\n        }\n        grid.detailsOpenedItems = detailsOpenedItems;\n        if (updatedSelectedItem) {\n          // IE 11 Object doesn't support method values\n          grid.selectedItems = Object.keys(selectedKeys).map(function(e) {\n            return selectedKeys[e]\n          });\n        }\n      };\n\n      /**\n       * Updates the cache for the given page for grid or tree-grid.\n       *\n       * @param page index of the page to update\n       * @param parentKey the key of the parent item for the page\n       * @returns an array of the updated items for the page, or undefined if no items were cached for the page\n       */\n      const updateGridCache = function(page, parentKey) {\n        let items;\n        if((parentKey || root) !== root) {\n          items = cache[parentKey][page];\n          let parentCache = grid.$connector.getCacheByKey(parentKey);\n          if(parentCache && parentCache.itemkeyCaches) {\n            let _cache = parentCache.itemkeyCaches[parentKey];\n            const callbacksForParentKey = treePageCallbacks[parentKey];\n            const callback = callbacksForParentKey && callbacksForParentKey[page];\n            _updateGridCache(page, items, callback, _cache);\n          }\n\n        } else {\n          items = cache[root][page];\n          _updateGridCache(page, items, rootPageCallbacks[page], grid._cache);\n        }\n        return items;\n      };\n\n      const _updateGridCache = function(page, items, callback, levelcache) {\n        // Force update unless there's a callback waiting\n        if (!callback) {\n          let rangeStart = page * grid.pageSize;\n          let rangeEnd = rangeStart + grid.pageSize;\n          if (!items) {\n            if (levelcache && levelcache.items) {\n              for (let idx = rangeStart; idx < rangeEnd; idx++) {\n                delete levelcache.items[idx];\n              }\n            }\n          } else {\n            if (levelcache && levelcache.items) {\n              for (let idx = rangeStart; idx < rangeEnd; idx++) {\n                if (levelcache.items[idx]) {\n                  levelcache.items[idx] = items[idx - rangeStart];\n                }\n              }\n            }\n          }\n        }\n      };\n\n      /**\n       * Updates all visible grid rows in DOM.\n       */\n      const updateAllGridRowsInDomBasedOnCache = function () {\n        grid._cache.updateSize();\n        grid._effectiveSize = grid._cache.effectiveSize;\n        grid.__updateVisibleRows();\n      };\n\n      /**\n       * Update the given items in DOM if currently visible.\n       *\n       * @param array items the items to update in DOM\n       */\n      const updateGridItemsInDomBasedOnCache = function(items) {\n        if (!items || !grid.$ || grid.$.items.childElementCount === 0) {\n          return;\n        }\n\n        const itemKeys = items.map(item => item.key);\n        const indexes = grid._getVisibleRows()\n            .filter(row => row._item && itemKeys.includes(row._item.key))\n            .map(row => row.index);\n        if (indexes.length > 0) {\n          grid.__updateVisibleRows(indexes[0], indexes[indexes.length - 1]);\n        }\n      };\n\n      grid.$connector.set = tryCatchWrapper(function(index, items, parentKey) {\n        if (index % grid.pageSize != 0) {\n          throw 'Got new data to index ' + index + ' which is not aligned with the page size of ' + grid.pageSize;\n        }\n        let pkey = parentKey || root;\n\n        const firstPage = index / grid.pageSize;\n        const updatedPageCount = Math.ceil(items.length / grid.pageSize);\n\n        for (let i = 0; i < updatedPageCount; i++) {\n          let page = firstPage + i;\n          let slice = items.slice(i * grid.pageSize, (i + 1) * grid.pageSize);\n          if(!cache[pkey]) {\n            cache[pkey] = {};\n          }\n          cache[pkey][page] = slice;\n\n          grid.$connector.doSelection(slice.filter(\n            item => item.selected && !isSelectedOnGrid(item)));\n          grid.$connector.doDeselection(slice.filter(\n            item => !item.selected  && (selectedKeys[item.key] || isSelectedOnGrid(item))));\n\n          const updatedItems = updateGridCache(page, pkey);\n          if (updatedItems) {\n            itemsUpdated(updatedItems);\n            updateGridItemsInDomBasedOnCache(updatedItems);\n          }\n        }\n      });\n\n      const itemToCacheLocation = function(item) {\n        let parent = item.parentUniqueKey || root;\n        if(cache[parent]) {\n          for (let page in cache[parent]) {\n            for (let index in cache[parent][page]) {\n              if (grid.getItemId(cache[parent][page][index]) === grid.getItemId(item)) {\n                return {page: page, index: index, parentKey: parent};\n              }\n            }\n          }\n        }\n        return null;\n      };\n\n      /**\n       * Updates the given items for a hierarchical grid.\n       *\n       * @param updatedItems the updated items array\n       */\n      grid.$connector.updateHierarchicalData = tryCatchWrapper(function(updatedItems) {\n        let pagesToUpdate = [];\n        // locate and update the items in cache\n        // find pages that need updating\n        for (let i = 0; i < updatedItems.length; i++) {\n          let cacheLocation = itemToCacheLocation(updatedItems[i]);\n          if (cacheLocation) {\n            cache[cacheLocation.parentKey][cacheLocation.page][cacheLocation.index] = updatedItems[i];\n            let key = cacheLocation.parentKey+':'+cacheLocation.page;\n            if (!pagesToUpdate[key]) {\n              pagesToUpdate[key] = {parentKey: cacheLocation.parentKey, page: cacheLocation.page};\n            }\n          }\n        }\n        // IE11 doesn't work with the transpiled version of the forEach.\n        let keys = Object.keys(pagesToUpdate);\n        for (let i = 0; i < keys.length; i++) {\n          let pageToUpdate = pagesToUpdate[keys[i]];\n          const affectedUpdatedItems = updateGridCache(pageToUpdate.page, pageToUpdate.parentKey);\n          if (affectedUpdatedItems) {\n            itemsUpdated(affectedUpdatedItems);\n            updateGridItemsInDomBasedOnCache(affectedUpdatedItems);\n          }\n        }\n      });\n\n      /**\n       * Updates the given items for a non-hierarchical grid.\n       *\n       * @param updatedItems the updated items array\n       */\n      grid.$connector.updateFlatData = tryCatchWrapper(function(updatedItems) {\n        // update (flat) caches\n        for (let i = 0; i < updatedItems.length; i++) {\n          let cacheLocation = itemToCacheLocation(updatedItems[i]);\n          if (cacheLocation) {\n            // update connector cache\n            cache[cacheLocation.parentKey][cacheLocation.page][cacheLocation.index] = updatedItems[i];\n\n            // update grid's cache\n            const index = parseInt(cacheLocation.page) * grid.pageSize + parseInt(cacheLocation.index);\n            if (grid._cache.items[index]) {\n              grid._cache.items[index] = updatedItems[i];\n            }\n          }\n        }\n        itemsUpdated(updatedItems);\n\n        updateGridItemsInDomBasedOnCache(updatedItems);\n      });\n\n      grid.$connector.clearExpanded = tryCatchWrapper(function() {\n        grid.expandedItems = [];\n        ensureSubCacheQueue = [];\n        parentRequestQueue = [];\n      })\n\n      grid.$connector.clear = tryCatchWrapper(function(index, length, parentKey) {\n        let pkey = parentKey || root;\n        if (!cache[pkey] || Object.keys(cache[pkey]).length === 0){\n          return;\n        }\n        if (index % grid.pageSize != 0) {\n          throw 'Got cleared data for index ' + index + ' which is not aligned with the page size of ' + grid.pageSize;\n        }\n\n        let firstPage = Math.floor(index / grid.pageSize);\n        let updatedPageCount = Math.ceil(length / grid.pageSize);\n\n        for (let i = 0; i < updatedPageCount; i++) {\n          let page = firstPage + i;\n          let items = cache[pkey][page];\n          grid.$connector.doDeselection(items.filter(item => selectedKeys[item.key]));\n          delete cache[pkey][page];\n          const updatedItems = updateGridCache(page, parentKey);\n          if (updatedItems) {\n            itemsUpdated(updatedItems);\n          }\n          updateGridItemsInDomBasedOnCache(items);\n        }\n        let cacheToClear = grid._cache;\n        if(parentKey)  {\n          const cacheAndIndex = grid._cache.getCacheAndIndexByKey(pkey);\n          cacheToClear = cacheAndIndex.cache.itemCaches[cacheAndIndex.scaledIndex];\n        }\n        const endIndex = index + updatedPageCount * grid.pageSize;\n        for(let itemIndex = index; itemIndex < endIndex; itemIndex++) {\n          delete cacheToClear.items[itemIndex];\n          const subcacheToClear = cacheToClear.itemCaches[itemIndex];\n          delete cacheToClear.itemCaches[itemIndex];\n          const itemKeyToRemove = subcacheToClear && subcacheToClear.parentItem.key;\n          if(itemKeyToRemove) {\n            delete cacheToClear.itemkeyCaches[itemKeyToRemove];\n          }\n        }\n        grid._cache.updateSize();\n      });\n\n      const isSelectedOnGrid = function(item) {\n        const selectedItems = grid.selectedItems;\n        for(let i = 0; i < selectedItems; i++) {\n          let selectedItem = selectedItems[i];\n          if (selectedItem.key === item.key) {\n            return true;\n          }\n        }\n        return false;\n      };\n\n      grid.$connector.reset = tryCatchWrapper(function() {\n        grid.size = 0;\n        deleteObjectContents(cache);\n        deleteObjectContents(grid._cache.items);\n        deleteObjectContents(lastRequestedRanges);\n        if(ensureSubCacheDebouncer) {\n          ensureSubCacheDebouncer.cancel();\n        }\n        if(parentRequestDebouncer) {\n          parentRequestDebouncer.cancel();\n        }\n        if (rootRequestDebouncer) {\n          rootRequestDebouncer.cancel();\n        }\n        ensureSubCacheDebouncer = undefined;\n        parentRequestDebouncer = undefined;\n        ensureSubCacheQueue = [];\n        parentRequestQueue = [];\n        updateAllGridRowsInDomBasedOnCache();\n      });\n\n      const deleteObjectContents = obj => Object.keys(obj).forEach(key => delete obj[key]);\n\n      grid.$connector.updateSize = newSize => grid.size = newSize;\n\n      grid.$connector.updateUniqueItemIdPath = path => grid.itemIdPath = path;\n\n      grid.$connector.expandItems = tryCatchWrapper(function(items) {\n        let newExpandedItems = Array.from(grid.expandedItems);\n        items.filter(item => !grid._isExpanded(item))\n          .forEach(item =>\n            newExpandedItems.push(item));\n        grid.expandedItems = newExpandedItems;\n      })\n\n      grid.$connector.collapseItems = tryCatchWrapper(function(items) {\n        let newExpandedItems = Array.from(grid.expandedItems);\n        items.forEach(item => {\n          let index = grid._getItemIndexInArray(item, newExpandedItems);\n          if(index >= 0) {\n            newExpandedItems.splice(index, 1);\n          }\n        });\n        grid.expandedItems = newExpandedItems;\n        items.forEach(item => grid.$connector.removeFromQueue(item));\n      })\n\n      grid.$connector.removeFromQueue = tryCatchWrapper(function(item) {\n        let itemId = grid.getItemId(item);\n        delete treePageCallbacks[itemId];\n        grid.$connector.removeFromArray(ensureSubCacheQueue, item => item.itemkey === itemId);\n        grid.$connector.removeFromArray(parentRequestQueue, item => item.parentKey === itemId);\n      })\n\n      grid.$connector.removeFromArray = tryCatchWrapper(function(array, removeTest) {\n        if(array.length) {\n          for(let index = array.length - 1; index--; ) {\n            if (removeTest(array[index])) {\n              array.splice(index, 1);\n            }\n          }\n        }\n      })\n\n      grid.$connector.confirmParent = tryCatchWrapper(function(id, parentKey, levelSize) {\n        if(!treePageCallbacks[parentKey]) {\n          return;\n        }\n        if(cache[parentKey]) {\n          cache[parentKey].size = levelSize;\n        }\n        let outstandingRequests = Object.getOwnPropertyNames(treePageCallbacks[parentKey]);\n        for(let i = 0; i < outstandingRequests.length; i++) {\n          let page = outstandingRequests[i];\n\n          let lastRequestedRange = lastRequestedRanges[parentKey] || [0, 0];\n\n          const callback = treePageCallbacks[parentKey][page];\n          if((cache[parentKey] && cache[parentKey][page]) || page < lastRequestedRange[0] || page > lastRequestedRange[1]) {\n            delete treePageCallbacks[parentKey][page];\n            let items = cache[parentKey][page] || new Array(levelSize);\n            callback(items, levelSize);\n          } else if (callback && levelSize === 0) {\n            // The parent item has 0 child items => resolve the callback with an empty array\n            delete treePageCallbacks[parentKey][page];\n            callback([], levelSize);\n          }\n        }\n        // Let server know we're done\n        grid.$server.confirmParentUpdate(id, parentKey);\n\n        if (!grid.loading) {\n          grid.__updateVisibleRows();\n        }\n      });\n\n      grid.$connector.confirm = tryCatchWrapper(function(id) {\n        // We're done applying changes from this batch, resolve outstanding\n        // callbacks\n        let outstandingRequests = Object.getOwnPropertyNames(rootPageCallbacks);\n        for(let i = 0; i < outstandingRequests.length; i++) {\n          let page = outstandingRequests[i];\n          let lastRequestedRange = lastRequestedRanges[root] || [0, 0];\n\n          const lastAvailablePage = grid.size ? Math.ceil(grid.size / grid.pageSize) - 1 : 0;\n          // It's possible that the lastRequestedRange includes a page that's beyond lastAvailablePage if the grid's size got reduced during an ongoing data request\n          const lastRequestedRangeEnd = Math.min(lastRequestedRange[1], lastAvailablePage);\n          // Resolve if we have data or if we don't expect to get data\n          const callback = rootPageCallbacks[page];\n          if ((cache[root] && cache[root][page]) || page < lastRequestedRange[0] || +page > lastRequestedRangeEnd) {\n            delete rootPageCallbacks[page];\n\n            if (cache[root][page]) {\n              // Cached data is available, resolve the callback\n              callback(cache[root][page]);\n            } else {\n              // No cached data, resolve the callback with an empty array\n              callback(new Array(grid.pageSize));\n              // Request grid for content update\n              grid.requestContentUpdate();\n            }\n\n            // Makes sure to push all new rows before this stack execution is done so any timeout expiration called after will be applied on a fully updated grid\n            //Resolves https://github.com/vaadin/vaadin-grid-flow/issues/511\n            if(grid._debounceIncreasePool){\n              grid._debounceIncreasePool.flush();\n            }\n\n          } else if (callback && grid.size === 0) {\n            // The grid has 0 items => resolve the callback with an empty array\n            delete rootPageCallbacks[page];\n            callback([]);\n          }\n        }\n\n        // Let server know we're done\n        grid.$server.confirmUpdate(id);\n      })\n\n      grid.$connector.ensureHierarchy = tryCatchWrapper(function() {\n        for (let parentKey in cache) {\n          if(parentKey !== root) {\n            delete cache[parentKey];\n          }\n        }\n        deleteObjectContents(lastRequestedRanges);\n\n        grid._cache.itemCaches = {};\n        grid._cache.itemkeyCaches = {};\n\n        updateAllGridRowsInDomBasedOnCache();\n      })\n\n      grid.$connector.setSelectionMode = tryCatchWrapper(function(mode) {\n        if ((typeof mode === 'string' || mode instanceof String)\n            && validSelectionModes.indexOf(mode) >= 0) {\n          selectionMode = mode;\n          selectedKeys = {};\n          grid.$connector.updateMultiSelectable();\n        } else {\n          throw 'Attempted to set an invalid selection mode';\n        }\n      });\n\n      /*\n       * Manage aria-multiselectable attribute depending on the selection mode.\n       * see more: https://github.com/vaadin/web-components/issues/1536\n       * or: https://www.w3.org/TR/wai-aria-1.1/#aria-multiselectable\n       * For selection mode SINGLE, set the aria-multiselectable attribute to false\n       */\n      grid.$connector.updateMultiSelectable = tryCatchWrapper(function() {\n        if (!grid.$) {\n          return;\n        }\n\n        if (selectionMode === validSelectionModes[0]) {\n          grid.$.table.setAttribute('aria-multiselectable', false);\n          // For selection mode NONE, remove the aria-multiselectable attribute\n        } else if (selectionMode === validSelectionModes[1]) {\n          grid.$.table.removeAttribute('aria-multiselectable');\n          // For selection mode MULTI, set aria-multiselectable to true\n        } else {\n          grid.$.table.setAttribute('aria-multiselectable', true);\n        }\n      });\n\n      // Have the multi-selectable state updated on attach\n      grid._createPropertyObserver(\"isAttached\", () => grid.$connector.updateMultiSelectable());\n\n      // TODO: should be removed once https://github.com/vaadin/vaadin-grid/issues/1471 gets implemented\n      grid.$connector.setVerticalScrollingEnabled = tryCatchWrapper(function(enabled) {\n        // There are two scollable containers in grid so apply the changes for both\n        setVerticalScrollingEnabled(grid.$.table, enabled);\n      });\n\n      const setVerticalScrollingEnabled = function(scrollable, enabled) {\n        // Prevent Y axis scrolling with CSS. This will hide the vertical scrollbar.\n        scrollable.style.overflowY = enabled ? '' : 'hidden';\n        // Clean up an existing listener\n        scrollable.removeEventListener('wheel', scrollable.__wheelListener);\n        // Add a wheel event listener with the horizontal scrolling prevention logic\n        !enabled && scrollable.addEventListener('wheel', scrollable.__wheelListener = tryCatchWrapper(e => {\n          if (e.deltaX) {\n            // If there was some horizontal delta related to the wheel event, force the vertical\n            // delta to 0 and let grid process the wheel event normally\n            Object.defineProperty(e, 'deltaY', { value: 0 });\n          } else {\n            // If there was verical delta only, skip the grid's wheel event processing to\n            // enable scrolling the page even if grid isn't scrolled to end\n            e.stopImmediatePropagation();\n          }\n        }));\n      };\n\n      const contextMenuListener = function(e) {\n        // For `contextmenu` events, we need to access the source event,\n        // when using open on click we just use the click event itself\n        const sourceEvent = e.detail.sourceEvent || e;\n        const eventContext = grid.getEventContext(sourceEvent);\n        const key = eventContext.item && eventContext.item.key;\n        const colId = eventContext.column && eventContext.column.id;\n        grid.$server.updateContextMenuTargetItem(key, colId);\n      };\n\n      grid.addEventListener('vaadin-context-menu-before-open', tryCatchWrapper(function(e) {\n        contextMenuListener(grid.$contextMenuConnector.openEvent);\n      }));\n\n      grid.getContextMenuBeforeOpenDetail = tryCatchWrapper(function(event) {\n        // For `contextmenu` events, we need to access the source event,\n        // when using open on click we just use the click event itself\n        const sourceEvent = event.detail.sourceEvent || event;\n        const eventContext = grid.getEventContext(sourceEvent);\n        return {\n          key: (eventContext.item && eventContext.item.key) || \"\"\n        };\n      });\n\n      grid.addEventListener('click', tryCatchWrapper(e => _fireClickEvent(e, 'item-click')));\n      grid.addEventListener('dblclick', tryCatchWrapper(e => _fireClickEvent(e, 'item-double-click')));\n\n      grid.addEventListener('column-resize', tryCatchWrapper(e => {\n        const cols = grid._getColumnsInOrder().filter(col => !col.hidden);\n\n        cols.forEach(col => {\n          col.dispatchEvent(new CustomEvent('column-drag-resize'));\n        });\n\n        grid.dispatchEvent(new CustomEvent('column-drag-resize', { detail: {\n          resizedColumnKey: e.detail.resizedColumn._flowId\n        }}));\n      }));\n\n      grid.addEventListener('column-reorder', tryCatchWrapper(e => {\n        const columns = grid._columnTree.slice(0).pop()\n          .filter(c => c._flowId)\n          .sort((b, a) => (b._order - a._order))\n          .map(c => c._flowId);\n\n        grid.dispatchEvent(new CustomEvent('column-reorder-all-columns', {\n          detail: { columns }\n        }));\n      }));\n\n      grid.addEventListener('cell-focus', tryCatchWrapper(e => {\n        const eventContext = grid.getEventContext(e);\n        const expectedSectionValues = ['header', 'body', 'footer'];\n\n        if(expectedSectionValues.indexOf(eventContext.section) === -1) {\n          return;\n        }\n\n        grid.dispatchEvent(new CustomEvent('grid-cell-focus', {\n          detail: {\n            itemKey: eventContext.item\n                ? eventContext.item.key\n                : null,\n\n            internalColumnId: eventContext.column\n                ? eventContext.column._flowId\n                : null,\n\n            section: eventContext.section\n          }\n        }));\n      }));\n\n      function _fireClickEvent(event, eventName) {\n        const target = event.target;\n        const eventContext = grid.getEventContext(event);\n        const section = eventContext.section;\n\n        if (eventContext.item && !isFocusable(target) && section !== 'details') {\n          event.itemKey = eventContext.item.key;\n          // if you have a details-renderer, getEventContext().column is undefined\n          if (eventContext.column) {\n            event.internalColumnId = eventContext.column._flowId;\n          }\n          grid.dispatchEvent(new CustomEvent(eventName,\n            { detail: event }));\n        }\n      }\n\n      grid.cellClassNameGenerator = tryCatchWrapper(function(column, rowData) {\n          const style = rowData.item.style;\n          if (!style) {\n            return;\n          }\n          return (style.row || '') + ' ' + ((column && style[column._flowId]) || '');\n      })\n\n      grid.dropFilter = tryCatchWrapper(rowData => !rowData.item.dropDisabled);\n\n      grid.dragFilter = tryCatchWrapper(rowData => !rowData.item.dragDisabled);\n\n      grid.addEventListener('grid-dragstart', tryCatchWrapper(e => {\n\n        if (grid._isSelected(e.detail.draggedItems[0])) {\n          // Dragging selected (possibly multiple) items\n          if (grid.__selectionDragData) {\n            Object.keys(grid.__selectionDragData).forEach(type => {\n              e.detail.setDragData(type, grid.__selectionDragData[type]);\n            });\n          } else {\n            (grid.__dragDataTypes || []).forEach(type => {\n              e.detail.setDragData(type, e.detail.draggedItems.map(item => item.dragData[type]).join('\\n'));\n            });\n          }\n\n          if (grid.__selectionDraggedItemsCount > 1) {\n            e.detail.setDraggedItemsCount(grid.__selectionDraggedItemsCount);\n          }\n        } else {\n          // Dragging just one (non-selected) item\n          (grid.__dragDataTypes || []).forEach(type => {\n            e.detail.setDragData(type, e.detail.draggedItems[0].dragData[type]);\n          });\n        }\n      }));\n    })(grid)\n  }\n})();\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA,AAAC,YAAY;AACX,QAAM,kBAAkB,SAAU,UAAU;AAC1C,WAAO,OAAO,OAAO,KAAK,gBAAgB,UAAU,aAAa;AAAA,EACnE;AAEA,MAAI,yBAAyB;AAE7B,SAAO,OAAO,KAAK,gBAAgB;AAAA,IACjC,UAAU,UAAQ,gBAAgB,SAAS,OAAM;AAE/C,UAAI,MAAK,YAAW;AAClB;AAAA,MACF;AAIA,UAAI,CAAC,wBAAwB;AAC3B,iCAAyB;AAGzB,kBAAU,UAAU,uCAAuC,UAAU,UAAU;AAC/E,kBAAU,UAAU,+BAA+B,gBAAgB,SAAS,aAAa;AACvF,cAAI,CAAC,KAAK,KAAK,YAAY;AACzB,iBAAK,qCAAqC,WAAW;AACrD;AAAA,UACF;AAEA,cAAI,CAAC,KAAK,WAAW,cAAc;AACjC,iBAAK,KAAK,WAAW,mCAAmC,MAAM,WAAW;AAAA,UAC3E;AAAA,QACF,CAAC;AAED,kBAAU,UAAU,oBAAoB,UAAU,UAAU;AAC5D,kBAAU,UAAU,YAAY,gBAAgB,WAAW;AACzD,cAAI,CAAC,KAAK,KAAK,YAAY;AACzB,mBAAO,KAAK,kBAAkB;AAAA,UAChC;AAEA,iBAAO,QAAQ,KAAK,KAAK,WAAW,uBAAuB,KAAK,OAAO,KAAK,KAAK,eAAe,EAAE,UAAU,OAAO,KAAK,KAAK,UAAU,EAAE,OAAO,WAAS;AACvJ,mBAAO,KAAK,WAAW,OAAO,UAAU;AAAA,UAC1C,CAAC,EAAE,EAAE;AAAA,QACP,CAAC;AAED,kBAAU,UAAU,iCAAiC,gBAAgB,SAAS,aAAa;AACzF,cAAI,CAAC,KAAK,WAAW,cAAc;AACjC,kBAAM,WAAW,IAAI,UAAU,UAAU,YAAY,KAAK,MAAM,MAAM,KAAK,MAAM,YAAY;AAC7F,qBAAS,gBAAgB,CAAC;AAC1B,gBAAG,CAAC,KAAK,eAAe;AACtB,mBAAK,gBAAgB,CAAC;AAAA,YACxB;AACA,iBAAK,WAAW,eAAe;AAC/B,iBAAK,cAAc,KAAK,KAAK,UAAU,SAAS,UAAU,KAAK;AAC/D,iBAAK,KAAK,UAAU,GAAG,QAAQ;AAAA,UACjC;AAAA,QACF,CAAC;AAED,kBAAU,UAAU,wBAAwB,gBAAgB,SAAS,KAAK;AACxE,mBAAS,SAAS,KAAK,OAAO;AAC5B,gBAAG,KAAK,KAAK,UAAU,KAAK,MAAM,MAAM,MAAM,KAAK;AACjD,qBAAO,EAAC,OAAO,MAAM,aAAa,MAAK;AAAA,YACzC;AAAA,UACF;AACA,gBAAM,OAAO,OAAO,KAAK,KAAK,aAAa;AAC3C,mBAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,kBAAM,cAAc,KAAK;AACzB,kBAAM,WAAW,KAAK,cAAc;AACpC,gBAAI,gBAAgB,SAAS,sBAAsB,GAAG;AACtD,gBAAG,eAAe;AAChB,qBAAO;AAAA,YACT;AAAA,UACF;AACA,iBAAO;AAAA,QACT,CAAC;AAED,kBAAU,UAAU,WAAW,gBAAgB,WAAW;AACxD,cAAI,SAAQ;AACZ,cAAI,QAAQ;AACZ,iBAAO,OAAM,aAAa;AACxB,qBAAQ,OAAM;AACd;AAAA,UACF;AACA,iBAAO;AAAA,QACT,CAAC;AAAA,MACH;AAEA,YAAM,oBAAoB,CAAC;AAC3B,YAAM,oBAAoB,CAAC;AAC3B,YAAM,QAAQ,CAAC;AAMf,YAAM,qBAAqB;AAC3B,YAAM,4BAA4B;AAElC,UAAI,qBAAqB,CAAC;AAC1B,UAAI;AACJ,UAAI,sBAAsB,CAAC;AAC3B,UAAI;AAEJ,YAAM,mBAAmB;AACzB,UAAI;AAEJ,UAAI,sBAAsB,CAAC;AAC3B,YAAM,OAAO;AACb,0BAAoB,QAAQ,CAAC,GAAG,CAAC;AAEjC,YAAM,sBAAsB,CAAC,UAAU,QAAQ,OAAO;AACtD,UAAI,eAAe,CAAC;AACpB,UAAI,gBAAgB;AAEpB,UAAI,gCAAgC;AAEpC,YAAK,OAAO;AACZ,YAAK,aAAa;AAElB,YAAK,aAAa,CAAC;AAEnB,YAAK,WAAW,yBAAyB,gBAAgB,MAAM,oBAAoB,SAAS,CAAC;AAE7F,YAAK,WAAW,wBAAwB,gBAAgB,MAAM,mBAAmB,SAAS,CAAC;AAE3F,YAAK,WAAW,sBAAsB,gBAAgB,MAAM;AAC1D,eAAO,OAAO,KAAK,iBAAiB,EAAE,SAAS,KAAM,wBAAwB,qBAAqB,SAAS;AAAA,MAC7G,CAAC;AAED,YAAK,WAAW,qCAAqC,gBAAgB,SAAS,aAAa,aAAa;AAEtG,4BAAoB,KAAK;AAAA,UACvB,OAAO;AAAA,UACP;AAAA,UACA,SAAS,MAAK,UAAU,YAAY,MAAM,YAAY;AAAA,UACtD,OAAO,YAAY,SAAS;AAAA,QAC9B,CAAC;AAED,4BAAoB,KAAK,SAAS,GAAG,GAAG;AACtC,iBAAO,EAAE,cAAc,EAAE,eAAe,EAAE,QAAQ,EAAE;AAAA,QACtD,CAAC;AAED,kCAA0B,UAAU,SAAS,yBAAyB,gBACpE,MAAM;AACJ,iBAAO,oBAAoB,QAAQ;AACjC,kBAAK,WAAW,oBAAoB;AAAA,UACtC;AAAA,QACF,CACF;AAAA,MACF,CAAC;AAED,YAAK,WAAW,cAAc,gBAAgB,SAAS,OAAO,gBAAgB;AAC5E,YAAI,kBAAkB,UAAU,CAAC,MAAM,UAClC,kBAAkB,MAAK,aAAa,UAAU,GAAI;AACrD;AAAA,QACF;AACA,YAAI,kBAAkB,UAAU;AAC9B,gBAAK,gBAAgB,CAAC;AACtB,yBAAe,CAAC;AAAA,QAClB;AAEA,cAAK,gBAAgB,MAAK,cAAc,OAAO,KAAK;AACpD,cAAM,QAAQ,UAAQ;AACpB,cAAI,MAAM;AACR,yBAAa,KAAK,OAAO;AACzB,gBAAI,gBAAgB;AAClB,mBAAK,WAAW;AAChB,oBAAK,QAAQ,OAAO,KAAK,GAAG;AAAA,YAC9B;AAAA,UACF;AACA,gBAAM,gCAAgC,CAAC,MAAK,cAAc,CAAC,QAAQ,KAAK,OAAO,MAAK,WAAW;AAC/F,cAAI,CAAC,kBAAkB,kBAAkB,YAAY,+BAA+B;AAClF,kBAAK,aAAa;AAAA,UACpB;AAAA,QACF,CAAC;AAAA,MACH,CAAC;AAED,YAAK,WAAW,gBAAgB,gBAAgB,SAAS,OAAO,gBAAgB;AAC9E,YAAI,kBAAkB,UAAU,CAAC,MAAM,UAClC,kBAAkB,MAAK,aAAa,UAAU,GAAI;AACrD;AAAA,QACF;AAEA,cAAM,uBAAuB,MAAK,cAAc,MAAM;AACtD,eAAO,MAAM,QAAQ;AACnB,gBAAM,iBAAiB,MAAM,MAAM;AACnC,mBAAS,IAAI,GAAG,IAAI,qBAAqB,QAAQ,KAAK;AACpD,kBAAM,eAAe,qBAAqB;AAC1C,gBAAI,kBAAkB,eAAe,QAAQ,aAAa,KAAK;AAC7D,mCAAqB,OAAO,GAAG,CAAC;AAChC;AAAA,YACF;AAAA,UACF;AACA,cAAI,gBAAgB;AAClB,mBAAO,aAAa,eAAe;AACnC,gBAAI,gBAAgB;AAClB,qBAAO,eAAe;AACtB,oBAAK,QAAQ,SAAS,eAAe,GAAG;AAAA,YAC1C;AAAA,UACF;AAAA,QACF;AACA,cAAK,gBAAgB;AAAA,MACvB,CAAC;AAED,YAAK,sBAAsB,gBAAgB,SAAS,QAAQ,QAAQ;AAClE,YAAI,iBAAiB,UAAU;AAC7B;AAAA,QACF;AACA,YAAI,CAAC,QAAQ;AACX,cAAI,UAAU,aAAa,OAAO,MAAM;AACtC,gBAAI,MAAK,sBAAsB;AAC7B,oBAAK,aAAa;AAAA,YACpB,OAAO;AACL,oBAAK,WAAW,cAAc,CAAC,MAAM,GAAG,IAAI;AAAA,YAC9C;AAAA,UACF;AAAA,QACF,WAAW,CAAC,aAAa,OAAO,MAAM;AACpC,gBAAK,WAAW,YAAY,CAAC,MAAM,GAAG,IAAI;AAAA,QAC5C;AAAA,MACF,CAAC;AACD,YAAK,wBAAwB,cAAc,uBAAuB,IAAI;AAEtE,YAAK,6BAA6B,gBAAgB,SAAS,QAAQ,QAAQ;AACzE,YAAI,MAAK,0BAA0B;AACjC;AAAA,QACF;AAGA,YAAK,UAAU,QAAU,WAAW,QAAY;AAC9C;AAAA,QACF;AACA,YAAI,UAAU,CAAC,OAAO,eAAe;AACnC,gBAAK,QAAQ,kBAAkB,OAAO,GAAG;AAAA,QAC3C,OAAO;AACL,gBAAK,QAAQ,kBAAkB,IAAI;AAAA,QACrC;AAAA,MACF,CAAC;AACD,YAAK,wBAAwB,cAAc,8BAA8B,IAAI;AAE7E,YAAK,WAAW,sBAAsB,gBAAgB,SAAS,WAAW,OAAO,aAAa;AAC5F,YAAI,gBAAgB,MAAK,OAAO,iBAAiB,KAAK;AACtD,YAAI,aAAa,cAAc,MAAM;AACrC,YAAI,mBAAoB,aAAc,MAAK,UAAU,UAAU,IAAI;AACnE,YAAG,cAAc,kBAAkB;AACjC,iBAAO;AAAA,QACT,OAAO;AACL,iBAAO,MAAK,iBAAiB,cAAc,WAAW;AAAA,QACxD;AAAA,MACF,CAAC;AAED,YAAK,WAAW,gBAAgB,gBAAgB,SAAS,KAAK;AAC5D,YAAI,gBAAgB,MAAK,OAAO,sBAAsB,GAAG;AACzD,YAAG,eAAe;AAChB,iBAAO,cAAc;AAAA,QACvB;AACA,eAAO;AAAA,MACT,CAAC;AAED,YAAK,WAAW,sBAAsB,gBAAgB,WAAW;AAC/D,YAAI,eAAe,oBAAoB,OAAO,GAAG,CAAC,EAAE;AACpD,YAAI,UAAW,aAAa;AAE5B,cAAM,cAAc,MAAK,gBAAgB;AACzC,YAAI,QAAQ,YAAY,GAAG;AAC3B,YAAI,MAAM,YAAY,YAAY,SAAS,GAAG;AAE9C,YAAI,SAAS,MAAM;AACnB,YAAI,mBAAmB,KAAK,IAAI,GAAG,QAAQ,MAAM;AACjD,YAAI,kBAAkB,KAAK,IAAI,MAAM,QAAQ,MAAK,cAAc;AAGhE,iBAAQ,QAAQ,kBAAkB,SAAS,iBAAiB,SAAS;AACnE,cAAI,OAAO,MAAK,OAAO,gBAAgB,KAAK;AAE5C,cAAG,MAAK,UAAU,IAAI,MAAM,SAAS;AACnC,gBAAG,MAAK,YAAY,IAAI,GAAG;AACzB,2BAAa,MAAM,+BAA+B,aAAa,WAAW;AAC1E,qBAAO;AAAA,YACT,OAAO;AACL;AAAA,YACF;AAAA,UACF;AAAA,QACF;AACA,eAAO;AAAA,MACT,CAAC;AAED,YAAK,WAAW,sBAAsB,gBAAgB,WAAW;AAC/D,YAAI,iBAAiB,mBAAmB,OAAO,GAAG,yBAAyB;AAE3E,YAAG,eAAe,QAAQ;AACxB,gBAAK,QAAQ,yBAAyB,cAAc;AACpD,iBAAO;AAAA,QACT;AACA,eAAO;AAAA,MACT,CAAC;AAED,YAAK,WAAW,sBAAsB,gBAAgB,SAAS,YAAY,MAAM,WAAW;AAE1F,2BAAmB,KAAK;AAAA,UACtB;AAAA,UACA;AAAA,UACA;AAAA,QACF,CAAC;AAED,iCAAyB,UAAU,SAAS,wBAAwB,QAAQ,MAAM,kBAAkB,GAClG,MAAM;AACJ,iBAAO,mBAAmB,QAAQ;AAChC,kBAAK,WAAW,oBAAoB;AAAA,UACtC;AAAA,QACF,CACF;AAAA,MACF,CAAC;AAED,YAAK,WAAW,YAAY,gBAAgB,SAAS,OAAO,MAAM,WAAW;AAO3E,cAAM,cAAc,MAAK,gBAAgB;AACzC,YAAI,QAAQ,YAAY,SAAS,IAAI,YAAY,GAAG,QAAQ;AAC5D,YAAI,MAAM,YAAY,SAAS,IAAI,YAAY,YAAY,SAAS,GAAG,QAAQ;AAC/E,YAAI,SAAS,MAAM;AAEnB,YAAI,mBAAmB,KAAK,IAAI,GAAG,QAAQ,MAAM;AACjD,YAAI,kBAAkB,KAAK,IAAI,MAAM,QAAQ,MAAK,cAAc;AAEhE,YAAI,kBAAkB;AACtB,YAAI,iBAAiB;AACrB,iBAAQ,MAAM,kBAAkB,OAAO,iBAAiB,OAAO;AAC7D,4BAAkB,KAAK,IAAI,iBAAiB,MAAK,WAAW,oBAAoB,WAAW,KAAK,eAAe,CAAC;AAChH,2BAAiB,KAAK,IAAI,gBAAgB,MAAK,WAAW,oBAAoB,WAAW,KAAK,cAAc,CAAC;AAAA,QAC/G;AAEA,YAAI,YAAY,KAAK,IAAI,GAAI,eAAe;AAC5C,YAAI,WAAY,cAAc,OAAQ,iBAAgB,KAAK,IAAI,gBAAgB,KAAK,MAAM,MAAK,OAAO,MAAK,QAAQ,CAAC;AACpH,YAAI,qBAAqB,oBAAoB;AAC7C,YAAG,CAAC,oBAAoB;AACtB,+BAAqB,CAAC,IAAI,EAAE;AAAA,QAC9B;AACA,YAAI,mBAAmB,MAAM,aAAa,mBAAmB,MAAM,UAAU;AAC3E,+BAAqB,CAAC,WAAW,QAAQ;AACzC,8BAAoB,aAAa;AACjC,cAAI,QAAQ,WAAW,YAAY;AACnC,gBAAM,YAAY,MAAK,UAAU,QAAQ,MAAK,QAAQ;AAAA,QACxD;AAAA,MACF,CAAC;AAED,YAAK,eAAe,gBAAgB,SAAS,QAAQ,UAAU;AAC7D,YAAI,OAAO,YAAY,MAAK,UAAU;AACpC,gBAAM;AAAA,QACR;AAEA,YAAI,OAAO,OAAO;AAElB,YAAG,OAAO,YAAY;AACpB,cAAI,kBAAkB,MAAK,UAAU,OAAO,UAAU;AACtD,cAAG,CAAC,kBAAkB,kBAAkB;AACtC,8BAAkB,mBAAmB,CAAC;AAAA,UACxC;AAEA,cAAI,cAAc,MAAK,WAAW,cAAc,eAAe;AAC/D,cAAI,YAAa,eAAe,YAAY,gBAAiB,YAAY,cAAc,mBAAmB;AAC1G,cAAG,MAAM,oBAAoB,MAAM,iBAAiB,SAAS,WAAW;AAEtE,mBAAO,KAAK,IAAI,MAAM,KAAK,MAAM,MAAM,iBAAiB,OAAO,MAAK,QAAQ,CAAC;AAE7E,qBAAS,MAAM,iBAAiB,OAAO,MAAM,iBAAiB,IAAI;AAAA,UACpE,OAAO;AACL,8BAAkB,iBAAiB,QAAQ;AAAA,UAC7C;AACA,gBAAK,WAAW,UACd,CAAC,YAAY,SAAS,MAAK,WAAW,oBAAoB,YAAY,MAAM,OAAO,WAAW,GAAG,GACjG,MACA,eACF;AAAA,QAEF,OAAO;AAEL,iBAAO,KAAK,IAAI,MAAM,KAAK,MAAM,MAAK,OAAO,MAAK,QAAQ,CAAC;AAE3D,cAAI,MAAM,SAAS,MAAM,MAAM,OAAO;AACpC,qBAAS,MAAM,MAAM,KAAK;AAAA,UAC5B,OAAO;AACL,8BAAkB,QAAQ;AAAA,UAC5B;AAEA,iCAAuB,UAAU,SAAS,sBAAsB,QAAQ,MAAM,MAAK,WAAW,mBAAmB,CAAC,GAChH,MAAM;AACJ,kBAAK,WAAW,UAAU,CAAC,YAAY,SAAS,MAAK,QAAQ,kBAAkB,YAAY,IAAI,GAAG,MAAM,IAAI;AAAA,UAC9G,CACF;AAAA,QACF;AAAA,MACF,CAAC;AAED,YAAM,uBAAuB,gBAAgB,SAAS,GAAG,UAAU;AACjE,YAAI,aAAa,UAAa,CAAC,+BAA+B;AAC5D,gBAAK,QAAQ,eAAe,MAAK,SAAS,IAAI,SAAU,QAAQ;AAC9D,mBAAO;AAAA,cACL,MAAM,OAAO;AAAA,cACb,WAAW,OAAO;AAAA,YACpB;AAAA,UACF,CAAC,CAAC;AAAA,QACJ;AAAA,MACF,CAAC;AAED,YAAK,WAAW,sBAAsB,gBAAgB,SAAS,YAAY;AACzE,wCAAgC;AAChC,mBAAW,gBAAgB,MAAM;AAC/B,cAAI;AACF,kBAAM,UAAU,MAAM,KAAK,MAAK,iBAAiB,oBAAoB,CAAC;AAEtE,oBAAQ,QAAQ,YAAU;AACxB,kBAAI,CAAC,WAAW,OAAO,OAAK,EAAE,WAAW,OAAO,aAAa,MAAM,CAAC,EAAE,IAAI;AACxE,uBAAO,YAAY;AAAA,cACrB;AAAA,YACF,CAAC;AAED,uBAAW,QAAQ,EAAE,QAAQ,CAAC,EAAC,QAAQ,gBAAe;AACpD,sBAAQ,QAAQ,YAAU;AACxB,oBAAI,OAAO,aAAa,MAAM,MAAM,UAAU,OAAO,cAAc,WAAW;AAC5E,yBAAO,YAAY;AAAA,gBACrB;AAAA,cACF,CAAC;AAAA,YACH,CAAC;AAAA,UACH,UAAE;AACA,4CAAgC;AAAA,UAClC;AAAA,QACF,CAAC,CAAC;AAAA,MACJ,CAAC;AACD,YAAK,wBAAwB,oBAAoB,oBAAoB;AAErE,YAAK,cAAc,gBAAgB,SAAS,KAAK,MAAM;AACrD,aAAK,UAAU,YAAY,KAAK,OAAM,KAAK,IAAI;AAK/C,YAAI,CAAC,IAAI,QAAQ;AAEf,gBAAM,KAAK,IAAI,QAAQ,EAAE,QAAQ,UAAQ;AACvC,gBAAI,KAAK,YAAY,KAAK,SAAS,sBAAsB,KAAK,SAAS,mBAAmB,UAAU;AAClG,oBAAM,KAAK,KAAK,SAAS,mBAAmB,QAAQ,EAAE,QAAQ,aAAW;AACvE,oBAAG,QAAQ,gCAAgC;AACzC,0BAAQ,+BAA+B;AAAA,gBACzC;AAGA,oBAAI,QAAQ,UAAU;AACpB,wBAAM,KAAK,QAAQ,QAAQ,EAAE,QAAQ,kBAAgB;AACnD,wBAAG,aAAa,gCAAgC;AAC5C,mCAAa,+BAA+B;AAAA,oBAChD;AAAA,kBACF,CAAC;AAAA,gBACH;AAAA,cACH,CAAC;AAAA,YACF;AAAA,UACF,CAAC;AAAA,QACH;AAGA,YAAI,kBAAkB,oBAAoB,IAAI;AAC5C,cAAI,gBAAgB,eAAe;AACnC,gBAAM,KAAK,IAAI,QAAQ,EAAE,QAAQ,UAAQ,KAAK,gBAAgB,eAAe,CAAC;AAAA,QAChF;AAAA,MACF,CAAC;AAED,YAAM,sBAAsB,gBAAgB,SAAS,MAAM,UAAU;AAEnE,YAAI,QAAQ,UAAa,MAAK,QAAQ,uBAAuB,QAAW;AACtE;AAAA,QACF;AACA,YAAI,YAAY,MAAK,UAAU,IAAI;AACnC,cAAK,QAAQ,oBAAoB,WAAW,QAAQ;AAEpD,YAAI,CAAC,UAAU;AACb,iBAAO,MAAM;AACb,cAAI,cAAc,MAAK,WAAW,cAAc,SAAS;AACzD,cAAI,eAAe,YAAY,iBAAiB,YAAY,cAAc,YAAY;AACpF,mBAAO,YAAY,cAAc;AAAA,UACnC;AACA,cAAI,eAAe,YAAY,eAAe;AAC5C,mBAAO,KAAK,YAAY,UAAU,EAC7B,OAAO,SAAO,YAAY,MAAM,KAAK,QAAQ,SAAS,EACtD,QAAQ,SAAO,OAAO,YAAY,WAAW,IAAI;AAAA,UACxD;AACA,iBAAO,oBAAoB;AAAA,QAC7B;AAAA,MACF,CAAC;AAID,YAAK,aAAa,gBAAgB,SAAS,MAAM;AAC/C,4BAAoB,MAAM,IAAI;AAC9B,aAAK,UAAU,WAAW,KAAK,OAAM,IAAI;AAAA,MAC3C,CAAC;AAED,YAAK,eAAe,gBAAgB,SAAS,MAAM;AACjD,4BAAoB,MAAM,KAAK;AAC/B,aAAK,UAAU,aAAa,KAAK,OAAM,IAAI;AAAA,MAC7C,CAAC;AAED,YAAM,eAAe,SAAS,OAAO;AACnC,YAAI,CAAC,SAAS,CAAC,MAAM,QAAQ,KAAK,GAAG;AACnC,gBAAM,2DAA2D,KAAK,UAAU,KAAK;AAAA,QACvF;AACA,YAAI,qBAAqB,MAAM,KAAK,MAAK,kBAAkB;AAC3D,YAAI,sBAAsB;AAC1B,iBAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,EAAE,GAAG;AACrC,gBAAM,OAAO,MAAM;AACnB,cAAG,CAAC,MAAM;AACR;AAAA,UACF;AACA,cAAI,KAAK,eAAe;AACtB,gBAAG,MAAK,qBAAqB,MAAM,kBAAkB,IAAI,GAAG;AAC1D,iCAAmB,KAAK,IAAI;AAAA,YAC9B;AAAA,UACF,WAAU,MAAK,qBAAqB,MAAM,kBAAkB,KAAK,GAAG;AAClE,+BAAmB,OAAO,MAAK,qBAAqB,MAAM,kBAAkB,GAAG,CAAC;AAAA,UAClF;AACA,cAAI,aAAa,KAAK,MAAM;AAC1B,yBAAa,KAAK,OAAO;AACzB,iBAAK,WAAW;AAChB,kCAAsB;AAAA,UACxB;AAAA,QACF;AACA,cAAK,qBAAqB;AAC1B,YAAI,qBAAqB;AAEvB,gBAAK,gBAAgB,OAAO,KAAK,YAAY,EAAE,IAAI,SAAS,GAAG;AAC7D,mBAAO,aAAa;AAAA,UACtB,CAAC;AAAA,QACH;AAAA,MACF;AASA,YAAM,kBAAkB,SAAS,MAAM,WAAW;AAChD,YAAI;AACJ,YAAI,cAAa,UAAU,MAAM;AAC/B,kBAAQ,MAAM,WAAW;AACzB,cAAI,cAAc,MAAK,WAAW,cAAc,SAAS;AACzD,cAAG,eAAe,YAAY,eAAe;AAC3C,gBAAI,SAAS,YAAY,cAAc;AACvC,kBAAM,wBAAwB,kBAAkB;AAChD,kBAAM,WAAW,yBAAyB,sBAAsB;AAChE,6BAAiB,MAAM,OAAO,UAAU,MAAM;AAAA,UAChD;AAAA,QAEF,OAAO;AACL,kBAAQ,MAAM,MAAM;AACpB,2BAAiB,MAAM,OAAO,kBAAkB,OAAO,MAAK,MAAM;AAAA,QACpE;AACA,eAAO;AAAA,MACT;AAEA,YAAM,mBAAmB,SAAS,MAAM,OAAO,UAAU,YAAY;AAEnE,YAAI,CAAC,UAAU;AACb,cAAI,aAAa,OAAO,MAAK;AAC7B,cAAI,WAAW,aAAa,MAAK;AACjC,cAAI,CAAC,OAAO;AACV,gBAAI,cAAc,WAAW,OAAO;AAClC,uBAAS,MAAM,YAAY,MAAM,UAAU,OAAO;AAChD,uBAAO,WAAW,MAAM;AAAA,cAC1B;AAAA,YACF;AAAA,UACF,OAAO;AACL,gBAAI,cAAc,WAAW,OAAO;AAClC,uBAAS,MAAM,YAAY,MAAM,UAAU,OAAO;AAChD,oBAAI,WAAW,MAAM,MAAM;AACzB,6BAAW,MAAM,OAAO,MAAM,MAAM;AAAA,gBACtC;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAKA,YAAM,qCAAqC,WAAY;AACrD,cAAK,OAAO,WAAW;AACvB,cAAK,iBAAiB,MAAK,OAAO;AAClC,cAAK,oBAAoB;AAAA,MAC3B;AAOA,YAAM,mCAAmC,SAAS,OAAO;AACvD,YAAI,CAAC,SAAS,CAAC,MAAK,KAAK,MAAK,EAAE,MAAM,sBAAsB,GAAG;AAC7D;AAAA,QACF;AAEA,cAAM,WAAW,MAAM,IAAI,UAAQ,KAAK,GAAG;AAC3C,cAAM,UAAU,MAAK,gBAAgB,EAChC,OAAO,SAAO,IAAI,SAAS,SAAS,SAAS,IAAI,MAAM,GAAG,CAAC,EAC3D,IAAI,SAAO,IAAI,KAAK;AACzB,YAAI,QAAQ,SAAS,GAAG;AACtB,gBAAK,oBAAoB,QAAQ,IAAI,QAAQ,QAAQ,SAAS,EAAE;AAAA,QAClE;AAAA,MACF;AAEA,YAAK,WAAW,MAAM,gBAAgB,SAAS,OAAO,OAAO,WAAW;AACtE,YAAI,QAAQ,MAAK,YAAY,GAAG;AAC9B,gBAAM,2BAA2B,QAAQ,iDAAiD,MAAK;AAAA,QACjG;AACA,YAAI,OAAO,aAAa;AAExB,cAAM,YAAY,QAAQ,MAAK;AAC/B,cAAM,mBAAmB,KAAK,KAAK,MAAM,SAAS,MAAK,QAAQ;AAE/D,iBAAS,IAAI,GAAG,IAAI,kBAAkB,KAAK;AACzC,cAAI,OAAO,YAAY;AACvB,cAAI,QAAQ,MAAM,MAAM,IAAI,MAAK,UAAW,KAAI,KAAK,MAAK,QAAQ;AAClE,cAAG,CAAC,MAAM,OAAO;AACf,kBAAM,QAAQ,CAAC;AAAA,UACjB;AACA,gBAAM,MAAM,QAAQ;AAEpB,gBAAK,WAAW,YAAY,MAAM,OAChC,UAAQ,KAAK,YAAY,CAAC,iBAAiB,IAAI,CAAC,CAAC;AACnD,gBAAK,WAAW,cAAc,MAAM,OAClC,UAAQ,CAAC,KAAK,YAAc,cAAa,KAAK,QAAQ,iBAAiB,IAAI,EAAE,CAAC;AAEhF,gBAAM,eAAe,gBAAgB,MAAM,IAAI;AAC/C,cAAI,cAAc;AAChB,yBAAa,YAAY;AACzB,6CAAiC,YAAY;AAAA,UAC/C;AAAA,QACF;AAAA,MACF,CAAC;AAED,YAAM,sBAAsB,SAAS,MAAM;AACzC,YAAI,SAAS,KAAK,mBAAmB;AACrC,YAAG,MAAM,SAAS;AAChB,mBAAS,QAAQ,MAAM,SAAS;AAC9B,qBAAS,SAAS,MAAM,QAAQ,OAAO;AACrC,kBAAI,MAAK,UAAU,MAAM,QAAQ,MAAM,MAAM,MAAM,MAAK,UAAU,IAAI,GAAG;AACvE,uBAAO,EAAC,MAAY,OAAc,WAAW,OAAM;AAAA,cACrD;AAAA,YACF;AAAA,UACF;AAAA,QACF;AACA,eAAO;AAAA,MACT;AAOA,YAAK,WAAW,yBAAyB,gBAAgB,SAAS,cAAc;AAC9E,YAAI,gBAAgB,CAAC;AAGrB,iBAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC5C,cAAI,gBAAgB,oBAAoB,aAAa,EAAE;AACvD,cAAI,eAAe;AACjB,kBAAM,cAAc,WAAW,cAAc,MAAM,cAAc,SAAS,aAAa;AACvF,gBAAI,MAAM,cAAc,YAAU,MAAI,cAAc;AACpD,gBAAI,CAAC,cAAc,MAAM;AACvB,4BAAc,OAAO,EAAC,WAAW,cAAc,WAAW,MAAM,cAAc,KAAI;AAAA,YACpF;AAAA,UACF;AAAA,QACF;AAEA,YAAI,OAAO,OAAO,KAAK,aAAa;AACpC,iBAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,cAAI,eAAe,cAAc,KAAK;AACtC,gBAAM,uBAAuB,gBAAgB,aAAa,MAAM,aAAa,SAAS;AACtF,cAAI,sBAAsB;AACxB,yBAAa,oBAAoB;AACjC,6CAAiC,oBAAoB;AAAA,UACvD;AAAA,QACF;AAAA,MACF,CAAC;AAOD,YAAK,WAAW,iBAAiB,gBAAgB,SAAS,cAAc;AAEtE,iBAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC5C,cAAI,gBAAgB,oBAAoB,aAAa,EAAE;AACvD,cAAI,eAAe;AAEjB,kBAAM,cAAc,WAAW,cAAc,MAAM,cAAc,SAAS,aAAa;AAGvF,kBAAM,QAAQ,SAAS,cAAc,IAAI,IAAI,MAAK,WAAW,SAAS,cAAc,KAAK;AACzF,gBAAI,MAAK,OAAO,MAAM,QAAQ;AAC5B,oBAAK,OAAO,MAAM,SAAS,aAAa;AAAA,YAC1C;AAAA,UACF;AAAA,QACF;AACA,qBAAa,YAAY;AAEzB,yCAAiC,YAAY;AAAA,MAC/C,CAAC;AAED,YAAK,WAAW,gBAAgB,gBAAgB,WAAW;AACzD,cAAK,gBAAgB,CAAC;AACtB,8BAAsB,CAAC;AACvB,6BAAqB,CAAC;AAAA,MACxB,CAAC;AAED,YAAK,WAAW,QAAQ,gBAAgB,SAAS,OAAO,QAAQ,WAAW;AACzE,YAAI,OAAO,aAAa;AACxB,YAAI,CAAC,MAAM,SAAS,OAAO,KAAK,MAAM,KAAK,EAAE,WAAW,GAAE;AACxD;AAAA,QACF;AACA,YAAI,QAAQ,MAAK,YAAY,GAAG;AAC9B,gBAAM,gCAAgC,QAAQ,iDAAiD,MAAK;AAAA,QACtG;AAEA,YAAI,YAAY,KAAK,MAAM,QAAQ,MAAK,QAAQ;AAChD,YAAI,mBAAmB,KAAK,KAAK,SAAS,MAAK,QAAQ;AAEvD,iBAAS,IAAI,GAAG,IAAI,kBAAkB,KAAK;AACzC,cAAI,OAAO,YAAY;AACvB,cAAI,QAAQ,MAAM,MAAM;AACxB,gBAAK,WAAW,cAAc,MAAM,OAAO,UAAQ,aAAa,KAAK,IAAI,CAAC;AAC1E,iBAAO,MAAM,MAAM;AACnB,gBAAM,eAAe,gBAAgB,MAAM,SAAS;AACpD,cAAI,cAAc;AAChB,yBAAa,YAAY;AAAA,UAC3B;AACA,2CAAiC,KAAK;AAAA,QACxC;AACA,YAAI,eAAe,MAAK;AACxB,YAAG,WAAY;AACb,gBAAM,gBAAgB,MAAK,OAAO,sBAAsB,IAAI;AAC5D,yBAAe,cAAc,MAAM,WAAW,cAAc;AAAA,QAC9D;AACA,cAAM,WAAW,QAAQ,mBAAmB,MAAK;AACjD,iBAAQ,YAAY,OAAO,YAAY,UAAU,aAAa;AAC5D,iBAAO,aAAa,MAAM;AAC1B,gBAAM,kBAAkB,aAAa,WAAW;AAChD,iBAAO,aAAa,WAAW;AAC/B,gBAAM,kBAAkB,mBAAmB,gBAAgB,WAAW;AACtE,cAAG,iBAAiB;AAClB,mBAAO,aAAa,cAAc;AAAA,UACpC;AAAA,QACF;AACA,cAAK,OAAO,WAAW;AAAA,MACzB,CAAC;AAED,YAAM,mBAAmB,SAAS,MAAM;AACtC,cAAM,gBAAgB,MAAK;AAC3B,iBAAQ,IAAI,GAAG,IAAI,eAAe,KAAK;AACrC,cAAI,eAAe,cAAc;AACjC,cAAI,aAAa,QAAQ,KAAK,KAAK;AACjC,mBAAO;AAAA,UACT;AAAA,QACF;AACA,eAAO;AAAA,MACT;AAEA,YAAK,WAAW,QAAQ,gBAAgB,WAAW;AACjD,cAAK,OAAO;AACZ,6BAAqB,KAAK;AAC1B,6BAAqB,MAAK,OAAO,KAAK;AACtC,6BAAqB,mBAAmB;AACxC,YAAG,yBAAyB;AAC1B,kCAAwB,OAAO;AAAA,QACjC;AACA,YAAG,wBAAwB;AACzB,iCAAuB,OAAO;AAAA,QAChC;AACA,YAAI,sBAAsB;AACxB,+BAAqB,OAAO;AAAA,QAC9B;AACA,kCAA0B;AAC1B,iCAAyB;AACzB,8BAAsB,CAAC;AACvB,6BAAqB,CAAC;AACtB,2CAAmC;AAAA,MACrC,CAAC;AAED,YAAM,uBAAuB,SAAO,OAAO,KAAK,GAAG,EAAE,QAAQ,SAAO,OAAO,IAAI,IAAI;AAEnF,YAAK,WAAW,aAAa,aAAW,MAAK,OAAO;AAEpD,YAAK,WAAW,yBAAyB,UAAQ,MAAK,aAAa;AAEnE,YAAK,WAAW,cAAc,gBAAgB,SAAS,OAAO;AAC5D,YAAI,mBAAmB,MAAM,KAAK,MAAK,aAAa;AACpD,cAAM,OAAO,UAAQ,CAAC,MAAK,YAAY,IAAI,CAAC,EACzC,QAAQ,UACP,iBAAiB,KAAK,IAAI,CAAC;AAC/B,cAAK,gBAAgB;AAAA,MACvB,CAAC;AAED,YAAK,WAAW,gBAAgB,gBAAgB,SAAS,OAAO;AAC9D,YAAI,mBAAmB,MAAM,KAAK,MAAK,aAAa;AACpD,cAAM,QAAQ,UAAQ;AACpB,cAAI,QAAQ,MAAK,qBAAqB,MAAM,gBAAgB;AAC5D,cAAG,SAAS,GAAG;AACb,6BAAiB,OAAO,OAAO,CAAC;AAAA,UAClC;AAAA,QACF,CAAC;AACD,cAAK,gBAAgB;AACrB,cAAM,QAAQ,UAAQ,MAAK,WAAW,gBAAgB,IAAI,CAAC;AAAA,MAC7D,CAAC;AAED,YAAK,WAAW,kBAAkB,gBAAgB,SAAS,MAAM;AAC/D,YAAI,SAAS,MAAK,UAAU,IAAI;AAChC,eAAO,kBAAkB;AACzB,cAAK,WAAW,gBAAgB,qBAAqB,WAAQ,MAAK,YAAY,MAAM;AACpF,cAAK,WAAW,gBAAgB,oBAAoB,WAAQ,MAAK,cAAc,MAAM;AAAA,MACvF,CAAC;AAED,YAAK,WAAW,kBAAkB,gBAAgB,SAAS,OAAO,YAAY;AAC5E,YAAG,MAAM,QAAQ;AACf,mBAAQ,QAAQ,MAAM,SAAS,GAAG,WAAW;AAC3C,gBAAI,WAAW,MAAM,MAAM,GAAG;AAC5B,oBAAM,OAAO,OAAO,CAAC;AAAA,YACvB;AAAA,UACF;AAAA,QACF;AAAA,MACF,CAAC;AAED,YAAK,WAAW,gBAAgB,gBAAgB,SAAS,IAAI,WAAW,WAAW;AACjF,YAAG,CAAC,kBAAkB,YAAY;AAChC;AAAA,QACF;AACA,YAAG,MAAM,YAAY;AACnB,gBAAM,WAAW,OAAO;AAAA,QAC1B;AACA,YAAI,sBAAsB,OAAO,oBAAoB,kBAAkB,UAAU;AACjF,iBAAQ,IAAI,GAAG,IAAI,oBAAoB,QAAQ,KAAK;AAClD,cAAI,OAAO,oBAAoB;AAE/B,cAAI,qBAAqB,oBAAoB,cAAc,CAAC,GAAG,CAAC;AAEhE,gBAAM,WAAW,kBAAkB,WAAW;AAC9C,cAAI,MAAM,cAAc,MAAM,WAAW,SAAU,OAAO,mBAAmB,MAAM,OAAO,mBAAmB,IAAI;AAC/G,mBAAO,kBAAkB,WAAW;AACpC,gBAAI,QAAQ,MAAM,WAAW,SAAS,IAAI,MAAM,SAAS;AACzD,qBAAS,OAAO,SAAS;AAAA,UAC3B,WAAW,YAAY,cAAc,GAAG;AAEtC,mBAAO,kBAAkB,WAAW;AACpC,qBAAS,CAAC,GAAG,SAAS;AAAA,UACxB;AAAA,QACF;AAEA,cAAK,QAAQ,oBAAoB,IAAI,SAAS;AAE9C,YAAI,CAAC,MAAK,SAAS;AACjB,gBAAK,oBAAoB;AAAA,QAC3B;AAAA,MACF,CAAC;AAED,YAAK,WAAW,UAAU,gBAAgB,SAAS,IAAI;AAGrD,YAAI,sBAAsB,OAAO,oBAAoB,iBAAiB;AACtE,iBAAQ,IAAI,GAAG,IAAI,oBAAoB,QAAQ,KAAK;AAClD,cAAI,OAAO,oBAAoB;AAC/B,cAAI,qBAAqB,oBAAoB,SAAS,CAAC,GAAG,CAAC;AAE3D,gBAAM,oBAAoB,MAAK,OAAO,KAAK,KAAK,MAAK,OAAO,MAAK,QAAQ,IAAI,IAAI;AAEjF,gBAAM,wBAAwB,KAAK,IAAI,mBAAmB,IAAI,iBAAiB;AAE/E,gBAAM,WAAW,kBAAkB;AACnC,cAAK,MAAM,SAAS,MAAM,MAAM,SAAU,OAAO,mBAAmB,MAAM,CAAC,OAAO,uBAAuB;AACvG,mBAAO,kBAAkB;AAEzB,gBAAI,MAAM,MAAM,OAAO;AAErB,uBAAS,MAAM,MAAM,KAAK;AAAA,YAC5B,OAAO;AAEL,uBAAS,IAAI,MAAM,MAAK,QAAQ,CAAC;AAEjC,oBAAK,qBAAqB;AAAA,YAC5B;AAIA,gBAAG,MAAK,uBAAsB;AAC5B,oBAAK,sBAAsB,MAAM;AAAA,YACnC;AAAA,UAEF,WAAW,YAAY,MAAK,SAAS,GAAG;AAEtC,mBAAO,kBAAkB;AACzB,qBAAS,CAAC,CAAC;AAAA,UACb;AAAA,QACF;AAGA,cAAK,QAAQ,cAAc,EAAE;AAAA,MAC/B,CAAC;AAED,YAAK,WAAW,kBAAkB,gBAAgB,WAAW;AAC3D,iBAAS,aAAa,OAAO;AAC3B,cAAG,cAAc,MAAM;AACrB,mBAAO,MAAM;AAAA,UACf;AAAA,QACF;AACA,6BAAqB,mBAAmB;AAExC,cAAK,OAAO,aAAa,CAAC;AAC1B,cAAK,OAAO,gBAAgB,CAAC;AAE7B,2CAAmC;AAAA,MACrC,CAAC;AAED,YAAK,WAAW,mBAAmB,gBAAgB,SAAS,MAAM;AAChE,YAAK,QAAO,SAAS,YAAY,gBAAgB,WAC1C,oBAAoB,QAAQ,IAAI,KAAK,GAAG;AAC7C,0BAAgB;AAChB,yBAAe,CAAC;AAChB,gBAAK,WAAW,sBAAsB;AAAA,QACxC,OAAO;AACL,gBAAM;AAAA,QACR;AAAA,MACF,CAAC;AAQD,YAAK,WAAW,wBAAwB,gBAAgB,WAAW;AACjE,YAAI,CAAC,MAAK,GAAG;AACX;AAAA,QACF;AAEA,YAAI,kBAAkB,oBAAoB,IAAI;AAC5C,gBAAK,EAAE,MAAM,aAAa,wBAAwB,KAAK;AAAA,QAEzD,WAAW,kBAAkB,oBAAoB,IAAI;AACnD,gBAAK,EAAE,MAAM,gBAAgB,sBAAsB;AAAA,QAErD,OAAO;AACL,gBAAK,EAAE,MAAM,aAAa,wBAAwB,IAAI;AAAA,QACxD;AAAA,MACF,CAAC;AAGD,YAAK,wBAAwB,cAAc,MAAM,MAAK,WAAW,sBAAsB,CAAC;AAGxF,YAAK,WAAW,8BAA8B,gBAAgB,SAAS,SAAS;AAE9E,oCAA4B,MAAK,EAAE,OAAO,OAAO;AAAA,MACnD,CAAC;AAED,YAAM,8BAA8B,SAAS,YAAY,SAAS;AAEhE,mBAAW,MAAM,YAAY,UAAU,KAAK;AAE5C,mBAAW,oBAAoB,SAAS,WAAW,eAAe;AAElE,SAAC,WAAW,WAAW,iBAAiB,SAAS,WAAW,kBAAkB,gBAAgB,OAAK;AACjG,cAAI,EAAE,QAAQ;AAGZ,mBAAO,eAAe,GAAG,UAAU,EAAE,OAAO,EAAE,CAAC;AAAA,UACjD,OAAO;AAGL,cAAE,yBAAyB;AAAA,UAC7B;AAAA,QACF,CAAC,CAAC;AAAA,MACJ;AAEA,YAAM,sBAAsB,SAAS,GAAG;AAGtC,cAAM,cAAc,EAAE,OAAO,eAAe;AAC5C,cAAM,eAAe,MAAK,gBAAgB,WAAW;AACrD,cAAM,MAAM,aAAa,QAAQ,aAAa,KAAK;AACnD,cAAM,QAAQ,aAAa,UAAU,aAAa,OAAO;AACzD,cAAK,QAAQ,4BAA4B,KAAK,KAAK;AAAA,MACrD;AAEA,YAAK,iBAAiB,mCAAmC,gBAAgB,SAAS,GAAG;AACnF,4BAAoB,MAAK,sBAAsB,SAAS;AAAA,MAC1D,CAAC,CAAC;AAEF,YAAK,iCAAiC,gBAAgB,SAAS,OAAO;AAGpE,cAAM,cAAc,MAAM,OAAO,eAAe;AAChD,cAAM,eAAe,MAAK,gBAAgB,WAAW;AACrD,eAAO;AAAA,UACL,KAAM,aAAa,QAAQ,aAAa,KAAK,OAAQ;AAAA,QACvD;AAAA,MACF,CAAC;AAED,YAAK,iBAAiB,SAAS,gBAAgB,OAAK,gBAAgB,GAAG,YAAY,CAAC,CAAC;AACrF,YAAK,iBAAiB,YAAY,gBAAgB,OAAK,gBAAgB,GAAG,mBAAmB,CAAC,CAAC;AAE/F,YAAK,iBAAiB,iBAAiB,gBAAgB,OAAK;AAC1D,cAAM,OAAO,MAAK,mBAAmB,EAAE,OAAO,SAAO,CAAC,IAAI,MAAM;AAEhE,aAAK,QAAQ,SAAO;AAClB,cAAI,cAAc,IAAI,YAAY,oBAAoB,CAAC;AAAA,QACzD,CAAC;AAED,cAAK,cAAc,IAAI,YAAY,sBAAsB,EAAE,QAAQ;AAAA,UACjE,kBAAkB,EAAE,OAAO,cAAc;AAAA,QAC3C,EAAC,CAAC,CAAC;AAAA,MACL,CAAC,CAAC;AAEF,YAAK,iBAAiB,kBAAkB,gBAAgB,OAAK;AAC3D,cAAM,UAAU,MAAK,YAAY,MAAM,CAAC,EAAE,IAAI,EAC3C,OAAO,OAAK,EAAE,OAAO,EACrB,KAAK,CAAC,GAAG,MAAO,EAAE,SAAS,EAAE,MAAO,EACpC,IAAI,OAAK,EAAE,OAAO;AAErB,cAAK,cAAc,IAAI,YAAY,8BAA8B;AAAA,UAC/D,QAAQ,EAAE,QAAQ;AAAA,QACpB,CAAC,CAAC;AAAA,MACJ,CAAC,CAAC;AAEF,YAAK,iBAAiB,cAAc,gBAAgB,OAAK;AACvD,cAAM,eAAe,MAAK,gBAAgB,CAAC;AAC3C,cAAM,wBAAwB,CAAC,UAAU,QAAQ,QAAQ;AAEzD,YAAG,sBAAsB,QAAQ,aAAa,OAAO,MAAM,IAAI;AAC7D;AAAA,QACF;AAEA,cAAK,cAAc,IAAI,YAAY,mBAAmB;AAAA,UACpD,QAAQ;AAAA,YACN,SAAS,aAAa,OAChB,aAAa,KAAK,MAClB;AAAA,YAEN,kBAAkB,aAAa,SACzB,aAAa,OAAO,UACpB;AAAA,YAEN,SAAS,aAAa;AAAA,UACxB;AAAA,QACF,CAAC,CAAC;AAAA,MACJ,CAAC,CAAC;AAEF,+BAAyB,OAAO,WAAW;AACzC,cAAM,SAAS,MAAM;AACrB,cAAM,eAAe,MAAK,gBAAgB,KAAK;AAC/C,cAAM,UAAU,aAAa;AAE7B,YAAI,aAAa,QAAQ,CAAC,YAAY,MAAM,KAAK,YAAY,WAAW;AACtE,gBAAM,UAAU,aAAa,KAAK;AAElC,cAAI,aAAa,QAAQ;AACvB,kBAAM,mBAAmB,aAAa,OAAO;AAAA,UAC/C;AACA,gBAAK,cAAc,IAAI,YAAY,WACjC,EAAE,QAAQ,MAAM,CAAC,CAAC;AAAA,QACtB;AAAA,MACF;AAEA,YAAK,yBAAyB,gBAAgB,SAAS,QAAQ,SAAS;AACpE,cAAM,QAAQ,QAAQ,KAAK;AAC3B,YAAI,CAAC,OAAO;AACV;AAAA,QACF;AACA,eAAQ,OAAM,OAAO,MAAM,MAAQ,WAAU,MAAM,OAAO,YAAa;AAAA,MAC3E,CAAC;AAED,YAAK,aAAa,gBAAgB,aAAW,CAAC,QAAQ,KAAK,YAAY;AAEvE,YAAK,aAAa,gBAAgB,aAAW,CAAC,QAAQ,KAAK,YAAY;AAEvE,YAAK,iBAAiB,kBAAkB,gBAAgB,OAAK;AAE3D,YAAI,MAAK,YAAY,EAAE,OAAO,aAAa,EAAE,GAAG;AAE9C,cAAI,MAAK,qBAAqB;AAC5B,mBAAO,KAAK,MAAK,mBAAmB,EAAE,QAAQ,UAAQ;AACpD,gBAAE,OAAO,YAAY,MAAM,MAAK,oBAAoB,KAAK;AAAA,YAC3D,CAAC;AAAA,UACH,OAAO;AACL,YAAC,OAAK,mBAAmB,CAAC,GAAG,QAAQ,UAAQ;AAC3C,gBAAE,OAAO,YAAY,MAAM,EAAE,OAAO,aAAa,IAAI,UAAQ,KAAK,SAAS,KAAK,EAAE,KAAK,IAAI,CAAC;AAAA,YAC9F,CAAC;AAAA,UACH;AAEA,cAAI,MAAK,+BAA+B,GAAG;AACzC,cAAE,OAAO,qBAAqB,MAAK,4BAA4B;AAAA,UACjE;AAAA,QACF,OAAO;AAEL,UAAC,OAAK,mBAAmB,CAAC,GAAG,QAAQ,UAAQ;AAC3C,cAAE,OAAO,YAAY,MAAM,EAAE,OAAO,aAAa,GAAG,SAAS,KAAK;AAAA,UACpE,CAAC;AAAA,QACH;AAAA,MACF,CAAC,CAAC;AAAA,IACJ,CAAC,EAAE,IAAI;AAAA,EACT;AACF,GAAG;",
  "names": []
}
