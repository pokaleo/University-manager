import {
  Checkbox
} from "./chunk-NON5YMRO.js";
import {
  FieldMixin
} from "./chunk-CCEZKRVB.js";
import {
  DisabledMixin
} from "./chunk-TNYX3KNS.js";
import {
  FocusMixin
} from "./chunk-Q3ITW52D.js";
import {
  FlattenedNodesObserver
} from "./chunk-IASAGYPQ.js";
import {
  ThemableMixin
} from "./chunk-PALO6AVQ.js";
import {
  ElementMixin
} from "./chunk-ZAXSWEEW.js";
import {
  PolymerElement,
  html
} from "./chunk-EMDRMWGL.js";

// node_modules/@vaadin/checkbox-group/src/vaadin-checkbox-group.js
var CheckboxGroup = class extends FieldMixin(FocusMixin(DisabledMixin(ElementMixin(ThemableMixin(PolymerElement))))) {
  static get is() {
    return "vaadin-checkbox-group";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: inline-flex;
        }

        :host::before {
          content: '\\2003';
          width: 0;
          display: inline-block;
        }

        :host([hidden]) {
          display: none !important;
        }

        .vaadin-group-field-container {
          display: flex;
          flex-direction: column;
          width: 100%;
        }

        :host(:not([has-label])) [part='label'] {
          display: none;
        }
      </style>

      <div class="vaadin-group-field-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true"></span>
        </div>

        <div part="group-field">
          <slot></slot>
        </div>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>
    `;
  }
  static get properties() {
    return {
      value: {
        type: Array,
        value: () => [],
        notify: true
      }
    };
  }
  static get observers() {
    return ["__valueChanged(value, value.splices)"];
  }
  constructor() {
    super();
    this.__registerCheckbox = this.__registerCheckbox.bind(this);
    this.__unregisterCheckbox = this.__unregisterCheckbox.bind(this);
    this.__onCheckboxCheckedChanged = this.__onCheckboxCheckedChanged.bind(this);
  }
  ready() {
    super.ready();
    this.ariaTarget = this;
    this.setAttribute("role", "group");
    this._observer = new FlattenedNodesObserver(this, ({ addedNodes, removedNodes }) => {
      const addedCheckboxes = this.__filterCheckboxes(addedNodes);
      const removedCheckboxes = this.__filterCheckboxes(removedNodes);
      addedCheckboxes.forEach(this.__registerCheckbox);
      removedCheckboxes.forEach(this.__unregisterCheckbox);
      this.__warnOfCheckboxesWithoutValue(addedCheckboxes);
    });
  }
  checkValidity() {
    return !this.required || this.value.length > 0;
  }
  __filterCheckboxes(nodes) {
    return nodes.filter((child) => child instanceof Checkbox);
  }
  get __checkboxes() {
    return this.__filterCheckboxes([...this.children]);
  }
  __warnOfCheckboxesWithoutValue(checkboxes) {
    const hasCheckboxesWithoutValue = checkboxes.some((checkbox) => {
      const { value } = checkbox;
      return !checkbox.hasAttribute("value") && (!value || value === "on");
    });
    if (hasCheckboxesWithoutValue) {
      console.warn("Please provide the value attribute to all the checkboxes inside the checkbox group.");
    }
  }
  __registerCheckbox(checkbox) {
    checkbox.addEventListener("checked-changed", this.__onCheckboxCheckedChanged);
    if (this.disabled) {
      checkbox.disabled = true;
    }
    if (checkbox.checked) {
      this.__addCheckboxToValue(checkbox.value);
    } else if (this.value.includes(checkbox.value)) {
      checkbox.checked = true;
    }
  }
  __unregisterCheckbox(checkbox) {
    checkbox.removeEventListener("checked-changed", this.__onCheckboxCheckedChanged);
    if (checkbox.checked) {
      this.__removeCheckboxFromValue(checkbox.value);
    }
  }
  _disabledChanged(newValue, oldValue) {
    super._disabledChanged(newValue, oldValue);
    if (!newValue && oldValue === void 0) {
      return;
    }
    if (oldValue !== newValue) {
      this.__checkboxes.forEach((checkbox) => {
        checkbox.disabled = newValue;
      });
    }
  }
  __addCheckboxToValue(value) {
    if (!this.value.includes(value)) {
      this.value = [...this.value, value];
    }
  }
  __removeCheckboxFromValue(value) {
    if (this.value.includes(value)) {
      this.value = this.value.filter((v) => v !== value);
    }
  }
  __onCheckboxCheckedChanged(event) {
    const checkbox = event.target;
    if (checkbox.checked) {
      this.__addCheckboxToValue(checkbox.value);
    } else {
      this.__removeCheckboxFromValue(checkbox.value);
    }
  }
  __valueChanged(value) {
    if (value.length === 0 && this.__oldValue === void 0) {
      return;
    }
    this.__oldValue = value;
    this.toggleAttribute("has-value", value.length > 0);
    this.__checkboxes.forEach((checkbox) => {
      checkbox.checked = value.includes(checkbox.value);
    });
    this.validate();
  }
  _shouldRemoveFocus(event) {
    return !this.contains(event.relatedTarget);
  }
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused) {
      this.validate();
    }
  }
};
customElements.define(CheckboxGroup.is, CheckboxGroup);
/**
 * @license
 * Copyright (c) 2018 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-W3V3BGD6.js.map
