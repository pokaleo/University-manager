import {
  TimePicker
} from "./chunk-Y3YHMEST.js";
import {
  SlotMixin
} from "./chunk-HEO3XYAH.js";
import {
  customField
} from "./chunk-PAZO4RLR.js";
import {
  DatePicker,
  dateEquals
} from "./chunk-HPU23LSV.js";
import "./chunk-I4XSFGAQ.js";
import "./chunk-EGRHWZRV.js";
import "./chunk-HZRES5DH.js";
import "./chunk-CD2SCIJQ.js";
import "./chunk-YIXZHRC6.js";
import "./chunk-2P64M2FJ.js";
import "./chunk-QFBWESZ7.js";
import "./chunk-VPQC7TEI.js";
import "./chunk-3GYD24OI.js";
import "./chunk-YBQVYLTV.js";
import {
  inputFieldShared
} from "./chunk-3DPYGOOZ.js";
import "./chunk-OA3YIVWN.js";
import "./chunk-ON7ICNNX.js";
import {
  FieldMixin,
  helper
} from "./chunk-YJVFTOSG.js";
import "./chunk-DN7NE4EQ.js";
import {
  requiredField
} from "./chunk-4JL67NGK.js";
import "./chunk-NENT67AA.js";
import "./chunk-YESAUM4I.js";
import "./chunk-2PREY5TQ.js";
import "./chunk-BSWEWLID.js";
import "./chunk-W2FE6W4J.js";
import "./chunk-IYXOBYFR.js";
import "./chunk-DFQLQY2A.js";
import "./chunk-JKBBW2QH.js";
import "./chunk-YMQIJIR3.js";
import "./chunk-75G4VMZU.js";
import "./chunk-7N2APOXI.js";
import "./chunk-6I3PSOTG.js";
import "./chunk-IZT3AP6L.js";
import "./chunk-Z624KRTI.js";
import "./chunk-T5JDTCGA.js";
import "./chunk-N4COYWWO.js";
import "./chunk-VRMTXLCJ.js";
import "./chunk-I6OY4CB4.js";
import "./chunk-2GZ522BV.js";
import "./chunk-BUARF445.js";
import "./chunk-ZGILPT2L.js";
import {
  FlattenedNodesObserver
} from "./chunk-IASAGYPQ.js";
import "./chunk-THDKHJJJ.js";
import "./chunk-6FZMJTZI.js";
import "./chunk-UTZKFO5A.js";
import "./chunk-CHZ6BFNC.js";
import {
  DisabledMixin
} from "./chunk-TNYX3KNS.js";
import "./chunk-5B3W7TLP.js";
import "./chunk-75WEHVQA.js";
import {
  FocusMixin
} from "./chunk-Q3ITW52D.js";
import "./chunk-SYJMCSOT.js";
import "./chunk-TSMFV5J4.js";
import "./chunk-WUR5UZ22.js";
import "./chunk-YZXPUGLM.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-PALO6AVQ.js";
import {
  ElementMixin
} from "./chunk-OKCEHAIA.js";
import "./chunk-KCWZ32HQ.js";
import "./chunk-ZFVP5VBM.js";
import "./chunk-QNRFZUBX.js";
import {
  css
} from "./chunk-PYLEJJK2.js";
import {
  PolymerElement,
  html
} from "./chunk-EMDRMWGL.js";
import "./chunk-H3KD7FYF.js";
import "./chunk-NZ6RMXB7.js";
import "./chunk-RQI6IG5T.js";
import {
  __spreadProps,
  __spreadValues
} from "./chunk-KTZKXPFA.js";

// node_modules/@vaadin/date-time-picker/theme/lumo/vaadin-date-time-picker-styles.js
registerStyles("vaadin-date-time-picker", [requiredField, helper, customField], {
  moduleId: "lumo-date-time-picker"
});
registerStyles("vaadin-date-time-picker-date-picker", css`
    :host {
      margin-right: 2px;
    }

    /* RTL specific styles */
    :host([dir='rtl']) {
      margin-right: auto;
      margin-left: 2px;
    }

    [part~='input-field'] {
      border-top-right-radius: 0;
      border-bottom-right-radius: 0;
    }

    /* RTL specific styles */
    :host([dir='rtl']) [part~='input-field'] {
      border-radius: var(--lumo-border-radius-m);
      border-top-left-radius: 0;
      border-bottom-left-radius: 0;
    }
  `, { moduleId: "lumo-date-time-picker-date-picker" });
registerStyles("vaadin-date-time-picker-time-picker", css`
    [part~='input-field'] {
      border-top-left-radius: 0;
      border-bottom-left-radius: 0;
    }

    /* RTL specific styles */
    :host([dir='rtl']) [part~='input-field'] {
      border-radius: var(--lumo-border-radius-m);
      border-top-right-radius: 0;
      border-bottom-right-radius: 0;
    }
  `, { moduleId: "lumo-date-time-picker-time-picker" });

// node_modules/@vaadin/date-time-picker/src/vaadin-date-time-picker-date-picker.js
var DateTimePickerDatePicker = class extends DatePicker {
  static get is() {
    return "vaadin-date-time-picker-date-picker";
  }
};
customElements.define(DateTimePickerDatePicker.is, DateTimePickerDatePicker);

// node_modules/@vaadin/date-time-picker/src/vaadin-date-time-picker-time-picker.js
var DateTimePickerTimePicker = class extends TimePicker {
  static get is() {
    return "vaadin-date-time-picker-time-picker";
  }
};
customElements.define(DateTimePickerTimePicker.is, DateTimePickerTimePicker);

// node_modules/@vaadin/date-time-picker/src/vaadin-date-time-picker.js
registerStyles("vaadin-date-time-picker", inputFieldShared, { moduleId: "vaadin-date-time-picker" });
function getPropertyFromPrototype(clazz, prop) {
  while (clazz) {
    if (clazz.properties && clazz.properties[prop]) {
      return clazz.properties[prop];
    }
    clazz = Object.getPrototypeOf(clazz);
  }
}
var datePickerClass = customElements.get("vaadin-date-time-picker-date-picker");
var timePickerClass = customElements.get("vaadin-date-time-picker-time-picker");
var datePickerI18nDefaults = getPropertyFromPrototype(datePickerClass, "i18n").value();
var timePickerI18nDefaults = getPropertyFromPrototype(timePickerClass, "i18n").value();
var datePickerI18nProps = Object.keys(datePickerI18nDefaults);
var timePickerI18nProps = Object.keys(timePickerI18nDefaults);
var DateTimePicker = class extends FieldMixin(SlotMixin(DisabledMixin(FocusMixin(ThemableMixin(ElementMixin(PolymerElement)))))) {
  static get template() {
    return html`
      <style>
        .vaadin-date-time-picker-container {
          --vaadin-field-default-width: auto;
        }

        .slots {
          display: flex;
          --vaadin-field-default-width: 12em;
        }

        [part='date'],
        .slots ::slotted([slot='date-picker']) {
          pointer-events: all;
          min-width: 0;
          flex: 1 1 auto;
        }

        [part='time'],
        .slots ::slotted([slot='time-picker']) {
          pointer-events: all;
          min-width: 0;
          flex: 1 1.65 auto;
        }
      </style>

      <div class="vaadin-date-time-picker-container">
        <div part="label" on-click="focus">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true"></span>
        </div>

        <div class="slots">
          <slot name="date-picker" id="dateSlot"></slot>
          <slot name="time-picker" id="timeSlot"></slot>
        </div>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>
    `;
  }
  static get is() {
    return "vaadin-date-time-picker";
  }
  static get properties() {
    return {
      name: {
        type: String
      },
      value: {
        type: String,
        notify: true,
        value: "",
        observer: "__valueChanged"
      },
      min: {
        type: String,
        observer: "__minChanged"
      },
      max: {
        type: String,
        observer: "__maxChanged"
      },
      __minDateTime: {
        type: Date,
        value: ""
      },
      __maxDateTime: {
        type: Date,
        value: ""
      },
      datePlaceholder: {
        type: String
      },
      timePlaceholder: {
        type: String
      },
      step: {
        type: Number
      },
      initialPosition: String,
      showWeekNumbers: {
        type: Boolean
      },
      autoOpenDisabled: Boolean,
      readonly: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      autofocus: {
        type: Boolean
      },
      __selectedDateTime: {
        type: Date
      },
      i18n: {
        type: Object,
        value: () => __spreadValues(__spreadValues({}, datePickerI18nDefaults), timePickerI18nDefaults)
      },
      __datePicker: {
        type: HTMLElement,
        observer: "__datePickerChanged"
      },
      __timePicker: {
        type: HTMLElement,
        observer: "__timePickerChanged"
      }
    };
  }
  static get observers() {
    return [
      "__selectedDateTimeChanged(__selectedDateTime)",
      "__datePlaceholderChanged(datePlaceholder)",
      "__timePlaceholderChanged(timePlaceholder)",
      "__stepChanged(step)",
      "__initialPositionChanged(initialPosition)",
      "__showWeekNumbersChanged(showWeekNumbers)",
      "__requiredChanged(required)",
      "__invalidChanged(invalid)",
      "__disabledChanged(disabled)",
      "__readonlyChanged(readonly)",
      "__i18nChanged(i18n.*)",
      "__autoOpenDisabledChanged(autoOpenDisabled)",
      "__themeChanged(theme, __datePicker, __timePicker)",
      "__pickersChanged(__datePicker, __timePicker)"
    ];
  }
  get slots() {
    return __spreadProps(__spreadValues({}, super.slots), {
      "date-picker": () => {
        const element = document.createElement("vaadin-date-time-picker-date-picker");
        element.__defaultPicker = true;
        return element;
      },
      "time-picker": () => {
        const element = document.createElement("vaadin-date-time-picker-time-picker");
        element.__defaultPicker = true;
        return element;
      }
    });
  }
  constructor() {
    super();
    this.__defaultDateMinMaxValue = void 0;
    this.__defaultTimeMinValue = "00:00:00.000";
    this.__defaultTimeMaxValue = "23:59:59.999";
    this.__changeEventHandler = this.__changeEventHandler.bind(this);
    this.__valueChangedEventHandler = this.__valueChangedEventHandler.bind(this);
    this._observer = new FlattenedNodesObserver(this, (info) => {
      this.__onDomChange(info.addedNodes);
    });
  }
  ready() {
    super.ready();
    this.addEventListener("focusout", (e) => {
      if (e.relatedTarget !== this.__datePicker.$.overlay) {
        this.validate();
      }
    });
    this.__datePicker = this._getDirectSlotChild("date-picker");
    this.__timePicker = this._getDirectSlotChild("time-picker");
    if (this.autofocus && !this.disabled) {
      window.requestAnimationFrame(() => this.focus());
    }
    this.setAttribute("role", "group");
    this.ariaTarget = this;
  }
  __filterElements(node) {
    return node.nodeType === Node.ELEMENT_NODE;
  }
  focus() {
    this.__datePicker.focus();
  }
  _shouldRemoveFocus(event) {
    const target = event.relatedTarget;
    if (this.__datePicker.contains(target) || this.__timePicker.contains(target) || target === this.__datePicker.$.overlay) {
      return false;
    }
    return true;
  }
  __syncI18n(target, source, props) {
    props = props || Object.keys(source.i18n);
    props.forEach((prop) => {
      if (source.i18n && source.i18n.hasOwnProperty(prop)) {
        target.set(`i18n.${prop}`, source.i18n[prop]);
      }
    });
  }
  __changeEventHandler(event) {
    event.stopPropagation();
    if (this.__dispatchChangeForValue === this.value) {
      this.__dispatchChange();
      this.validate();
    }
    this.__dispatchChangeForValue = void 0;
  }
  __addInputListeners(node) {
    node.addEventListener("change", this.__changeEventHandler);
    node.addEventListener("value-changed", this.__valueChangedEventHandler);
  }
  __removeInputListeners(node) {
    node.removeEventListener("change", this.__changeEventHandler);
    node.removeEventListener("value-changed", this.__valueChangedEventHandler);
  }
  __onDomChange(addedNodes) {
    addedNodes.filter((node) => node.nodeType === Node.ELEMENT_NODE).forEach((node) => {
      const slotAttributeValue = node.getAttribute("slot");
      if (slotAttributeValue === "date-picker") {
        this.__datePicker = node;
      } else if (slotAttributeValue === "time-picker") {
        this.__timePicker = node;
      }
    });
  }
  __datePickerChanged(newDatePicker, existingDatePicker) {
    if (!newDatePicker) {
      return;
    }
    if (existingDatePicker) {
      this.__removeInputListeners(existingDatePicker);
      existingDatePicker.remove();
    }
    this.__addInputListeners(newDatePicker);
    if (newDatePicker.__defaultPicker) {
      newDatePicker.placeholder = this.datePlaceholder;
      newDatePicker.invalid = this.invalid;
      newDatePicker.initialPosition = this.initialPosition;
      newDatePicker.showWeekNumbers = this.showWeekNumbers;
      this.__syncI18n(newDatePicker, this, datePickerI18nProps);
    } else {
      this.datePlaceholder = newDatePicker.placeholder;
      this.initialPosition = newDatePicker.initialPosition;
      this.showWeekNumbers = newDatePicker.showWeekNumbers;
      this.__syncI18n(this, newDatePicker, datePickerI18nProps);
    }
    newDatePicker.min = this.__formatDateISO(this.__minDateTime, this.__defaultDateMinMaxValue);
    newDatePicker.max = this.__formatDateISO(this.__maxDateTime, this.__defaultDateMinMaxValue);
    newDatePicker.required = this.required;
    newDatePicker.disabled = this.disabled;
    newDatePicker.readonly = this.readonly;
    newDatePicker.autoOpenDisabled = this.autoOpenDisabled;
    newDatePicker.validate = () => {
    };
    newDatePicker._validateInput = () => {
    };
  }
  __timePickerChanged(newTimePicker, existingTimePicker) {
    if (!newTimePicker) {
      return;
    }
    if (existingTimePicker) {
      this.__removeInputListeners(existingTimePicker);
      existingTimePicker.remove();
    }
    this.__addInputListeners(newTimePicker);
    if (newTimePicker.__defaultPicker) {
      newTimePicker.placeholder = this.timePlaceholder;
      newTimePicker.step = this.step;
      newTimePicker.invalid = this.invalid;
      this.__syncI18n(newTimePicker, this, timePickerI18nProps);
    } else {
      this.timePlaceholder = newTimePicker.placeholder;
      this.step = newTimePicker.step;
      this.__syncI18n(this, newTimePicker, timePickerI18nProps);
    }
    this.__updateTimePickerMinMax();
    newTimePicker.required = this.required;
    newTimePicker.disabled = this.disabled;
    newTimePicker.readonly = this.readonly;
    newTimePicker.autoOpenDisabled = this.autoOpenDisabled;
    newTimePicker.validate = () => {
    };
  }
  __updateTimePickerMinMax() {
    if (this.__timePicker && this.__datePicker) {
      const selectedDate = this.__parseDate(this.__datePicker.value);
      const isMinMaxSameDay = dateEquals(this.__minDateTime, this.__maxDateTime);
      const oldTimeValue = this.__timePicker.value;
      if (this.__minDateTime && dateEquals(selectedDate, this.__minDateTime) || isMinMaxSameDay) {
        this.__timePicker.min = this.__dateToIsoTimeString(this.__minDateTime);
      } else {
        this.__timePicker.min = this.__defaultTimeMinValue;
      }
      if (this.__maxDateTime && dateEquals(selectedDate, this.__maxDateTime) || isMinMaxSameDay) {
        this.__timePicker.max = this.__dateToIsoTimeString(this.__maxDateTime);
      } else {
        this.__timePicker.max = this.__defaultTimeMaxValue;
      }
      if (this.__timePicker.value !== oldTimeValue) {
        this.__timePicker.value = oldTimeValue;
      }
    }
  }
  __i18nChanged(changeRecord) {
    if (this.__datePicker) {
      this.__datePicker.set(changeRecord.path, changeRecord.value);
    }
    if (this.__timePicker) {
      this.__timePicker.set(changeRecord.path, changeRecord.value);
    }
  }
  __datePlaceholderChanged(datePlaceholder) {
    if (this.__datePicker) {
      this.__datePicker.placeholder = datePlaceholder;
    }
  }
  __timePlaceholderChanged(timePlaceholder) {
    if (this.__timePicker) {
      this.__timePicker.placeholder = timePlaceholder;
    }
  }
  __stepChanged(step) {
    if (this.__timePicker && this.__timePicker.step !== step) {
      this.__timePicker.step = step;
    }
  }
  __initialPositionChanged(initialPosition) {
    if (this.__datePicker) {
      this.__datePicker.initialPosition = initialPosition;
    }
  }
  __showWeekNumbersChanged(showWeekNumbers) {
    if (this.__datePicker) {
      this.__datePicker.showWeekNumbers = showWeekNumbers;
    }
  }
  __invalidChanged(invalid) {
    if (this.__datePicker) {
      this.__datePicker.invalid = invalid;
    }
    if (this.__timePicker) {
      this.__timePicker.invalid = invalid;
    }
  }
  __requiredChanged(required) {
    if (this.__datePicker) {
      this.__datePicker.required = required;
    }
    if (this.__timePicker) {
      this.__timePicker.required = required;
    }
  }
  __disabledChanged(disabled) {
    if (this.__datePicker) {
      this.__datePicker.disabled = disabled;
    }
    if (this.__timePicker) {
      this.__timePicker.disabled = disabled;
    }
  }
  __readonlyChanged(readonly) {
    if (this.__datePicker) {
      this.__datePicker.readonly = readonly;
    }
    if (this.__timePicker) {
      this.__timePicker.readonly = readonly;
    }
  }
  __parseDate(str) {
    return datePickerClass.prototype._parseDate(str);
  }
  __formatDateISO(date, defaultValue) {
    if (!date) {
      return defaultValue;
    }
    return datePickerClass.prototype._formatISO(date);
  }
  __formatTimeISO(time) {
    return timePickerI18nDefaults.formatTime(time);
  }
  __parseTimeISO(str) {
    return timePickerI18nDefaults.parseTime(str);
  }
  __parseDateTime(str) {
    const [dateValue, timeValue] = str.split("T");
    if (!(dateValue && timeValue)) {
      return;
    }
    const date = this.__parseDate(dateValue);
    if (!date) {
      return;
    }
    const time = this.__parseTimeISO(timeValue);
    if (!time) {
      return;
    }
    date.setHours(parseInt(time.hours));
    date.setMinutes(parseInt(time.minutes || 0));
    date.setSeconds(parseInt(time.seconds || 0));
    date.setMilliseconds(parseInt(time.milliseconds || 0));
    return date;
  }
  __formatDateTime(date) {
    if (!date) {
      return "";
    }
    const dateValue = this.__formatDateISO(date, "");
    const timeValue = this.__dateToIsoTimeString(date);
    return `${dateValue}T${timeValue}`;
  }
  __dateToIsoTimeString(date) {
    return this.__formatTimeISO(this.__validateTime({
      hours: date.getHours(),
      minutes: date.getMinutes(),
      seconds: date.getSeconds(),
      milliseconds: date.getMilliseconds()
    }));
  }
  __validateTime(timeObject) {
    if (timeObject) {
      timeObject.seconds = this.__stepSegment < 3 ? void 0 : timeObject.seconds;
      timeObject.milliseconds = this.__stepSegment < 4 ? void 0 : timeObject.milliseconds;
    }
    return timeObject;
  }
  get __inputs() {
    return [this.__datePicker, this.__timePicker];
  }
  checkValidity() {
    const hasInvalidFields = this.__inputs.some((input) => !input.checkValidity());
    const hasEmptyFields = this.required && this.__inputs.some((el) => !el.value);
    if (hasInvalidFields || hasEmptyFields) {
      return false;
    }
    return true;
  }
  get __stepSegment() {
    const step = this.step == void 0 ? 60 : parseFloat(this.step);
    if (step % 3600 === 0) {
      return 1;
    } else if (step % 60 === 0 || !step) {
      return 2;
    } else if (step % 1 === 0) {
      return 3;
    } else if (step < 1) {
      return 4;
    }
  }
  __dateTimeEquals(date1, date2) {
    if (!dateEquals(date1, date2)) {
      return false;
    }
    return date1.getHours() === date2.getHours() && date1.getMinutes() === date2.getMinutes() && date1.getSeconds() === date2.getSeconds() && date1.getMilliseconds() === date2.getMilliseconds();
  }
  __handleDateTimeChange(property, parsedProperty, value, oldValue) {
    if (!value) {
      this[property] = "";
      this[parsedProperty] = "";
      return;
    }
    const dateTime = this.__parseDateTime(value);
    if (!dateTime) {
      this[property] = oldValue;
      return;
    }
    if (!this.__dateTimeEquals(this[parsedProperty], dateTime)) {
      this[parsedProperty] = dateTime;
    }
  }
  __valueChanged(value, oldValue) {
    this.__handleDateTimeChange("value", "__selectedDateTime", value, oldValue);
    if (oldValue !== void 0) {
      this.__dispatchChangeForValue = value;
    }
    this.toggleAttribute("has-value", !!value);
    this.__updateTimePickerMinMax();
  }
  __dispatchChange() {
    this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
  }
  __minChanged(value, oldValue) {
    this.__handleDateTimeChange("min", "__minDateTime", value, oldValue);
    if (this.__datePicker) {
      this.__datePicker.min = this.__formatDateISO(this.__minDateTime, this.__defaultDateMinMaxValue);
    }
    this.__updateTimePickerMinMax();
  }
  __maxChanged(value, oldValue) {
    this.__handleDateTimeChange("max", "__maxDateTime", value, oldValue);
    if (this.__datePicker) {
      this.__datePicker.max = this.__formatDateISO(this.__maxDateTime, this.__defaultDateMinMaxValue);
    }
    this.__updateTimePickerMinMax();
  }
  __selectedDateTimeChanged(selectedDateTime) {
    const formattedValue = this.__formatDateTime(selectedDateTime);
    if (this.value !== formattedValue) {
      this.value = formattedValue;
    }
    const isDatePickerReady = Boolean(this.__datePicker && this.__datePicker.$);
    if (isDatePickerReady && !this.__ignoreInputValueChange) {
      this.__ignoreInputValueChange = true;
      const [dateValue, timeValue] = this.value.split("T");
      this.__datePicker.value = dateValue || "";
      this.__timePicker.value = timeValue || "";
      this.__ignoreInputValueChange = false;
    }
  }
  get __formattedValue() {
    const dateValue = this.__datePicker.value;
    const timeValue = this.__timePicker.value;
    if (dateValue && timeValue) {
      return [dateValue, timeValue].join("T");
    }
    return "";
  }
  __valueChangedEventHandler() {
    if (this.__ignoreInputValueChange) {
      return;
    }
    const value = this.__formattedValue;
    const [date, time] = value.split("T");
    this.__ignoreInputValueChange = true;
    this.__updateTimePickerMinMax();
    if (date && time) {
      if (value !== this.value) {
        this.value = value;
      }
    } else {
      this.value = "";
    }
    this.__ignoreInputValueChange = false;
  }
  __autoOpenDisabledChanged(autoOpenDisabled) {
    if (this.__datePicker) {
      this.__datePicker.autoOpenDisabled = autoOpenDisabled;
    }
    if (this.__timePicker) {
      this.__timePicker.autoOpenDisabled = autoOpenDisabled;
    }
  }
  __themeChanged(theme, datePicker, timePicker) {
    [datePicker, timePicker].forEach((picker) => {
      if (picker) {
        if (theme) {
          picker.setAttribute("theme", theme);
        } else {
          picker.removeAttribute("theme");
        }
      }
    });
  }
  __pickersChanged(datePicker, timePicker) {
    if (!datePicker || !timePicker) {
      return;
    }
    if (datePicker.__defaultPicker !== timePicker.__defaultPicker) {
      return;
    }
    if (datePicker.value) {
      this.__valueChangedEventHandler();
    } else if (this.value) {
      this.__selectedDateTimeChanged(this.__selectedDateTime);
    }
  }
};
customElements.define(DateTimePicker.is, DateTimePicker);
/**
 * @license
 * Copyright (c) 2019 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=@vaadin_date-time-picker_theme_lumo_vaadin-date-time-picker_js.js.map
