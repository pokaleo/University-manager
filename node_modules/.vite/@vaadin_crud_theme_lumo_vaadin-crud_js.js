import "./chunk-EGRHWZRV.js";
import {
  FormLayout
} from "./chunk-XPKOJIYC.js";
import "./chunk-IG27LVVV.js";
import "./chunk-AYMBQKWZ.js";
import "./chunk-JWG3UC3E.js";
import {
  Grid
} from "./chunk-BAX4TXVI.js";
import "./chunk-LEIXEEHY.js";
import "./chunk-C672JIGV.js";
import "./chunk-C3NYLD5I.js";
import "./chunk-AC35BEKZ.js";
import "./chunk-2P64M2FJ.js";
import "./chunk-VKV6FIXH.js";
import "./chunk-QCXVEWEJ.js";
import "./chunk-3ZYBSPTG.js";
import "./chunk-3TXMMB5M.js";
import {
  SlotMixin
} from "./chunk-HEO3XYAH.js";
import {
  Dialog,
  DialogOverlay
} from "./chunk-LJHVE6HB.js";
import {
  MediaQueryController
} from "./chunk-I4XSFGAQ.js";
import "./chunk-56YCBFTR.js";
import "./chunk-FUN4RVJ7.js";
import "./chunk-VPQC7TEI.js";
import "./chunk-BPZR2M5B.js";
import "./chunk-EGRHWZRV.js";
import "./chunk-IYXOBYFR.js";
import "./chunk-U6NRXHHY.js";
import "./chunk-WVVSKGSY.js";
import "./chunk-WCV6MGXN.js";
import "./chunk-LRJZ3N63.js";
import "./chunk-RARRYMG4.js";
import "./chunk-YJVFTOSG.js";
import "./chunk-DN7NE4EQ.js";
import "./chunk-NENT67AA.js";
import "./chunk-YESAUM4I.js";
import "./chunk-2PREY5TQ.js";
import "./chunk-THDKHJJJ.js";
import "./chunk-6FZMJTZI.js";
import "./chunk-ON7ICNNX.js";
import "./chunk-7N2APOXI.js";
import "./chunk-4JL67NGK.js";
import "./chunk-VRMTXLCJ.js";
import "./chunk-W2FE6W4J.js";
import "./chunk-JKBBW2QH.js";
import "./chunk-CHZ6BFNC.js";
import "./chunk-TNYX3KNS.js";
import "./chunk-Q3ITW52D.js";
import "./chunk-UTZKFO5A.js";
import "./chunk-5B3W7TLP.js";
import "./chunk-75WEHVQA.js";
import "./chunk-I6OY4CB4.js";
import "./chunk-2GZ522BV.js";
import {
  ControllerMixin
} from "./chunk-BUARF445.js";
import {
  afterNextRender
} from "./chunk-ZGILPT2L.js";
import "./chunk-SYJMCSOT.js";
import "./chunk-TSMFV5J4.js";
import "./chunk-WUR5UZ22.js";
import "./chunk-YZXPUGLM.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-PALO6AVQ.js";
import {
  ElementMixin
} from "./chunk-OKCEHAIA.js";
import {
  Debouncer
} from "./chunk-KCWZ32HQ.js";
import "./chunk-ZFVP5VBM.js";
import {
  timeOut
} from "./chunk-QNRFZUBX.js";
import {
  css
} from "./chunk-PYLEJJK2.js";
import {
  FlattenedNodesObserver
} from "./chunk-IASAGYPQ.js";
import {
  PolymerElement,
  html
} from "./chunk-EMDRMWGL.js";
import "./chunk-H3KD7FYF.js";
import "./chunk-NZ6RMXB7.js";
import "./chunk-RQI6IG5T.js";
import {
  __spreadProps,
  __spreadValues
} from "./chunk-KTZKXPFA.js";

// node_modules/@vaadin/crud/theme/lumo/vaadin-crud-styles.js
registerStyles("vaadin-crud-edit", css`
    :host {
      min-width: auto;
      margin: 0;
      font-family: 'lumo-icons', var(--lumo-font-family);
      font-size: var(--lumo-icon-size-m);
      line-height: 1;
      position: relative;
      width: var(--lumo-size-s);
      height: var(--lumo-size-s);
      outline: none;
    }

    [part='icon']::before {
      content: var(--lumo-icons-edit);
      width: var(--lumo-size-m);
      height: var(--lumo-size-m);
      line-height: var(--lumo-size-m);
      text-align: center;
      position: absolute;
      top: calc((var(--lumo-size-m) - var(--lumo-size-s)) / -2);
      left: calc((var(--lumo-size-m) - var(--lumo-size-s)) / -2);
    }
  `, { moduleId: "lumo-crud-grid-edit" });
var editorStyles = css`
  [part='header'] ::slotted(h3) {
    margin-top: 0 !important;
  }

  [part='scroller'] {
    padding: var(--lumo-space-l);
  }

  [part='footer'] {
    background-color: var(--lumo-contrast-5pct);
    padding: var(--lumo-space-s);
  }

  [part='footer'] ::slotted(*) {
    margin-left: var(--lumo-space-s);
    margin-right: var(--lumo-space-s);
  }

  :host(:not([dir='rtl'])) ::slotted([slot='delete-button']) {
    margin-right: auto;
  }

  :host([dir='rtl']) ::slotted([slot='delete-button']) {
    margin-left: auto;
  }
`;
registerStyles("vaadin-crud", [
  editorStyles,
  css`
      :host {
        font-family: var(--lumo-font-family);
      }

      [part='toolbar'] {
        padding: var(--lumo-space-s) var(--lumo-space-m);
        background-color: var(--lumo-contrast-5pct);
        border: 1px solid var(--lumo-contrast-10pct);
        border-top: none;
      }

      :host(:not([dir='rtl'])) [part='toolbar'] ::slotted(*:not(:first-child)) {
        margin-left: var(--lumo-space-s);
      }

      :host([dir='rtl']) [part='toolbar'] ::slotted(*:not(:first-child)) {
        margin-right: var(--lumo-space-s);
      }

      :host([theme~='no-border']) [part='toolbar'] {
        border: 0;
      }

      [part='editor'] {
        background: var(--lumo-base-color);
        box-sizing: border-box;
      }

      :host(:not([editor-position=''])) [part='editor']:not([hidden]) {
        box-shadow: var(--lumo-box-shadow-m);
      }

      :host(:not([theme~='no-border']):not([editor-position=''])) [part='editor']:not([hidden]) {
        border: 1px solid var(--lumo-contrast-20pct);
      }

      :host(:not([theme~='no-border'])[editor-position='bottom']) [part='editor']:not([hidden]) {
        border-top: 0;
      }

      :host(:not([dir='rtl'])[editor-position='aside']) [part='editor']:not([hidden]) {
        border-left: 0;
      }

      :host([dir='rtl']:not([theme~='no-border'])[editor-position='aside']) [part='editor']:not([hidden]) {
        border-right: 0;
      }

      vaadin-grid-cell-content {
        text-overflow: ellipsis;
      }
    `
], { moduleId: "lumo-crud" });
registerStyles("vaadin-crud-dialog-overlay", editorStyles, {
  moduleId: "lumo-crud-dialog-overlay"
});

// node_modules/@vaadin/crud/src/vaadin-crud-dialog.js
registerStyles("vaadin-crud-dialog-overlay", css`
    [part='overlay'] {
      max-width: 54em;
      min-width: 20em;
    }

    [part='content'] {
      display: flex;
      flex-direction: column;
      padding: 0;
    }

    [part='scroller'] {
      display: flex;
      flex-direction: column;
      overflow: auto;
      flex: auto;
    }

    [part='footer'] {
      display: flex;
      flex: none;
      flex-direction: row-reverse;
    }

    :host([fullscreen]) {
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      padding: 0;
    }

    :host([fullscreen]) [part='overlay'] {
      height: 100vh;
      width: 100vw;
      border-radius: 0 !important;
    }

    :host([fullscreen]) [part='content'] {
      flex: 1;
    }
  `, { moduleId: "vaadin-crud-dialog-overlay-styles" });
var memoizedTemplate;
var editorTemplate = html`
  <div part="scroller" role="group" aria-labelledby="header">
    <div part="header" id="header">
      <slot name="header"></slot>
    </div>
    <slot name="form"></slot>
  </div>

  <div part="footer" role="toolbar">
    <slot name="save-button"></slot>
    <slot name="cancel-button"></slot>
    <slot name="delete-button"></slot>
  </div>
`;
var CrudDialogOverlay = class extends DialogOverlay {
  static get is() {
    return "vaadin-crud-dialog-overlay";
  }
  static get template() {
    if (!memoizedTemplate) {
      memoizedTemplate = super.template.cloneNode(true);
      const contentPart = memoizedTemplate.content.querySelector('[part="content"]');
      const defaultSlot = contentPart.querySelector("slot:not([name])");
      contentPart.removeChild(defaultSlot);
      contentPart.appendChild(editorTemplate.content.cloneNode(true));
    }
    return memoizedTemplate;
  }
};
customElements.define("vaadin-crud-dialog-overlay", CrudDialogOverlay);
var CrudDialog = class extends Dialog {
  static get template() {
    return html`
      <style>
        :host {
          display: none;
        }
      </style>

      <vaadin-crud-dialog-overlay
        id="overlay"
        on-opened-changed="_onOverlayOpened"
        on-mousedown="_bringOverlayToFront"
        on-touchstart="_bringOverlayToFront"
        theme$="[[theme]]"
        modeless="[[modeless]]"
        with-backdrop="[[!modeless]]"
        resizable$="[[resizable]]"
        focus-trap
      ></vaadin-crud-dialog-overlay>
    `;
  }
};
customElements.define("vaadin-crud-dialog", CrudDialog);

// node_modules/@vaadin/grid/src/vaadin-grid-filter.js
var GridFilter = class extends class extends PolymerElement {
} {
  static get template() {
    return html`
      <style>
        :host {
          display: inline-flex;
          max-width: 100%;
        }

        #filter {
          width: 100%;
          box-sizing: border-box;
        }
      </style>
      <slot name="filter">
        <vaadin-text-field id="filter" value="{{value}}"></vaadin-text-field>
      </slot>
    `;
  }
  static get is() {
    return "vaadin-grid-filter";
  }
  static get properties() {
    return {
      path: String,
      value: {
        type: String,
        notify: true
      },
      _connected: Boolean
    };
  }
  connectedCallback() {
    super.connectedCallback();
    this._connected = true;
  }
  static get observers() {
    return ["_filterChanged(path, value, _connected)"];
  }
  ready() {
    super.ready();
    const child = this.firstElementChild;
    if (child && child.getAttribute("slot") !== "filter") {
      console.warn('Make sure you have assigned slot="filter" to the child elements of <vaadin-grid-filter>');
      child.setAttribute("slot", "filter");
    }
  }
  _filterChanged(path, value, connected) {
    if (path === void 0 || value === void 0 || !connected) {
      return;
    }
    if (this._previousValue === void 0 && value === "") {
      return;
    }
    this._previousValue = value;
    this._debouncerFilterChanged = Debouncer.debounce(this._debouncerFilterChanged, timeOut.after(200), () => {
      this.dispatchEvent(new CustomEvent("filter-changed", { bubbles: true }));
    });
  }
  focus() {
    this.$.filter.focus();
  }
};
customElements.define(GridFilter.is, GridFilter);

// node_modules/@vaadin/crud/src/vaadin-crud-include-mixin.js
var IncludedMixin = (superClass) => class IncludedMixin extends superClass {
  static get properties() {
    return {
      exclude: {
        value: "^_",
        observer: "__onExcludeChange"
      },
      include: {
        observer: "__onIncludeChange"
      }
    };
  }
  __onExcludeChange(exclude) {
    if (typeof exclude == "string") {
      this.exclude = exclude ? RegExp(exclude.replace(/, */g, "|"), "i") : void 0;
    }
  }
  __onIncludeChange(include) {
    if (typeof include == "string") {
      this.include = include ? include.split(/, */) : void 0;
    } else if (!this._fields && Array.isArray(include)) {
      const item = {};
      this.include.forEach((path) => this.__set(path, null, item));
      this._configure(item);
    }
  }
};

// node_modules/@vaadin/crud/src/vaadin-crud-grid.js
var CrudGrid = class extends IncludedMixin(Grid) {
  static get is() {
    return "vaadin-crud-grid";
  }
  static get properties() {
    return {
      noFilter: Boolean,
      noSort: Boolean,
      noHead: Boolean,
      __hideEditColumn: Boolean
    };
  }
  static get observers() {
    return ["__onItemsChange(items)", "__onHideEditColumnChange(hideEditColumn)"];
  }
  __onItemsChange(items) {
    if ((!this.dataProvider || this.dataProvider == this._arrayDataProvider) && !this.include && items && items[0]) {
      this._configure(items[0]);
    }
  }
  __onHideEditColumnChange() {
    if (this.firstChild) {
      this.__toggleEditColumn();
    }
  }
  __toggleEditColumn() {
    const el = this.querySelector("vaadin-crud-edit-column");
    if (this.hideEditColumn) {
      el && this.removeChild(el);
    } else if (!el) {
      this.appendChild(document.createElement("vaadin-crud-edit-column"));
    }
  }
  __dataProviderWrapper(params, callback) {
    this.__dataProvider(params, (items, size) => {
      if (this.innerHTML == "" && !this.include && items[0]) {
        this._configure(items[0]);
      }
      callback(items, size);
    });
  }
  _dataProviderChanged(dataProvider, oldDataProvider) {
    if (this._arrayDataProvider == dataProvider) {
      super._dataProviderChanged(dataProvider, oldDataProvider);
    } else if (this.__dataProviderWrapper != dataProvider) {
      this.innerHTML = "";
      this.__dataProvider = dataProvider;
      this.dataProvider = this.__dataProviderWrapper;
      super._dataProviderChanged(this.__dataProviderWrapper, oldDataProvider);
    }
  }
  _configure(item) {
    this.innerHTML = "";
    this.__createColumns(this, item, void 0, this.__getPropertyDepth(item));
    this.__toggleEditColumn();
  }
  __getPropertyDepth(object) {
    if (!object || typeof object !== "object") {
      return 0;
    }
    return Object.keys(object).reduce((deepest, prop) => {
      if (this.exclude && this.exclude.test(prop)) {
        return deepest;
      }
      return Math.max(deepest, 1 + this.__getPropertyDepth(object[prop]));
    }, 0);
  }
  _generateHeader(path) {
    return path.substr(path.lastIndexOf(".") + 1).replace(/([A-Z])/g, "-$1").toLowerCase().replace(/-/g, " ").replace(/^./, (match) => match.toUpperCase());
  }
  __createColumn(parent, path) {
    let col;
    if (!this.noFilter && !this.noSort && !parent.__sortColumnGroup) {
      col = this.__createGroup(parent);
      col.__sortColumnGroup = true;
      this.__createColumn(col, path);
    } else {
      col = document.createElement("vaadin-grid-column");
      parent.appendChild(col);
      col.renderer = (root, _column, model) => {
        root.textContent = path ? this.get(path, model.item) : model.item;
      };
    }
    if (!this.noHead && path) {
      col.headerRenderer = (root) => {
        if (root.firstElementChild) {
          return;
        }
        const label = this._generateHeader(path);
        if (col.__sortColumnGroup || this.noFilter && !this.noSort) {
          const sorter = document.createElement("vaadin-grid-sorter");
          sorter.setAttribute("path", path);
          sorter.setAttribute("aria-label", `Sort by ${label}`);
          sorter.textContent = label;
          root.appendChild(sorter);
        } else if (!this.noFilter) {
          const filter = document.createElement("vaadin-grid-filter");
          filter.setAttribute("path", path);
          filter.setAttribute("aria-label", `Filter by ${label}`);
          filter.style.display = "flex";
          const textField = window.document.createElement("vaadin-text-field");
          textField.setAttribute("theme", "small");
          textField.setAttribute("slot", "filter");
          textField.setAttribute("focus-target", true);
          textField.style.width = "100%";
          this.noSort && (textField.placeholder = label);
          textField.addEventListener("value-changed", function(event) {
            filter.value = event.detail.value;
          });
          filter.appendChild(textField);
          root.appendChild(filter);
        } else if (this.noSort && this.noFilter) {
          root.textContent = label;
        }
      };
    }
  }
  __createColumns(parent, object, path, depth) {
    if (object && typeof object === "object") {
      Object.keys(object).forEach((prop) => {
        if (!this.include && this.exclude && this.exclude.test(prop)) {
          return;
        }
        const subObject = object[prop];
        const subObjectPath = path ? `${path}.${prop}` : prop;
        let subObjectColumn = parent;
        if (!this.noHead && depth > 1) {
          const isSubObject = subObject && typeof subObject === "object";
          subObjectColumn = this.__createGroup(parent, isSubObject ? prop : void 0);
        }
        this.__createColumns(subObjectColumn, subObject, subObjectPath, depth - 1);
      });
    } else if (depth > 1) {
      this.__createColumns(this.__createGroup(parent), void 0, path, depth - 1);
    } else {
      this.__createColumn(parent, path);
    }
  }
  __createGroup(parent, header) {
    const grp = document.createElement("vaadin-grid-column-group");
    if (header) {
      grp.header = this.__capitalize(header);
    }
    parent.appendChild(grp);
    return grp;
  }
  __capitalize(path) {
    return path.toLowerCase().replace(/([^\w]+)/g, " ").trim().replace(/^./, (c) => c.toUpperCase());
  }
  __set(path, val, obj) {
    if (obj && path) {
      path.split(".").slice(0, -1).reduce((o, p) => o[p] = o[p] || {}, obj);
      this.set(path, val, obj);
    }
  }
};
customElements.define(CrudGrid.is, CrudGrid);

// node_modules/@vaadin/crud/src/vaadin-crud-form.js
var CrudForm = class extends IncludedMixin(FormLayout) {
  static get is() {
    return "vaadin-crud-form";
  }
  static get properties() {
    return {
      item: Object
    };
  }
  static get observers() {
    return ["__onItemChange(item)"];
  }
  _configure(object) {
    this.innerHTML = "";
    this._fields = [];
    this.__createFields(this, object);
    this._updateLayout();
  }
  __onItemChange(item) {
    if (!this._fields) {
      this._configure(item);
    }
  }
  __createField(parent, path) {
    const field = document.createElement("vaadin-text-field");
    field.label = this.__capitalize(path);
    field.path = path;
    field.required = true;
    parent.appendChild(field);
    this._fields.push(field);
    return field;
  }
  __createFields(parent, object, path) {
    Object.keys(object).forEach((prop) => {
      if (!this.include && this.exclude && this.exclude.test(prop)) {
        return;
      }
      const newPath = (path ? `${path}.` : "") + prop;
      if (object[prop] && typeof object[prop] === "object") {
        this.__createFields(parent, object[prop], newPath);
      } else {
        this.__createField(parent, newPath);
      }
    });
    if (!this._fields.length) {
      this._fields = void 0;
    }
  }
  __capitalize(path) {
    return path.toLowerCase().replace(/([^\w]+)/g, " ").trim().replace(/^./, (c) => c.toUpperCase());
  }
  __set(path, val, obj) {
    if (obj && path) {
      path.split(".").slice(0, -1).reduce((o, p) => o[p] = o[p] || {}, obj);
      this.set(path, val, obj);
    }
  }
};
customElements.define(CrudForm.is, CrudForm);

// node_modules/@vaadin/crud/src/vaadin-crud.js
var HOST_PROPS = {
  save: [{ attr: "disabled", prop: "__isDirty", parseProp: "__isSaveBtnDisabled" }, { prop: "i18n.saveItem" }],
  cancel: [{ prop: "i18n.cancel" }],
  delete: [{ attr: "hidden", prop: "__isNew", parseProp: (prop) => prop }, { prop: "i18n.deleteItem" }]
};
var Crud = class extends SlotMixin(ControllerMixin(ElementMixin(ThemableMixin(PolymerElement)))) {
  static get template() {
    return html`
      <style>
        :host {
          width: 100%;
          height: 400px;
          --vaadin-crud-editor-max-height: 40%;
          --vaadin-crud-editor-max-width: 40%;
        }

        :host,
        #main {
          display: flex;
          flex-direction: column;
          align-self: stretch;
          position: relative;
          overflow: hidden;
        }

        #main {
          flex: 1 1 100%;
          height: 100%;
        }

        :host([hidden]),
        [hidden] {
          display: none !important;
        }

        [part='toolbar'] {
          display: flex;
          flex-shrink: 0;
          align-items: baseline;
          justify-content: flex-end;
        }

        :host([no-toolbar]) [part='toolbar'] {
          display: none;
        }

        #container {
          display: flex;
          height: 100%;
        }

        :host([editor-position='bottom']) #container {
          flex-direction: column;
        }

        [part='editor'] {
          z-index: 1;
          display: flex;
          flex-direction: column;
          height: 100%;
        }

        :host(:not([editor-position=''])[editor-opened]:not([fullscreen])) [part='editor'] {
          flex: 1 0 100%;
        }

        :host([editor-position='bottom'][editor-opened]:not([fullscreen])) [part='editor'] {
          max-height: var(--vaadin-crud-editor-max-height);
        }

        :host([editor-position='aside'][editor-opened]:not([fullscreen])) [part='editor'] {
          min-width: 300px;
          max-width: var(--vaadin-crud-editor-max-width);
        }

        [part='scroller'] {
          display: flex;
          flex-direction: column;
          overflow: auto;
          flex: auto;
        }

        [part='footer'] {
          display: flex;
          flex: none;
          flex-direction: row-reverse;
        }
      </style>

      <div id="container">
        <div id="main">
          <slot name="grid">
            <vaadin-crud-grid
              theme$="[[theme]]"
              id="grid"
              include="[[include]]"
              exclude="[[exclude]]"
              no-sort="[[noSort]]"
              no-filter="[[noFilter]]"
              no-head="[[noHead]]"
              hide-edit-column="[[editOnClick]]"
            ></vaadin-crud-grid>
          </slot>

          <div id="toolbar" part="toolbar" on-click="__new">
            <slot name="toolbar">
              <vaadin-button new-button="" id="new" theme="primary">[[i18n.newItem]]</vaadin-button>
            </slot>
          </div>
        </div>

        <div id="editor" part="editor" hidden$="[[__computeEditorHidden(editorOpened, _fullscreen, editorPosition)]]">
          <div part="scroller" id="scroller" role="group" aria-labelledby="header">
            <div part="header" id="header">
              <slot name="header"></slot>
            </div>
            <slot name="form"></slot>
          </div>

          <div part="footer" role="toolbar">
            <slot name="save-button"></slot>
            <slot name="cancel-button"></slot>
            <slot name="delete-button"></slot>
          </div>
        </div>
      </div>

      <vaadin-crud-dialog
        id="dialog"
        opened="[[__computeDialogOpened(editorOpened, _fullscreen, editorPosition)]]"
        aria-label="[[__editorAriaLabel]]"
        no-close-on-outside-click="[[__isDirty]]"
        no-close-on-esc="[[__isDirty]]"
        theme$="[[theme]]"
        on-opened-changed="__onDialogOpened"
      ></vaadin-crud-dialog>

      <vaadin-confirm-dialog
        theme$="[[theme]]"
        id="confirmCancel"
        on-confirm="__confirmCancel"
        cancel
        confirm-text="[[i18n.confirm.cancel.button.confirm]]"
        cancel-text="[[i18n.confirm.cancel.button.dismiss]]"
        header="[[i18n.confirm.cancel.title]]"
        message="[[i18n.confirm.cancel.content]]"
        confirm-theme="primary"
      ></vaadin-confirm-dialog>

      <vaadin-confirm-dialog
        theme$="[[theme]]"
        id="confirmDelete"
        on-confirm="__confirmDelete"
        cancel
        confirm-text="[[i18n.confirm.delete.button.confirm]]"
        cancel-text="[[i18n.confirm.delete.button.dismiss]]"
        header="[[i18n.confirm.delete.title]]"
        message="[[i18n.confirm.delete.content]]"
        confirm-theme="primary error"
      ></vaadin-confirm-dialog>
    `;
  }
  static get is() {
    return "vaadin-crud";
  }
  static get properties() {
    return {
      _grid: {
        type: HTMLElement,
        observer: "__onGridChange"
      },
      _form: {
        type: HTMLElement,
        observer: "__onFormChange"
      },
      _saveButton: {
        type: HTMLElement,
        observer: "__onSaveButtonChange"
      },
      _deleteButton: {
        type: HTMLElement,
        observer: "__onDeleteButtonChange"
      },
      _cancelButton: {
        type: HTMLElement,
        observer: "__onCancelButtonChange"
      },
      _headerNode: {
        type: HTMLElement
      },
      items: {
        type: Array,
        notify: true,
        observer: "__onItemsChange"
      },
      editedItem: {
        type: Object,
        observer: "__onItemChange",
        notify: true
      },
      editorPosition: {
        type: String,
        value: "",
        reflectToAttribute: true,
        observer: "__onEditorPositionChange"
      },
      editOnClick: {
        type: Boolean,
        value: false
      },
      dataProvider: {
        type: Function,
        observer: "__onDataProviderChange"
      },
      noFilter: Boolean,
      noSort: Boolean,
      noHead: Boolean,
      include: String,
      exclude: String,
      editorOpened: {
        type: Boolean,
        reflectToAttribute: true,
        notify: true,
        observer: "__onOpenedChanged"
      },
      size: {
        type: Number,
        readOnly: true,
        notify: true
      },
      noToolbar: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      i18n: {
        type: Object,
        value: function() {
          return {
            newItem: "New item",
            editItem: "Edit item",
            saveItem: "Save",
            cancel: "Cancel",
            deleteItem: "Delete...",
            editLabel: "Edit",
            confirm: {
              delete: {
                title: "Delete item",
                content: "Are you sure you want to delete this item? This action cannot be undone.",
                button: {
                  confirm: "Delete",
                  dismiss: "Cancel"
                }
              },
              cancel: {
                title: "Discard changes",
                content: "There are unsaved changes to this item.",
                button: {
                  confirm: "Discard",
                  dismiss: "Cancel"
                }
              }
            }
          };
        }
      },
      __editorAriaLabel: String,
      __isDirty: Boolean,
      __isNew: Boolean,
      _fullscreen: {
        type: Boolean,
        observer: "__fullscreenChanged"
      },
      _fullscreenMediaQuery: {
        value: "(max-width: 600px), (max-height: 600px)"
      }
    };
  }
  static get observers() {
    return [
      "__headerNodeChanged(_headerNode, __isNew, i18n.newItem, i18n.editItem)",
      "__formChanged(_form, theme, include, exclude)",
      "__onI18Change(i18n, _grid)",
      "__onEditOnClickChange(editOnClick, _grid)",
      "__hostPropsChanged(" + HOST_PROPS.save.map(({ prop }) => prop).join(",") + "," + HOST_PROPS.cancel.map(({ prop }) => prop).join(",") + "," + HOST_PROPS.delete.map(({ prop }) => prop).join(",") + ")"
    ];
  }
  static _finalizeClass() {
    super._finalizeClass();
    const devModeCallback = window.Vaadin.developmentModeCallback;
    const licenseChecker = devModeCallback && devModeCallback["vaadin-license-checker"];
    if (typeof licenseChecker === "function") {
      licenseChecker(Crud);
    }
  }
  get slots() {
    return __spreadProps(__spreadValues({}, super.slots), {
      header: () => {
        return document.createElement("h3");
      },
      form: () => {
        return document.createElement("vaadin-crud-form");
      },
      "save-button": () => {
        const button = document.createElement("vaadin-button");
        button.id = "save";
        button.setAttribute("theme", "primary");
        return button;
      },
      "cancel-button": () => {
        const button = document.createElement("vaadin-button");
        button.id = "cancel";
        button.setAttribute("theme", "tertiary");
        return button;
      },
      "delete-button": () => {
        const button = document.createElement("vaadin-button");
        button.id = "delete";
        button.setAttribute("theme", "tertiary error");
        return button;
      }
    });
  }
  constructor() {
    super();
    this._observer = new FlattenedNodesObserver(this, (info) => {
      this.__onDomChange(info.addedNodes);
    });
  }
  ready() {
    super.ready();
    this.__editListener = (e) => this.__onCrudGridEdit(e);
    this.__changeListener = (e) => this.__onFormChanges(e);
    this.__saveBound = this.__save.bind(this);
    this.__cancelBound = this.__cancel.bind(this);
    this.__deleteBound = this.__delete.bind(this);
    this.__gridSizeListener = this.__onGridSizeChanges.bind(this);
    this.__boundEditOnClickListener = this.__editOnClickListener.bind(this);
    this._grid = this.$.grid;
    this.$.dialog.$.overlay.addEventListener("vaadin-overlay-outside-click", this.__cancelBound);
    this.$.dialog.$.overlay.addEventListener("vaadin-overlay-escape-press", this.__cancelBound);
    this.__propagateHostAttributes();
    this.addController(new MediaQueryController(this._fullscreenMediaQuery, (matches) => {
      this._fullscreen = matches;
    }));
  }
  __isSaveBtnDisabled(isDirty) {
    return !isDirty;
  }
  __headerNodeChanged(headerNode, isNew, newItem, editItem) {
    if (headerNode) {
      headerNode.textContent = isNew ? newItem : editItem;
    }
  }
  __formChanged(form, theme, include, exclude) {
    if (form) {
      form.include = include;
      form.exclude = exclude;
      form.setAttribute("theme", theme);
    }
  }
  __onI18Change(i18n, grid) {
    if (!grid) {
      return;
    }
    afterNextRender(grid, () => {
      Array.from(grid.querySelectorAll("vaadin-crud-edit-column")).forEach((column) => {
        column.ariaLabel = i18n.editLabel;
      });
    });
  }
  __onEditorPositionChange(editorPosition) {
    if (Crud._isValidEditorPosition(editorPosition)) {
      return;
    }
    this.editorPosition = "";
  }
  static _isValidEditorPosition(editorPosition) {
    return ["bottom", "aside"].indexOf(editorPosition) != -1;
  }
  __onOpenedChanged(opened, old) {
    if (!opened && old) {
      this.__closeEditor();
    } else {
      this.__onFormChange(this._form);
    }
    if (opened) {
      this.__ensureChildren();
    }
    this.__toggleToolbar();
    this.$.scroller.scrollTop = 0;
  }
  __fullscreenChanged(fullscreen, oldFullscreen) {
    if (fullscreen || oldFullscreen) {
      this.__toggleToolbar();
      this.__ensureChildren();
      this.toggleAttribute("fullscreen", fullscreen);
      this.$.dialog.$.overlay.toggleAttribute("fullscreen", fullscreen);
    }
  }
  __toggleToolbar() {
    if (this.editorPosition === "bottom" && !this._fullscreen) {
      this.$.toolbar.style.display = this.editorOpened ? "none" : "";
    }
  }
  __moveChildNodes(target) {
    const nodes = [this._headerNode, this._form, this._saveButton, this._cancelButton, this._deleteButton];
    if (!nodes.every((node) => node instanceof HTMLElement)) {
      return;
    }
    nodes.forEach((node) => {
      target.appendChild(node);
    });
    setTimeout(() => {
      this.__dialogAriaLabel = this._headerNode.textContent.trim();
    });
  }
  __shouldOpenDialog(fullscreen, editorPosition) {
    return editorPosition === "" || fullscreen;
  }
  __ensureChildren() {
    if (this.__shouldOpenDialog(this._fullscreen, this.editorPosition)) {
      this.__moveChildNodes(this.$.dialog.$.overlay);
    } else {
      this.__moveChildNodes(this);
    }
  }
  __computeDialogOpened(opened, fullscreen, editorPosition) {
    return this.__shouldOpenDialog(fullscreen, editorPosition) ? opened : false;
  }
  __computeEditorHidden(opened, fullscreen, editorPosition) {
    if (["aside", "bottom"].includes(editorPosition) && !fullscreen) {
      return !opened;
    }
    return true;
  }
  __onDialogOpened(event) {
    this.editorOpened = event.detail.value;
  }
  __onDomChange(addedNodes) {
    addedNodes.filter((node) => node.nodeType === Node.ELEMENT_NODE).forEach((node) => {
      const slotAttributeValue = node.getAttribute("slot");
      if (!slotAttributeValue) {
        return;
      }
      if (slotAttributeValue == "grid") {
        this.__onEditOnClickChange(false, this._grid);
        this._grid = node;
        this.__onEditOnClickChange(this.editOnClick, this._grid);
      } else if (slotAttributeValue == "form") {
        this._form = node;
      } else if (slotAttributeValue.indexOf("button") >= 0) {
        const [button] = slotAttributeValue.split("-");
        this[`_${button}Button`] = node;
      } else if (slotAttributeValue == "header") {
        this._headerNode = node;
      }
    });
  }
  __onCrudGridEdit(e) {
    e.stopPropagation();
    this.__confirmBeforeChangingEditedItem(e.detail.item);
  }
  __onFormChanges() {
    this.__isDirty = true;
  }
  __onGridSizeChanges() {
    this._setSize(this._grid.size);
  }
  __onGridChange(grid, old) {
    if (old) {
      old.removeEventListener("edit", this.__editListener);
      old.removeEventListener("size-changed", this.__gridSizeListener);
    }
    if (this.items) {
      this.__onItemsChange(this.items);
    }
    if (this.editedItem) {
      this.__onItemChange(this.editedItem);
    }
    grid.addEventListener("edit", this.__editListener);
    grid.addEventListener("size-changed", this.__gridSizeListener);
    this.__onGridSizeChanges();
  }
  __onFormChange(form, old) {
    if (old && old.parentElement) {
      old.parentElement && old.parentElement.removeChild(old);
      old.removeEventListener("change", this.__changeListener);
      old.removeEventListener("input", this.__changeListener);
    }
    if (!form) {
      return;
    }
    if (this.items) {
      this.__onItemsChange(this.items);
    }
    if (this.editedItem) {
      this.__onItemChange(this.editedItem);
    }
    form.addEventListener("change", this.__changeListener);
    form.addEventListener("input", this.__changeListener);
  }
  __onSaveButtonChange(save, old) {
    this.__setupSlottedButton(save, old, this.__saveBound);
  }
  __onDeleteButtonChange(deleteButton, old) {
    this.__setupSlottedButton(deleteButton, old, this.__deleteBound);
  }
  __onCancelButtonChange(cancel, old) {
    this.__setupSlottedButton(cancel, old, this.__cancelBound);
  }
  __setupSlottedButton(slottedButton, currentButton, clickListener) {
    if (currentButton && currentButton.parentElement) {
      currentButton.parentElement.removeChild(currentButton);
    }
    slottedButton.addEventListener("click", clickListener);
  }
  __hostPropsChanged() {
    this.__propagateHostAttributes();
  }
  __propagateHostAttributes() {
    this.__propagateHostAttributesToButton(this._saveButton, HOST_PROPS.save);
    this.__propagateHostAttributesToButton(this._cancelButton, HOST_PROPS.cancel);
    this.__propagateHostAttributesToButton(this._deleteButton, HOST_PROPS.delete);
  }
  __propagateHostAttributesToButton(button, props) {
    if (button) {
      props.forEach(({ attr, prop, parseProp }) => {
        if (prop.indexOf("i18n") >= 0) {
          button.textContent = this.i18n[prop.split(".")[1]];
        } else {
          if (typeof parseProp === "string") {
            this._setOrToggleAttribute(attr, this[parseProp](this[prop]), button);
            return;
          }
          this._setOrToggleAttribute(attr, parseProp(this[prop]), button);
        }
      });
    }
  }
  _setOrToggleAttribute(name, value, node) {
    if (!name || !node) {
      return;
    }
    if (value) {
      node.setAttribute(name, typeof value === "boolean" ? "" : value);
    } else {
      node.removeAttribute(name);
    }
  }
  __onDataProviderChange(dataProvider) {
    if (this._grid) {
      this._grid.dataProvider = this.__createDataProviderProxy(dataProvider);
    }
  }
  __onEditOnClickChange(rowToEditChange, _grid) {
    if (!_grid) {
      return;
    }
    if (rowToEditChange) {
      _grid.addEventListener("active-item-changed", this.__boundEditOnClickListener);
    } else {
      _grid.removeEventListener("active-item-changed", this.__boundEditOnClickListener);
    }
  }
  __editOnClickListener(event) {
    const item = event.detail.value;
    if (this.editorOpened && this.__isDirty) {
      this.__confirmBeforeChangingEditedItem(item);
      return;
    }
    if (item) {
      this.__edit(item);
    } else if (!this.__keepOpened) {
      this.__closeEditor();
    }
  }
  __confirmBeforeChangingEditedItem(item, keepOpened) {
    if (this.editorOpened && this.__isDirty && this.editedItem !== item) {
      this.$.confirmCancel.opened = true;
      const listenOnce = (event) => {
        event.preventDefault();
        if (item || keepOpened) {
          this.__edit(item);
          this.__clearItemAndKeepEditorOpened(item, keepOpened);
        } else {
          this.__closeEditor();
        }
        this.removeEventListener("cancel", listenOnce);
      };
      this.addEventListener("cancel", listenOnce);
    } else {
      this.__edit(item);
      this.__clearItemAndKeepEditorOpened(item, keepOpened);
    }
  }
  __clearItemAndKeepEditorOpened(item, keepOpened) {
    if (!item) {
      setTimeout(() => {
        this.__keepOpened = keepOpened;
        this.editedItem = this._grid.activeItem = void 0;
      });
    }
  }
  __createDataProviderProxy(dataProvider) {
    return (params, callback) => {
      const callbackProxy = (chunk, size) => {
        if (chunk && chunk[0]) {
          this.__model = chunk[0];
        }
        callback(chunk, size);
      };
      dataProvider(params, callbackProxy);
    };
  }
  __onItemsChange(items) {
    if (this.items && this.items[0]) {
      this.__model = items[0];
    }
    if (this._grid) {
      this._grid.items = items;
    }
  }
  __onItemChange(item) {
    if (!this._form) {
      return;
    }
    if (item) {
      if (!this._fields.length && this._form._configure) {
        if (this.__model) {
          this._form._configure(this.__model);
        } else {
          console.warn("<vaadin-crud> Unable to autoconfigure form because the data structure is unknown. Either specify `include` or ensure at least one item is available beforehand.");
        }
      }
      this._form.item = item;
      this._fields.forEach((e) => {
        const path = e.path || e.getAttribute("path");
        path && (e.value = this.get(path, item));
      });
      this.__isNew = this.__isNew || this.items && this.items.indexOf(item) < 0;
      this.editorOpened = true;
    }
  }
  get _fields() {
    if (!this.__fields || !this.__fields.length) {
      this.__fields = Array.from(this._form.querySelectorAll("*")).filter((e) => e.validate || e.checkValidity);
    }
    return this.__fields;
  }
  __validate() {
    return this._fields.every((e) => (e.validate || e.checkValidity).call(e));
  }
  __setHighlightedItem(item) {
    if (this._grid === this.$.grid) {
      this._grid.selectedItems = item ? [item] : [];
    }
  }
  __closeEditor() {
    this.editorOpened = false;
    this.__isDirty = false;
    this.__setHighlightedItem(null);
    setTimeout(() => this.__clearItemAndKeepEditorOpened(null, false));
  }
  __new(event) {
    if (event.composedPath().filter((e) => e.nodeType == 1 && e.hasAttribute("new-button"))[0]) {
      this.__confirmBeforeChangingEditedItem(null, true);
    }
  }
  __edit(item) {
    if (this.editedItem === item) {
      return;
    }
    this.__setHighlightedItem(item);
    this.__openEditor("edit", item);
  }
  __openEditor(type, item) {
    this.__isDirty = false;
    this.__isNew = !item;
    const evt = this.dispatchEvent(new CustomEvent(this.__isNew ? "new" : "edit", { detail: { item }, cancelable: true }));
    if (evt) {
      this.editedItem = item || {};
    } else {
      this.editorOpened = true;
    }
  }
  __save() {
    if (!this.__validate()) {
      return;
    }
    const item = __spreadValues({}, this.editedItem);
    this._fields.forEach((e) => {
      const path = e.path || e.getAttribute("path");
      path && this.__set(path, e.value, item);
    });
    const evt = this.dispatchEvent(new CustomEvent("save", { detail: { item }, cancelable: true }));
    if (evt) {
      if (this.__isNew && !this.dataProvider) {
        if (!this.items) {
          this.items = [item];
        } else {
          this.items.push(item);
        }
      } else {
        Object.assign(this.editedItem, item);
      }
      this._grid.clearCache();
      this.__closeEditor();
    }
  }
  __cancel() {
    if (this.__isDirty) {
      this.$.confirmCancel.opened = true;
    } else {
      this.__confirmCancel();
    }
  }
  __confirmCancel() {
    const evt = this.dispatchEvent(new CustomEvent("cancel", { detail: { item: this.editedItem }, cancelable: true }));
    if (evt) {
      this.__closeEditor();
    }
  }
  __delete() {
    this.$.confirmDelete.opened = true;
  }
  __confirmDelete() {
    const evt = this.dispatchEvent(new CustomEvent("delete", { detail: { item: this.editedItem }, cancelable: true }));
    if (evt) {
      if (this.items && this.items.indexOf(this.editedItem) >= 0) {
        this.items.splice(this.items.indexOf(this.editedItem), 1);
      }
      this._grid.clearCache();
      this.__closeEditor();
    }
  }
  __set(path, val, obj) {
    if (obj && path) {
      path.split(".").slice(0, -1).reduce((o, p) => o[p] = o[p] || {}, obj);
      this.set(path, val, obj);
    }
  }
};
customElements.define(Crud.is, Crud);
/**
 * @license
 * Copyright (c) 2016 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
/**
 * @license
 * Copyright (c) 2018 - 2022 Vaadin Ltd.
 * This program is available under Commercial Vaadin Developer License 4.0, available at https://vaadin.com/license/cvdl-4.0.
 */
//# sourceMappingURL=@vaadin_crud_theme_lumo_vaadin-crud_js.js.map
