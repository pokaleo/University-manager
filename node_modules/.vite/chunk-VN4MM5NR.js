import {
  DomIf
} from "./chunk-KAVQBH4L.js";
import {
  ResizeMixin
} from "./chunk-WCV6MGXN.js";
import {
  DomRepeat
} from "./chunk-IZT3AP6L.js";
import {
  ElementMixin
} from "./chunk-OKCEHAIA.js";
import {
  PolymerElement,
  html
} from "./chunk-EMDRMWGL.js";

// node_modules/@vaadin/board/src/vaadin-board-row.js
var CLASSES = {
  SMALL: "small",
  MEDIUM: "medium",
  LARGE: "large"
};
var BoardRow = class extends ResizeMixin(ElementMixin(PolymerElement)) {
  static get template() {
    return html`
      <style>
        :host {
          display: flex;
          flex-flow: row wrap;
          align-items: stretch;
          --small-size: var(--vaadin-board-width-small, 600px);
          --medium-size: var(--vaadin-board-width-medium, 960px);
        }

        :host ::slotted(*) {
          box-sizing: border-box;
          flex-grow: 1;
          overflow: hidden;
        }
      </style>
      <slot id="insertionPoint"></slot>
    `;
  }
  static get is() {
    return "vaadin-board-row";
  }
  constructor() {
    super();
    this._oldWidth = 0;
    this._oldBreakpoints = { smallSize: 600, mediumSize: 960 };
    this._oldFlexBasis = [];
  }
  ready() {
    super.ready();
    this.$.insertionPoint.addEventListener("slotchange", () => this.redraw());
  }
  connectedCallback() {
    super.connectedCallback();
    this._onResize();
  }
  _addStyleNames(width, breakpoints) {
    if (width < breakpoints.smallSize) {
      this.classList.add(CLASSES.SMALL);
      this.classList.remove(CLASSES.MEDIUM);
      this.classList.remove(CLASSES.LARGE);
    } else if (width < breakpoints.mediumSize) {
      this.classList.remove(CLASSES.SMALL);
      this.classList.add(CLASSES.MEDIUM);
      this.classList.remove(CLASSES.LARGE);
    } else {
      this.classList.remove(CLASSES.SMALL);
      this.classList.remove(CLASSES.MEDIUM);
      this.classList.add(CLASSES.LARGE);
    }
  }
  _calculateFlexBasis(colSpan, width, colsInRow, breakpoints) {
    if (width < breakpoints.smallSize) {
      colsInRow = 1;
    } else if (width < breakpoints.mediumSize && colsInRow == 4) {
      colsInRow = 2;
    }
    let flexBasis = colSpan / colsInRow * 100;
    flexBasis = flexBasis > 100 ? 100 : flexBasis;
    return flexBasis + "%";
  }
  _reportError() {
    const errorMessage = "The column configuration is not valid; column count should add up to 3 or 4.";
    console.warn(errorMessage, "check: \r\n" + this.outerHTML);
  }
  _parseBoardCols(nodes) {
    const boardCols = nodes.map((node) => {
      if (node.getAttribute("board-cols")) {
        return parseInt(node.getAttribute("board-cols"));
      }
      return 1;
    });
    let spaceLeft = 4;
    let returnBoardCols = [];
    nodes.forEach((node, i) => {
      spaceLeft -= boardCols[i];
    });
    if (spaceLeft < 0) {
      this._reportError();
      boardCols.forEach((node, i) => {
        returnBoardCols[i] = 1;
      });
    } else {
      returnBoardCols = boardCols.slice(0);
    }
    return returnBoardCols;
  }
  _removeExtraNodesFromDOM(boardCols, nodes) {
    let isErrorReported = false;
    let spaceLeft = 4;
    const returnNodes = [];
    nodes.forEach((node, i) => {
      spaceLeft -= boardCols[i];
      if (spaceLeft < 0) {
        if (!isErrorReported) {
          isErrorReported = true;
          this._reportError();
        }
        this.removeChild(node);
      } else {
        returnNodes[i] = node;
      }
    });
    return returnNodes;
  }
  redraw() {
    this._recalculateFlexBasis(true);
  }
  _onResize() {
    this._recalculateFlexBasis(false);
  }
  _recalculateFlexBasis(forceResize) {
    const width = this.getBoundingClientRect().width;
    const breakpoints = this._measureBreakpointsInPx();
    if (forceResize || width != this._oldWidth || breakpoints.smallSize != this._oldBreakpoints.smallSize || breakpoints.mediumSize != this._oldBreakpoints.mediumSize) {
      const nodes = this.$.insertionPoint.assignedNodes({ flatten: true });
      const isElementNode = (node) => {
        return !(node.nodeType === node.TEXT_NODE || node instanceof DomRepeat || node instanceof DomIf);
      };
      const filteredNodes = nodes.filter(isElementNode);
      this._addStyleNames(width, breakpoints);
      const boardCols = this._parseBoardCols(filteredNodes);
      const colsInRow = boardCols.reduce((a, b) => a + b, 0);
      this._removeExtraNodesFromDOM(boardCols, filteredNodes).forEach((e, i) => {
        const newFlexBasis = this._calculateFlexBasis(boardCols[i], width, colsInRow, breakpoints);
        if (forceResize || !this._oldFlexBasis[i] || this._oldFlexBasis[i] != newFlexBasis) {
          this._oldFlexBasis[i] = newFlexBasis;
          e.style.flexBasis = newFlexBasis;
        }
      });
      this._oldWidth = width;
      this._oldBreakpoints = breakpoints;
    }
  }
  _measureBreakpointsInPx() {
    const breakpoints = {};
    const tmpStyleProp = "background-position";
    const smallSize = getComputedStyle(this).getPropertyValue("--small-size");
    const mediumSize = getComputedStyle(this).getPropertyValue("--medium-size");
    this.style.setProperty(tmpStyleProp, smallSize);
    breakpoints.smallSize = parseFloat(getComputedStyle(this).getPropertyValue(tmpStyleProp));
    this.style.setProperty(tmpStyleProp, mediumSize);
    breakpoints.mediumSize = parseFloat(getComputedStyle(this).getPropertyValue(tmpStyleProp));
    this.style.removeProperty(tmpStyleProp);
    return breakpoints;
  }
};
customElements.define(BoardRow.is, BoardRow);

export {
  BoardRow
};
/**
 * @license
 * Copyright (c) 2017 - 2022 Vaadin Ltd.
 * This program is available under Commercial Vaadin Developer License 4.0, available at https://vaadin.com/license/cvdl-4.0.
 */
//# sourceMappingURL=chunk-VN4MM5NR.js.map
