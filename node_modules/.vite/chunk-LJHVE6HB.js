import {
  processTemplates
} from "./chunk-VPQC7TEI.js";
import {
  OverlayElement
} from "./chunk-BPZR2M5B.js";
import {
  overlay
} from "./chunk-7N2APOXI.js";
import {
  isTouch
} from "./chunk-2GZ522BV.js";
import {
  ThemePropertyMixin,
  registerStyles
} from "./chunk-PALO6AVQ.js";
import {
  ElementMixin
} from "./chunk-OKCEHAIA.js";
import {
  css
} from "./chunk-PYLEJJK2.js";
import {
  PolymerElement,
  html
} from "./chunk-EMDRMWGL.js";
import {
  __spreadValues
} from "./chunk-KTZKXPFA.js";

// node_modules/@vaadin/dialog/theme/lumo/vaadin-dialog-styles.js
var dialogOverlay = css`
  /* Optical centering */
  :host::before,
  :host::after {
    content: '';
    flex-basis: 0;
    flex-grow: 1;
  }

  :host::after {
    flex-grow: 1.1;
  }

  [part='overlay'] {
    border-radius: var(--lumo-border-radius-l);
    box-shadow: 0 0 0 1px var(--lumo-shade-5pct), var(--lumo-box-shadow-xl);
    background-image: none;
    outline: none;
    -webkit-tap-highlight-color: transparent;
  }

  [part='content'] {
    padding: var(--lumo-space-l);
  }

  /* No padding */
  :host([theme~='no-padding']) [part='content'] {
    padding: 0;
  }

  /* Animations */

  :host([opening]),
  :host([closing]) {
    animation: 0.25s lumo-overlay-dummy-animation;
  }

  :host([opening]) [part='overlay'] {
    animation: 0.12s 0.05s vaadin-dialog-enter cubic-bezier(0.215, 0.61, 0.355, 1) both;
  }

  @keyframes vaadin-dialog-enter {
    0% {
      opacity: 0;
      transform: scale(0.95);
    }
  }

  :host([closing]) [part='overlay'] {
    animation: 0.1s 0.03s vaadin-dialog-exit cubic-bezier(0.55, 0.055, 0.675, 0.19) both;
  }

  :host([closing]) [part='backdrop'] {
    animation-delay: 0.05s;
  }

  @keyframes vaadin-dialog-exit {
    100% {
      opacity: 0;
      transform: scale(1.02);
    }
  }
`;
registerStyles("vaadin-dialog-overlay", [overlay, dialogOverlay], { moduleId: "lumo-dialog" });

// node_modules/@vaadin/dialog/src/vaadin-dialog-utils.js
function getMouseOrFirstTouchEvent(e) {
  return e.touches ? e.touches[0] : e;
}
function eventInWindow(e) {
  return e.clientX >= 0 && e.clientX <= window.innerWidth && e.clientY >= 0 && e.clientY <= window.innerHeight;
}

// node_modules/@vaadin/dialog/src/vaadin-dialog-draggable-mixin.js
var DialogDraggableMixin = (superClass) => class VaadinDialogDraggableMixin extends superClass {
  static get properties() {
    return {
      draggable: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      _touchDevice: {
        type: Boolean,
        value: isTouch
      },
      __dragHandleClassName: {
        type: String
      }
    };
  }
  ready() {
    super.ready();
    this._originalBounds = {};
    this._originalMouseCoords = {};
    this._startDrag = this._startDrag.bind(this);
    this._drag = this._drag.bind(this);
    this._stopDrag = this._stopDrag.bind(this);
    this.$.overlay.$.overlay.addEventListener("mousedown", this._startDrag);
    this.$.overlay.$.overlay.addEventListener("touchstart", this._startDrag);
  }
  _startDrag(e) {
    if (e.type === "touchstart" && e.touches.length > 1) {
      return;
    }
    if (this.draggable && (e.button === 0 || e.touches)) {
      const resizerContainer = this.$.overlay.$.resizerContainer;
      const isResizerContainer = e.target === resizerContainer;
      const isResizerContainerScrollbar = e.offsetX > resizerContainer.clientWidth || e.offsetY > resizerContainer.clientHeight;
      const isContentPart = e.target === this.$.overlay.$.content;
      const isDraggable = e.composedPath().some((node, index) => {
        if (!node.classList) {
          return false;
        }
        const isDraggableNode = node.classList.contains(this.__dragHandleClassName || "draggable");
        const isDraggableLeafOnly = node.classList.contains("draggable-leaf-only");
        const isLeafNode = index === 0;
        return isDraggableLeafOnly && isLeafNode || isDraggableNode && (!isDraggableLeafOnly || isLeafNode);
      });
      if (isResizerContainer && !isResizerContainerScrollbar || isContentPart || isDraggable) {
        !isDraggable && e.preventDefault();
        this._originalBounds = this.$.overlay.getBounds();
        const event = getMouseOrFirstTouchEvent(e);
        this._originalMouseCoords = { top: event.pageY, left: event.pageX };
        window.addEventListener("mouseup", this._stopDrag);
        window.addEventListener("touchend", this._stopDrag);
        window.addEventListener("mousemove", this._drag);
        window.addEventListener("touchmove", this._drag);
        if (this.$.overlay.$.overlay.style.position !== "absolute") {
          this.$.overlay.setBounds(this._originalBounds);
        }
      }
    }
  }
  _drag(e) {
    const event = getMouseOrFirstTouchEvent(e);
    if (eventInWindow(event)) {
      const top = this._originalBounds.top + (event.pageY - this._originalMouseCoords.top);
      const left = this._originalBounds.left + (event.pageX - this._originalMouseCoords.left);
      this.$.overlay.setBounds({ top, left });
    }
  }
  _stopDrag() {
    window.removeEventListener("mouseup", this._stopDrag);
    window.removeEventListener("touchend", this._stopDrag);
    window.removeEventListener("mousemove", this._drag);
    window.removeEventListener("touchmove", this._drag);
  }
};

// node_modules/@vaadin/dialog/src/vaadin-dialog-resizable-mixin.js
registerStyles("vaadin-dialog-overlay", css`
    [part='overlay'] {
      position: relative;
      overflow: visible;
      max-height: 100%;
      display: flex;
    }

    [part='content'] {
      box-sizing: border-box;
      height: 100%;
    }

    .resizer-container {
      overflow: auto;
      flex-grow: 1;
    }

    [part='overlay'][style] .resizer-container {
      min-height: 100%;
      width: 100%;
    }

    :host(:not([resizable])) .resizer {
      display: none;
    }

    .resizer {
      position: absolute;
      height: 16px;
      width: 16px;
    }

    .resizer.edge {
      height: 8px;
      width: 8px;
      top: -4px;
      right: -4px;
      bottom: -4px;
      left: -4px;
    }

    .resizer.edge.n {
      width: auto;
      bottom: auto;
      cursor: ns-resize;
    }

    .resizer.ne {
      top: -4px;
      right: -4px;
      cursor: nesw-resize;
    }

    .resizer.edge.e {
      height: auto;
      left: auto;
      cursor: ew-resize;
    }

    .resizer.se {
      bottom: -4px;
      right: -4px;
      cursor: nwse-resize;
    }

    .resizer.edge.s {
      width: auto;
      top: auto;
      cursor: ns-resize;
    }

    .resizer.sw {
      bottom: -4px;
      left: -4px;
      cursor: nesw-resize;
    }

    .resizer.edge.w {
      height: auto;
      right: auto;
      cursor: ew-resize;
    }

    .resizer.nw {
      top: -4px;
      left: -4px;
      cursor: nwse-resize;
    }
  `, { moduleId: "vaadin-dialog-resizable-overlay-styles" });
var DialogResizableMixin = (superClass) => class VaadinDialogResizableMixin extends superClass {
  static get properties() {
    return {
      resizable: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      }
    };
  }
  ready() {
    super.ready();
    this._originalBounds = {};
    this._originalMouseCoords = {};
    this._resizeListeners = { start: {}, resize: {}, stop: {} };
    this._addResizeListeners();
  }
  _addResizeListeners() {
    ["n", "e", "s", "w", "nw", "ne", "se", "sw"].forEach((direction) => {
      const resizer = document.createElement("div");
      this._resizeListeners.start[direction] = (e) => this._startResize(e, direction);
      this._resizeListeners.resize[direction] = (e) => this._resize(e, direction);
      this._resizeListeners.stop[direction] = () => this._stopResize(direction);
      if (direction.length === 1) {
        resizer.classList.add("edge");
      }
      resizer.classList.add("resizer");
      resizer.classList.add(direction);
      resizer.addEventListener("mousedown", this._resizeListeners.start[direction]);
      resizer.addEventListener("touchstart", this._resizeListeners.start[direction]);
      this.$.overlay.$.resizerContainer.appendChild(resizer);
    });
  }
  _startResize(e, direction) {
    if (e.type === "touchstart" && e.touches.length > 1) {
      return;
    }
    if (e.button === 0 || e.touches) {
      e.preventDefault();
      this._originalBounds = this.$.overlay.getBounds();
      const event = getMouseOrFirstTouchEvent(e);
      this._originalMouseCoords = { top: event.pageY, left: event.pageX };
      window.addEventListener("mousemove", this._resizeListeners.resize[direction]);
      window.addEventListener("touchmove", this._resizeListeners.resize[direction]);
      window.addEventListener("mouseup", this._resizeListeners.stop[direction]);
      window.addEventListener("touchend", this._resizeListeners.stop[direction]);
      if (this.$.overlay.$.overlay.style.position !== "absolute") {
        this.$.overlay.setBounds(this._originalBounds);
      }
    }
  }
  _resize(e, resizer) {
    const event = getMouseOrFirstTouchEvent(e);
    if (eventInWindow(event)) {
      const minimumSize = 40;
      resizer.split("").forEach((direction) => {
        switch (direction) {
          case "n": {
            const height = this._originalBounds.height - (event.pageY - this._originalMouseCoords.top);
            const top = this._originalBounds.top + (event.pageY - this._originalMouseCoords.top);
            if (height > minimumSize) {
              this.$.overlay.setBounds({ top, height });
            }
            break;
          }
          case "e": {
            const width = this._originalBounds.width + (event.pageX - this._originalMouseCoords.left);
            if (width > minimumSize) {
              this.$.overlay.setBounds({ width });
            }
            break;
          }
          case "s": {
            const height = this._originalBounds.height + (event.pageY - this._originalMouseCoords.top);
            if (height > minimumSize) {
              this.$.overlay.setBounds({ height });
            }
            break;
          }
          case "w": {
            const width = this._originalBounds.width - (event.pageX - this._originalMouseCoords.left);
            const left = this._originalBounds.left + (event.pageX - this._originalMouseCoords.left);
            if (width > minimumSize) {
              this.$.overlay.setBounds({ left, width });
            }
            break;
          }
          default:
            break;
        }
      });
    }
  }
  _stopResize(direction) {
    window.removeEventListener("mousemove", this._resizeListeners.resize[direction]);
    window.removeEventListener("touchmove", this._resizeListeners.resize[direction]);
    window.removeEventListener("mouseup", this._resizeListeners.stop[direction]);
    window.removeEventListener("touchend", this._resizeListeners.stop[direction]);
    this.dispatchEvent(new CustomEvent("resize", { detail: this._getResizeDimensions() }));
  }
  _getResizeDimensions() {
    const scrollPosition = this.$.overlay.$.resizerContainer.scrollTop;
    const { width, height } = getComputedStyle(this.$.overlay.$.overlay);
    const content = this.$.overlay.$.content;
    content.setAttribute("style", "position: absolute; top: 0; right: 0; bottom: 0; left: 0; box-sizing: content-box; height: auto;");
    const { width: contentWidth, height: contentHeight } = getComputedStyle(content);
    content.removeAttribute("style");
    this.$.overlay.$.resizerContainer.scrollTop = scrollPosition;
    return { width, height, contentWidth, contentHeight };
  }
};

// node_modules/@vaadin/dialog/src/vaadin-dialog.js
registerStyles("vaadin-dialog-overlay", css`
    /*
      NOTE(platosha): Make some min-width to prevent collapsing of the content
      taking the parent width, e. g., <vaadin-grid> and such.
    */
    [part='content'] {
      min-width: 12em; /* matches the default <vaadin-text-field> width */
    }

    :host([has-bounds-set]) [part='overlay'] {
      max-width: none;
    }
  `, { moduleId: "vaadin-dialog-overlay-styles" });
var memoizedTemplate;
var DialogOverlay = class extends OverlayElement {
  static get is() {
    return "vaadin-dialog-overlay";
  }
  static get template() {
    if (!memoizedTemplate) {
      memoizedTemplate = super.template.cloneNode(true);
      const contentPart = memoizedTemplate.content.querySelector('[part="content"]');
      const overlayPart = memoizedTemplate.content.querySelector('[part="overlay"]');
      const resizerContainer = document.createElement("div");
      resizerContainer.id = "resizerContainer";
      resizerContainer.classList.add("resizer-container");
      resizerContainer.appendChild(contentPart);
      overlayPart.appendChild(resizerContainer);
    }
    return memoizedTemplate;
  }
  static get properties() {
    return {
      modeless: Boolean,
      withBackdrop: Boolean
    };
  }
  setBounds(bounds) {
    const overlay2 = this.$.overlay;
    const parsedBounds = __spreadValues({}, bounds);
    if (overlay2.style.position !== "absolute") {
      overlay2.style.position = "absolute";
      this.setAttribute("has-bounds-set", "");
      this.__forceSafariReflow();
    }
    for (const arg in parsedBounds) {
      if (typeof parsedBounds[arg] === "number") {
        parsedBounds[arg] = `${parsedBounds[arg]}px`;
      }
    }
    Object.assign(overlay2.style, parsedBounds);
  }
  getBounds() {
    const overlayBounds = this.$.overlay.getBoundingClientRect();
    const containerBounds = this.getBoundingClientRect();
    const top = overlayBounds.top - containerBounds.top;
    const left = overlayBounds.left - containerBounds.left;
    const width = overlayBounds.width;
    const height = overlayBounds.height;
    return { top, left, width, height };
  }
  __forceSafariReflow() {
    const scrollPosition = this.$.resizerContainer.scrollTop;
    const overlay2 = this.$.overlay;
    overlay2.style.display = "block";
    requestAnimationFrame(() => {
      overlay2.style.display = "";
      this.$.resizerContainer.scrollTop = scrollPosition;
    });
  }
};
customElements.define(DialogOverlay.is, DialogOverlay);
var Dialog = class extends ThemePropertyMixin(ElementMixin(DialogDraggableMixin(DialogResizableMixin(PolymerElement)))) {
  static get template() {
    return html`
      <style>
        :host {
          display: none;
        }
      </style>

      <vaadin-dialog-overlay
        id="overlay"
        on-opened-changed="_onOverlayOpened"
        on-mousedown="_bringOverlayToFront"
        on-touchstart="_bringOverlayToFront"
        theme$="[[theme]]"
        modeless="[[modeless]]"
        with-backdrop="[[!modeless]]"
        resizable$="[[resizable]]"
        focus-trap
      ></vaadin-dialog-overlay>
    `;
  }
  static get is() {
    return "vaadin-dialog";
  }
  static get properties() {
    return {
      opened: {
        type: Boolean,
        value: false,
        notify: true
      },
      noCloseOnOutsideClick: {
        type: Boolean,
        value: false
      },
      noCloseOnEsc: {
        type: Boolean,
        value: false
      },
      ariaLabel: {
        type: String,
        value: ""
      },
      renderer: Function,
      modeless: {
        type: Boolean,
        value: false
      }
    };
  }
  static get observers() {
    return ["_openedChanged(opened)", "_ariaLabelChanged(ariaLabel)", "_rendererChanged(renderer)"];
  }
  ready() {
    super.ready();
    this.$.overlay.setAttribute("role", "dialog");
    this.$.overlay.addEventListener("vaadin-overlay-outside-click", this._handleOutsideClick.bind(this));
    this.$.overlay.addEventListener("vaadin-overlay-escape-press", this._handleEscPress.bind(this));
    processTemplates(this);
  }
  requestContentUpdate() {
    this.$.overlay.requestContentUpdate();
  }
  _rendererChanged(renderer) {
    this.$.overlay.setProperties({ owner: this, renderer });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.opened = false;
  }
  _openedChanged(opened) {
    this.$.overlay.opened = opened;
  }
  _ariaLabelChanged(ariaLabel) {
    if (ariaLabel) {
      this.$.overlay.setAttribute("aria-label", ariaLabel);
    } else {
      this.$.overlay.removeAttribute("aria-label");
    }
  }
  _onOverlayOpened(e) {
    if (e.detail.value === false) {
      this.opened = false;
    }
  }
  _handleOutsideClick(e) {
    if (this.noCloseOnOutsideClick) {
      e.preventDefault();
    }
  }
  _handleEscPress(e) {
    if (this.noCloseOnEsc) {
      e.preventDefault();
    }
  }
  _bringOverlayToFront() {
    if (this.modeless) {
      this.$.overlay.bringToFront();
    }
  }
};
customElements.define(Dialog.is, Dialog);

export {
  DialogOverlay,
  Dialog
};
/**
 * @license
 * Copyright (c) 2017 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-LJHVE6HB.js.map
