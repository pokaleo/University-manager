import {
  ContextMenu
} from "./chunk-243RA6ZX.js";
import {
  Button
} from "./chunk-JTXRSU57.js";
import {
  ResizeMixin
} from "./chunk-WCV6MGXN.js";
import {
  DisabledMixin
} from "./chunk-TNYX3KNS.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-PALO6AVQ.js";
import {
  css
} from "./chunk-PYLEJJK2.js";
import {
  ElementMixin
} from "./chunk-ZAXSWEEW.js";
import {
  PolymerElement,
  html
} from "./chunk-EMDRMWGL.js";
import {
  __spreadValues
} from "./chunk-KTZKXPFA.js";

// node_modules/@vaadin/menu-bar/src/vaadin-menu-bar-submenu.js
var MenuBarSubmenu = class extends ContextMenu {
  static get is() {
    return "vaadin-menu-bar-submenu";
  }
  constructor() {
    super();
    this.openOn = "opensubmenu";
  }
  _openedChanged(opened) {
    this.$.overlay.opened = opened;
  }
  close() {
    super.close();
    if (this.hasAttribute("is-root")) {
      this.getRootNode().host._close();
    }
  }
};
customElements.define(MenuBarSubmenu.is, MenuBarSubmenu);

// node_modules/@vaadin/menu-bar/src/vaadin-menu-bar-button.js
registerStyles("vaadin-menu-bar-button", css`
    [part='label'] ::slotted(vaadin-context-menu-item) {
      position: relative;
      z-index: 1;
    }
  `, { moduleId: "vaadin-menu-bar-button-styles" });
var MenuBarButton = class extends Button {
  static get is() {
    return "vaadin-menu-bar-button";
  }
};
customElements.define(MenuBarButton.is, MenuBarButton);

// node_modules/@vaadin/menu-bar/src/vaadin-menu-bar-buttons-mixin.js
var ButtonsMixin = (superClass) => class extends ResizeMixin(superClass) {
  static get properties() {
    return {
      _hasOverflow: {
        type: Boolean,
        value: false
      }
    };
  }
  static get observers() {
    return ["_menuItemsChanged(items, items.splices)"];
  }
  ready() {
    super.ready();
    this.setAttribute("role", "menubar");
  }
  connectedCallback() {
    super.connectedCallback();
    this._initButtonAttrs(this._overflow);
  }
  get _buttons() {
    return Array.from(this.shadowRoot.querySelectorAll('[part$="button"]'));
  }
  get _container() {
    return this.shadowRoot.querySelector('[part="container"]');
  }
  get _overflow() {
    return this.shadowRoot.querySelector('[part="overflow-button"]');
  }
  _menuItemsChanged(items) {
    if (items !== this._oldItems) {
      this._oldItems = items;
      this.__renderButtons(items);
    }
  }
  __getOverflowCount(overflow) {
    return overflow.item && overflow.item.children && overflow.item.children.length || 0;
  }
  __restoreButtons(buttons) {
    for (let i = 0; i < buttons.length; i++) {
      const btn = buttons[i];
      btn.disabled = btn.item && btn.item.disabled || this.disabled;
      btn.style.visibility = "";
      btn.style.position = "";
      const item = btn.item && btn.item.component;
      if (item instanceof HTMLElement && item.classList.contains("vaadin-menu-item")) {
        btn.appendChild(item);
        item.classList.remove("vaadin-menu-item");
      }
    }
    this._overflow.item = { children: [] };
    this._hasOverflow = false;
  }
  __setOverflowItems(buttons, overflow) {
    const container = this._container;
    if (container.offsetWidth < container.scrollWidth) {
      this._hasOverflow = true;
      const isRTL = this.getAttribute("dir") === "rtl";
      let i;
      for (i = buttons.length; i > 0; i--) {
        const btn = buttons[i - 1];
        const btnStyle = getComputedStyle(btn);
        if (!isRTL && btn.offsetLeft + btn.offsetWidth < container.offsetWidth - overflow.offsetWidth || isRTL && btn.offsetLeft >= overflow.offsetWidth) {
          break;
        }
        btn.disabled = true;
        btn.style.visibility = "hidden";
        btn.style.position = "absolute";
        btn.style.width = btnStyle.width;
      }
      overflow.item = {
        children: buttons.filter((b, idx) => idx >= i).map((b) => b.item)
      };
    }
  }
  __detectOverflow() {
    const overflow = this._overflow;
    const buttons = this._buttons.filter((btn) => btn !== overflow);
    const oldOverflowCount = this.__getOverflowCount(overflow);
    this.__restoreButtons(buttons);
    this.__setOverflowItems(buttons, overflow);
    const newOverflowCount = this.__getOverflowCount(overflow);
    if (oldOverflowCount !== newOverflowCount && this._subMenu.opened) {
      this._subMenu.close();
    }
  }
  _removeButtons() {
    const container = this._container;
    while (container.children.length > 1) {
      container.removeChild(container.firstElementChild);
    }
  }
  _initButton(item) {
    const button = document.createElement("vaadin-menu-bar-button");
    button.setAttribute("part", "menu-bar-button");
    const itemCopy = __spreadValues({}, item);
    button.item = itemCopy;
    if (item.component) {
      const component = this.__getComponent(itemCopy);
      itemCopy.component = component;
      component.item = itemCopy;
      button.appendChild(component);
    } else if (item.text) {
      button.textContent = item.text;
    }
    return button;
  }
  _initButtonAttrs(button) {
    button.setAttribute("role", "menuitem");
    if (button === this._overflow || button.item && button.item.children) {
      button.setAttribute("aria-haspopup", "true");
      button.setAttribute("aria-expanded", "false");
    }
  }
  _setButtonDisabled(button, disabled) {
    button.disabled = disabled;
    button.setAttribute("tabindex", disabled ? "-1" : "0");
  }
  _setTheme(theme) {
    super._setTheme(theme);
    if (!this.shadowRoot) {
      return;
    }
    this.__applyTheme(theme);
  }
  __applyTheme(theme) {
    this._buttons.forEach((btn) => this._setButtonTheme(btn, theme));
    this.__detectOverflow();
  }
  _setButtonTheme(btn, hostTheme) {
    let theme = hostTheme;
    const itemTheme = btn.item && btn.item.theme;
    if (itemTheme != null) {
      theme = Array.isArray(itemTheme) ? itemTheme.join(" ") : itemTheme;
    }
    if (theme) {
      btn.setAttribute("theme", theme);
    } else {
      btn.removeAttribute("theme");
    }
  }
  _appendButton(button) {
    this._container.insertBefore(button, this._overflow);
  }
  __getComponent(item) {
    const itemComponent = item.component;
    let component;
    const isElement = itemComponent instanceof HTMLElement;
    if (isElement && itemComponent.localName === "vaadin-context-menu-item") {
      component = itemComponent;
    } else {
      component = document.createElement("vaadin-context-menu-item");
      component.appendChild(isElement ? itemComponent : document.createElement(itemComponent));
    }
    if (item.text) {
      const node = component.firstChild || component;
      node.textContent = item.text;
    }
    component.setAttribute("theme", "menu-bar-item");
    return component;
  }
  __renderButtons(items = []) {
    this._removeButtons();
    if (items.length === 0) {
      return;
    }
    items.forEach((item) => {
      const button = this._initButton(item);
      this._appendButton(button);
      this._setButtonDisabled(button, item.disabled);
      this._initButtonAttrs(button);
    });
    this.__applyTheme(this.theme);
  }
  _onResize() {
    this.__detectOverflow();
  }
};

// node_modules/@vaadin/menu-bar/src/vaadin-menu-bar-interactions-mixin.js
var InteractionsMixin = (superClass) => class InteractionsMixin extends superClass {
  static get properties() {
    return {
      openOnHover: {
        type: Boolean
      }
    };
  }
  constructor() {
    super();
    this.__boundOnContextMenuKeydown = this.__onContextMenuKeydown.bind(this);
  }
  static get observers() {
    return ["_itemsChanged(items, items.splices)", "_themeChanged(theme)"];
  }
  ready() {
    super.ready();
    this.addEventListener("keydown", (e) => this._onKeydown(e));
    this.addEventListener("focusin", (e) => this._onFocusin(e));
    this._subMenu.addEventListener("item-selected", this.__onItemSelected.bind(this));
    this._subMenu.addEventListener("close-all-menus", this.__onEscapeClose.bind(this));
    const overlay = this._subMenu.$.overlay;
    overlay.addEventListener("keydown", this.__boundOnContextMenuKeydown);
    overlay.addEventListener("vaadin-overlay-open", this.__alignOverlayPosition.bind(this));
    const container = this._container;
    container.addEventListener("click", this.__onButtonClick.bind(this));
    container.addEventListener("mouseover", (e) => this._onMouseOver(e));
  }
  get __isRTL() {
    return this.getAttribute("dir") === "rtl";
  }
  _themeChanged(theme) {
    if (theme) {
      this._subMenu.setAttribute("theme", theme);
    } else {
      this._subMenu.removeAttribute("theme");
    }
  }
  _setExpanded(button, expanded) {
    button.toggleAttribute("expanded", expanded);
    button.toggleAttribute("active", expanded);
    button.setAttribute("aria-expanded", expanded ? "true" : "false");
  }
  _setTabindex(button, focused) {
    button.setAttribute("tabindex", focused ? "0" : "-1");
  }
  _focusButton(button) {
    button.focus();
    button.setAttribute("focus-ring", "");
    this._buttons.forEach((btn) => {
      this._setTabindex(btn, btn === button);
    });
  }
  _getButtonFromEvent(e) {
    return Array.from(e.composedPath()).filter((el) => el.localName === "vaadin-menu-bar-button")[0];
  }
  _getCurrentButton() {
    return this.shadowRoot.activeElement || this._expandedButton;
  }
  _onFocusin() {
    const target = this.shadowRoot.querySelector('[part$="button"][tabindex="0"]');
    if (target) {
      this._buttons.forEach((btn) => {
        this._setTabindex(btn, btn === target);
      });
    }
  }
  _onKeydown(event) {
    const button = this._getButtonFromEvent(event);
    if (button) {
      if (event.keyCode === 40) {
        event.preventDefault();
        if (button === this._expandedButton) {
          this._focusFirstItem();
        } else {
          this.__openSubMenu(button, event);
        }
      } else if (event.keyCode === 38) {
        event.preventDefault();
        if (button === this._expandedButton) {
          this._focusLastItem();
        } else {
          this.__openSubMenu(button, event, { focusLast: true });
        }
      } else if (event.keyCode === 27 && button === this._expandedButton) {
        this._close(true);
      } else {
        this._navigateByKey(event);
      }
    }
  }
  _navigateByKey(event) {
    const key = event.key.replace(/^Arrow/, "");
    const buttons = this._buttons;
    const currentBtn = this._getCurrentButton();
    const currentIdx = buttons.indexOf(currentBtn);
    let idx;
    let increment;
    const dirIncrement = this.__isRTL ? -1 : 1;
    switch (key) {
      case "Left":
        increment = -dirIncrement;
        idx = currentIdx - dirIncrement;
        break;
      case "Right":
        increment = dirIncrement;
        idx = currentIdx + dirIncrement;
        break;
      case "Home":
        increment = 1;
        idx = 0;
        break;
      case "End":
        increment = -1;
        idx = buttons.length - 1;
        break;
      default:
    }
    idx = this._getAvailableIndex(idx, increment, buttons);
    if (idx >= 0) {
      event.preventDefault();
      const btn = buttons[idx];
      const wasExpanded = currentBtn === this._expandedButton;
      if (wasExpanded) {
        this._close();
      }
      this._focusButton(btn);
      if (wasExpanded && btn.item && btn.item.children) {
        this.__openSubMenu(btn, event, { keepFocus: true });
      }
    }
  }
  _getAvailableIndex(index, increment, buttons) {
    const totalItems = buttons.length;
    let idx = index;
    for (let i = 0; typeof idx === "number" && i < totalItems; i++, idx += increment || 1) {
      if (idx < 0) {
        idx = totalItems - 1;
      } else if (idx >= totalItems) {
        idx = 0;
      }
      const btn = buttons[idx];
      if (!btn.disabled && !btn.hasAttribute("hidden")) {
        return idx;
      }
    }
    return -1;
  }
  get _subMenu() {
    return this.shadowRoot.querySelector("vaadin-menu-bar-submenu");
  }
  __alignOverlayPosition(e) {
    if (!this._expandedButton) {
      return;
    }
    const overlay = e.target;
    const { width, height, left } = this._expandedButton.getBoundingClientRect();
    if (overlay.hasAttribute("bottom-aligned")) {
      overlay.style.bottom = parseInt(getComputedStyle(overlay).bottom) + height + "px";
    }
    const endAligned = overlay.hasAttribute("end-aligned");
    if (endAligned) {
      if (this.__isRTL) {
        overlay.style.left = left + "px";
      } else {
        overlay.style.right = parseInt(getComputedStyle(overlay).right) - width + "px";
      }
    }
  }
  _itemsChanged() {
    const subMenu = this._subMenu;
    if (subMenu && subMenu.opened) {
      subMenu.close();
    }
  }
  _onMouseOver(e) {
    const button = this._getButtonFromEvent(e);
    if (button && button !== this._expandedButton) {
      const isOpened = this._subMenu.opened;
      if (button.item.children && (this.openOnHover || isOpened)) {
        this.__openSubMenu(button, e);
      } else if (isOpened) {
        this._close();
      }
    }
  }
  __onContextMenuKeydown(e) {
    const item = Array.from(e.composedPath()).filter((el) => el._item)[0];
    if (item) {
      const list = item.parentNode;
      if (e.keyCode === 38 && item === list.items[0]) {
        this._close(true);
      }
      if (e.keyCode === 37 || e.keyCode === 39 && !item._item.children) {
        e.stopImmediatePropagation();
        this._navigateByKey(e);
        const button = this.shadowRoot.activeElement;
        if (button && button.item && button.item.children) {
          this.__openSubMenu(button, e, { keepFocus: true });
        }
      }
    }
  }
  __fireItemSelected(value) {
    this.dispatchEvent(new CustomEvent("item-selected", { detail: { value } }));
  }
  __onButtonClick(e) {
    e.stopPropagation();
    const button = this._getButtonFromEvent(e);
    if (button) {
      this.__openSubMenu(button, e);
    }
  }
  __openSubMenu(button, event, options = {}) {
    const subMenu = this._subMenu;
    const item = button.item;
    if (subMenu.opened) {
      this._close();
      if (subMenu.listenOn === button) {
        return;
      }
    }
    const items = item && item.children;
    if (!items || items.length === 0) {
      this.__fireItemSelected(item);
      return;
    }
    subMenu.items = items;
    subMenu.listenOn = button;
    const overlay = subMenu.$.overlay;
    overlay.positionTarget = button;
    overlay.noVerticalOverlap = true;
    this._expandedButton = button;
    requestAnimationFrame(() => {
      button.dispatchEvent(new CustomEvent("opensubmenu", {
        detail: {
          children: items
        }
      }));
      this._setExpanded(button, true);
    });
    if (options.focusLast) {
      this.__onceOpened(() => this._focusLastItem());
    }
    if (options.keepFocus) {
      this.__onceOpened(() => {
        this._focusButton(this._expandedButton);
      });
    }
    this.__onceOpened(() => {
      if (event.type !== "keydown") {
        subMenu.$.overlay.$.overlay.focus();
      }
      overlay._updatePosition();
    });
  }
  _focusFirstItem() {
    const list = this._subMenu.$.overlay.firstElementChild;
    list.focus();
  }
  _focusLastItem() {
    const list = this._subMenu.$.overlay.firstElementChild;
    const item = list.items[list.items.length - 1];
    item && item.focus();
  }
  __onceOpened(cb) {
    this.style.pointerEvents = "auto";
    const overlay = this._subMenu.$.overlay;
    const listener = () => {
      cb();
      overlay.removeEventListener("vaadin-overlay-open", listener);
    };
    overlay.addEventListener("vaadin-overlay-open", listener);
  }
  __onItemSelected(e) {
    e.stopPropagation();
    this._close();
    this.__fireItemSelected(e.detail.value);
  }
  __onEscapeClose() {
    this.__deactivateButton(true);
  }
  __deactivateButton(restoreFocus) {
    const button = this._expandedButton;
    if (button && button.hasAttribute("expanded")) {
      this._setExpanded(button, false);
      if (restoreFocus) {
        this._focusButton(button);
      }
      this._expandedButton = null;
    }
  }
  _close(restoreFocus) {
    this.style.pointerEvents = "";
    this.__deactivateButton(restoreFocus);
    this._subMenu.opened && this._subMenu.close();
  }
};

// node_modules/@vaadin/menu-bar/src/vaadin-menu-bar.js
var MenuBar = class extends ButtonsMixin(DisabledMixin(InteractionsMixin(ElementMixin(ThemableMixin(PolymerElement))))) {
  static get template() {
    return html`
      <style>
        :host {
          display: block;
          align-self: stretch; /* make overflow work in flex */
        }

        :host([hidden]) {
          display: none !important;
        }

        [part='container'] {
          position: relative;
          display: flex;
          width: 100%;
          flex-wrap: nowrap;
          overflow: hidden;
        }

        [part$='button'] {
          flex-shrink: 0;
        }

        [part='overflow-button'] {
          margin-right: 0;
        }

        .dots::before {
          display: block;
          content: '\\00B7\\00B7\\00B7';
          font-size: inherit;
          line-height: inherit;
        }
      </style>

      <div part="container">
        <vaadin-menu-bar-button part="overflow-button" hidden$="[[!_hasOverflow]]" aria-label$="[[i18n.moreOptions]]">
          <div class="dots"></div>
        </vaadin-menu-bar-button>
      </div>
      <vaadin-menu-bar-submenu is-root=""></vaadin-menu-bar-submenu>
    `;
  }
  static get is() {
    return "vaadin-menu-bar";
  }
  static get properties() {
    return {
      items: {
        type: Array,
        value: () => []
      },
      i18n: {
        type: Object,
        value: () => {
          return {
            moreOptions: "More options"
          };
        }
      }
    };
  }
  _disabledChanged(newValue, oldValue) {
    super._disabledChanged(newValue, oldValue);
    if (oldValue !== newValue) {
      this.__updateButtonsDisabled(newValue);
    }
  }
  __updateButtonsDisabled(disabled) {
    this._buttons.forEach((btn) => {
      btn.disabled = disabled || btn.item && btn.item.disabled;
    });
  }
};
customElements.define(MenuBar.is, MenuBar);
/**
 * @license
 * Copyright (c) 2016 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
/**
 * @license
 * Copyright (c) 2019 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-E2F3PZVB.js.map
