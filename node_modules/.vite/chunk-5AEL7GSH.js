import {
  Select
} from "./chunk-FZMH3WMA.js";
import {
  GridColumn
} from "./chunk-VH2MUWJU.js";
import {
  TextField
} from "./chunk-ATQKI5W3.js";
import {
  Checkbox
} from "./chunk-NON5YMRO.js";
import {
  get,
  set
} from "./chunk-EMDRMWGL.js";

// node_modules/@vaadin/grid-pro/src/vaadin-grid-pro-edit-checkbox.js
var GridProEditCheckbox = class extends Checkbox {
  static get is() {
    return "vaadin-grid-pro-edit-checkbox";
  }
};
customElements.define(GridProEditCheckbox.is, GridProEditCheckbox);

// node_modules/@vaadin/grid-pro/src/vaadin-grid-pro-edit-select.js
var GridProEditSelect = class extends Select {
  static get is() {
    return "vaadin-grid-pro-edit-select";
  }
  static get properties() {
    return {
      options: {
        type: Array,
        value: () => []
      },
      _grid: {
        type: Object
      },
      _initialized: {
        type: Boolean
      }
    };
  }
  static get observers() {
    return ["_optionsChanged(options)"];
  }
  ready() {
    super.ready();
    this.setAttribute("theme", "grid-pro-editor");
  }
  _onKeyDown(e) {
    super._onKeyDown(e);
    if (this.options.length === 0 && /^(ArrowDown|Down|ArrowUp|Up|Enter|SpaceBar| )$/.test(e.key)) {
      console.warn('Missing "editorOptions" for <vaadin-grid-pro-edit-column> select editor!');
    }
    if (e.defaultPrevented) {
      e.stopPropagation();
    }
  }
  _onKeyDownInside(event) {
    if (event.keyCode === 13) {
      this._enterKeydown = event;
    }
    if (event.keyCode === 9) {
      !this._grid.singleCellEdit && this._grid._switchEditCell(event);
    }
    super._onKeyDownInside(event);
  }
  _valueChanged(value, oldValue) {
    super._valueChanged(value, oldValue);
    if (value === "" && oldValue === void 0) {
      return;
    }
    if (this._initialized) {
      const enter = this._enterKeydown;
      if (enter && this._grid.enterNextRow) {
        this._grid._switchEditCell(enter);
      } else if (this._grid.singleCellEdit) {
        this._grid._stopEdit(false, true);
      } else {
        this.focus();
      }
    }
  }
  _optionsChanged(options) {
    if (options && options.length) {
      this.renderer = (root) => {
        if (root.firstChild) {
          return;
        }
        const listBox = document.createElement("vaadin-list-box");
        listBox.selected = options.indexOf(this.value);
        options.forEach((option) => {
          const item = document.createElement("vaadin-item");
          item.textContent = option;
          listBox.appendChild(item);
        });
        root.appendChild(listBox);
      };
      this._overlayElement.addEventListener("vaadin-overlay-outside-click", () => {
        this._grid._stopEdit();
      });
      setTimeout(() => {
        this.opened = true;
        this._initialized = true;
      });
    }
  }
};
customElements.define(GridProEditSelect.is, GridProEditSelect);

// node_modules/@vaadin/grid-pro/src/vaadin-grid-pro-edit-text-field.js
var GridProEditText = class extends TextField {
  static get is() {
    return "vaadin-grid-pro-edit-text-field";
  }
  ready() {
    super.ready();
    this.setAttribute("theme", "grid-pro-editor");
  }
};
customElements.define(GridProEditText.is, GridProEditText);

// node_modules/@vaadin/grid-pro/src/vaadin-grid-pro-edit-column.js
var GridProEditColumn = class extends GridColumn {
  static get is() {
    return "vaadin-grid-pro-edit-column";
  }
  static get properties() {
    return {
      editModeRenderer: Function,
      editorOptions: {
        type: Array,
        value: () => []
      },
      editorType: {
        type: String,
        notify: true,
        value: "text"
      },
      editorValuePath: {
        type: String,
        value: "value"
      },
      path: {
        type: String,
        observer: "_pathChanged"
      },
      _oldRenderer: Function
    };
  }
  static get observers() {
    return ["_editModeRendererChanged(editModeRenderer, __initialized)", "_cellsChanged(_cells.*)"];
  }
  constructor() {
    super();
    this.__editModeRenderer = function(root, column) {
      const cell = root.assignedSlot.parentNode;
      const tagName = column._getEditorTagName(cell);
      if (!root.firstElementChild || root.firstElementChild.localName.toLowerCase() !== tagName) {
        root.innerHTML = `
          <${tagName}></${tagName}>
        `;
      }
    };
  }
  _pathChanged(path) {
    if (!path || path.length == 0) {
      throw new Error("You should specify the path for the edit column");
    }
  }
  _cellsChanged() {
    this._cells.forEach((cell) => {
      const part = cell.getAttribute("part");
      if (part.indexOf("editable-cell") < 0) {
        cell.setAttribute("part", part + " editable-cell");
      }
    });
  }
  _editModeRendererChanged(renderer) {
    if (renderer) {
      this.editorType = "custom";
    } else if (this._oldRenderer) {
      this.editorType = "text";
    }
    this._oldRenderer = renderer;
  }
  _getEditorTagName(cell) {
    return this.editorType === "custom" ? this._getEditorComponent(cell).localName : this._getTagNameByType();
  }
  _getEditorComponent(cell) {
    return this.editorType === "custom" ? cell._content.firstElementChild : cell._content.querySelector(this._getEditorTagName(cell));
  }
  _getTagNameByType() {
    let type;
    switch (this.editorType) {
      case "checkbox":
        type = "checkbox";
        break;
      case "select":
        type = "select";
        break;
      case "text":
      default:
        type = "text-field";
        break;
    }
    return this.constructor.is.replace("column", type);
  }
  _focusEditor(editor) {
    editor.focus();
    if (this.editorType === "checkbox") {
      editor.setAttribute("focus-ring", "");
    } else if (editor instanceof HTMLInputElement) {
      editor.select();
    } else if (editor.focusElement && editor.focusElement instanceof HTMLInputElement) {
      editor.focusElement.select();
    }
  }
  _getEditorValue(editor) {
    const path = this.editorType === "checkbox" ? "checked" : this.editorValuePath;
    return get(editor, path);
  }
  _renderEditor(cell, model) {
    cell.__savedRenderer = this._renderer || cell._renderer;
    cell._renderer = this.editModeRenderer || this.__editModeRenderer;
    this._clearCellContent(cell);
    this._runRenderer(cell._renderer, cell, model);
  }
  _removeEditor(cell, _model) {
    if (!cell.__savedRenderer) {
      return;
    }
    cell._renderer = cell.__savedRenderer;
    cell.__savedRenderer = void 0;
    this._clearCellContent(cell);
    const row = cell.parentElement;
    this._grid._updateItem(row, row._item);
  }
  _setEditorOptions(editor) {
    if (this.editorOptions && this.editorOptions.length) {
      editor.options = this.editorOptions;
    }
  }
  _setEditorValue(editor, value) {
    const path = this.editorType === "checkbox" ? "checked" : this.editorValuePath;
    value = this.editorType === "checkbox" && typeof value === "string" ? value == "true" : value;
    set(editor, path, value);
    editor.notifyPath && editor.notifyPath(path, value);
  }
  _startCellEdit(cell, model) {
    this._renderEditor(cell, model);
    const editor = this._getEditorComponent(cell);
    editor.addEventListener("focusout", this._grid.__boundEditorFocusOut);
    editor.addEventListener("focusin", this._grid.__boundEditorFocusIn);
    editor.addEventListener("internal-tab", this._grid.__boundCancelCellSwitch);
    document.body.addEventListener("focusin", this._grid.__boundGlobalFocusIn);
    this._setEditorOptions(editor);
    this._setEditorValue(editor, get(model.item, this.path));
    editor._grid = this._grid;
    this._focusEditor(editor);
  }
  _stopCellEdit(cell, model) {
    document.body.removeEventListener("focusin", this._grid.__boundGlobalFocusIn);
    this._removeEditor(cell, model);
  }
};
customElements.define(GridProEditColumn.is, GridProEditColumn);
/**
 * @license
 * Copyright (c) 2018 - 2022 Vaadin Ltd.
 * This program is available under Commercial Vaadin Developer License 4.0 (CVDLv4).
 * See <a href="https://vaadin.com/license/cvdl-4.0">the website</a> for the complete license.
 */
//# sourceMappingURL=chunk-5AEL7GSH.js.map
