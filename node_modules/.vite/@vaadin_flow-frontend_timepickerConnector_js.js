import {
  __commonJS
} from "./chunk-KTZKXPFA.js";

// node_modules/@vaadin/flow-frontend/timepickerConnector.js
var require_timepickerConnector = __commonJS({
  "node_modules/@vaadin/flow-frontend/timepickerConnector.js"() {
    (function() {
      const tryCatchWrapper = function(callback) {
        return window.Vaadin.Flow.tryCatchWrapper(callback, "Vaadin Time Picker");
      };
      function when(predicate, callback, timeout = 0) {
        if (predicate()) {
          callback();
        } else {
          setTimeout(() => when(predicate, callback, 200), timeout);
        }
      }
      window.Vaadin.Flow.timepickerConnector = {
        initLazy: (timepicker) => tryCatchWrapper(function(timepicker2) {
          if (timepicker2.$connector) {
            return;
          }
          timepicker2.$connector = {};
          const getAmPmString = function(locale, testTime) {
            const testTimeString = testTime.toLocaleTimeString(locale);
            const endWithAmPmRegex = /[^\d\u0660-\u0669]+$/g;
            let amPmString = testTimeString.match(endWithAmPmRegex);
            if (!amPmString) {
              amPmString = testTimeString.match(/^[^\d\u0660-\u0669]+/g);
            }
            if (amPmString) {
              amPmString = amPmString[0].trim();
            }
            return amPmString;
          };
          const testPmTime = new Date("August 19, 1975 23:15:30");
          const testAmTime = new Date("August 19, 1975 05:15:30");
          const getPmString = function(locale) {
            return getAmPmString(locale, testPmTime);
          };
          const getAmString = function(locale) {
            return getAmPmString(locale, testAmTime);
          };
          const arabicDigitMap = {
            "\\u0660": "0",
            "\\u0661": "1",
            "\\u0662": "2",
            "\\u0663": "3",
            "\\u0664": "4",
            "\\u0665": "5",
            "\\u0666": "6",
            "\\u0667": "7",
            "\\u0668": "8",
            "\\u0669": "9"
          };
          const anyNumberCharToArabicNumberReplacer = function(charsToReplace) {
            return charsToReplace.replace(/[\u0660-\u0669]/g, function(char) {
              const unicode = "\\u0" + char.charCodeAt(0).toString(16);
              return arabicDigitMap[unicode];
            });
          };
          const parseAnyCharsToInt = function(anyNumberChars) {
            return parseInt(anyNumberCharToArabicNumberReplacer(anyNumberChars));
          };
          const parseMillisecondCharsToInt = function(millisecondChars) {
            millisecondChars = anyNumberCharToArabicNumberReplacer(millisecondChars);
            if (millisecondChars.length === 1) {
              millisecondChars += "00";
            } else if (millisecondChars.length === 2) {
              millisecondChars += "0";
            }
            return parseInt(millisecondChars);
          };
          const millisecondRegExp = /[[\.][\d\u0660-\u0669]{1,3}$/;
          timepicker2.$connector.setLocale = tryCatchWrapper(function(locale) {
            let previousValueObject;
            if (timepicker2.value && timepicker2.value !== "") {
              previousValueObject = timepicker2.i18n.parseTime(timepicker2.value);
            }
            try {
              testPmTime.toLocaleTimeString(locale);
            } catch (e) {
              locale = "en-US";
              throw new Error("vaadin-time-picker: The locale " + locale + " is not supported, falling back to default locale setting(en-US).");
            }
            const pmString = getPmString(locale);
            const amString = getAmString(locale);
            let localeTimeString = testPmTime.toLocaleTimeString(locale);
            if (pmString && localeTimeString.startsWith(pmString)) {
              localeTimeString = localeTimeString.replace(pmString, "");
            }
            const separator = localeTimeString.match(/[^\u0660-\u0669\s\d]/);
            const numbersRegExp = new RegExp("([\\d\\u0660-\\u0669]){1,2}(?:" + separator + ")?", "g");
            const includeSeconds = function() {
              return timepicker2.step && timepicker2.step < 60;
            };
            const includeMilliSeconds = function() {
              return timepicker2.step && timepicker2.step < 1;
            };
            let cachedStep;
            let cachedOptions;
            const getTimeFormatOptions = function() {
              if (!cachedOptions || cachedStep !== timepicker2.step) {
                cachedOptions = {
                  hour: "numeric",
                  minute: "numeric",
                  second: includeSeconds() ? "numeric" : void 0
                };
                cachedStep = timepicker2.step;
              }
              return cachedOptions;
            };
            const formatMilliseconds = function(localeTimeString2, milliseconds) {
              if (includeMilliSeconds()) {
                let cleanedTimeString = localeTimeString2;
                if (localeTimeString2.endsWith(amString)) {
                  cleanedTimeString = localeTimeString2.replace(" " + amString, "");
                } else if (localeTimeString2.endsWith(pmString)) {
                  cleanedTimeString = localeTimeString2.replace(" " + pmString, "");
                }
                if (milliseconds) {
                  let millisecondsString = milliseconds < 10 ? "0" : "";
                  millisecondsString += milliseconds < 100 ? "0" : "";
                  millisecondsString += milliseconds;
                  cleanedTimeString += "." + millisecondsString;
                } else {
                  cleanedTimeString += ".000";
                }
                if (localeTimeString2.endsWith(amString)) {
                  cleanedTimeString = cleanedTimeString + " " + amString;
                } else if (localeTimeString2.endsWith(pmString)) {
                  cleanedTimeString = cleanedTimeString + " " + pmString;
                }
                return cleanedTimeString;
              }
              return localeTimeString2;
            };
            let cachedTimeString;
            let cachedTimeObject;
            timepicker2.i18n = {
              formatTime: tryCatchWrapper(function(timeObject) {
                if (timeObject) {
                  let timeToBeFormatted = new Date();
                  timeToBeFormatted.setHours(timeObject.hours);
                  timeToBeFormatted.setMinutes(timeObject.minutes);
                  timeToBeFormatted.setSeconds(timeObject.seconds !== void 0 ? timeObject.seconds : 0);
                  let localeTimeString2 = timeToBeFormatted.toLocaleTimeString(locale, getTimeFormatOptions());
                  localeTimeString2 = formatMilliseconds(localeTimeString2, timeObject.milliseconds);
                  return localeTimeString2;
                }
              }),
              parseTime: tryCatchWrapper(function(timeString) {
                if (timeString && timeString === cachedTimeString && cachedTimeObject) {
                  return cachedTimeObject;
                }
                if (timeString) {
                  const pm = timeString.search(pmString);
                  const am = timeString.search(amString);
                  let numbersOnlyTimeString = timeString.replace(amString, "").replace(pmString, "").trim();
                  numbersRegExp.lastIndex = 0;
                  let hours = numbersRegExp.exec(numbersOnlyTimeString);
                  if (hours) {
                    hours = parseAnyCharsToInt(hours[0].replace(separator, ""));
                    if (pm !== am) {
                      if (hours === 12 && am !== -1) {
                        hours = 0;
                      } else {
                        hours += pm !== -1 && hours !== 12 ? 12 : 0;
                      }
                    }
                    const minutes = numbersRegExp.exec(numbersOnlyTimeString);
                    const seconds = minutes && numbersRegExp.exec(numbersOnlyTimeString);
                    let milliseconds = seconds && includeMilliSeconds() && millisecondRegExp.exec(numbersOnlyTimeString);
                    if (milliseconds && milliseconds["index"] <= seconds["index"]) {
                      milliseconds = void 0;
                    }
                    cachedTimeObject = hours !== void 0 && {
                      hours,
                      minutes: minutes ? parseAnyCharsToInt(minutes[0].replace(separator, "")) : 0,
                      seconds: seconds ? parseAnyCharsToInt(seconds[0].replace(separator, "")) : 0,
                      milliseconds: minutes && seconds && milliseconds ? parseMillisecondCharsToInt(milliseconds[0].replace(".", "")) : 0
                    };
                    cachedTimeString = timeString;
                    return cachedTimeObject;
                  }
                }
              })
            };
            if (previousValueObject) {
              when(() => timepicker2.$, () => {
                const newValue = timepicker2.i18n.formatTime(previousValueObject);
                if (timepicker2.inputElement.value !== newValue) {
                  timepicker2.inputElement.value = newValue;
                  timepicker2.$.comboBox.value = newValue;
                }
              });
            }
          });
        })(timepicker)
      };
    })();
  }
});

// dep:@vaadin_flow-frontend_timepickerConnector_js
var vaadin_flow_frontend_timepickerConnector_js_default = require_timepickerConnector();
export {
  vaadin_flow_frontend_timepickerConnector_js_default as default
};
//# sourceMappingURL=@vaadin_flow-frontend_timepickerConnector_js.js.map
